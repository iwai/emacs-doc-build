GNU Emacs Manual (Japanese Translation) Seventeenth Edition, Updated for Emacs Version 26.2. Richard Stallman et al.
This is the GNU Emacs Manual, updated for Emacs version 26.2.

Copyright © 2016–2019 ayatakesi &lt;ayanokoji.takesi@gmail.com&gt; Copyright © 1985–1987, 1993–2019 Free Software Foundation, Inc.

> Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with the Invariant Sections being “The GNU Manifesto,” “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the Front-Cover Texts being “A GNU Manual,” and with the Back-Cover Texts as in (a) below. A copy of the license is included in the section entitled “GNU Free Documentation License.”
>
> (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and modify this GNU manual. Buying copies from the FSF supports it in developing GNU and promoting software freedom.”

Published by the Free Software Foundation 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA ISBN 978-0-9831592-5-4

Cover art by Etienne Suvasa; cover design by Matt Lee.

The Emacs Editor
================

Emacsは、拡張可能で、カスタマイズ可能な、セルフドキュメント方式のリアルタイム画面エディターです。このinfoファイルでは、Emacsでの編集方法や Emacsのカスタマイズ方法について説明します。GNU Emacs 26.2に対応します。

Emacsの拡張に関しては、section “Emacs Lisp” in The Emacs Lisp Reference Manualを参照してください。

This is the GNU Emacs Manual, updated for Emacs version 26.2.

Copyright © 2016–2019 ayatakesi &lt;ayanokoji.takesi@gmail.com&gt; Copyright © 1985–1987, 1993–2019 Free Software Foundation, Inc.

> Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with the Invariant Sections being “The GNU Manifesto,” “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the Front-Cover Texts being “A GNU Manual,” and with the Back-Cover Texts as in (a) below. A copy of the license is included in the section entitled “GNU Free Documentation License.”
>
> (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and modify this GNU manual. Buying copies from the FSF supports it in developing GNU and promoting software freedom.”

ディストリビューション
======================

GNU Emacsはfree software(フリーソフトウェアー、自由なソフトウェアー)です。これはすべての人が自由に使用でき、特定の条件の元に自由に再配布できることを意味します。GNU Emacsはパブリックドメイン(public domain: 特許権の消滅状態)ではありません。copyright(版権)されており、配布については制限があります。しかし、それらの制限は良き共同的な市民(good cooperating citizen)が行ないたいと欲するであろう、すべてのことを許すようデザインされています。なにが許されていないか、それはあなたから取得するかもしれないGNU Emacsの任意のバージョンの更なる共有を妨げる試みです。これの正確な条件はEmacsのGNU General Public Licenseで見ることができ、このマニュアルにも記載されています[1]。 [Copying](#Copying)を参照してください。

GNU Emacsのコピーを入手する1つの方法は、それを所有する他の誰かから入手する方法です。これを行なうための許可を求めたり、他の誰かに告げる必要はありません。ただコピーするだけです。インターネットへアクセスできるなら、匿名FTPからGNU NEmacsの最新のディストリビューションバージョンを入手できます。わたしたちのウェブサイトについての詳細は、<https://www.gnu.org/software/emacs>を参照してください。

コンピューターを購入したときに、GNU Emacsを入手するかもしれません。コンピューター業者は、他のすべての人に適用されるのと同じ条件で、コピーを自由に配布できます。これらの条件は、コンピューター業者がソースにたいして行なった変更を含む完全なソースをあなたに与えることと、General Public Licenseの通常の条件の下に、入手したGNU Emacsをあなたが再配布できることを要求します。言い換えると、そのプログラムはあなたが入手したときはフリーでなければならず、業者にとっては単にフリーという訳ではありません。

GNU Emacsが有用だと思ったら、わたしたちの作業をサポートするために、どうかFree Software Foundationに**寄付を送ってください**。合衆国ではFree Software Foundationへの寄付は、税金が控除されます。職場でGNU Emacsを使用している場合は、どうかその企業に寄付を行なうよう提案してください。寄付をするには、<https://my.fsf.org/donate/>を参照してください。あなたが手助けできる他の方法については、<https://www.gnu.org/help/help.html>を参照してください。

わたしたちは、このマニュアルと、Robert J. ChassellによるAn Introduction to Programming in Emacs Lispのハードコピーも販売しています。あなたは、わたしたちのオンラインショップ<https://shop.fsf.org/>を訪れることができます。販売による収益は、Free Software Foundationの目的 — すなわち新しいソフトウェアーの開発、GNU Emacsを含む既存のプログラムの改良をサポートします。

Free Software Foundationに連絡する必要がある場合は、<https://www.fsf.org/about/contact/>を参照するか、下記に手紙を送ってください

    Free Software Foundation
    51 Franklin Street, Fifth Floor
    Boston, MA 02110-1301
    USA

イントロダクション
==================

あなたはEmacsのマニュアル読んでいるところです。Emacsは、セルフドキュメント方式で、カスタマイズ可能で、拡張可能エディターであり、GNUの先進性を具現化したものです( GNU (GNU’s Not Unix) の‘`G`’は発音します)。

Emacsは先進的(advanced)であるというのは、単純な挿入と削除だけでなく、プロセスの制御、プログラムのインデントの自動化、複数ファイルの同時表示、整形済みテキストの編集、文字、単語、行、文、段落、ページを扱うのと同様に、異なるプログラミム言語の式やコメントを扱う機能なども提供するからです。

セルフドキュメント方式(Self-documenting)とは、いつでもヘルプコマンドとして知られる、特別なコマンドを使うことができることです。これはどのようなオプションがあるのか、コマンドが何をするのかを見つけたり、与えられたトピックと関連するすべてのコマンドを見つけることができるコマンドです。[Help](#Help)を参照してください。

カスタマイズ可能(Customizable)とは、シンプルな方法でEmacsコマンドの動作を簡単に変更できるということです。たとえば、‘`<**`’で始まり‘`**>`’で終わるようなコメントのプログラム言語を使っている場合は、Emacsのコメント操作コマンドに、これらの文字列を使うように指示できます([Comments](#Comments)を参照してください)。別の例としては、カーソル動作(上下左右)を再編成して使いやすくカスタマイズできます。[Customization](#Customization)を参照してください。

拡張可能(Extensible)とは、単純なカスタマイズではなく、まったく新しいコマンドを作成できるということです。新しいコマンドは、Emacs自身のLisp処理系で動作する、Lisp言語でプログラムを記述されます。既存のコマンドは、編集を行なっている最中でさえ、Emacsを再起動することなく再定義できます。Emacsのほとんどの編集コマンドはLispで記述されています。Lispで記述することも可能ですが、効率のためにCで記述されているものもあります。拡張機能の記述はプログラミングですが、プログラマーでない人も後でそれを使うことができます。もしあなたがEmacs Lispを学びたければ、section “Preface” in An Introduction to Programming in Emacs Lispを参照してください。

画面の構成
==========

screen
frame
Xウィンドウシステムを使うGNU/Linuxのようなグラフィカルなディスプレーの場合、Emacsはグラフィカルなウィンドウに表示されます。テキスト端末の場合、Emacsは端末スクリーン全体を表示領域として使います。Emacsが占有する画面スクリーンや、グラフィカルなウィンドウを指して、フレーム(frame)という用語を使用します。Emacsの振る舞いは、どちらのフレームでも同じです。通常は1個のフレームだけで始まりますが、必要ならば新たにフレームを作れます([Frames](#Frames)を参照)。

それぞれのフレームにはいくつかの領域が含まれています。いちばん上のフレームはメニューバー(menu bar)で、メニューにある一連のコマンドにアクセスできます。グラフィカルなディスプレーでは、メニューバーのすぐ下にツールバー(tool bar)があり、アイコンをクリックすることにより編集コマンドを実行できます。いちばん下のフレームはエコーエリア(echo area)で、メッセージが表示されたり、Emacsが入力を求める際に使用されます。

(もしあれば)ツールバーの下とエコーエリアの間の、フレームの主要な領域の部分を、ウィンドウ(the window)といいます。このマニュアルでは“ウィンドウ”という言葉を、上記のような場合に使います。グラフィカルなディスプレーのシステムでは、“ウィンドウ”という言葉を違う意味で用いますが、上述したとおり、そのようなグラフィカルなウィンドウのことは、“フレーム”と呼ぶことにします。

Emacsのウィンドウには、バッファー(buffer) — 編集、または閲覧しているテキストやグラフィック — が表示されます。グラフィカルなディスプレーでは、ウィンドウの片側にスクロールバー(scroll bar)あり、これを使ってバッファー内をスクロールできます。ウィンドウのいちばん下の行は、モードライン(mode line)です。これには保存されてない変更や、使用されている編集モード、現在のライン番号など、バッファーについての様々な情報が表示されます。

Emacsを起動すると、通常フレームには1つのウィンドウが表示されます。しかしこのウィンドウを水平方向、または垂直方向に分割して複数のウィンドウを作成し、それぞれ異なるバッファーを表示することもできます([Windows](#Windows)を参照)。

どんな時でも、1つのウィンドウが選択されたウィンドウ(selected window)となります。グラフィカルなディスプレーでは、選択されたウィンドウには目立つカーソル(通常は塗りつぶされて点滅している)が表示され、他のウィンドウには目立たないカーソル(通常はぬりつぶされていない四角)が表示されます。テキスト端末では、選択されたウィンドウのカーソルだけが表示されます。選択されたウィンドウ上に表示されているバッファーを、カレントバッファー(current buffer)と呼び、それが編集が行われているバッファーとなります。多くのEmacsコマンドはカレントバッファーに暗黙に適用され、選択されてないウィンドウに表示されているテキストは参照用に使用します。もしグラフィカルなディスプレーで複数のフレームを使っている場合、特定のフレームを選択すると、そのフレームのウィンドウが選択されます。

ポイント
--------

point
cursor
カーソルは、選択されたウィンドウで多くの編集コマンドが作用する場所を示し、その場所をポイント(point)[2]と呼びます。多くのEmacsコマンドはポイントをテキスト中で移動し、テキスト中のさまざまな箇所で編集できるようにします。マウスのボタン1(通常は左ボタン)をクリックしても、ポイントを移動できます。

デフォルトでは、選択されたウィンドウ上にある、塗りつぶされたボックスのカーソルは文字の*上*に表示されますが、ポイントは2つの文字の*間*にあると考える必要があります。つまりポイントは、カーソルが重なっている文字の*前*にあります。たとえば、‘`frob`’というテキストで、‘`b`’にカーソルがある場合、ポイントは‘`o`’と‘`b`’の間にあります。その位置に‘`!`’という文字を挿入すると、‘`fro!b`’という結果になり、ポイントは‘`!`’と‘`b`’の間にあります。つまりカーソルは‘`b`’の上にあり、実行前と同じです。

Emacsでいくつかのファイルを編集して、各ファイルがそれぞれ専用のバッファーにある場合、各バッファには独自のポイント位置があります。バッファーが表示されていなくても、後で表示されるときに備えて、ポイント位置を記録しています。1つのフレームに複数のウィンドウがある場合、各ウィンドウには独自のポイント位置があります。

Emacsがカーソルをどのように表示するか制御する方法については、[Cursor Display](#Cursor-Display)を参照してください。

エコーエリア
------------

echo area
フレームの1番下の行は、エコーエリア(echo area)です。ここは、いろいろな目的向けの短いテキスト表示に使われます。

echoing
エコーエリアという名前は、あなたが打った文字がエコーされることが由来で、これは複数の文字からなるコマンドが表示されることを意味します。1文字のコマンドをエコーすることはありません。複数の文字からなるコマンド([Keys](#Keys)を参照)の途中で、入力中に1秒以上間を置くとエコーされます。Emacsはそれまでに入力されたコマンドの文字を表示し、ユーザーに残りの文字の入力を促します。いったんエコーが始まると、コマンドの残りは、打つと同時にただちにエコーされます。これは、タイプに自信のあるユーザーには速い応答を提供する一方で、自信のないユーザーには最大限のフィードバックを与えるための機能です。

error message
echo area message
エコーエリアは、コマンドを実行できなかったときに、エラーメッセージ(error message)を表示するためにも使用されます。エラーメッセージと共に、ビープ音が鳴ったり、画面が点滅する場合もあります。

エコーエリアに有用なメッセージを表示するコマンドもあります。これらの有用なメッセージは、エラーメッセージによく似ていますが、ビープ音を伴わず点滅もしません。たとえば、コマンド`C-x
=`(Ctrlを押したまま`x`をタイプし、Ctrlを離してから`=`をタイプします)は、テキスト中のポイントの文字位置と、ウィンドウの現在の列位置を示すメッセージを表示します。処理に時間のかかるコマンドでは、実行中に‘`...`’(どの程度進行したかをパーセント表示で示す場合もあります)で終わるメッセージをエコーエリアに表示し、完了時には‘`done`’を最後に付け加えることがよくあります。

\*Messages\*
buffer
saved echo area messages
messages saved from echo area
message-log-max
エコーエリアに表示される有益なメッセージは、`*Messages*`と呼ばれる特別なバッファーに保存されます(まだバッファーについては説明していませんが、詳細は[Buffers](#Buffers)を参照)。画面上に短時間しか表示されないメッセージを見逃してしまった場合には、`*Messages*`バッファーに切り替えて、もう一度そのメッセージを見ることができます。`*Messages*`のサイズは、ある行数に制限されています。変数`message-log-max`は、その行数を指定します(まだ変数については説明していませんが、詳細は[Variables](#Variables)を参照)。いったんバッファーがこの行数を超えると、最後に1行加わるごとに先頭の1行を削除します。

Emacsがエコーエリアをどのように使用するか制御するオプションについては、[Display Custom](#Display-Custom)を参照してください。

エコーエリアはミニバッファー(minibuffer)の表示にも使われます。これは、編集しようとするファイル名のような、コマンドへの引数を読むのに使われるウィンドウです。ミニバッファーが使用されているとき、エコーエリアにはプロンプト文字列(prompt string)で始まるテキストが表示され、エコーエリアが一時的に選択されたウィンドウとなり、カーソルもその行に表示されます。`C-g`を打つと、いつでもミニバッファーから抜けられます。[Minibuffer](#Minibuffer)を参照してください。

モードライン
------------

mode line
top level
ウィンドウの最後の行はモードライン(mode line)で、そのウィンドウで何が進行しているか表示します。ウィンドウが1つしかない場合、モードラインはエコーエリアのすぐ上に表示されます。フレームでは最後から2番目の行になります。グラフィカルなディスプレーでは、モードラインは立体的に描画されます。通常、Emacsは目立つように選択されたウィンドウのモードラインを、選択されていないウィンドウと異なるカラーで描画します。

モードラインに表示されるテキストは以下の書式です:

     cs:ch-fr  buf      pos line   (major minor)

テキスト端末では、上記テキストの後ろからウィンドウの右端まで一連のダッシュ表示されます。これらのダッシュはグラフィカルなディスプレーでは省略されます。

csとその後ろのコロンは、カレントバッファーのキャラクターセットと改行の規則を説明しています。通常Emacsはこれらの設定を自動的に処理しますが、このメッセージが便利なときもあります。

csはバッファーのキャラクターセットを説明します([Coding Systems](#Coding-Systems)を参照)。もしこれがダッシュ(‘`-`’)の場合、特定のキャラクターセットの処理が行われていないことを意味します(例外として、以降で説明する行末規則があります)。‘`=`’の場合は、変換が行われていないことを意味し、通常はテキストに非テキストデータが含まれているときに使用されます。他の文字はさまざまなコーディングシステム(coding systems) — たとえば‘`1`’はISO Latin-1を表します。

テキスト端末ではcsの前に追加で2つの文字が表示され、それによりキーボード入力と端末出力のコーディングシステムが示されます。さらに何らかの入力メソッドを使用している場合は、csの前に入力メソッドを識別する文字列が表示されます([Input Methods](#Input-Methods)を参照)。

end-of-line convention, mode-line indication
csの後ろの文字は、通常コロンです。もし違う文字が表示されている場合、それはファイルのエンコーディングに特別な行末規則が使われていることを意味します。通常ファイル内のテキストの各行は改行文字(newline characters)で区切られていますが、他の2つの規則が使われる場合もあります。MS-DOSのファイルを編集する場合にはキャリッジリターン(carriage-return)とラインフィード(linefeed)が使われ、コロンではなくバックスラッシュ(‘`\`’)または‘`(DOS)`’(オペレーティングシステムに依存する)が表示されます。古いマッキントッシュシステムのファイルでは、改行文字の代わりにキャリッジリターン(carriage-return)が使われ、そのような場合コロンではなくスラッシュ(‘`/`’)または‘`(Mac)`’が表示されます。いくつかのシステムでは行の区切りとして改行文字を使う場合、コロンではなく‘`(Unix)`’と表示されます。

`emacsclient` ([Invoking emacsclient](#Invoking-emacsclient)を参照)で作成されたフレームでは、次の文字に‘`@`’が表示されます。これは通常、デーモン([Emacs Server](#Emacs-Server)を参照)として実行中のEmacsプロセスのフレームにたいして表示されます。

モードラインの次の要素はchで示される文字列です。2つのダッシュ(‘`--`’)が表示されている場合、ウィンドウに表示されているバッファーとディスク上のファイルの内容が同じことを意味し、たとえばバッファーが未変更(unmodified)の場合です。バッファーが変更されている場合には2つの星印(‘`**`’)が表示されます。読み出し専用のバッファーの場合には、バッファーが編集されている場合には‘`%*`’になり、バッファーが編集されていない場合には‘`%%`’となります。

通常、chの後ろの文字はダッシュ(‘`-`’)です。しかしカレントバッファーの`default-directory` ([File Names](#File-Names)を参照)がリモートマシン上([File Names](#File-Names)を参照)にある場合、かわりに‘`@`’が表示されます。

frは選択されているフレームの名前です([Frames](#Frames)を参照)。これはテキスト端末でだけ表示されます。フレーム名の初期値は‘`F1`’です。

bufは、ウィンドウに表示されているバッファーの名前です。通常は編集中のファイル名と同じです。[Buffers](#Buffers)を参照してください。

posはウィンドウの上またはウィンドウの下に、まだテキストがあるかを知らせます。もしバッファーが小さくてウィンドウに全体が表示されている場合、posには‘`All`’が表示されます。そうではなくバッファーの一部が表示されているときには、バッファーの先頭が表示されている場合には‘`Top`’、バッファーの最後が表示されている場合には‘`Bot`’、‘`nn%`’と表示されている場合、nnはウィンドウの上部がバッファーのどこかをパーセント表示したものです。Size Indication(サイズ表示)モードでは、バッファー全体のサイズを表示できます。

lineは、‘`L`’のあとに現在ポイントがある行の番号が続いたものです(Column Number(列番号)モードをオンにすると、現在の列番号も表示できます。[Optional Mode Line](#Optional-Mode-Line)を参照)。

majorは、そのバッファのメジャーモード(major mode)の名前です。メジャーモードはバッファーを編集する際の主要なモードで、Textモード、Lispモード、Cモードなどがあります。[Major Modes](#Major-Modes)を参照してください。メジャーモード名の後ろに追加の情報を表示するメジャーモードもあります。たとえばCompilation buffer(コンパイルバッファー)やShell buffer(Shellバッファー)などは、サブプロセスの状態を表示します。

minorは有効になっているマイナーモード(minor modes)の一覧で、上位のメジャーモードに追加の機能を提供するための編集モードです。[Minor Modes](#Minor-Modes)を参照してください。

いくつかの機能は、それらが本当はマイナーモードではなくても、有効になっていればマイナーモードの一覧とともに表示されます。‘`Narrow`’は、表示中のバッファーが、そのテキストの一部のみを編集するように制限されていることを示します([Narrowing](#Narrowing)を参照)。‘`Def`’は、キーボードマクロを定義中であることを示します([Keyboard Macros](#Keyboard-Macros)を参照)。

さらにEmacsが再帰編集(recursive edit)にあるときには、モードを囲んでいるカッコの周りに角カッコ(‘`[…]`’)が現れます。再帰編集中も別の再帰編集に入ると、角カッコは2重になります。再帰編集は、特定のバッファにだけ関係するものではなく、Emacs全体に影響するので、角カッコはすべてのウィンドウのモード行に表示されるか、まったく表示されないのどちらかです。[Recursive Edit](#Recursive-Edit)を参照してください。

モードラインの外観は、その内容の書式と同様、変更できます。[Optional Mode Line](#Optional-Mode-Line)を参照してください。さらにモードラインはマウスに反応します。モードラインの違う部分をクリックすることでさまざまなコマンドを実行できます。[Mode Line Mouse](#Mode-Line-Mouse)を参照してください。また、モードラインのマウス感応範囲上でマウスポインターをホバリングすると、モードライン上でクリックして呼び出すことができるコマンドに関する情報を表示するツールチップ([Tooltips](#Tooltips)を参照)が表示されます。また、モードラインのマウスセンシティブ(mouse-sensitive: マウス感応)な部分の上にマウスをホバリングすると、モードライン上をクリックして呼び出せるコマンドに関する情報がツールチップ([Tooltips](#Tooltips)を参照)が表示されます。

メニューバー
------------

menu bar
各Emacsフレームには通常、最上部にメニューバー(menu bar)があり、よく使われる操作を実行するために使用できます。これはあなた自身で簡単に確かめられますから、ここではそれらを列挙する必要はないでしょう。

マウスをサポートするディスプレー上では、マウスを使ってメニューバーからコマンドを選ぶことができます。メニューアイテムの後にある右矢印は、そのアイテムにサブメニュー(submenu)があることを示します。アイテムの最後に‘`...`’がある場合は、コマンドを実際に実行する前に、そのコマンドがキーボードから引数を読み取ることを意味します。

メニューのコマンドの中には、他のコマンドと同様、キーが割り当てられているものもあります。そのような場合、メニューのアイテムの後にキーバインディングが表示されます。メニューアイテムの完全なコマンド名や説明文を見るには、`C-h
k`とタイプしてから、通常どおりにマウスでメニューバーを選択してください([Key Help](#Key-Help)を参照)。

F10
menu-bar-open
menu bar access using keyboard
マウスを使う代わりにF10(コマンド`menu-bar-open`を実行します)を押せば、メニューバーの最初のアイテムを呼び出すことができます。その後は矢印キー、または`C-b`と`C-f`(左右)、`C-p`と`C-n`(上下)でメニュー操作できます。選択されたメニューアイテムを起動するときはRET、メニュー操作をキャンセルするときは`C-g`か`ESC
ESC
ESC`を押します。(ただし、GUIツールキットとともにビルドされたEmacsでは、メニューはそのツールキットにより描画および制御され、メニュー操作をキャンセルするキーシーケンスは上記の説明とは異なるかもしれません。)

M-‘
tmm-menubar
tty-menu-open-use-tmm
テキスト端末では、エコーエリアからメニューバーのメニューにアクセスすることもできます。これを行うには、変数`tty-menu-open-use-tmm`をカスタマイズして、非`nil`値にします。その後はF10をタイプするとメニューをドロップダウンせずに、コマンド`tmm-menubar`が実行されます(`` M-` ``は常に`tmm-menubar`を呼び出します)。`tmm-menubar`では、キーボードでメニューアイテムを選択できます。暫定的な候補がエコーエリアに表示されるので、上矢印か下矢印でメニューの異なるアイテムを表示し、RETを押せばアイテムを選択できます。各メニューアイテムを文字か数字で指定することもできます(通常メニューアイテム名のイニシャル)。この文字または数字とアイテム名は‘`==>`’で区切られています。アイテムの文字または数字を押せばアイテムを選択することができます。

ユーザー入力の種類
==================

input with the keyboard
keyboard input
character set (keyboard)
ASCII
GNU Emacsは、主にキーボードを使うようにデザインされています。マウスを使ってメニューバーやツールバーの編集コマンドを実行することはできますが、キーボードを使う場合に比べて効率的ではありません。したがって、このマニュアルには主にキーボードで編集する方法を記します。

control character
Emacsにたいするキーボード入力は、ASCIIを大きく拡張したバージョンが基本となっています。‘`a`’、‘`B`’、‘`3`’、‘`=`’や空白文字(SPC)と表記します)などの単純な文字は、それぞれに対応するキーをタイプして入力します。RET、TAB、DEL、ESC、F1、Home、LEFTなどの制御文字なども、この方法で入力できますし、非英語キーボードの特定の文字も同様です([International](#International)を参照)。

modifier keys
Control
C-
META
M-
Emacsは修飾キー(modifier keys)を用いて入力された制御文字も認識します。よく使用される修飾キーは、Control(通常Ctrl)というラベル)と、Meta(通常Alt[3]というラベル)の2つです。たとえば、`Control-a`はCtrlを押したままで`a`を押して入力しますが、これを短く`C-a`と記します。同様に、`Meta-a`または短く`M-a`は、Altを押したまま`a`を押すことです。修飾キーは英数文字以外のキーにも適用できます。例: `C-F1`、`M-LEFT`

ESC
replacing
Meta
key
ESCで始まる2文字キーシーケンスを使って、Meta文字を入力することもできます。したがって`M-a`を`ESC
a`と入力することができます。`C-M-a`(CtrlとAltを両方押しながら`a`を押下)は`ESC
C-a`と入力できます。Metaと違い、ESCは切り離された文字です。次の文字を押すときESCを押しっぱなしにするのではなく、ESCを押して離してから次の文字を入力します。この機能はMetaキーをあてにできない、一部のテキスト端末で有用です。

keys stolen by window manager
window manager, keys stolen by
グラフィカルなディスプレーでは、ウィンドウマネージャーが`M-TAB`、`M-SPC`、`C-M-d`、`C-M-l`などのキーボード入力をブロックするかもしれません。このような問題がある場合、ウィンドウマネージャーがこれらのキーをブロックしないようにカスタマイズしたり、影響を受けるEmacsのコマンドをリバインド(rebind)したりできます([Customization](#Customization)を参照)。

input event
単純な文字や制御文字、同様にマウスのクリックなどの非キーボード入力は、総じて入力イベント(input events)と呼ばれます。Emacsが内部で入力イベントをどのように処理するかについての詳細は、section “Input Events” in The Emacs Lisp Reference Manualを参照してください。

キー
====

Emacsコマンドには、ただ1つの入力イベントで呼び出されるものが、いくつかあります。たとえば`C-f`はバッファーを1文字前方に移動します。他のコマンドは、`C-x
C-f`や`C-x 4 C-f`のように、2つ以上の入力イベントにより呼び出されます。

key
key sequence
complete key
prefix key
キーシーケンス(key sequence)、短く書くとキー(key)は、1つの単位として考えることのできる、1つまたはそれ以上の一連の入力イベントの集まりのことです。もし、あるキーシーケンスがコマンドを呼び出すような場合、それをコンプリートキー(complete key)と呼ぶことにします。たとえば`C-f`、`C-x C-f`、`C-x 4
C-f`などはコンプリートキーです。もし、あるキーシーケンスがコマンドを呼び出すほど十分長くないとき、それをプレフィクスキー(prefix key)と呼ぶことにします。たとえば前の例でいうと、`C-x`や`C-x
4`はプレフィクスキーです。すべてのキーシーケンスは、コンプリートキーかプレフィクスキーのどちらかになります。

プレフィクスキーは、その後の入力イベントと組み合わせて、もっと長いキーシーケンスを作るためのものです。たとえば`C-x` はプレフィクスキーなので、`C-x`と入力しただけではコマンドは呼び出されません。かわりにEmacsは更なる入力を待ちます(もし１秒以上入力がない場合、入力を促すために`C-x`がエコーされます。[Echo Area](#Echo-Area)を参照)。`C-x`は、それに続く次の入力イベントと組み合わされる、2イベントのキーシーケンスで、それはプレフィクスキー(`C-x
4`)など)のときもあれば、コンプリートキー(`C-x
C-f`など)のときもあります。キーシーケンスの長さに制限はありませんが、実際に3つ、4つ以上の入力イベントの場合は、ほとんどありません。

コンプリートキーに入力イベントを付け加えることはできません。たとえば、`C-f`はコンプリートキーなので、2イベントのシーケンス`C-f
C-k`は、1つではなく2つのキーシーケンスです。

デフォルトではEmacsのプレフィクスキーは`C-c`、`C-h`、`C-x`、`C-x
RET`、`C-x @`、`C-x a`、`C-x n`、`C-x r`、`C-x
v`、`C-x 4`、`C-x 5`、`C-x
6`、ESC、`M-g`、`M-o`です(F1とF2は、`C-h`と`C-x
6`のエイリアスです)。このリストは不変のものではありません。Emacsをカスタマイズすれば、新しいプレフィクスキーを作ることができます。標準のプレフィクスキーを無効にすることさえできますが、これはほとんどのユーザーにたいして推奨はできません。たとえばプレフィクス定義`C-x
4`を削除すると、`C-x 4 C-f`は無効なキーシーケンスになります。[Key Bindings](#Key-Bindings)を参照してください。

プレフィックスキーのあとにヘルプ文字(`C-h`やF1)を押すと、そのプレフィックスで始まるコマンド一覧を表示できます。唯一の例外はESCです。`ESC
C-h`は`C-M-h`と同じで、これは何かまったく別のことを行うコマンドです。しかしF1ならば、ESCで始まるコマンドの一覧を表示できます。

キーとコマンド
==============

binding
command
このマニュアルは、特定のキーが何を行うかを説明するページばかりです。しかし、Emacsは直接キーに意味を与えてはいません。そのかわりに、Emacsは名前を付けたコマンド(commands)に意味を持たせ、キーとコマンドをバインディング(binding)することによって、キーに意味を与えています。

すべてのコマンドには、プログラマーが選んだ名前が付いています。名前は、たとえば`next-line`、`forward-word`のように、いくつかの英単語をダッシュで区切って作られます。内部的には、それぞれのコマンドはLispの関数(function)の特別な型で、コマンドに関連付けられたアクションは、関数を実行することによって機能します。section “What Is a Function” in The Emacs Lisp Reference Manualを参照してください。

キーとコマンドの間のバインディングは、keymapsというテーブルに記憶されます。[Keymaps](#Keymaps)を参照してください。

“`C-n`は下に1行動きます”という言い方は、通常の使用では関係ないものの、Emacsをカスタマイズする上では重要になる点を隠蔽しています。1行下に移動するコマンドは`next-line`です。`C-n`が`next-line`にバインドされているから効果があるのです。もし`C-n`をコマンド`forward-word`にリバインドしたら、`C-n`で1語前方に動くことになります。

厳密に言えばキーはコマンドにバインドされているだけですが、このマニュアルでは`C-n`をコマンドであるかのような言い回しをするときがあります。そのようなときは、処理を実行させるキーの後ろに、本当に処理を行うコマンドの名前をカッコ内に記します。たとえば、“コマンド`C-n` (`next-line`)は、ポイントを垂直下方に移動します”というときは、コマンド`next-line`がポイントを垂直下方に移動し、それは通常`C-n`にバインドされている、ということを意味します。

カスタマイズについて議論したので、変数(variables)にもふれておくべきでしょう。コマンドの説明で、“これを変更する場合、変数 `mumble-foo`をセットしてください”というときがあります。変数とは、値を保存するときに使用する名前のことです。このマニュアルに記載されている変数は、ほとんどがカスタマイズに関するものです。いくつかのコマンド、およびEmacsのある部分は、変数を調べてその変数にセットされた値により、動作がかわります。カスタマイズに興味がでるまでは、、変数に関する情報は無視してかまいません。その後で変数([Variables](#Variables)を参照)の基本を読めば、特定の変数についての情報に合点がいくでしょう。

Emacsの起動
===========

entering Emacs
starting Emacs
Emacsを呼び出す通常の方法は、シェルコマンド`emacs`です。GUI端末上で実行されるUnixシェルからは、`emacs
&`によりEmacsをバックグラウンドで実行できます。この方法だとEmacsが端末ウィンドウに結びつけられないため、他のシェルコマンドを実行できます(MS-WindowsでEmacsを開始する方法については、[Windows Startup](#Windows-Startup)を参照)。

startup screen
Emacsを起動すると、初期フレームは‘`*GNU
Emacs*`’という名前の特別なバッファーを表示します。このスタートアップ画面(startup screen)には、Emacsについての情報と、初心者にとって便利な一般的タスクへのリンクが含まれています。たとえば‘`Emacs
Tutorial`’というリンクはEmacsのチュートリアルを開きます。これはコマンド`C-h t` (`help-with-tutorial`)と同じです。リンクをアクティブにするには、ポイントをそこに動かして`RET`をタイプするか、`mouse-1`(マウスの左ボタン)をクリックしてください。

コマンドライン引数を使うと、Emacsが起動直後に1つ以上のファイルをアクセスするよう指示できます。たとえば`emacs
foo.txt`は、‘`foo.txt`’の内容を表示するバッファーとともにEmacsを起動します。これは他のエディターとの互換性により存在する機能で、シェルから短い編集セッションを始めるときのためにデザインされています。Emacsをこの方法で呼び出すと、初期フレームは2つのウィンドウに分割されます。1つは指定されたファイルで、もう1つはスタートアップ画面です。[Windows](#Windows)を参照してください。

一般的に、ファイルを編集するたびに新たにEmacsを起動するのは不必要で無駄です。Emacsを使うときの推奨方法は、Emacsを1度だけ起動する方法で、ログインしたら起動して、同じEmacsセッションですべての編集作業を行うのです。1つ以上のファイルをアクセスする方法は、[Files](#Files)を参照してください。この方法でEmacsを使うと、Emacsのセッションはキルリング(kill ring)、レジスター(registers)、アンドゥヒストリー(undo history)、マークリング(mark ring)などの、値をもつコンテキストを蓄積するので、これを共有すれば編集がより快適になります。これらの機能については、このマニュアルの後で説明します。

Emacsを実行中に、他のプログラムからファイルを編集する場合、既存のEmacsセッションのファイルを開くために、`emacsclient`というヘルパープログラムを使うことができます。[Emacs Server](#Emacs-Server)を参照してください。

コマンドライン引数を使って、EmacsにLispファイルをロードして初期フレームに適用させたりできます。[Emacs Invocation](#Emacs-Invocation)を参照してください。

inhibit-startup-screen
変数`inhibit-startup-screen`が非`nil`の場合、Emacsはスタートアップ画面を表示しません。この場合、コマンドラインに1つ以上のファイルが指定されていれば、Emacsは単にそれらのファイルを表示し、指定されていないときはLispの式を対話的に評価できる、`*scratch*`という名前のバッファーを表示します。[Lisp Interaction](#Lisp-Interaction)を参照してください。変数`inhibit-startup-screen`のセットは、Emacsのカスタマイズ機能([Easy Customization](#Easy-Customization)を参照してください)を使うか、初期設定ファイル([Init File](#Init-File)を参照してください)を編集して行うことができます。[4]

変数`initial-buffer-choice`にファイルやディレクトリーの名前をセットすることにより、Emacsのスタートアップ時にファイルやディレクトリーを表示させることもできます。`initial-buffer-choice`の値に、その後に表示するバッファーを戻す関数(引数なし)をセットすることもできます。 `initial-buffer-choice`が非`nil`の場合、コマンドラインにファイルを指定しても、それらのファイルは表示されますが、初期画面としては表示されません。

Emacsからのexit
===============

exiting
killing Emacs
leaving Emacs
quitting Emacs
`C-x C-c`  
Emacsをkill(終了)します。(`save-buffers-kill-terminal`)。

`C-z`  
テキスト端末ではEmacsをサスペンドします。グラフィカルなディスプレーでは選択されたフレームをアイコン化(または“最小化”)します(`suspend-frame`)。

C-x C-c
save-buffers-kill-terminal
EmacsをKillするというのは、Emacsプログラムを終了するという意味です。これを行うには、`C-x C-c` (`save-buffers-kill-terminal`)とタイプします。2文字キーシーケンスが使われているのは、アクシデントにより間違ってタイプしづらくするためです。もし変更されたファイルがある場合、`C-x
C-c`をタイプすると、Emacsとそれらのバッファーを巡回して、バッファーを保存するか問い合わせます。それらすべてを保存しない場合、未保存の変更が失われてしまう前に、もう一度問い合わせます。サブプロセスがまだ実行中の場合にも、Emacsをkillするとサブプロセスもkillされるので、問い合わせを行います([Shell](#Shell)を参照してください)。

もしEmacsをサーバーとして使っている場合、`C-x
C-c`は特別に振る舞います。もしクライアントフレームからタイプした場合は、クライアントのコネクションをクローズします。[Emacs Server](#Emacs-Server)を参照してください。

Emacsはオプションで、killしたときに表示していたファイルなどの、セッション情報を記録することができます。この情報は次回Emacsを起動するとき利用可能です。[Saving Emacs Sessions](#Saving-Emacs-Sessions)を参照してください。

confirm-kill-emacs
変数`confirm-kill-emacs`の値が非`nil`の場合、`C-x
C-c`はその値が関数だとみなして、その関数を呼び出します。その関数呼び出しの結果が非`nil`の場合、セッションはkillされ、そうでない場合、Emacsは実行を続けます。`confirm-kill-emacs`の値として使うのに適した関数の1つが、`yes-or-no-p`です。`confirm-kill-emacs`のデフォルト値は`nil`です。

confirm-kill-processes
変数`confirm-kill-processes`の値が`nil`の場合、`C-x
C-c`はEmacsにより開始されたサブプロセスをkillする前に確認を求めません。デフォルトでは、この値は`t`です。

Emacsをexitするとき何が起こるかさらにカスタマイズするには、section “Killing Emacs” in The GNU Emacs Lisp Reference Manualを参照してください。

kill-emacs
保存の問い合わせを行わずにEmacsをkillするときは、`M-x kill-emacs`とタイプします。

C-z
suspend-frame
minimizing
iconifying
suspending
`C-z`は、コマンド`suspend-frame`を実行します。グラフィカルなディスプレーでは、このコマンドは選択されたEmacsのフレームを後で戻れるように、最小化(またはアイコン化)して隠します(どのように隠されるかはウィンドウシステムに依存します)。テキスト端末では、`C-z`はEmacsをサスペンド(休止)します。プログラムは一時的に停止し、制御は親プロセス(通常はシェル)に戻ります。ほとんどのシェルではシェルのコマンド`%emacs`で、サスペンド中のEmacsを再開できます。

テキスト端末は、通常、実行中のプログラムをkillしたりサスペンドする、特定の特殊文字を監視しています。**この端末の機能は、Emacsではオフになっています。**Emacsでの`C-z`や`C-x
C-c`のキーの意味は、いくつかのオペレーティングシステムでプログラムを休止させたり終了させたりするために用いる文字、`C-z`と`C-c`にヒントを得たものですが、オペレーティングシステムとの関係はそれだけです。これらのキーは、他のコマンドを実行するようにカスタマイズできます([Keymaps](#Keymaps)を参照してください)。

基本的な編集コマンド
====================

C-h t
help-with-tutorial
ここではテキストの入力、修正、ファイルへの保存といった基本操作について説明します。これらに接するのが初めてなら、learn-by-doing(行ってみることで学ぶ)形式のチュートリアルをやってみることを提案します。チュートリアルを行うには`C-h
t` (`help-with-tutorial`)とタイプしてください。

テキストの挿入
--------------

insertion
graphic characters
普通のグラフィック文字(graphic character)(例 ‘`a`’、‘`B`’、‘`3`’、‘`=`’)は、対応するキーをタイプして挿入することができます。これによりバッファーのポイント位置に文字が追加されます。挿入によりポイントは前方に移動するので、ポイントは挿入された文字の直後になります。[Point](#Point)を参照してください。

RET
C-j
newline
行を終了して新しい行を開始するにはRET(`newline`)を入力します(キーボードでRETキーは、ReturnやEnter、もしくは↲のような奇妙な左矢印のラベルがついているかもしれませんが、このマニュアルではRETと呼ぶことにします)。このコマンドは改行文字をバッファーに挿入してから、メジャーモードに基づきインデント([Indentation](#Indentation)を参照してください)を行います。ポイントが行末にある場合には、新しく空行を作成してから新しい行をインデントします。もしポイントが行の途中にある場合、行はその位置で分割されます。自動インデントをオフにするには、Electric Indentモード([Indent Convenience](#Indent-Convenience)を参照してください)を無効にするか、自動インデントを行わず改行だけを挿入する`C-j`を入力します。

マニュアルの後ろで説明しますが、マイナーモード(minor modes)を利用することにより、Emacsが挿入を処理する方法を変更できます。たとえばAuto Fillモードというマイナーモードは行が長くなりすぎたとき自動的に行を分割します(see [Filling](#Filling))。Overwrite modeというマイナーモードは、既存の文字を右方に押しやるかわりに、既存の文字を置き換え(上書き)ます。[Minor Modes](#Minor-Modes)を参照してください。

quoting
C-q
quoted-insert
対応するキーを押して挿入できるのはグラフィック文字だけです。他のキーは編集コマンドとして動作し、文字自体の挿入はしません。たとえば、デフォルトではDELは、コマンド`delete-backward-char`を実行します(違うコマンドにバインドされているモードもあります)。このキーはリテラルの‘`DEL`’(ASCIIの文字コード127)を入力する訳ではありません。

非グラフィック文字や、キーボードがサポートしていない文字を挿入するには、最初に`C-q` (`quoted-insert`)で文字をクォート(quote)します。`C-q`の使い方は2つあります:

-   `C-q`に続けて非グラフィック文字(`C-g`でさえも)をタイプすると、その文字が挿入されます。たとえば`C-q
    DEL`は、リテラルの‘`DEL`’文字を挿入します。

-   `C-q`に続けて8進文字のシーケンスを入力すると、8進の文字コードに対応する文字が挿入されます。任意の8進数字を使うことができます。非8進数字により入力は終了します。もし終了文字がRETの場合、RETは入力の終了だけに用いられます。他の非8進文字は入力を終了させてから、通常の入力として扱われます。つまり`C-q
    1 0 1 B`は‘`AB`’を挿入します。

    8進数字での入力は、通常の非バイナリーのOverwriteモードでは無効になっています。それにより上書きすることなく数字を挿入する便利な方法が提供されます。

read-quoted-char-radix
8進のかわりに10進や16進を使うには、変数`read-quoted-char-radix`に、10や16をセットします。もし基数が16の場合、`a`から`f`は文字コードの一部として扱われます。大文字小文字は区別されません。

insert-char
C-x 8
Unicode characters, inserting
insert Unicode character
characters, inserting by name or code-point
curly quotes, inserting
curved quotes, inserting
数は多くありませんが、一般的なUnicode文字は、`C-x 8`で始まるコマンドを通じて挿入できます。たとえば`C-x 8
[`は、『`‘`』を挿入します。これはUnicodeコードポイント`U+2018`のLEFT SINGLE QUOTATION MARK(単独の左“curved quote”、または“curly quote”と呼ばれることもあります)を挿入します。同様に、`C-x
8 ]`は『`’`』、`C-x 8 {`は『`“`』、`C-x 8
}`は『`”`』を挿入します。また、Altキーも`C-x 8`と同じように機能します。たとえば`A-[`は`C-x 8
[`と同様に、『‘』を挿入します。どの文字が`C-x 8`による短縮入力をもつかを確認するには、`C-x 8
C-h`とタイプしてください。

かわりにコマンド`C-x 8 RET` (`insert-char`)を使うこともできます。これはミニバッファーを使って、Unicode名かコードポイント(code-point)の入力を求めます。もし名前を入力する時、コマンドが補完機能を提供します([Completion](#Completion)を参照してください)。コードポイントを入力する場合、それは16進(Unicodeの規約による)、または指定した基数の数字(例 `#o23072` (octal); section “Integer Basics” in The Emacs Lisp Reference Manualを参照してください)であるべきです。このコマンドは対応する文字をバッファーに挿入します。

たとえば以下はすべて同じ文字を挿入します:

    C-x 8 RET left single quotation mark RET
    C-x 8 RET left sin TAB RET
    C-x 8 RET 2018 RET
    C-x 8 [
    A-[  (Altキーが機能する場合)
    `    (Electric Quoteモードの場合)

`C-q`または`C-x 8
...`への数引数は、文字のコピーを何個挿入するかを指定します([Arguments](#Arguments)を参照してください)。

さらに加えて、あるコンテキストにおいては、`` `like this' ``のようにクォートにgrave accentとapostropheを使用した場合は、たとえ`C-x
8`コマンドを使用していなくても、これは1つのクォーテーションマークを使用した形式`‘like
this’`のように変換されます。同様に、``` ``like this'' ```のように2重のgrave accentとapostropheを使用した場合、これはダブルクォーテーションマークを使用した形式`“like
this”`のように変換されます。[Quotation Marks](#Quotation-Marks)を参照してください。

ポイント位置の変更
------------------

arrow keys
moving point
movement
cursor motion
moving the cursor
文字の挿入以上のことを行うには、ポイントを移動する方法について知る必要があります([Point](#Point)を参照してください)。キーボードのコマンド`C-f`、`C-b`、`C-n`、`C-p`は、それぞれ右・左・下・上にポイントを移動します。ほとんどのキーボードにある矢印キー — RIGHT、LEFT、DOWN、UPでもポイントを移動できます。しかし多くのEmacsユーザーは矢印キーより、コントロールキーのほうが速いと考えています。なぜなら矢印キーを押すためにそれらが配置されている領域に手を動かす必要があるからです。

ポイントを移動したい場所でマウスの左ボタンをクリックしてもポイントを移動できます。Emacsは、さらに洗練された方法でポイントを移動する、さまざまなキーボードコマンドを提供します。

`C-f`  
C-f

forward-char

1文字前方(forward)に移動します (`forward-char`)。

`RIGHT`  
RIGHT

right-char

このコマンド(`right-char`)は`C-f`と同様に振る舞います。例外はポイントのあるパラグラフがright-to-leftの場合です。[Bidirectional Editing](#Bidirectional-Editing)を参照してください。

`C-b`  
C-b

backward-char

1文字後方(backward)に移動します (`backward-char`)。

`LEFT`  
LEFT

left-char

このコマンド(`left-char`)は`C-b`と同様に振る舞います。例外は現在のパラグラフがright-to-leftの場合です。[Bidirectional Editing](#Bidirectional-Editing)を参照してください。

`C-n`; `DOWN`  
C-n

DOWN

next-line

スクリーンに表示された行で1行下に移動します(`next-line`)。このコマンドは横方向の位置を変更しないよう試みます。そのため行の途中でコマンドを開始すると、次の行の途中に移動することになります。

`C-p`; `UP`  
C-p

UP

previous-line

スクリーンに表示された行で1行上に移動します(`previous-line`)。このコマンドは`C-n`と同様、行内の位置を保ちます。

`C-a`; `Home`  
C-a

HOME

move-beginning-of-line

行の先頭に移動します(`move-beginning-of-line`)。

`C-e`; `End`  
C-e

END

move-end-of-line

行の最後に移動します(`move-end-of-line`)。

`M-f`  
1単語前方に移動します(`forward-word`)。[Words](#Words)を最終してください。

`C-RIGHT`; `M-RIGHT`  
C-RIGHT

M-RIGHT

right-word

このコマンド(`right-word`)は`M-f`と同様に振る舞います。例外は現在のパラグラフがright-to-leftの場合、1語*後方*に移動することになります。[Bidirectional Editing](#Bidirectional-Editing)を参照してください。

`M-b`  
1単語後方に移動します(`backward-word`)。[Words](#Words)を参照してください。

`C-LEFT`; `M-LEFT`  
C-LEFT

M-LEFT

left-word

このコマンド(`left-word`)は`M-b`と同様に振る舞います。例外は現在のパラグラフがright-to-leftの場合、1語*前方*に移動することになります。[Bidirectional Editing](#Bidirectional-Editing)を参照してください。

`M-r`  
M-r

move-to-window-line-top-bottom

スクリーン上のテキストを移動させることなく、ポイントの位置をウィンドウ上で中央にもっとも近いテキスト行の左端に移動します。連続して呼び出すと、最上行の左端、最下行の左端へと循環的にポイントを移動します(`move-to-window-line-top-bottom`)。

数引数はスクリーンの行の何行目にポイントを移動するか指定します。数値はウィンドウの最上行から数えた行数です(0は最上行を意味します)。負の引数は最下行から数えた行数です(−1は最下行を意味します。数引数については詳細は、[Arguments](#Arguments)を参照してください。

`M-<`  
M-&lt;

beginning-of-buffer

バッファーの先頭に移動します(`beginning-of-buffer`)。数引数nが与えられた場合、最上行からn/10に移動します。グラフィカルなディスプレイでは、`C-HOME`で同じことを行うことができます。

`M->`  
M-&gt;

C-END

end-of-buffer

バッファーの最後に移動します(`end-of-buffer`)。グラフィカルなディスプレイでは、`C-END`で同じことを行うことができます。

`C-v`; `PageDown`; `next`  
C-v

PageDown

next

画面を1画面前方にスクロールします。もし必要ならポイントをスクリーン上の位置に移動します(`scroll-up-command`)。[Scrolling](#Scrolling)を参照してください。

`M-v`; `PageUp`; `prior`  
M-v

PageUp

prior

画面を1画面後方にスクロールします。もし必要ならポイントをスクリーン上の位置に移動します(`scroll-down-command`)。[Scrolling](#Scrolling)を参照してください。

`M-g c`  
M-g c

goto-char

数値nを読み取り、ポイントをバッファー位置nに移動します。1を指定するとバッファーの先頭に移動します。

`M-g M-g`; `M-g g`  
M-g M-g

M-g g

goto-line

数値nを読み、ポイントをバッファーの先頭からn行目に移動します。行に1を指定するとバッファーの先頭に移動します。もしポイントがバッファーの数字の上または直後にある場合、その数がnのデフォルトになります。ミニバッファーで単にRETを押すと、その数が使われます。数値のプレフィクス引数でnを指定して`M-g
M-g`に与えることもできます。単にプレフィクス引数を与えた場合の`M-g M-g`の動作については、[Select Buffer](#Select-Buffer)を参照してください。

`M-g TAB`  
M-g TAB

move-to-column

数値nを読み取り、現在行のn列目に移動します。列0は最左列です。プレフィクス引数とともに呼び出された場合、引数で指定された数の列に移動します。

`C-x C-n`  
C-x C-n

set-goal-column

カレントバッファー内の現在ポイントがある列を`C-n`や`C-p`の半恒久的な目標列(semipermanent goal column)として使用します。目標列が有効な場合、これらのコマンドで垂直に移動すると、その列もしくはできる限り近い列に移動しようと試みます。目標列はキャンセルされるまで有効です。

`C-u C-x C-n`  
目標列をキャンセルします。それ以降の`C-n`や`C-p`は通常どおり水平位置を保とうと試みます。

line-move-visual
バッファーのテキストがウィンドウの幅より長い場合、通常Emacsは2行以上のスクリーン行(screen lines)で表示します。便宜上、`C-n`と`C-p`そして`down`と`up`も、同様にスクリーン行にしたがってポイントを移動します。これらのコマンドを論理行(logical lines)(たとえばバッファーのテキスト行)にしたがって移動させるには、`line-move-visual`に`nil`をセットします。そうすると論理行が複数のスクリーン行となるような場合、カーソルは追加されたスクリーン行をスキップします。詳細は[Continuation Lines](#Continuation-Lines)を参照してください。`line-move-visual`などの変数をセットする方法については、[Variables](#Variables)を参照してください。

`C-n`や`C-p`と異なり、ほとんどのEmacsコマンドは*論理的*な行に作用します。たとえば`C-a` (`move-beginning-of-line`)や`C-e` (`move-end-of-line`)は、論理行の先頭もしくは最後に移動します。`C-n`や`C-p`のようにスクリーン行に作用するコマンドの場合、わたしたちはそれを示すようにします。

track-eol
`line-move-visual`が`nil`の場合、変数`track-eol`にも非`nil`値をセットできます。そうすると論理行の行末で`C-n`や`C-p`を開始すると、次の論理行の行末に移動します。通常`track-eol`は`nil`です。

next-line-add-newlines
通常`C-n`をバッファーの最後の行で使用した場合、バッファーの最後でストップします。しかし変数`next-line-add-newlines`に非`nil`値をセットした場合、バッファーの最後の行で`C-n`を押すと、行を追加してその行に移動します。

テキストの消去
--------------

killing characters and lines
deleting characters and lines
erasing characters and lines
`DEL`; `BACKSPACE`  
ポイントの前の文字、またはリージョンがアクティブのときはリージョンを削除します(`delete-backward-char`)。

`Delete`  
ポイントの後の文字、またはリージョンがアクティブのときはリージョンを削除します(`delete-forward-char`)。

`C-d`  
ポイントの後ろの文字を削除します(`delete-char`)。

`C-k`  
行末までkillします(`kill-line`)。

`M-d`  
次の単語(word)の末尾までを前方にkillします(`kill-word`)。

`M-DEL`; `M-BACKSPACE`  
前の単語の先頭までを後方にkillします(`backward-kill-word`)。

コマンド`DEL` (`delete-backward-char`)は、ポイントの前の文字を削除して、カーソルと後ろの文字を後方に移動します。ポイントが行の先頭にある場合、前の改行を削除して、その行を前の行と連結します。

しかしリージョンがアクティブのとき、`DEL`はリージョンのテキストを削除します。リージョンの説明は、[Mark](#Mark)を参照してください。

ほとんどのキーボードでは、DELにはBACKSPACEというラベルがついていますが、このマニュアルではDELと呼ぶことにします(DELをDeleteと混同しないでください。Deleteについてはこの後で議論します)。いくつかのテキスト端末では、EmacsはDELを正しく認識しません。もしこの問題に遭遇したときには、[DEL Does Not Delete](#DEL-Does-Not-Delete)を参照してください。

コマンドDelete (`delete-forward-char`)は、反対方向に削除します。これはポイントの後ろの文字、たとえばカーソルの下の文字を削除します。ポイントが行末にある場合は、その行を次の行と連結します。`DEL`と同様、リージョンがアクティブのときはリージョンのテキストを削除します([Mark](#Mark)を参照してください)。

`C-d` (`delete-char`)は、Deleteと同じようにポイントの後ろの文字を削除しますが、リージョンがアクティブかどうかは関係ありません。

上述した削除コマンドについての詳細な情報は、[Deletion](#Deletion)を参照してください。

`C-k` (`kill-line`)は行を一度に消去(kill)します。もし行頭または行の途中で`C-k`とタイプすると、行末までのすべてのテキストをkillします。行末で`C-k`とタイプすると、その行を次の行と連結します。

`C-k`と関連するコマンドについては、[Killing](#Killing)を参照してください。

変更のアンドゥ
--------------

`C-/`; `C-x u`; `C-_`  
undoレコードにあるエントリーをundoします。通常1つのコマンドを元に戻す(`undo`)ことに相当します(1つ目のキーはテキストモードのディスプレイでは利用できないかもしれない)。

Emacsはバッファー内のテキストに行われた変更のリストを記録しているので、最近の変更はundoできます。これは`C-/`(および`C-x
u`と`C-_`)にバインドされているコマンド`undo`を使って行われます。通常このコマンドは最後の変更をundoして、ポイントを変更前の位置に移動します。undoコマンドはバッファーへの変更のみに適用されるので、カーソルの動きをundoすることはできません。

個々の編集コマンドは、通常undoレコードの個別のエントリーとなりますが、とても単純なコマンドはグループ化される場合があります。1つのエントリーが、実は複雑なコマンドのほんの一部の場合もあります。

もし`C-/`(またはそれの別名コマンド)を繰り返すと、undoされた箇所はさらにundoされ、初期の変更もundoされ、ついには利用可能なundo情報の限界に達します。もし記録された変更がすべてundoされている場合、undoコマンドはエラーメッセージを表示して、何も行いません。

`undo`コマンドについてさらに学ぶには、[Undo](#Undo)を参照してください。

ファイル
--------

Emacsのバッファーに挿入したテキストは、Emacsのセッションの間だけ存在します。テキストを永続化させるためには、それをファイル(file)に保存しなければなりません。

ホームディレクトリーに、`test.emacs`という名前のファイルがあるとしましょう。このファイルをEmacsで編集するには、以下を入力します

    C-x C-f test.emacs RET

ここでファイル名は、コマンド`C-x C-f` (`find-file`)に与えられる、引数(argument)です。このコマンドは引数を読み取るためにミニバッファー(minibuffer)を使い、RETは引数を終端させます([Minibuffer](#Minibuffer)を参照してください)。

このコマンドに従うために、Emacsはそのファイルをvisit(訪問)します: すなわちバッファーを作成し、ファイル内容をバッファーにコピーし、編集のためにバッファーを表示します。テキストを変更したら、`C-x C-s` (`save-buffer`)と入力することにより、ファイルを保存(save)できます。これにより変更されたバッファー内容は、`test.emacs`に書き戻され永続化されます。保存するまでは、テキストへの変更はEmacs内部にだけ存在し、ファイル`test.emacs`は変更されません。

ファイルを作成するには、すでにファイルが存在するかのように`C-x
C-f`でファイルをvisitするだけです。これはファイルに書き込みたいテキストを入力できる、空のバッファーを作成します。最初にこのバッファーを`C-x
C-s`で保存するとき、Emacsは実際にファイルを作成します。

Emacsでファイルを使うことについてさらに学ぶには、[Files](#Files)を参照してください。

ヘルプ
------

getting help with keys
もしキーが何をするか忘れた場合、`C-h k` (`describe-key`)と入力して、それに続けて関心のあるキーを入力します。たとえば`C-h k
C-n`は、`C-n`が何をするか表示します。

プレフィクスキー`C-h`は“ヘルプ(help)”が由来です。F1キーは`C-h`の別名です。`C-h
k`以外にも、異なる種類のヘルプを提供する多くのヘルプコマンドがあります。

詳細については、[Help](#Help)を参照してください。

空行
----

inserting blank lines
deleting blank lines
空行を挿入したり削除するための、特別なコマンドとテクニックがあります。

`C-o`  
カーソルの後ろに空行を挿入します(`open-line`)。

`C-x C-o`  
連続する空行を、1行残してすべて削除します(`delete-blank-lines`)。

C-o
C-x C-o
blank lines
open-line
delete-blank-lines
これまで`RET` (`newline`)が、どうやってテキストの新しい行を開始するのか見てきました。しかし最初に空行を作ってからテキストを挿入するほうが、何を行っているのかわかりやすいでしょう。これはキー`C-o` (`open-line`)を使えば、簡単に行うことができます。これはポイントの後ろに改行を挿入し、ポイントを改行の前に維持します。`C-o`の後に新しい行のためのテキストを入力します。

複数の空行は`C-o`を数回入力するか、何個の空行を作るのかを数引数で与えれば作れます。方法については、[Arguments](#Arguments)を参照してください。もしフィルプレフィクスがあって、行頭で`C-o`が入力された場合、新しい行にフィルプレフィクスを挿入します。[Fill Prefix](#Fill-Prefix)を参照してください。

余分な空行を取り除く簡単な方法は、`C-x C-o` (`delete-blank-lines`)です。連続する空行の中にポイントがあるとき、`C-x
C-o`は1行残してすべての空行を削除します。ポイントが単独の空行にある場合、`C-x
C-o`はその空行を削除します。ポイントが空でない行にある場合、`C-x C-o`は、後続する空行があれば、それらすべてを削除します。

継続行
------

continuation line
wrapping
line wrapping
fringes, and continuation lines
バッファー内のテキストの行 — 論理行(logical line) — がウィンドウに収まらないほど長い場合、Emacsがそれを2行以上のスクリーン行(screen lines)で表示するときがあります。これは行の折り返し(line wrapping)または継続(continuation)と呼ばれ、論理行は継続された行(continued line)と呼ばれます。グラフィカルなディスプレーでは、Emacsは行の折り返しをウィンドウの左右のフリンジ(fringes、縁)の小さな曲矢印で示します。テキスト端末では、Emacsは右の余白に‘`\`’を表示して行の折り返しを示します。

ほとんどのコマンドは、スクリーン行ではなく論理行にたいして作用します。たとえば`C-k`は論理行をkillします。前に説明したように、`C-n` (`next-line`)と`C-p` (`previous-line`)は特別な例外です。これらはスクリーン行にたいしてポイントを上下に移動させます([Moving Point](#Moving-Point)を参照してください)。

line truncation, and fringes
Emacsはオプションで長い論理行を継続するかわりに、切り詰める(truncate)ことができます。これは論理行が1つのスクリーン行を占めることを意味します。もし論理行がウィンドウ幅より長い場合、行の残りは表示されません。グラフィカルなディスプレーでは切り詰められた行は、右フリンジの小さな直矢印で示されます。テキスト端末では右余白の‘`$`’で示されます。[Line Truncation](#Line-Truncation)を参照してください。

デフォルトでは継続行はウィンドウの右端で折り返されます。折り返しが単語の途中で発生すると、継続された行は読むのが難しくなります。普通の解決策は、行が長くなりすぎる前に改行を挿入することです。もしお好みなら、行が長くなりすぎたときにEmacsが自動的に改行を挿入するように、Auto Fillモードを使うことができます。[Filling](#Filling)を参照してください。

多くの長い論理行を含むファイルを編集する必要があり、それらすべてを改行で分割するのが実用的でない場合があります。そのようなケースでは単語折り返し(word wrapping)が有効なVisual Lineモードを使うことができます。これは長い行を正確にウィンドウの右端で折り返すのではなく、ウィンドウの右端に一番近い単語境界(スペースやタブなど)で折り返します。Visual Lineモードでは、`C-a`、`C-n`、`C-k`などの編集コマンドも、論理行ではなくスクリーン行を処理するように再定義されます。[Visual Line Mode](#Visual-Line-Mode)を参照してください。

カーソル位置の情報
------------------

バッファーのある部分にたいしてサイズや位置、単語数や行数についての情報を得るためのコマンドがあります。

`M-x what-line`  
ポイントの行番号を表示します。

`M-x line-number-mode`; `M-x column-number-mode`  
現在の行番号および列番号の自動表示を切り替えます。[Optional Mode Line](#Optional-Mode-Line)を参照してください。各行の前に行番号を表示したい場合は、[Display Custom](#Display-Custom)を参照してください。

`M-=`  
現在のリージョンの行数、単語数、文字数を表示します(`count-words-region`)。リージョンについては、[Mark](#Mark)を参照してください。

`M-x count-words`  
現在のバッファーの行数、単語数、文字数を表示します。リージョン([Mark](#Mark)を参照してください)がアクティブのときは、かわりにリージョンの数字を表示します。

`C-x =`  
ポイントの後ろの文字の文字コード、ポイントの文字位置、ポイントの列位置を表示します(`what-cursor-position`)。

`M-x hl-line-mode`  
現在行のハイライト表示を有効または無効にします。[Cursor Display](#Cursor-Display)を参照してください。

`M-x size-indication-mode`  
バッファーのサイズの自動表示を切り替えます。[Optional Mode Line](#Optional-Mode-Line)を参照してください。

what-line
line number commands
location of point
cursor location
point location
`M-x
what-line`は、エコーエリアに現在の行番号を表示します。通常このコマンドは不必要です。なぜならモードラインに現在の行番号が、すでに表示されているからです ([Mode Line](#Mode-Line)を参照してください)。しかしバッファーがナロー(narrow: 制限)されている場合、モードラインはアクセスできる範囲についての行番号しか表示しません([Narrowing](#Narrowing)を参照してください)。それにくらべて`what-line`は、制限されたリージョンとバッファー全体、両方の行番号を表示します。

M-=
count-words-region
`M-=` (`count-words-region`)はリージョン内の行数、単語数、文字数を報告するメッセージを表示します(リージョンについての説明は、[Mark](#Mark)を参照してください)。プレフィクス引数`C-u
M-=`を指定すると、このコマンドはバッファー全体の数字を表示します。

count-words
`M-x
count-words`は同じことを行いますが、呼び出し規約が異なります。もしリージョンがアクティブの場合はリージョン、そうでない場合はバッファーの数字を表示します。

C-x =
what-cursor-position
コマンド`C-x =` (`what-cursor-position`)は現在のカーソル位置と、その位置にあるバッファー内容についての情報を表示します。エコーエリアには、以下のような行が表示されます:

    Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

‘`Char:`’には、バッファー中のそのポイントにある文字が表示されます。カッコ内にはその文字に対応する文字コードが10進、8進、16進で表示されます。`C-x
=`が文字の情報について表示する方法については、[International Chars](#International-Chars)を参照してください。‘`point=`’はポイント位置を文字数(バッファーの最初の文字は1、次の文字は2、...)で表示します。その後ろの数字ではバッファー内の文字数の合計が表示され、カッコ内にはその位置が全体から見て何パーセントの位置なのかが表示されます。‘`column=`’にはポイントの水平位置、すなわちウィンドウの左端から数えて何番目の列かが表示されます。

もしバッファーがナローされている場合、最初と最後の部分のテキストが一時的にアクセス不能になります。`C-x
=`は現在アクセス可能な範囲についての追加説明を表示します。たとえば以下のように表示します:

    Char: C (67, #o103, #x43) point=252 of 889 (28%) <231-599> column=0

ここで、新たに追加された2つの数字が、ポイントを設定できる文字位置の下限と上限を示します。これら2つの位置のあいだの文字が参照可能な文字です。[Narrowing](#Narrowing)を参照してください。

関連はあるものの異なる機能が`display-line-numbers-mode`([Display Custom](#Display-Custom)を参照)です。

数引数
------

numeric arguments
prefix arguments
arguments to commands
数学や計算機の用語では、引数(argument)という単語は、“関数や操作に与えるデータ”を意味します。Emacsのコマンドには、数引数(numeric argument)(プレフィクス引数(prefix argument)とも呼ぶ)を指定できるものがあります。引数を反復回数として解釈するコマンドもあります。たとえば、引数10を`C-f`に指定すると、カーソルを通常の1文字ではなく、10文字分前向きに移動します。これらのコマンドでは、引数を指定しないと引数1を指定したのと同等になります。この種のコマンドの多くでは、負の引数を指定すると、逆向きの移動や逆の操作を指示することになります。

M-1
M-
-
digit-argument
negative-argument
数引数を指定するもっとも簡単な方法は、Metaキーを押しながら数字またはマイナス記号(と数字)を入力する方法です。以下はその例です:

    M-5 C-n

これは５行下に移動します。キー`M-1`、`M-2`、...、同様に`M--`は、次のコマンドへの引数をセットアップするコマンド、(`digit-argument`と`negative-argument`)にバインドされています。数字をともなわない`M--`は、通常−1を意味します。

2桁以上の数字を入力したい場合、2文字目以降の数字を入力するときにMetaを押しつづける必要はありません。つまり50行下に移動するときは、以下のように入力します:

    M-5 0 C-n

これは、(あなたが期待するように)‘`0`’を5つコピーして挿入してから1行下がるのでは*ない*ことに注意してください。‘`0`’はプレフィクス引数の一部として扱われます。

(‘`0`’を5つコピーして挿入するときは、`M-5 C-u
0`と入力します。ここで`C-u`はプレフィクス引数を終端させるので、次のキー入力はあなたが実行したいコマンドです。ここでの`C-u`の意味はこのケースだけに適用される使い方です。`C-u`の通常の役割については以下を参照してください。)

C-u
universal-argument
数引数を指定する別の方法として、`M-1`、`M-2`、...と入力するかわりに、`C-u` (`universal-argument`)のあとに数字(負の引数の場合はマイナス記号と数字)を入力する方法があります。通常、数字をともなわないマイナス記号は−1を意味します。

単独の`C-u`は、“4倍”という特別な意味をもち、次のコマンドの引数を4倍にします。`C-u
C-u`は16倍です。つまり`C-u C-u C-f`は16文字前方に移動します。その他に便利な使い方としては`C-u
C-n`、`C-u C-u C-n`(適当な割り合いで画面を下に移動する)や、`C-u C-u
C-o`(16個の空行を作る)、`C-u C-k`(4行削除する)、などがあります。

自分自身を挿入する文字の前に数引数を使えば、指定した分のコピーを挿入できます。これは挿入したい文字が数字でないときは簡単です。たとえば`C-u
6 4 a`は、‘`a`’を64個コピーして挿入します。しかし数字を挿入したいときは、これではうまくいきません。`C-u 6 4
1`は引数に641を指定することになってしまいます。このようなときは引数と挿入したい数字を分けるために、他の`C-u`を使うことができます。たとえば`C-u
6 4 C-u 1`とすれば、これは‘`1`’を64個コピーして挿入します。

引数の有無は確認しても、その値は無視するコマンドもあります。たとえばコマンド`M-q` (`fill-paragraph`)は、1行に収まるようできるだけテキストをフィルしますが、引数をともなうと、余分なスペースを挿入してテキストが正確に1行の最大幅を使うよう均等に割り付けてフィルします(`M-q`については、[Filling](#Filling)を参照してください)。このようなコマンドは、引数として単に`C-u`を指定するだけで充分です。

引数の値を繰り返しの回数として使いますが、引数がないときは特別な処理を行うコマンドもあります。たとえばコマンド`C-k` (`kill-line`)に引数nを指定すると、これは行末の改行も含めてn行をkillします。しかし引数を指定しないで`C-k`した場合、ポイントから改行までのテキストをkillするか、ポイントが行末にある場合は改行をkillします。つまりコマンド`C-k`を引数なしで2回呼び出すと、`C-k`に引数1を指定したのと同様、空でない行をkillできます(`C-k`についての情報は、[Killing](#Killing)を参照してください)。

いくつかのコマンドは、`C-u`だけの引数を通常の引数とは異なるものとして扱います。また、マイナス記号のみの引数を、−1とは区別するコマンドもあります。これらの例外については、必要になったときに説明します。これらの例外は、それぞれのコマンドを使いやすくするためにあり、コマンドのドキュメント文字列に記載されています。

コマンドの前に引数を入力するという点を強調するために、そしてコマンドが呼び出されてから入力されるミニバッファー引数([Minibuffer](#Minibuffer)を参照してください)と区別するために、わたしたちはプレフィクス引数(prefix argument)という言葉を使います。

グラフィカルなディスプレイでは`C-0`、`C-1`、...は`M-0`、`M-1`、...と同じように振る舞います。

コマンドの繰り返し
------------------

repeating a command
単純なキーで呼び出されるものや、`M-x command-name
RET`で実行できるような多くのコマンドは、数引数で繰り返し回数([Arguments](#Arguments)を参照してください)を与えることで、その回数だけ繰り返すことができます。しかし、入力を求めるものや数引数を別の目的に使うコマンドでは、この方法はうまくいきません。

C-x z
repeat
コマンド`C-x z` (`repeat`)は、Emacsコマンドを何回も反復する別の方法です。このコマンドは、直前のEmacsコマンドが何であっても、それを繰り返します。繰り返されるコマンドは、まえと同じ引数を使います。毎回新たに引数を読み取ることはしません。

コマンドを2回以上繰り返すには`z`を追加して入力します。1つの`z`でコマンドを1回繰り返します。`z`以外の文字を入力するか、マウスボタンを押すと繰り返しを終了します。

たとえば、20文字削除するために`C-u 2 0 C-d`と入力したとしましょう。`C-x z z
z`と入力すれば、(引数を含めて)削除コマンドをさらに3回繰り返し、全部で80文字削除できます。始めの`C-x
z`でコマンドを1回繰り返し、そのあとのそれぞれの`z`で1回ずつ繰り返します。

ミニバッファー
==============

minibuffer
ミニバッファー(minibuffer)とは、Emacsのコマンドがファイル名、バッファー名、Emacsコマンド名、Lisp式といった、複雑な引数を読み取るための場所です。なぜ“ミニバッファー”と呼ぶかというと、それがスクリーン上の小領域を占める、特別な目的のためのバッファーだからです。ミニバッファーで引数テキストを編集するために、通常のEmacs編集コマンドを使うことができます。

ミニバッファーを使う
--------------------

prompt
ミニバッファーを使用中、ミニバッファーはエコーエリアにカーソルとともに表示されます。ミニバッファーは通常、コロンが最後についたプロンプト(prompt)から開始されます。プロンプトはどのような入力が期待されるか、そしてそれがどのように使われるのかを示します。プロンプトは、フェイス`minibuffer-prompt`を使ってハイライトされます。

ミニバッファーで入力するもっとも簡単な方法は、テキストを入力してからRETで引数入力を完了してミニバッファーを終了する方法です。かわりに`C-g`を入力して引数を求めているコマンドをキャンセルし、ミニバッファーを終了することもできます([Quitting](#Quitting)を参照してください)。

default argument
コロンの前のカッコ内にデフォルト引数(default argument)を表示するプロンプトもあります。このデフォルト値は、RETだけを入力したときに、引数として使用されます。たとえばバッファー名を読み取るコマンドは、通常デフォルト値としてバッファー名を表示します。RETを入力することでデフォルトのバッファーにたいして処理を行うことができます。

Minibuffer Electric Default mode
mode, Minibuffer Electric Default
minibuffer-electric-default-mode
minibuffer-eldef-shorten-default
Minibuffer Electric Defaultモードというグローバルマイナーモードを有効にしている場合、ミニバッファーの内容の変更を開始すると、Emacsはデフォルト引数を非表示にします。ミニバッファーのテキストを元に戻せば、ふたたびプロンプトにデフォルト値が表示されます。さらに変数`minibuffer-eldef-shorten-default`を非`nil`値に変更すると、スクリーンのスペースを節約するために、‘`(default
default-arg)`’のかわりに‘`[default-arg]`’の形式でデフォルト値を表示します。このマイナーモードを有効にするには、`M-x
minibuffer-electric-default-mode`とタイプしてください。

エコーエリアにミニバッファーが表示されると、他のエコーエリアの使用と競合するかもしれません。ミニバッファーがアクティブなとき、エラーメッセージや情報メッセージは一時的な表示となります。メッセージは数秒ミニバッファーを隠すように表示されるか、なにかタイプするまでのあいだ表示され、その後ミニバッファーに戻ります。ミニバッファーの使用中、Emacsはキーストロークをエコーしません。

ミニバッファーでのファイル名
----------------------------

default directory
`C-x C-f` (`find-file`)のようなコマンドは、ミニバッファーを使ってファイル名引数を読み取ります。ファイル名を読み取るためにミニバッファーを使用しているとき、通常は最後にスラッシュがついたテキストで開始されています。これはデフォルトディレクトリー(default directory)です。たとえば以下のように開始されていたとします:

    Find file: /u2/emacs/src/

ここで‘`Find file:
`’はプロンプト、‘`/u2/emacs/src/`’はデフォルトディレクトリーです。ここで`buffer.c`を入力すると`/u2/emacs/src/buffer.c`を指定したことになります。デフォルトディレクトリーについての情報は、[File Names](#File-Names)を参照してください。

あなたが望むかもしれないファイル名のデフォルト候補は、`M-n`とタイプすることにより利用できます。[Minibuffer History](#Minibuffer-History)を参照してください。

`..`で親ディレクトリー内のファイルを指定できます。つまり`/a/b/../foo.el`は`/a/foo.el`と同じです。`M-DEL`を使えば、ディレクトリー名を後方にkillできます([Words](#Words)を参照してください)。

デフォルトディレクトリーとは無関係のファイルを指定する場合、デフォルト値全部を`C-a
C-k`でkillできます。かわりにデフォルト値を無視することもできます。これはスラッシュで始まる絶対パスのファイル名か、チルダで始まるファイル名をデフォルトディレクトリーに続けて入力します。たとえば以下のようにして`/etc/termcap`を指定できます:

    Find file: /u2/emacs/src//etc/termcap

// in file name double slash in file name slashes repeated in file name file-name-shadow-mode ダブルスラッシュにより、Emacsは2番目のスラッシュより前のすべてを無視します。上の例では`/u2/emacs/src/`は無視されるので、引数は`/etc/termcap`となります。無視される部分のファイル名は、端末に可能なら目立たないような表示になります(これを無効にするには、コマンド`M-x
file-name-shadow-mode`でFile Name Shadowモードをオフにしてください)。

リモートファイルの名前([Remote Files](#Remote-Files)を参照)を補完する際、ダブルスラッシュは若干異なる挙動を示します。この場合のダブルスラッシュは、Emacsがファイル名の部分だけを無視して、他の部分(method、host、username、...など)を手付かずのままにするようにします。3つのスラッシュを連続してタイプすると、リモートファイル名の中のすべてを無視します。section “File name completion” in The Tramp Manualを参照してください。

home directory shorthand
Emacsは`~/`をホームディレクトリーと解釈します。`~/foo/bar.txt`はホームディレクトリーにある、`foo`というディレクトリーの、`bar.txt`という名前のファイルを指定します。さらに`~user-id/`はログイン名がuser-idというユーザーの、ホームディレクトリーを意味します。`~`の前のディレクトリー名は無視されるので、`/u2/emacs/~/foo/bar.txt`は`~/foo/bar.txt`と同じです。

MS-WindowsとMS-DOSでは、ユーザーは常にホームディレクトリーを持つとは限らないので、Emacsはいくつかの代替ディレクトリーを使います。MS-Windowsについては[Windows HOME](#Windows-HOME)、MS-DOSについては [MS-DOS File Names](#MS_002dDOS-File-Names)を参照してください。 これらのシステムでは`~user-id/`は現在のユーザーの場合だけ、つまりuser-idが現在のユーザーのログイン名のときだけがサポートされます。

insert-default-directory
Emacsがファイル名を読みとるとき、デフォルトディレクトリーを挿入しないようにするには、変数`insert-default-directory`を`nil`に変更します。この場合、ミニバッファーは空で開始されます。それでも相対パスでのファイル名引数は、同じデフォルトディレクトリーにもとづいて解釈されます。

ミニバッファーにリモートファイル名を入力することもできます。 [Remote Files](#Remote-Files)を参照してください。

ミニバッファーでの編集
----------------------

ミニバッファーは一風変わっていますがEmacsのバッファーなので、引数テキストを編集するための、通常のEmacsコマンドが利用可能です(しかしプロンプトは読み取り専用(read-only)なので変更できません)。

ミニバッファーでのRETは引数を完了させるので、これを使って改行を挿入することはできません。`C-q
C-j`を使えば制御文字`C-j`(改行文字と等しい)を挿入できます([Inserting Text](#Inserting-Text)を参照してください)。かわりに`C-o` (`open-line`)を使うこともできます([Blank Lines](#Blank-Lines)を参照してください)。

ミニバッファーの中ではTAB、SPC、`?`は補完コマンド(completion commands)にバインドされている場合があります。これによりテキスト全部を入力せずに、入力したいテキストを簡単に入力できます。[Completion](#Completion)を参照してください。RETのときと同様、`C-q`を使ってTAB、SPC、‘`?`’のような文字を入力できます。

便宜上ミニバッファーでの`C-a` (`move-beginning-of-line`)は、プロンプトの先頭ではなく引数テキストの先頭にポイントを移動します。これにより、たとえば`C-a
C-k`で引数全体をkillことができます。

height of minibuffer
size of minibuffer
growing minibuffer
resizing minibuffer
ミニバッファーがアクティブのとき、エコーエリアは通常のEmacsウィンドウのように扱われます。たとえば(`C-x
o`で)他のウィンドウに切り替えて、そこでテキストを編集して、またミニバッファーのウィンドウにもどって引数の入力を完了できます。ほかのウィンドウでテキストをkillしてからミニバッファーのウィンドウにもどり、引数にテキストをyankすることさえ可能です。しかしミニバッファーのウィンドウは分割(split)できないなどの制限もあります。[Windows](#Windows)を参照してください。

resize-mini-windows
通常ミニバッファーのウィンドウは、スクリーン行で1行を占めます。しかし2行以上のテキストをミニバッファーに追加すると、そのテキストに対応して自動的に拡張されます。変数`resize-mini-windows`は、ミニバッファーのサイズ調整を制御します。デフォルト値は`grow-only`で、これは今説明したとおりの振る舞いを意味します。もし値が`t`の場合、ミニバッファーから行を削除すると。ミニバッファーのウィンドウは自動的に縮小されて、スクリーン行で1行まで小さくなります。値が`nil`の場合、ミニバッファーのウィンドウは自動的にサイズを変更しません。しかし通常のウィンドウのサイズ調整コマンドは使用できます([Windows](#Windows)を参照してください)。

max-mini-window-height
変数`max-mini-window-height`は、ミニバッファーのウィンドウのサイズ変更するときの、最大高さを制御します。浮動少数を指定した場合は、フレームの高さにたいする比になります。整数を指定した場合は最大行数になります。`nil`を指定すると、ミニバッファーのウィンドウの自動サイズ調整は行われません。デフォルト値は0.25です。

ミニバッファーでの`C-M-v`コマンドは、他のウィンドウに表示されたコマンドのヘルプテキストをスクロールします。`M-PageUp`や`M-PageDown`(または`M-prior`や`M-next`)でも、ヘルプテキストをスクロールできます。これは長い補完候補のリストを選ぶときなどに便利です。[Other Window](#Other-Window)を参照してください。

enable-recursive-minibuffers
通常Emacsはミニバッファーがアクティブのときは、ミニバッファーにたいして多くのコマンドを使用できないようにしています。ミニバッファーでこれらのコマンドを使えるようにするには、変数`enable-recursive-minibuffers`に`t`をセットしてください。

minibuffer-inactive-mode
アクティブでないとき、ミニバッファーは`minibuffer-inactive-mode`になっており、`mouse-1`をクリックすると、`*Messages*`バッファーを表示します。ミニバッファー専用のフレームを使用している場合、Emacsはそこでのキー入力も認識します。たとえば`n`は新しいフレームを作成します。

補完
----

completion
引数を入力する助けとなる、補完(completion)という機能が使えるときがあります。これは引数の一部を入力すると、それまでに何を入力したかにもとづいて、Emacsが残りあるいは残りの一部を補完してくれることを意味します。

completion alternative
補完が利用可能なとき、特定のキー(通常はTAB、RET、SPC)が、ミニバッファーの特別な補完コマンド([Completion Commands](#Completion-Commands)を参照してください)にリバインドされています。これらのコマンドは、ミニバッファーのテキストを完了させようと試みます。これは引数を要求したコマンドが提供する、補完候補(completion alternatives)にもとづいています。通常`?`を入力すると、補完候補のリストを見ることができます。

補完は通常ミニバッファー内で行われますが、通常のバッファーないでもこの機能を利用可能なときがあります。[Symbol Completion](#Symbol-Completion)を参照してください。

### 補完の例

TAB (completion example)
ここでは簡単な例が理解しやすいでしょう。`M-x`は、コマンド名を読み取るためにミニバッファーを使います。補完はミニバッファーのテキストと、既存のEmacsコマンドの名前のマッチによって機能します。コマンドを`auto-fill-mode`を実行したいとします。`M-x
auto-fill-mode RET`をタイプすればよいのですが、補完を使えばもっと簡単になります。

`M-x a u
TAB`とタイプすると、TABは‘`au`’で始まる補完候補(この例ではコマンド名)を探します。`auto-fill-mode`、`autoconf-mode`などの候補がいくつかありますが、候補はすべて`auto`で始まるので、ミニバッファーの‘`au`’は‘`auto`’に補完されます(あなたのEmacsのセッションには、もっと多くのコマンドが定義されているかもしれません。たとえば`authorize-me`というコマンドが定義されている場合には、Emacsが補完できるのは‘`aut`’までです)。

もう一度TABをタイプしても、次の文字は‘`-`’、‘`a`’、‘`c`’のどれなのか決定できません。そのため文字は追加されず、かわりにTABは可能性のある補完候補の一覧を別のウィンドウに表示します。

次に`-f`と入力します。ミニバッファーには‘`auto-f`’が入力されました。この文字で始まるコマンド名は、`auto-fill-mode`だけです。ここでTABを入力すると、残りの部分が補完されて、ミニバッファーの引数は‘`auto-fill-mode`’になります。

したがって`a u TAB - f
TAB`と入力するだけで、‘`auto-fill-mode`’と入力できるのです。

### 補完コマンド

以下は補完が使えるときに、ミニバッファーで定義されている補完コマンドの一覧です。

`TAB`  
可能な限りミニバッファーのテキストを補完します。補完できないときは、可能性のある補完候補のリストを表示します(`minibuffer-complete`)。

`SPC`  
ミニバッファーのテキストを単語単位で補完します(`minibuffer-complete-word`)。このコマンドは、引数にスペースが含まれる可能性のあるファイル名などでは利用できません。

`RET`  
最初に可能な限り補完した後で、ミニバッファーのテキストを引数として確定します。[Completion Exit](#Completion-Exit)を参照してください。

`?`  
補完候補の一覧を表示します(`minibuffer-completion-help`)。

TAB (completion)
minibuffer-complete
TAB (`minibuffer-complete`)は、もっとも基本的な補完コマンドです。これはミニバッファーのテキストとマッチする可能性のある、すべての補完候補を検索して、できるかぎりの補完を試みます。補完候補が選択される方法については、[Completion Styles](#Completion-Styles)を参照してください。

SPC (completion)
minibuffer-complete-word
SPC (`minibuffer-complete-word`)は、TABと同じように補完をおこないますが、次のハイフンまたは空白までしか補完しません。ミニバッファーが‘`auto-f`’の場合、‘`auto-fill-mode`’まで補完できますが、‘`ill-`’しか挿入しないので‘`auto-fill-`’となります。次にSPCを入力すると‘`auto-fill-mode`’が補完されます。

? (completion)
completion list
TABやSPCが補完できない場合、マッチする補完候補のリスト(複数ある場合)を、別のウィンドウに表示します。同じリストは`?` (`minibuffer-completion-help`)でも表示できます。以下は補完一覧で使うことができるコマンドです:

`M-v`; `PageUp`; `prior`  
ミニバッファーで`M-v`を入力すると、候補リストを表示しているウィンドウを選択します(`switch-to-completions`)。以下のコマンドを使うには、この方法がよいでしょう。PageUpとpriorは同じことをおこないます。他の方法でもウィンドウを選択できます([Windows](#Windows)を参照してください)。

choose-completion

`RET`; `mouse-1`; `mouse-2`  
補完候補リストのバッファー内では、ポイント位置の補完候補を選択します(`choose-completion`)。

next-completion

`RIGHT`  
補完候補リストのバッファー内では、次の補完候補にポイントを移動します(`next-completion`)。

previous-completion

`LEFT`  
補完候補リストのバッファー内では、前の補完候補にポイントを移動します(`previous-completion`)。

### 補完の終了

RET (completion in minibuffer)
minibuffer-complete-and-exit
コマンドがミニバッファーの補完を使って引数を読みとる場合、引数を確定するためにRET (`minibuffer-complete-and-exit`)をタイプしたときに、何が起こるかも制御します。これには4種類の動作があります:

-   強い補完(Strict completion)は、正確にマッチする補完のみを許します。RETでミニバッファーを抜けるのは、ミニバッファーのテキストが正確にマッチしているか、1つに補完された場合だけです。それ以外の場合、Emacsはミニバッファーからのexit(入力を完了してミニバッファーから抜け出す)を拒絶します。かわりに補完を試み、補完できなかったときは、ミニバッファーのテキストの後ろに数秒‘`[No
    match]`’と表示します(`C-g`を使えばミニバッファーを離れることができます)。

    この動作をおこなうコマンドの例は`M-x`で、それは存在しないコマンド名を受けとるのは無意味だからです。

-   慎重な補完(Cautious completion)は強い補完と似ていますが、テキストがすでに正確にマッチしているときだけexitできる点が異なります。テキストが正確なマッチに補完できるとき、RETは補完を行いますが、まだexitしません。exitするには、もう一度RETを入力しなければなりません。

    慎重な補完は、たとえば存在しなければならないファイル名を読みとるときに使用されます。

-   寛大な補完(Permissive completion)は、任意の入力を許容します。補完候補はあくまでも提案です。RETでは補完は行われず、単に入力された引数を確定します。

-   minibuffer confirmation
    confirming in the minibuffer
    確認付きの寛大な補完(Permissive completion with confirmation)は、寛大な補完と似ていますが例外があります。TABを入力して、テキストがある中間的な状態まで補完されたとき(たとえばまだ正確なマッチに至らないとき)、次にRETを入力しても引数は確定されません。かわりにEmacsはテキストの後ろに‘`[Confirm]`’を数秒表示して、確認を求めます。その次のRETは確認とみなされテキストが確定されます。これによりTABにより希望するマッチまで補完されたと勘違いして、RETを押してしまうなどの一般的な間違いを捕らえることができます。

    confirm-nonexistent-file-or-buffer
    変数`confirm-nonexistent-file-or-buffer`をカスタマイズして、確認動作を微調整できます。デフォルト値の`after-completion`は、まさに説明したとおりに動作します。これを`nil`に変更すると、Emacsは確認を求めなくなり、寛大な補完にフォールバックします。他の非`nil`値に変更した場合、その前のコマンドがTABかどうかにかかわらず、Emacsは確認を求めます。

    この動作はファイル名を読みとる`C-x C-f`や、バッファー名を読み取る`C-x b`など、多くのコマンドで使われています。

### 補完候補が選択される方法

completion style
補完コマンドは、たくさんの可能性のある補完候補を、ミニバッファーに入力したものとマッチ(match)する、より少ないサブセットへと絞り込むことにより機能します。[Completion Example](#Completion-Example)では、そのようなマッチングの簡単な例を紹介しました。どのような構成がマッチなのかを決定する手続きはとても複雑です。Emacsは多くの状況下でもっとも妥当と思われる補完を試みます。

Emacsは1つ以上の補完スタイル(completion styles)を使って補完をおこないます。これはミニバッファーのテキストを補完候補とマッチングするための条件のセットです。補完を行うとき、Emacsは補完スタイルを順番に試します。もしあるスタイルが1つ以上のマッチを獲得した場合、それらは補完候補リストのために使用されます。もしあるスタイルがマッチを獲得できなかった場合、Emacsは次のスタイルにフォールバックします。

completion-styles
リスト変数`completion-styles`は、使用する補完スタイルを定義します。それぞれのリスト要素(list element)は、補完スタイルの名前(Lispシンボル)です。デフォルトの補完スタイルは、リスト変数に以下の名前の要素が順番に並んでいます。

`basic`  
basic

, completion style

ミニバッファーのポイントより前のテキストと、補完候補の先頭が同じでなければなりません。さらにミニバッファーのポイントより後ろのテキストがある場合、補完候補の残りそれが含まれていなければなりません。

partial completion

partial-completion

, completion style

`partial-completion`  
このアグレッシブな補完スタイルは、ミニバッファーのテキストをハイフンまたは空白で区切り、各単語ごとに補完をおこないます(たとえばコマンド名を補完する場合、‘`em-l-m`’は、‘`emacs-lisp-mode`’に補完されます)。

さらにミニバッファーのテキスト中の‘`*`’は、ワイルドカード(wildcard)として扱われます。これは補完候補の対応する位置にある文字列の、任意の文字とマッチします。

`emacs22`  
emacs22

, completion style

この補完スタイルは`basic`とにていますが、ミニバッファーのポイントより後のテキストを無視します。この名前は補完の動作がEmacs 22と同じだからです。

以下の追加の補完スタイルが定義されており、`completion-styles`に追加することもできます([Customization](#Customization)を参照してください)。

`substring`  
substring

, completion style

補完候補は、ミニバッファーのポイントより前のテキストと、ポイントより後のテキストが同じ順番で含まれていなければなりません。

したがって、ミニバッファーのテキストが‘`foobar`’で、ポイントが‘`foo`’と‘`bar`’の間にある場合、‘`afoobbarc`’にマッチします。この場合a、b、cは空文字列を含む任意の文字列です。

`initials`  
initials

, completion style

このとてもアグレッシブな補完スタイルは、頭文字とイニシャルで補完を試みます。たとえばコマンド名の補完をする場合、‘`lch`’は‘`list-command-history`’とマッチします。

`emacs21`と呼ばれる、とてもシンプルな補完スタイルもあります。このスタイルでは、ミニバッファーのテキストが‘`foobar`’の場合、‘`foobar`’で始まるものだけにマッチします。

completion-category-overrides
変数`completion-category-overrides`を設定することにより、状況に応じて異なる補完スタイルを使うことができます。たとえばバッファー名を補完するときは、デフォルトで`basic`と`substring`だけを使うよう指定できます。

### 補完オプション

case-sensitivity and completion
case in completion
大文字小文字の違いは、コマンド名のように大文字小文字を区別する(case-sensitive)引数では重要です。たとえばコマンド名の補完では、‘`AU`’では‘`auto-fill-mode`’に補完されません。大文字小文字の違いは、それが問題にならない引数の補完では無視されます。

read-file-name-completion-ignore-case
read-buffer-completion-ignore-case
ファイル名を補完するとき、変数`read-file-name-completion-ignore-case`が非`nil`なら、大文字小文字の違いは無視されます。GNU/Linuxのように、ファイル名の大文字と小文字を区別するシステムでは、デフォルト値は`nil`です。Microsoft Windowsのように、ファイル名の大文字と小文字を区別しないシステムでは、非`nil`です。バッファー名を補完するとき、`read-buffer-completion-ignore-case`が非`nil`なら、大文字小文字の違いは無視されます。デフォルトは`nil`です。

completion-ignored-extensions
ignored file names, in completion
通常Emacsはファイル名を補完するとき、選ばれるべきではないと思われる、特定の候補を無視します。これはリスト変数`completion-ignored-extensions`により決定されます。リストの要素はに文字列を指定します。それらの文字列で終わるファイル名は、補完候補としては無視されます。スラッシュ(`/`)で終わる要素は、ディレクトリー名を表します。`completion-ignored-extensions`の標準的な値は`".o"`、`".elc"`、`"~"`を含むいくつかの要素です。たとえばディレクトリーに‘`foo.c`’、‘`foo.elc`’があるとき、‘`foo`’は‘`foo.c`’に補完されます。しかし*すべて*の補完候補が無視すべき文字列で終わるとき、これらの候補は無視されません。前の例でいうと‘`foo.e`’は‘`foo.elc`’に補完されます。Emacsは補完候補リストで補完候補を表示するとき、`completion-ignored-extensions`を無視します。

Shellでの補完は、ファイル名補完の拡張されたバージョンです。[Shell Options](#Shell-Options)を参照してください。

completion-auto-help
`completion-auto-help`に`nil`がセットされていると、補完コマンドは補完リストバッファーを表示しません。表示するには`?`を入力しなければなりません。値が`lazy`の場合、Emacsは2度目の補完を試みたときだけ、補完リストバッファーを表示します。もし補完すべきものがない場合、1度目のTABは‘`Next
char not unique`’と表示し、2度目のTABで補完リストバッファーが表示されます。

completion-cycle-threshold
`completion-cycle-threshold`が非`nil`のとき、補完コマンドは補完候補を循環(cycle)することができます。ミニバッファーのテキストで１つ以上の補完候補がある場合は通常、補完コマンドは補完できた文字までを表示します。`completion-cycle-threshold`を`t`に変更すると、補完コマンドは補完候補の中から最初の候補を表示します。それ以降の補完コマンドの呼び出しでは、その次の補完候補を循環的に表示します。`completion-cycle-threshold`を数値nにすると、補完候補がn以下のときだけ循環表示の動作をします。

ミニバッファーヒストリー
------------------------

minibuffer history
history of minibuffer input
ミニバッファーで入力したすべての引数は、ミニバッファーヒストリーリスト(minibuffer history list)に保存されているので、簡単に後でまた使うことができます。以下のコマンドにより、前の引数をすばやく探してミニバッファーに呼び出すことができます:

`M-p`  
ミニバッファーヒストリーの前のアイテム、つまり以前のアイテムに移動します(`previous-history-element`)。

`M-n`  
ミニバッファーヒストリーの次のアイテムに移動します(`next-history-element`)。

`UP`; `DOWN`  
`M-p`や`M-n`と同様ですが、前のヒストリーアイテムに移動する前に、複数行アイテムの前、または次の行に移動します(`previous-line-or-history-element`、および`next-line-or-history-element`)。

`M-r regexp RET`  
regexpにマッチする、ミニバッファーヒストリーの以前のアイテムに移動します(`previous-matching-history-element`)。

`M-s regexp RET`  
regexpにマッチする、ミニバッファーヒストリーの以降のアイテムに移動します(`next-matching-history-element`)。

M-p (minibuffer history)
M-n (minibuffer history)
next-history-element
previous-history-element
ミニバッファーでの`M-p` (`previous-history-element`)は、ミニバッファーのヒストリーリストのアイテムを1つずつ移動します。`M-p`はヒストリーリストの以前のアイテムを取り出して、ミニバッファーの既存の内容を置き換えます。`M-n` (`next-history-element`)は、ミニバッファーのヒストリーリストを反対方向、つまり以降のエントリーを取り出してミニバッファーの既存の内容を置き換えます。

ミニバッファーヒストリーに以降のエントリーがないとき(たとえば前に1回も`M-p`を入力していないとき)、Emacsはデフォルト引数のリストから、あなたが入力するだろうと思われる値を取り出します。これは“未来のヒストリー”を移動すると考えることもできます。

future history for file names
minibuffer defaults for file names
file-name-at-point-functions
ファイルにたいする“未来のヒストリー(future history)”には、カレントバッファー内のポイント位置にあるファイル名やURLのような、あなたが便利だと思うかもしれないいくつかの候補が含まれます。この場合、“未来のヒストリー”に配されるデフォルトは、オプション`file-name-at-point-functions`の値にセットされた関数により制御されます。デフォルトでは、この値は`ffap`パッケージ((see [FFAP](#FFAP))を参照)を呼び出します。これはポイント周辺のテキストからデフォルトとなるファイルやURLを推測します。この推測を無効にするには、このオプションを`nil`値にカスタマイズします。これにより“未来のヒストリー”に含まれるのは、(もしあれば)カレントバッファーでvisitされたファイル、およびデフォルトディレクトリーのファイルだけになります。

previous-line-or-history-element
next-line-or-history-element
UP (minibuffer history)
DOWN (minibuffer history)
矢印キーの`UP`と`DOWN`は、`M-p`や`M-n`のように機能しますが、カレントヒストリーアイテムが複数行の場合には、前(または次)のヒストリーアイテムに移動する前に、前(または次)の行に移動します。

ミニバッファーコマンドの`M-p`または`M-n`で挿入されたテキストを編集しても、ヒストリーリストのエントリーは変更されません。かわりに編集された引数が確定されたとき、ヒストリーリストの最後に追加されます。

previous-matching-history-element
next-matching-history-element
M-r (minibuffer history)
M-s (minibuffer history)
`M-r` (`previous-matching-history-element`)でヒストリーリストの古い要素を、`M-s` (`next-matching-history-element`)で新しいエントリーを探すことができます。これらのコマンドはどちらも引数として正規表現(regular expression)を要求し、それにマッチした最初のエントリーをミニバッファーに取り出します。正規表現についての説明は、[Regexps](#Regexps)を参照してください。数引数nを指定すると、それはn番目に一致したエントリーを取り出すことを意味します。これらのコマンドはミニバッファーから呼び出されたとはいえ、ミニバッファーを使って正規表現を読みとるという点では、変わったコマンドです。正規表現に大文字が含まれていると、大文字小文字を区別する検索([Lax Search](#Lax-Search)を参照してください)となります。

ヒストリーをインクリメンタルサーチすることもできます。[Isearch Minibuffer](#Isearch-Minibuffer)を参照してください。

Emacsは引数の種類ごとに個別のリストを保持します。たとえばファイル名のリストは、ファイル名を読みとるすべてのコマンドで使われたファイル名、といった具合です。ほかのヒストリーリストとしてはバッファー名やコマンド名(`M-x`で使われたもの)、コマンド引数(`query-replace`のような引数で使われたもの)があります。

history-length
変数`history-length`には、ミニバッファーのヒストリーリストの最大の長さを指定します。リストが長くなりすぎたときは、一番古い要素を削除して新しい要素を追加します。`t`を指定したときは、長さは無制限になります。

history-delete-duplicates
変数`history-delete-duplicates`には、重複したヒストリーを削除するかを指定します。非`nil`の場合、新しい要素が追加されるとリストからそれと同じ要素がすべて削除されます。デフォルトは`nil`です。

ミニバッファーでのコマンドの繰り返し
------------------------------------

command history
history of commands
ミニバッファーを使用したコマンドはすべて、コマンドヒストリー(command history)という特別なヒストリーリストに記録されます。これにはコマンドの引数の値も記録されるので、コマンド全体を再実行できます。特に`M-x`はコマンド名を読みとるので、`M-x`を使用したものはすべてそこに記録されます。

list-command-history
`C-x ESC ESC`  
コマンドヒストリーから最近のミニバッファーのコマンドを再実行します(`repeat-complex-command`)。

`M-x list-command-history`  
コマンドヒストリー全体を表示します。表示されたすべてのコマンドは`C-x ESC
ESC`で再実行できます。一番最近のものが先頭に表示されます。

C-x ESC ESC
repeat-complex-command
`C-x ESC
ESC`は、ミニバッファーを使った最近のコマンドを再実行します。引数を与えないと、一番最近のコマンドを実行します。数引数で再実行したいコマンドを指定します。1は一番最近のコマンド、2はその前、といった具合です。

`C-x ESC
ESC`は、前のコマンドをLisp式に変換して、その式でミニバッファーのテキストを初期化します。Lispを知らなくても、何のコマンドが再実行用に表示されているか明白でしょう。単にRETを入力すると、コマンドを変更せずに再実行します。実行する前にLisp式を編集して、コマンドを変更できます。実行されたコマンドは、一番最近のコマンドと等しくなければ、コマンドヒストリーの一番先頭に追加されます。

`C-x ESC
ESC`で一度ミニバッファーの中に入れば、通常のミニバッファーのヒストリーコマンド([Minibuffer History](#Minibuffer-History)を参照してください)を使って、ヒストリーリスト中を移動できます。以前に実行したコマンドが見つけたら、式を編集してRETにより実行できます。

isearch-resume-in-command-history
厳密に言うとインクリメンタルサーチはミニバッファーを使いません。これが複雑なコマンドのように振る舞うとしても、通常は`C-x
ESC
ESC`で表示されるヒストリーリストに含まれません。ヒストリーにインクリメンタルサーチコマンドを表示させるには、`isearch-resume-in-command-history`に非`nil`をセットしてください。[Incremental Search](#Incremental-Search)を参照してください。

command-history
ミニバッファーを使用した以前のコマンドのリストは、Lispのリスト値として`command-history`に格納されています。Lisp式の各要素は、1つのコマンドとその引数をあらわしています。Lispプログラムは`eval`に`command-history`の要素を使って呼び出すことで、コマンドを再実行できます。

パスワードの入力
----------------

Emacsでパスワードを入力したい場合があります。たとえばEmacsにFTPのようなネットワークプロトコルを介して他のマシンのファイルをvisitし、マシンへのアクセスのためにパスワードを与える場合などです([Remote Files](#Remote-Files)を参照してください)。

パスワードの入力はミニバッファーの使用と似ています。Emacsは(‘`Password:
`’のような)プロンプトをエコーエリアに表示します。要求されたパスワードを入力した後、それを確定するためにRETを押します。他の人がパスワードを見るのを防ぐために、入力した文字は通常の形式ではなく、ドット(‘`.`’)で表示されます。

ミニバッファーに関連付けられた多くの機能およびコマンドは、パスワード入力では使用*できません*。ヒストリーや補完はできず、ウィンドウの変更やEmacsでの他の処理も、パスワードをsubmitするまでは行うことができません。

パスワードのタイプ中は、DELを押して後方に、すなわち最後に入力した文字から削除できます。`C-u`で入力したすべての文字を削除できます。`C-g`はパスワードプロンプトを閉じます([Quitting](#Quitting)を参照してください)。`C-y`は現在のkillリングからパスワードを挿入します(see [Killing](#Killing))。パスワードを確定するには、RETまたはESCを入力します。他の自己挿入文字は、対応する文字をパスワードに入力します.それ以外の入力は無視されます。

Yes or No プロンプト
--------------------

Emacsのコマンドが実行の過程で、yes-or-no(はい/いいえ)形式で質問して答えを求めるかもしれません。これらの質問は大きく2つにわけることができます。

y or n prompt
1番目のyes-or-no形式の質問は、‘`(y or
n)`’で終わるプロンプトのものです。このような質問は、実際のところミニバッファーを使用しません。プロンプトがエコーエリアに表示され、答えを‘`y`’または‘`n`’で入力すると、ただちにそれが答えとなります。たとえばバッファーの保存で`C-x
C-w` (`write-file`)を入力して既存のファイル名を入力すると、Emacsは以下のようなプロンプトを表示します:

    File ‘foo.el’ exists; overwrite? (y or n)

この質問はミニバッファーを使用しないので、通常のミニバッファー編集コマンドは使えません。しかしいくつかのウィンドウをスクロールする操作は行えます。`C-l`による選択されたウィンドウの再センタリング、`C-v`(またはPageDownかnext)による前方へのスクロール、`M-v`(またはPageUpかprior)による後方へのスクロール、`C-M-v`による次のウィンドウの前方へのスクロール、`C-M-S-v`による次のウィンドウの後方へのスクロールができます。`C-g`は質問を打ちきり、質問を発したコマンドを終了します([Quitting](#Quitting)を参照してください)。

yes or no prompt
2番目のyes-or-no形式の質問は、間違った答えが深刻な事態を招くような場合に使用されます。これはミニバッファーを使い、‘`(yes or
no)`’で終わるプロンプトという特徴があります。たとえば変更が保存されていないファイルをvisitしているバッファーで、`C-x k` (`kill-buffer`)を呼び出すと、Emacsはミニバッファーをアクティブにして以下のようなプロンプトを表示します:

    Buffer foo.el modified; kill anyway? (yes or no)

これに答えるには、ミニバッファーに‘`yes`’または‘`no`’と入力してから、RETを押さなければなりません。ミニバッファーは前のセクションで説明したように動作します。`C-x
o`による他のウィンドウへのスイッチ、ヒストリーコマンドの`M-p`や`M-n`などが使用できます。`C-g`でミニバッファーを閉じて、質問を発したコマンドを終了できます。

名前を指定してコマンドを実行する
================================

すべてのEmacsコマンドは、それを使えば実行できるような名前を持っています。使いやすいようにキーバインディングされているコマンドも、たくさんあります。これらのコマンドはキーまたは名前で実行できます。キーがバインドされていないコマンドもたくさんあり、そのようなコマンドは名前でしか実行できません(キーバインドをセットアップする方法については、[Key Bindings](#Key-Bindings)を参照してください)。

慣例によりコマンド名は`auto-fill-mode`や`manual-entry`のように、ハイフンで区切られた、1つ以上の単語となっています。コマンド名は覚えやすいように、略されていない英単語が主に使われます。

M-x
コマンドを名前で実行するには、最初に`M-x`をタイプしてから、コマンド名をタイプしてRETで実行します。`M-x`はミニバッファーを使ってコマンド名を読みとります。ミニバッファーの先頭には、実行のために名前の入力が必要なことを気付かせるため、‘`M-x`’という文字がプロンプトとして表示されます。RETでミニバッファーを抜けだしコマンドを実行します。ミニバッファーについての詳細は、[Minibuffer](#Minibuffer)を参照してください。

コマンド名の入力には補完が使用できます。たとえば`forward-char`を呼び出すには以下のように入力できます

    M-x forward-char RET

または

    M-x forw TAB c RET

`forward-char`は、キー`C-f`で呼び出されるのと同じコマンドであることに注意してください。キーバインドの存在は、名前によるコマンドの実行を妨げません。

obsolete command
`M-x`でコマンドを補完するとき、obsolete(時代遅れ)と宣言されたコマンドは無視されます。これらのコマンドにたいしては、完全な名前をタイプする必要があります。時代遅れのコマンドとは、もっと新しく、より良い代替が存在していて、将来のEmacsリリースにおいて廃止が予定されているコマンドのことです。

`M-x`とコマンドの実行をキャンセルするには、コマンド名の入力のかわりに`C-g`を入力します。これによりコマンドを呼び出したレベルまで戻ります。

`M-x`で呼び出すコマンドに数引数を渡すには、`M-x`の前に数引数を指定します。引数の値はコマンド名が読みとられるときにプロンプトとして表示され、最終的に`M-x`は引数をコマンドに渡します。たとえば、コマンド`forward-char`に数引数として42を渡すには、`C-u
42 M-x forward-char RET`とタイプできます。

suggest-key-bindings
`M-x`で実行するコマンドがキーバインディングを持つ場合、Emacsはコマンド実行後にその旨をエコーエリアに表示します。たとえば`M-x
forward-word`と入力すると、同じコマンドを`M-f`で実行できるというメッセージが表示されます。このメッセージは変数`suggest-key-bindings`に`nil`にセットすればオフにできます。`suggest-key-bindings`の値には数字も指定でき、この場合Emaceは指定された秒数の間、キーバインドを表示します。バインディングを表示するときのデフォルトは2秒です。

extended-command-suggest-shorter
キーバインドをもたないコマンドも、‘`M-x`’のプロンプトで、完全な名前より短くタイプして呼び出すことができます。Emacsは、短縮入力が完全なコマンド名より明らかに短く、`extended-command-suggest-shorter`が非`nil`の場合は、そのような短縮入力をエコーエリアに表示します。`suggest-key-bindings`のセッティングは、そのようなヒントにも同様に効果を及ぼします。

このマニュアルではコマンドを名前で実行するとき、名前を終了させるためのRETを省くことがあります。つまり`M-x
auto-fill-mode RET`ではなく`M-x
auto-fill-mode`と表記します。RETはコマンドに引数がある場合に強調させる意味で使用します。

execute-extended-command
`M-x`は`execute-extended-command`を実行します。これは他のコマンドの名前を読み取って実行するコマンドです。

ヘルプ
======

help
self-documentation
help-command
C-h
F1
C-h C-h
help-for-help
Emacsはバラエティに富んだヘルプコマンドを提供しており、それらにはプレフィクスキー`C-h`(ファンクションキーF1でも可)からアクセスできます。以下のセクションではこれらのコマンドについて説明します。`C-h
C-h` (`help-for-help`)と入力すれば、ヘルプコマンドの一覧を見ることもできます。この一覧はSPCとDELでスクロールでき、それから見たいヘルプコマンドを入力するか、`C-g`でキャンセルできます。

多くのヘルプコマンドは、ヘルプバッファー(help buffer)という特別なバッファーに情報を表示します。このバッファーではSPCとDELによりスクロールし、RETでハイパーリンクをフォローすることができます。[Help Mode](#Help-Mode)を参照してください。

searching documentation efficiently
looking for a subject in documentation
特定の機能を探しているが、それが何と呼ばれているかわからない、どこを見ればよいのかわからないときには、次の3つの方法を推奨します。まず最初にaproposコマンドを試してください。次にマニュアルのインデックスを探してください。そしてFAQとパッケージのキーワードを探してください。

`C-h a topics RET`  
引数topicsと名前が一致するコマンドを検索します。引数にはキーワード、キーワードのリスト、正規表現([Regexps](#Regexps)を参照してください)を指定できます。[Apropos](#Apropos)を参照してください。

`C-h i d m emacs RET i topic RET`  
Emacsのinfoマニュアルのインデックスから、topicを検索して最初にマッチしたものを表示します。`,`を押すと次にマッチしたものを表示します。topicには正規表現を指定できます。

`C-h i d m emacs RET s topic RET`  
同様ですが、インデックスではなくマニュアル本文の*テキスト*を検索します。

`C-h C-f`  
Infoを使ってEmacs FAQを表示します。

`C-h p`  
キーワードに基づいて、利用可能なEmacsパッケージを表示します。[Package Keywords](#Package-Keywords)を参照してください。

他のさまざまなコンテキストでも、`C-h`やF1は“ヘルプ”を意味します。たとえばプレフィクスキーの後にこれらのキーを入力すると、プレフィクスキーに続けて入力できるキーの一覧を表示することができます(このコンテキストでは`?`も使用できます。いくつかのプレフィクスキーは`C-h`や`?`に別の意味を持たせているものがあるので使えませんが、それらのものでもF1はサポートされています)。

ヘルプの概要
------------

ここではビルトインのドキュメントにアクセスする、ヘルプコマンドの要約を記します。これらの大部分については、以下のセクションで詳細を説明します。

`C-h a topics RET`  
名前がtopicsにマッチするコマンドの一覧を表示します(`apropos-command`)。

`C-h b`  
有効なキーバインディングをすべて表示します。最初はマイナーモード、次にメジャーモード、それからグローバルのバインディングを表示します(`describe-bindings`)。

`C-h c key`  
キーシーケンスkeyがバインドされているコマンドの名前を表示します(`describe-key-briefly`)。`c`は“character”からきています。keyについてさらに詳しい情報を得るには、`C-h
k`を使います。

`C-h d topics RET`  
topicsにマッチするドキュメントをもつ、コマンドまたは変数を表示します(`apropos-documentation`)。

`C-h e`  
バッファー`*Messages*`を表示します(`view-echo-area-messages`)。

`C-h f function RET`  
functionという名前の、Lisp関数のドキュメントを表示します(`describe-function`)。コマンドもLisp関数なので、これはコマンドにも使用できます。

`C-h h`  
ファイル`HELLO`を表示します。このファイルは様々な文字セットの例です。

`C-h i`  
GNUドキュメントブラウザー(`info`)を実行します。Emacsのマニュアルはinfoで利用できます。

`C-h k key`  
keyで実行されるコマンドの名前と、ドキュメントを表示します(`describe-key`)。

`C-h l`  
最近のキーストローク300回分のの説明を表示します(`view-lossage`)。

`C-h m`  
カレントのメジャーモード、およびマイナーモードのドキュメントを表示します(`describe-mode`)。

`C-h n`  
最近のEmacsの変更に関するニュースを表示します(`view-emacs-news`)。

`C-h o symbol`  
symbolという名前のLispシンボルのドキュメントを表示します(`describe-symbol`)。これはすべての種類のシンボル、すなわち関数、変数、フェイスのドキュメントも表示します。

`C-h p`  
トピックのキーワードでパッケージを見つけます(`finder-by-keyword`)。これはパッケージメニューバッファーを使ってパッケージを一覧します。[Packages](#Packages)を参照してください。

`C-h P package RET`  
指定したパッケージのドキュメントを表示します(`describe-package`)。

`C-h r`  
Emacsのマニュアルをinfoで表示します(`info-emacs-manual`)。

`C-h s`  
現在の構文テーブル(syntax table)を表示します(`describe-syntax`)。構文テーブルは、どの文字が開始デリミッターで、その文字が単語の一部なのかを定義します。詳細については、section “Syntax Tables” in The Emacs Lisp Reference Manualを参照してください。

`C-h t`  
Emacsの対話的なチュートリアルを開始します(`help-with-tutorial`)。

`C-h v var RET`  
Lisp変数varのドキュメントを表示します(`describe-variable`)。

`C-h w command RET`  
commandという名前のコマンドを実行するキーを表示します(`where-is`)。

`C-h C coding RET`  
コーディングシステムcodingを説明します(`describe-coding-system`)。

`C-h C RET`  
現在使用されているコーディングシステムを説明します。

`C-h F command RET`  
infoを開始して、Emacsコマンドcommandのドキュメントのノードに移動します(`Info-goto-emacs-command-node`)。

`C-h I method RET`  
インプットメソッドmethodを説明します(`describe-input-method`)。

`C-h K key`  
infoを開始して、キーシーケンスkeyのドキュメントのノードに移動します(`Info-goto-emacs-key-command-node`)。

`C-h L language-env RET`  
言語環境(language environment)language-envで使用される文字セット、コーディングシステム、インプットメソッドに関する情報を表示します。

`C-h S symbol RET`  
編集中のプログラム言語に基づいて、シンボルsymbolのinfoドキュメントを表示します(`info-lookup-symbol`)。

`C-h .`  
ポイントが特別なテキスト領域のとき(これには、たとえば`*Help*`のリンクなどが含まれます)、ヘルプメッセージを表示します(`display-local-help`)。

キーのドキュメント
------------------

describe-key-briefly
describe-key
キーシーケンスに関する情報を得るためのヘルプコマンドは、`C-h c` (`describe-key-briefly`)と`C-h k` (`describe-key`)です。

C-h c
`C-h c key`は、keyにバインドされているコマンドの名前を、エコーエリアに表示します。たとえば`C-h
c C-f`は、‘`forward-char`’と表示します。

documentation string
C-h k
`C-h k
key`も同様ですが、さらに多くの情報が得られます。これはコマンドが何をするかが正確に説明する、ドキュメント文字列(documentation string)を含むヘルプバッファーを表示します。

C-h K
Info-goto-emacs-key-command-node
`C-h K key`は、keyに対応するコマンドが説明されている、Emacsマニュアルのセクションを表示します。

`C-h c`、`C-h k`、`C-h K`はファンクションキー、メニュー、マウスイベント(ただし`C-h
c`はマウス移動イベントを無視する)を含む、任意のキーシーケンスにたいして動作します。たとえば`C-h
k`の後で、メニューバーからメニューアイテムを選択すれば、それにより実行されるコマンドのドキュメントが表示されます。

C-h w
where-is
`C-h w command
RET`は、commandがバインドされているキーをリストします。リストはエコーエリアに表示されます。コマンドがキーにバインドされていないとき、それは`M-x`を使って実行しなければならないことを意味します。`C-h
w`はコマンド`where-is`を実行します。

コマンドと変数名のヘルプ
------------------------

C-h f
describe-function
`C-h f function RET` (`describe-function`)は、Lisp関数functionのドキュメントをウィンドウに表示します。コマンドもLisp関数なので、この方法を使えば、名前を知っている任意のコマンドのドキュメントを閲覧できます。たとえば

    C-h f auto-fill-mode RET

は`auto-fill-mode`のドキュメントを表示します。これはキーにバインドされていないコマンド(通常`M-x`で実行する)のドキュメントを閲覧する、唯一の方法です。

`C-h f`は、LispプログラムからLisp関数を使うときも便利です。たとえば式`(make-vector
len)`を書いたとしましょう。正しく`(make-vector len)`を使っているかチェックしたいときは、`C-h f
make-vector RET`と入力します。`C-h
f`はコマンド名だけでなくすべての関数名を許容するので、`M-x`では機能するいつもの補完による短縮形が、`C-h
f`では機能しないと気付くかもしれません。コマンド名では省略形が一意であっても、すべての関数名を含めたら一意ではないかもしれないからです。

`C-h f
RET`を入力すると、バッファーのポイントがある位置の、一番内側のLisp式で呼び出されている関数の名前が有効で、Lisp関数として定義されていれば、その関数の説明が表示されます(引数を入力するときデフォルトとして関数名が表示されます)。たとえばポイントが‘`(make-vector
(car x)`’の後ろにあるとき、ポイントを含む一番内側のリストは‘`(make-vector`’で始まっているので、`C-h f
RET`により関数`make-vector`の説明が表示されます。

`C-h f`は、関数名を正しく記述しているか確かめたいときも便利です。`C-h
f`のミニバッファーのプロンプトで、編集中のバッファーの関数名がデフォルトとして表示されるなら、それは定義されたLisp関数であることを意味します。本当にドキュメントを見たい訳でなければ、`C-g`を押してコマンド`C-h
f`をキャンセルできます。

C-h v
describe-variable
`C-h v` (`describe-variable`)は、`C-h
f`と似ていますがLisp関数ではなく、Lisp関数の説明を表示します。ポイントの周囲または前にあるLispシンボルが、定義されたLisp変数名のときはそれがデフォルトとなります。[Variables](#Variables)を参照してください。

通常Emacsの変数または関数を説明するヘルプバッファーには、ソースファイルがインストールされていれば、対応するソースコードへのハイパーリンクが含まれています([Hyperlinking](#Hyperlinking)を参照してください)。

C-h F
Info-goto-emacs-command-node
マニュアルからコマンドのドキュメントを探すには、`C-h F` (`Info-goto-emacs-command-node`)を使います。これはEmacsのマニュアルだけでなく、さまざまなマニュアルを認識するので、正しいものを見つけられるでしょう。

C-h o
describe-symbol
`C-h o` (`describe-symbol`)は、`C-h f`や`C-h
v`と似ていますが、これは任意のシンボル(関数、変数、フェイス)を説明します。シンボルが複数の定義をもつ場合(たとえばシンボルが関数と変数の両方の定義をもつような場合)、このコマンドはそれらすべてのドキュメントを順に表示します。

Apropos(適切な)
---------------

apropos
apropos(折よい、適切な)コマンドは、“What are the commands for working with files?(ファイルを処理するコマンドは?)”のような質問に答えるものです。より正確に言うと単語、単語のリスト、正規表現によって、aproposパターンを指定します。

以下の各aproposコマンドは、ミニバッファーでaproposパターンを読み取り、パターンにマッチするアイテムを検索して、結果を別のウィンドウに表示します。

`C-h a`  
C-h a

apropos-command

コマンドを検索します(`apropos-command`)。プレフィクス引数を指定すると、非インタラクティブな関数も検索します。

`M-x apropos`  
apropos

関数と変数を検索します。これを使えばインタラクティブな関数(コマンド)と非インタラクティブな関数の両方を検索できます。

`M-x apropos-user-option`  
apropos-user-option

ユーザーがカスタマイズできる関数を検索します。プレフィクス引数を指定すると、カスタマイズできない変数も検索します。

`M-x apropos-variable`  
apropos-variable

変数を検索します。プレフィクス引数を指定すると、カスタマイズできる変数だけを検索します。

`M-x apropos-local-variable`  
apropos-local-variable

バッファーローカル変数を検索します。

`M-x apropos-value`  
apropos-value

指定したパターンにマッチする値の変数を検索します。プレフィクス引数を指定すると、定義がパターンにマッチする関数と、プロパティーリストがパターンにマッチする、Lispシンボルも検索します。

`M-x apropos-local-value`  
apropos-local-value

値が指定されたパターンにマッチする、バッファーローカル変数を検索します。

`C-h d`  
C-h d

apropos-documentation

指定されたパターンにマッチするドキュメント文字列の関数、または変数を検索します(`apropos-documentation`)。

最も簡単な種類のaproposパターンは単語です。その単語が含まれていれば、パターンにマッチします。ファイルを処理するコマンドを探すには、`C-h
a file
RET`と入力します。これは`copy-file`、`find-file`などの、名前に‘`file`’を含むすべてのコマンドの一覧を表示します。各コマンド名には簡単な説明と、それを呼び出すためのキーの一覧が一緒に表示されます。この例だと、`find-file`は`C-x
C-f`で呼び出せることがわかります。

aproposバッファーの関数定義、変数、シンボルの属性についてもっと情報が欲しいときは、`mouse-1`または`mouse-2`でクリックするか、そこに移動してRETを押してください。

2つ以上の単語をaproposパターンに指定したときは、マッチするために少なくとも名前に2つの単語が含まれていなければなりません。たとえばポイントの前のテキストをkillするコマンドを探すときは、`C-h
a kill back backward behind before
RET`などと試みることができます。これは実際のコマンド名`kill-backward`にマッチするでしょう。もし`kill-text-before`というコマンドがあったなら、これも指定した単語を2つ含んでいるのでマッチします。

より一層フレキシビリティを高めるために、正規表現(see [Regexps](#Regexps))を指定できます。aproposパターンに正規表現の特殊文字‘`^$*+?.\[`’が含まれていると、それは正規表現として扱われます。

Emacsコマンド命名の慣習に従うと、aproposパターンとして便利な単語がいくつかあります。これらを`C-h
a`で使うことにより、命名の慣習の必要性を感じることができるでしょう。

> char、line、word、sentence、paragraph、region、page、sexp、list、defun、rect、buffer、frame、window、face、file、dir、register、mode、beginning、end、forward、backward、next、previous、up、down、search、goto、kill、delete、mark、insert、yank、fill、indent、case、change、set、what、list、find、view、describe、default

apropos-do-all
変数`apropos-do-all`が非`nil`の場合、ほとんどのaproposコマンドは、プレフィクス引数が与えられたかのように振る舞います。例外が1つあります。プレフィクス引数なしの`apropos-variable`は、`apropos-do-all`の値に関係なく、常にすべての変数を検索します。

apropos-sort-by-scores
apropos search results, order by score
apropos-documentation-sort-by-scores
デフォルトでは、`apropos-documentation`を除くすべてのaproposコマンドは、結果をアルファベット順に一覧します。変数`apropos-sort-by-scores`が非`nil`のときは、かわりに結果の関連度を推測して、一番関連度が高いと思われるものを最初に表示します。`apropos-documentation`コマンドは、デフォルトで結果を関連度順で一覧します。これをアルファベット順にするには、変数`apropos-documentation-sort-by-scores`を`nil`に変更してください。

ヘルプモードのコマンド
----------------------

ヘルプバッファーはViewモード([View Mode](#View-Mode)を参照してください)と同じコマンドを提供します。たとえば前方へのスクロールはSPC、後方へのスクロールはDELか`S-SPC`です。他にも特別なコマンドをいくつか提供します:

`RET`  
ポイント位置のクロスリファレンス先をフォローします(`help-follow`)。

`TAB`  
ポイントを次のハイパーリンクへ進めます(`forward-button`)。

`S-TAB`  
ポイントを前のハイパーリンクへ戻します(`backward-button`)。

`mouse-1`; `mouse-2`  
クリックしたハイパーリンク先をフォローします。

`C-c C-c`  
ポイント位置のシンボルに関する、すべてのドキュメントを表示します(`help-follow-symbol`)。

`C-c C-f`; `r`  
次ののヘルプトピックに前方へ移動します(`help-go-forward`)。

`C-c C-b`; `l`  
前のヘルプトピックに戻ります(`help-go-back`)。

hyperlink
help-follow
help-go-back
help-go-forward
RET (Help mode)
C-c C-b (Help mode)
l (Help mode)
C-c C-f (Help mode)
r (Help mode)
もし関数名、変数名、フェイス名([Faces](#Faces)を参照してください)がヘルプバッファーのドキュメントにあると、通常はアンダーラインされたハイパーリンク(hyperlink)として表示されます。関連するドキュメントを閲覧するには、ポイントをそこに移動してRET (`help-follow`)とタイプするか、ハイパーリンクを`mouse-1`または`mouse-2`でクリックします。するとヘルプバッファーの内容が入れ替わりますが、`C-c
C-b`、または`l` (`help-go-back`)で元に戻すことができます。元に戻る途中では、`C-c
C-f`または`r` (`help-go-forward`)を使用して前に進むことができます。

URL, viewing in help
help, viewing web pages
viewing web pages in help
web pages, viewing in help
ヘルプバッファーには、infoマニュアル、ソースコード定義、URL(ウェブページ)へのハイパーリンクを含むこともできます。最初の2つはEmacs上で表示され、3番目のURLはコマンド`browse-url`により、ウェブブラウザーを使って表示されます。

TAB (Help mode)
forward-button
S-TAB (Help mode)
backward-button
ヘルプバッファーでは、TAB (`forward-button`)はポイントを次のハイパーリンクへ進め、`S-TAB` (`backward-button`)は前のハイパーリンクへ戻します。これらのコマンドは循環的です。たとえば最後のハイパーリンクでTABをタイプすると、最初のハイパーリンクに戻ります。

テキスト中のシンボルに関するすべてのドキュメントを閲覧するには、ポイントをシンボルに移動して`C-c C-c` (`help-follow-symbol`)とタイプします。これは変数、関数、および/またはフェイスとしての、そのシンボルが意味する、すべてのドキュメントを表示します。

パッケージのキーワード検索
--------------------------

finder
Emacsのたいていのオプション機能は、パッケージ(packages)にグループ化されています。Emacsには数百のビルトインパッケージが含まれており、ネットワークを通じて他のパッケージのインストールもできます([Packages](#Packages)を参照してください)。

C-h p
finder-by-keyword
あるトピックに関連するパッケージを探すのを簡単にするため、ほとんどのパッケージは、それが何をするかにもとづき、1つ以上のキーワード(keywords)に関連付けられています。`C-h
p` (`finder-by-keyword`)とタイプすると、パッケージキーワードとキーワードの意味を説明するリストが表示されます。キーワードに属するパッケージのリストを表示するには、そのキーワードの行でRETをタイプします。これによりパッケージメニューバッファー([Package Menu](#Package-Menu)を参照してください)で、パッケージの一覧が表示されます。

describe-package
C-h P
`C-h P` (`describe-package`)はパッケージ名([Packages](#Packages)を参照)の入力を求めて、パッケージの属性と、それが実装する機能をヘルプバッファーで表示します。このバッファーは、ボタン形式で関連するパッケージのキーワードを一覧します。ボタン`mouse-1`か`mouse-2`をクリックすると、そのキーワードに関連する他のパッケージを見ることができます。

国際化言語のサポートに関するヘルプ
----------------------------------

特定の言語環境(language environment: [Language Environments](#Language-Environments)を参照してください)の情報を得るには、`C-h
L`とタイプします。これはヘルプバッファーを開いて、言語環境でサポートされる言語の説明と、関連する文字セット、コーディングシステム、インプットメソッド、およびその言語環境のサンプルテキストを表示します。

コマンド`C-h h` (`view-hello-file`)は、ファイル`etc/HELLO`を表示します。このファイルはさまざまな言語で“hello”をどのように言うのかを、いろいろな文字セットで表示するデモンストレーションです。

コマンド`C-h I` (`describe-input-method`)は、指定されたインプットメソッド、または現在使われているインプットメソッド(デフォルト)の説明します。[Input Methods](#Input-Methods)を参照してください。

コマンド`C-h C` (`describe-coding-system`)は、指定されたコーディングシステム、または現在使われているものを説明します。[Coding Systems](#Coding-Systems)を参照してください。

その他のヘルプコマンド
----------------------

C-h i
info
Info
manuals, included
`C-h i` (`info`)は、infoプログラムを実行します。infoは構造化されたドキュメントファイルを閲覧するものです。Emacsマニュアル全体は、GNUシステムのための他のマニュアルとともに、infoで利用可能です。infoを開始した後、`h`をタイプすると、infoの使い方のチュートリアルが実行されます。

find Info manual by its file name
数引数nを指定すると、`C-h
i`はinfoバッファー‘`*info*<n>`’を選択します。これは同時に複数のinfoマニュアルを閲覧するとき便利です。プレフィクス引数`C-u`だけを指定した場合、`C-h
i`はドキュメントのファイル名を尋ねるので、infoメニューのトップレベルにエントリーがないファイルでも閲覧できます。

上記で説明しているヘルプコマンド`C-h F function RET`と`C-h K
key`は、infoを実行して関数(function)またはキー(key)に関するドキュメントを直接開きます。

C-h S
info-lookup-symbol
プログラムを編集しているとき、そのプログラム言語のinfo版のマニュアルを持っていれば、`C-h S` (`info-lookup-symbol`)を使ってシンボル(キーワード、関数、変数)のエントリーを、適切なマニュアルから探すことができます。コマンドがどのように動作するかの詳細は、メジャーモードに依存します。

C-h l
view-lossage
何か予期しないことが起こって、何をタイプしたかわからなくなったときは、`C-h l` (`view-lossage`)を使います。`C-h
l`は最近の300回分のキーストロークと、それらが呼び出したコマンドを表示します。馴染みのないコマンドを見つけたら、`C-h
k`や`C-h f`を使用して、それらのコマンドが何を行なうか調べることができます。

C-h e
view-echo-area-messages
最近のエコーエリアのメッセージを調べるには、`C-h e` (`view-echo-area-messages`)を使います。これはそれらのメッセージを保持するバッファー、`*Messages*`を表示します。

C-h m
describe-mode
Emacsの各メジャーモードでは、一般的にいくつかのキーが再定義されていて、編集動作も異なります。`C-h m` (`describe-mode`)は、現在のメジャーモードのドキュメントを表示します。これには通常このモードで変更されているコマンドや機能、およびそれらのキーバインドについても説明されています。

C-h b
describe-bindings
C-h s
describe-syntax
`C-h b` (`describe-bindings`)と`C-h s` (`describe-syntax`)は、現在のEmacs環境に関する、それ以外の情報を表示します。最初は現在のマイナーモードのローカルバインディング、次に現在のメジャーモードで定義されているローカルバインディング、最後にグローバルバインディングが表示されます。`C-h
s`は各文字の構文の説明とともに、構文テーブルの内容を表示します(section “Syntax Tables” in The Emacs Lisp Reference Manualを参照してください)。

describe-prefix-bindings
プレフィクスキーの後に`C-h`、`?`、F1をタイプすることにより、特定のプレフィクスキーにたいする、サブコマンドのリストを得ることができます(この方法が機能しないプレフィクスキーもあります。たとえばESCです。`ESC
C-h`は実際には`C-M-h`と解釈され、これはdefunをマークするコマンドです。このような場合でも`ESC
F1`や`ESC ?`はうまく機能します)。

ヘルプファイル
--------------

ビルトインのドキュメントとマニュアル以外にも、Emacsにはコピー条件(copying conditions)、リリースノート(release notes)、デバッグ説明書(instructions for debugging)、バグ報告(reporting bugs)などのトピックを説明する、いくつかのファイルが含まれています。これらのファイルは、以下のコマンドで閲覧することができます。`C-h
g`をのぞき、これらはすべて、`C-h C-char`という形式になっています。

C-h C-c
describe-copying
C-h C-d
view-emacs-debugging
C-h C-e
view-external-packages
C-h C-f
view-emacs-FAQ
C-h g
describe-gnu-project
C-h C-m
view-order-manuals
C-h C-n
view-emacs-news
C-h C-o
describe-distribution
C-h C-p
view-emacs-problems
C-h C-t
view-emacs-todo
C-h C-w
describe-no-warranty
`C-h C-c`  
Emacsをコピー、再頒布する場合の規則を表示します(`describe-copying`)。

`C-h C-d`  
Emacsをデバッグするためのヘルプを表示します(`view-emacs-debugging`)。

`C-h C-e`  
外部のパッケージをどこで入手するかについての情報を表示します(`view-external-packages`)。

`C-h C-f`  
EmacsのFAQ(frequently-answered-questions: 頻繁に答えられる質問)のリストを表示します(`view-emacs-FAQ`)。

`C-h g`  
GNUプロジェクトに関する情報がある、[ページ](http://www.gnu.org)をvisitします(`describe-gnu-project`)。

`C-h C-m`  
Emacsマニュアルの印刷されたコピーの注文に関する情報を表示します(`view-order-manuals`)。

`C-h C-n`  
このバージョンの新しい機能の一覧が含まれるnewsファイルを表示します(`view-emacs-news`)。

`C-h C-o`  
Emacsおよび他のGNUソフトウェアーの最新バージョンを、注文またはダウンロードする方法を表示します(`describe-distribution`)。

`C-h C-p`  
Emacsの既知の問題(それにどう対処するかの提案がある場合もあります)を表示します(`view-emacs-problems`)。

`C-h C-t`  
EmacsのTODOリストを表示します(`view-emacs-todo`)。

`C-h C-w`  
GNU Emacsが完全に無保証なことにたいする、すべての詳細を表示します(`describe-no-warranty`)。

アクティブテキストのヘルプとツールチップ
----------------------------------------

tooltip help
balloon help
active text
Emacsでは拡大解釈されるアクティブテキスト(active text: マウスのクリックやRETに特別な反応をするテキスト)は、しばしばヘルプテキストに関連付けられています。これにはEmacsのバッファーのハイパーリンク、同様にモードラインの一部が含まれます。グラフィカルなディスプレー、同様にいくつかのテキスト端末は、マウストラッキングをサポートしており、アクティブテキストの上をマウスが通過することにより、ヘルプテキストをツールチップ(tooltip)で表示します。[Tooltips](#Tooltips)を参照してください。

C-h .
display-local-help
help-at-pt-display-when-idle
マウストラッキングをサポートしない端末では、バッファーのアクティブテキストにポイントを移動して、`C-h .` (`display-local-help`)をタイプすれば、ヘルプテキストを表示できます。これはヘルプテキストをエコーエリアに表示します。ポイントがある場所のヘルプテキストが利用可能な場合に、常に表示させるには、変数`help-at-pt-display-when-idle`に`t`をセットしてください。

マークとリージョン
==================

mark
setting a mark
region
Emacsのコマンドには、現在のバッファー内の、任意の連続する領域(region)を操作するものがたくさんあります。そのようなコマンドが操作するテキストを指定するには、領域の一方の端にマーク(mark)をセットし、もう一方の端にポイントを移動します。ポイントとマークの間のテキストを、リージョン(region)と呼びます。リージョンは常にポイントとマークの間で拡張され、それは一方がテキストの先頭にある場合も変わりません。ポイントを移動すれば、常にリージョンは変化します。

active region
activating the mark
テキストのある位置にマークをセットすると、マークはアクティブ(active)になります。マークがアクティブのときは、リージョンもアクティブになります。Emacsはアクティブなリージョンの中にあるテキストを、フェイス`region`でハイライト表示します([Face Customization](#Face-Customization)を参照してください)。

deactivating the mark
バッファーのテキストを変更するコマンドを含む、特定の非移動系コマンド(non-motion commands)の後で、Emacsは自動的にマークを非アクティブ(deactivates)にし、これによりハイライトも解除されます。`C-g`をタイプすれば、いつでも明示的に非アクティブにすることができます([Quitting](#Quitting)を参照してください)。

上記のデフォルト動作は、Transient Markモード(暫定マークモード)という名で知られています。Transient Markモードを無効にすると、Emacsは通常ではリージョンをハイライトしなくなります。[Disabled Transient Mark](#Disabled-Transient-Mark)を参照してください。

highlight-nonselected-windows
あるバッファーでマークをセットしても、他のバッファーのマークは影響を受けません。アクティブなマークがあるバッファーに戻ったとき、マークは以前と同じ場所にあります。複数のウィンドウで同じバッファーを表示しているとき、これらのウィンドウはそれぞれのポイント位置をもっているので、リージョンも異なります。しかしこれらのウィンドウでは、マークの位置は共通です。[Windows](#Windows)を参照してください。通常、選択されたウィンドウのリージョンだけがハイライトされます。しかし変数`highlight-nonselected-windows`が非`nil`の場合、各ウィンドウのリージョンがハイライトされます。

rectangular region(矩形リージョン)という、違う種類のリージョンもあります。[Rectangles](#Rectangles)を参照してください。

マークのセット
--------------

マークをセットするためのコマンドがいくつかあります:

`C-SPC`  
ポイント位置にマークをセットしてアクティブにします(`set-mark-command`)。

`C-@`  
同じです。

`C-x C-x`  
ポイント位置にマークをセットしてアクティブにしてから、以前のマークがあった位置にポイントを移動します(`exchange-point-and-mark`)。

`Drag-mouse-1`  
ドラッグしたテキストの周りにポイントとマークをセットします。

`mouse-3`  
ポイント位置にマークをセットしてから、クリックした場所にポイントを移動します(`mouse-save-then-kill`)。

`‘シフトを押したカーソル移動キー’`  
マークが非アクティブなら、ポイント位置にマークをセットしてポイントを移動します。[Shift Selection](#Shift-Selection)を参照してください。

C-SPC
C-@
set-mark-command
マークをセットするもっとも一般的な方法は、`C-SPC` (`set-mark-command`)です[5]。これはポイントがある位置にマークをセットしてから、アクティブにします。その後、マークをそこに残したままポイントを移動できます。

たとえばバッファーの一部を大文字に変換したいとします。これを行うには対象のテキストの一方の端に移動して、`C-SPC`をタイプし、対象のテキストがハイライトされるまでポイントを移動します。そして`C-x
C-u` (`upcase-region`)をタイプすると、リージョンのテキストが大文字に変換されて、マークが非アクティブになります。

マークがアクティブなときに非アクティブにしたいときは、`C-g`をタイプします([Quitting](#Quitting)を参照してください)。リージョンにたいして操作を行うほとんどのコマンドは、上記の例の`C-x
C-u`のように、自動的にマークを非アクティブにします。

リージョンにたいしての操作は行わず、バッファーの位置を覚えておくためにマークをセット(`C-SPC
C-SPC`とタイプ)して、後でそこに戻る(`C-u
C-SPC`とタイプ)こともできます。詳細については、[Mark Ring](#Mark-Ring)を参照してください。

C-x C-x
exchange-point-and-mark
コマンド`C-x C-x` (`exchange-point-and-mark`)は、ポイントとマークの位置を交換します。ポイントの位置に問題はないが、リージョンのもう一方の端にポイントを移動したいとき`C-x
C-x`は便利です。2回目の`C-x
C-x`で、マークを新しいポイント位置にマークをセットしてから、ポイントを元の位置に戻すことができます。このコマンドはマークが非アクティブのとき、最初にマークをアクティブにします。これはマークが最後にどこにセットされたかを明確にするために、リージョンをハイライトするためです。しかしプレフィクス引数とともに呼び出せば、マークは非アクティブのままでリージョンもハイライトされません。これを使えば`C-u
C-SPC`と同様の方法で、マークの位置にジャンプできます。

マウスでマークをセットすることもできます。マウスの左ボタン(`down-mouse-1`)をクリックしてから、テキスト範囲をドラッグすると、最初にマウスボタンを押した位置にマークがセットされ、マウスボタンを話した位置にポイントが置かれます。かわりにマウスの右ボタン(`mouse-3`)をクリックすれば、ポイントのある位置にマークがセットされ、クリックした位置にポイントが移動します。これらのマウスコマンドに関する詳細な説明は、[Mouse Commands](#Mouse-Commands)を参照してください。

最後にシフトキーを押しながらカーソルを移動するコマンド(`S-RIGHT`、`S-C-f`、`S-C-n`など)でマークをセットできます。これはシフト選択(shift-selection)と呼ばれ、以前にシフト選択やマウスコマンドでセットされたアクティブなマークがないときに限り、ポイントを移動する前の位置にマークをセットします。マウスコマンドやシフト選択によるマークのセットは、通常のマークとは少し異なります。続けてシフトを押さないカーソル移動コマンドを実行するにより、マークは自動的に非アクティブになります。詳細は、[Shift Selection](#Shift-Selection)を参照してください。

`C-y` (`yank`)のようなテキストを挿入するコマンドの多くは、挿入されたテキストの先頭に、非アクティブなマークをセットします。これにより簡単にその位置に戻ることができます([Mark Ring](#Mark-Ring)を参照してください)。コマンドがこれを行っていることは、エコーエリアに‘`Mark set`’が表示されることで見分けることができます。

primary selection, when active region changes
Xではアクティブなリージョンが変化するたびに、Emacsはリージョンのテキストをプライマリー選択(primary selection)に保存します。これにより`mouse-2`をクリックして、他のXアプリケーションへテキストを挿入することができるようになります。[Primary Selection](#Primary-Selection)を参照してください。

テキストオブジェクトをマークするコマンド
----------------------------------------

marking sections of text
単語(word)、リスト(list)、パラグラフ(paragraph: 段落)、ページ(page)などのテキストオブジェクトの周辺に、ポイントを配置してマークするコマンドがあります:

`M-@`  
次の単語の末尾にマークをセットします(`mark-word`)。ポイントは移動しません。

`C-M-@`  
次の対応のとれた式の後にマークをセットします(`mark-sexp`)。ポイントは移動しません。

`M-h`  
ポイントを現在のパラグラフの先頭に移動して、パラグラフの最後にマークをセットします(`mark-paragraph`)。

`C-M-h`  
ポイントを現在のdefunの先頭に移動して、defunの最後にマークをセットします(`mark-defun`)。

`C-x C-p`  
ポイントを現在のページの先頭に移動して、ページの最後にマークをセットします(`mark-page`)。

`C-x h`  
ポイントを現在のバッファーの先頭に移動して、バッファーの最後にマークをセットします(`mark-whole-buffer`)。

M-@
mark-word
`M-@` (`mark-word`)は、次の単語の最後にマークをセットします(単語についての情報は、[Words](#Words)を参照してください)。繰り返し呼び出されると、マークを1度に1単語進めてリージョンを拡張します。例外として、マークがアクティブでポイントの前にある場合、`M-@`はマークを現在の位置から1単語後方に移動します。

このコマンドに数引数nを指定することにより、n単語進めてマークするよう指定できます。負の引数はn単語後方にマークを移動します。

C-M-@
mark-sexp
同様に`C-M-@` (`mark-sexp`)は、対応のとれた式の最後にマークをセットします([Expressions](#Expressions)を参照してください)。繰り返し呼び出すことにより、後続の式にリージョンを拡張します。正または負の数引数を指定するとその数に応じて前方または後方にマークを移動します。

上記のリストの他のコマンドは、ポイントとマークの両方をセットするので、バッファー内のオブジェクトを区切るコマンドです。`M-h` (`mark-paragraph`)はパラグラフ([Paragraphs](#Paragraphs)を参照してください)、`C-M-h` (`mark-defun`)はトップレベルの関数定義([Moving by Defuns](#Moving-by-Defuns)を参照してください)、`C-x
C-p` (`mark-page`)はページ([Pages](#Pages)を参照してください)をマークします。繰り返して呼び出すと、同種の連続するオブジェクトへと、リージョンを拡張します。数引数も同様で、マークを移動したいオブジェクトの数を指定します。

C-x h
mark-whole-buffer
select all
`C-x h` (`mark-whole-buffer`)はポイントをバッファーの先頭、マークを最後にセットすることによりバッファー全体をリージョンとします。

リージョンを操作する
--------------------

operations on a marked region
一度リージョンを設定すると、それを処理するいくつかの方法があります:

-   `C-w` (see [Killing](#Killing))でkillします。

-   `M-w` でkillリングにコピーします([Yanking](#Yanking)を参照してください)。

-   `C-x C-l`または`C-x C-u`で、大文字小文字を変換します([Case](#Case)を参照してください)。

-   `C-u C-/`で変更をアンドゥ(undo)します([Undo](#Undo)を参照してください)。

-   `M-%`でリージョンの中のテキストを置換します([Query Replace](#Query-Replace)を参照してください)。

-   `C-x TAB`または`C-M-\`でインデントします([Indentation](#Indentation)を参照してください)。

-   `M-x fill-region`でテキストとしてフィルします([Filling](#Filling)を参照してください)。

-   `M-$`で単語のスペルをチェックします([Spelling](#Spelling)を参照してください)。

-   `M-x eval-region`でLispコードとして評価します([Lisp Eval](#Lisp-Eval)を参照してください)。

-   `C-x r s`でレジスターに保存します([Registers](#Registers)を参照してください)。

-   バッファーまたはファイルに保存します([Accumulating Text](#Accumulating-Text)を参照してください)。

マークが非アクティブのときにはデフォルトの動作をするが、マークがアクティブのときはリージョンを処理するコマンドがいくつかあります。たとえば`M-$` (`ispell-word`)は、通常はポイントのある単語のスペルをチェックしますが、マークがアクティブのときはリージョンの中のテキストをチェックします([Spelling](#Spelling)を参照してください)。通常そのようなコマンドはリージョンが空のとき(たとえばマークとポイントが同じ位置のとき)は、デフォルトの動作をします。空のリージョンにたいして処理を行いたいときは、変数`use-empty-active-region`を`t`に変更してください。

delete-active-region
[Erasing](#Erasing)で説明したように、DEL (`backward-delete-char`)とDelete (`delete-forward-char`)もこの方法で動作します。マークがアクティブのときはリージョンのテキストを削除します(例外として数引数nに1以外が指定されたとき、これらのコマンドはマークがアクティブか関係なく、n文字を削除します)。変数`delete-active-region`を`nil`に変更すると、これらのコマンドはマークがアクティブのとき異なる動作をしなくなります。これを`kill`に変更するとリージョンを削除するかわりに、killするようになります([Killing](#Killing)を参照してください)。

mark-even-if-inactive
その他のコマンドにはデフォルトの動作はなく、常にリージョンを処理します。通常このようなコマンドには、`C-w` (`kill-region`)や`C-x C-u` (`upcase-region`)のように、名前に`region`がついています。マークが非アクティブのときは非アクティブなリージョン、すなわちポイントと最後にマークをセットした位置の間にあるテキストにたいして処理を行います([Mark Ring](#Mark-Ring)を参照してください)。この動作を無効にするには、変数`mark-even-if-inactive`を`nil`に変更してください。そうするとこれらのコマンドはマークが非アクティブのときエラーをシグナルします。

Delete Selection mode
mode, Delete Selection
delete-selection-mode
デフォルトでは、マークがアクティブでもテキストの挿入は普通に行われます。たとえば`a`をタイプすると、‘`a`’が挿入されてからマークが非アクティブになります。マイナーモードのDelete Selectionモードは、この振る舞いを変更します。Delete Selectionモードが有効な場合、マークがアクティブなときは、最初にリージョンのテキストを削除してから、テキストが挿入されます。Delete Selectionモードをオフにするには、`M-x delete-selection-mode`とタイプしてください。

マークリング
------------

mark ring
各バッファーは、マークリング(mark ring)の中に、以前のマークの位置を記録しています。マークをセットするコマンドは、古いマークをこのリングにpushします。マークリングの1つの使い方として、後で戻りたい場所を記録させる使い方があります。

`C-SPC C-SPC`  
マークをアクティブにせずにマークをセットしてから、マークリングにpushします。

`C-u C-SPC`  
マークがあった場所にポイントを移動し、マークリングから1つ前のマークを復元します。

C-SPC C-SPC
コマンド`C-SPC
C-SPC`は、後で戻ってきたい位置をマークするときに便利です。これは現在の位置をマークを(Emacsがリージョンをハイライト表示してしまう)アクティブにすることなく、マークリングにpushします。実際にこれは`C-SPC` (`set-mark-command`)を連続して2回呼び出しています。最初の`C-SPC`はマークをセットし、2回目の`C-SPC`はそれを非アクティブにしています(Transient Markモードがオフの場合、`C-SPC C-SPC`は一時的にTransient Markモードを有効にします。[Disabled Transient Mark](#Disabled-Transient-Mark)を参照してください)。

C-u C-SPC
マークした位置に戻るには、`C-u
C-SPC`のようにプレフィクス引数を指定して、`set-mark-command`を使います。これはマークがあった場所にポイントを移動して、もしマークがアクティブのときは非アクティブにします。`C-u
C-SPC`を連続して呼び出すと、マークリングに保存された前の位置へジャンプしていきます。この方法で移動した位置の情報は失われません。それらはリングの最後に移動します。

set-mark-command-repeat-pop
`set-mark-command-repeat-pop`を非`nil`にセットすると、`C-u
C-SPC`の後に続けて、`C-u
C-SPC`ではなく、`C-SPC`でマークリングを巡回できます。デフォルトでは`set-mark-command-repeat-pop`は`nil`です。

各バッファーは自身のマークリングを持ちます。すべての編集コマンドは現在のバッファーのマークリングを使います。特に`C-u
C-SPC`は常に同じバッファーに留まります。

mark-ring-max
変数`mark-ring-max`は、マークリングに保持する最大のエントリー数を指定します。デフォルトは16エントリーです。もしエントリー数が最大の場合、他のエントリーをpushするとリストの一番古いものが捨てられます。`C-u
C-SPC`を繰り返すと、リングの現在位置を巡回します。

もし何度も同じ場所に戻りたいときは、マークリングでは不十分でしょう。そのような場合は後で使うために、その位置をレジスターに記録できます([Position Registers](#Position-Registers)を参照してください)。

グローバルマークリング
----------------------

global mark ring
global-mark-ring-max
各バッファーに属する普通のマークリングに加えて、Emacsにはグローバルマークリング(global mark ring)が1つあります。以前マークをセットしてからバッファーを切り替えた場合、マークをセットすると、マークはカレントバッファーのマークリングに加えて、グローバルマークリングにも記録されます。その結果、グローバルマークリングには訪れていたバッファーの系列が記録され、各バッファーではマークを設定した箇所が記録されます。グローバルマークリングの長さは、`global-mark-ring-max`で制御され、デフォルトは16です。

C-x C-SPC
pop-global-mark
コマンド`C-x C-SPC` (`pop-global-mark`)は、グローバルリングの最新のバッファー位置にジャンプします。これもリングを巡回するので、連続して`C-x
C-SPC`を使うことにより、古いバッファーのマーク位置に移動します。

シフト選択
----------

shift-selection
シフトキーを押しながらカーソル移動コマンドをタイプすると、ポイントを移動する前の位置にマークをセットするので、リージョンが元のポイント位置から新しいポイント位置に拡張されます。この機能はシフト選択(shift-selection)と呼ばれます。これは他のエディターでテキストを選択する方法と似ています。

シフト選択によるマークのセットは、これまでの説明とは少し異なる振る舞いをします。最初に、マークを非アクティブにする通常の方法(バッファーのテキストを変更したり`C-g`をタイプするなど)に加え、*シフトキーを押さない(unshifted)*カーソル移動コマンドでも、マークが非アクティブになります。次に、連続する*シフトキーを押した(shifted)*カーソル移動コマンドでは、マークの更新はされません。つまりシフトキーを押しながらカーソル移動コマンドを繰り返すと、リージョンは継続的に変更されます。

シフト選択は、シフトキーを押したカーソル移動キーが、別のコマンドにバインドされていない場合のみ動作します([Customization](#Customization)を参照してください)。たとえば`S-C-f`を他のコマンドにバインドしていると、`S-C-f`はシフト選択バージョンの`C-f` (`forward-char`)ではなく、バインドされたコマンドを実行します。

マウスコマンドによるマークのセットも、シフト選択によるマークのセットと同様です([Setting Mark](#Setting-Mark)を参照してください)。たとえばマウスをドラッグしてリージョンを指定すると、シフトキーを押したカーソル移動コマンドを使って、そのリージョンの拡張を続けることができます。どちらのケースも、シフトキーを押さないカーソル移動コマンドで、マークが非アクティブになります。

シフト選択をオフにするには、`shift-select-mode`を`nil`にセットしてください。これをセットしても、マウスコマンドによるマークのセッティングは無効になりません。

Transient Markモードを無効にする
--------------------------------

mode, Transient Mark
Transient Mark mode
highlighting region
region highlighting
Zmacs mode
transient-mark-mode
マークとリージョンのデフォルト動作では、マークをアクティブにセットすると、リージョンがハイライトされます。これはTransient Markモードと呼ばれます。これはデフォルトで有効になっているマイナーモードです。`M-x
transient-mark-mode`、または‘`Options`’メニューの‘`Active Region
Highlighting`’で切り替えることができます。オフにすることによりEmacsの操作モードは変更されます。

-   `C-SPC`や`C-x
    C-x`のようなコマンドでマークをセットしても、リージョンはハイライトされません。そのためマークがどこにあるか見分けることができないので、覚えている必要があります。

    マークをセットしたらどこにセットしたか忘れる前にすぐ使うというのが、この問題にたいする通常の解決策です。ポイントとマークの位置を交換する`C-x
    C-x`で、マークがどこかチェックすることもできます。

-   通常マークがアクティブのときリージョンにたいして処理を行ういくつかのコマンドは、そのような振る舞いをしなくなります。たとえば普通`M-%` (`query-replace`)は、マークがアクティブのときはリージョンにたいして置換を行います。Transient Markがオフだと、常にポイントからバッファーの最後までを処理します。このような方法で動作するコマンドは、コマンド自身のドキュメントにより識別できます。

enabling Transient Mark mode temporarily
Transient Markモードがオフのときは、`C-SPC C-SPC`または`C-u C-x
C-x`を使って一時的にアクティブにすることができます。

`C-SPC C-SPC`  
C-SPC C-SPC, enabling Transient Mark mode temporarily

ポイント位置にマークをセット(普通の`C-SPC`と同様)して、マークが非アクティブになるまでの間、1度だけTransient Markモードを有効にします(実際にはこれは独立したコマンドではなく`C-SPC`コマンドを2回行っています)。

`C-u C-x C-x`  
C-u C-x C-x

ポイントとマークを交換してからマークをアクティブにして、次にマークが非アクティブになるまでの間、Transient Markモードを一時的に有効にします(これはプレフィクス引数を指定した`C-x C-x` (`exchange-point-and-mark`)コマンドです)。

これらのコマンドはマークをセットまたはアクティブにして、マークが非アクティブになるまでの間Transient Markモードを有効にします。これらを使う1つの理由は、いくつかのコマンドはTransient Markモードがオフのとき、リージョンにたいしてではなくバッファー全体を処理するからです。Transient Markモードを一時的に有効にできれば、これらのコマンドをリージョンにたいして処理させることができます。

リージョンをマウス([Setting Mark](#Setting-Mark)を参照してください)、またはシフト選択([Shift Selection](#Shift-Selection)を参照してください)で指定したときも、一時的にTransient Markモードが有効になり、リージョンがハイライトされます。

テキストのkillと移動
====================

Emacsでkillとはテキストを消去して、killリングにコピーすることを意味します。yankとは、killリングからテキストを取り出して、バッファーに戻すことを意味します(“cut(カット、切り取り)”と“paste(ペースト、貼り付け)”という用語を使うアプリケーションもあります)。これはテキストブロックのセットが、循環的にアクセスできるリングに格納されているイメージから、killリングと名付けられました。[Kill Ring](#Kill-Ring)を参照してください。

killとyankは、Emacsでテキストを移動したりコピーするための、もっとも一般的な方法です。これは用途が広いコマンドです。なぜなら、多くの異なる種類の構文単位をkillするためのコマンドが存在するからです。

削除とkill
----------

killing text
cutting text
deletion
バッファーからテキストを消去するコマンドの多くは、それをkillリング([Kill Ring](#Kill-Ring)を参照)に保存します。これらはkillコマンドとして知られており、通常名前に‘`kill`’が含まれます(例 `kill-line`)。killリングには、最近killしたものが、1つだけではなくいくつか格納されているので、killはとても安全な操作と言えます。なぜなら、以前にkillしたテキストが失われる心配をする必要がないからです。killリングは、すべてのバッファーで共有されているので、あるバッファーでkillしたテキストを、別のバッファーにyankすることができます。

`C-/` (`undo`)を使うと、killコマンドはアンドゥ([Undo](#Undo)を参照してください)されるので、killしたテキストはバッファーに戻されますが、killリングからは削除されません。

グラフィカルなディスプレーでは、テキストをkillすると、それはシステムのクリップボードにもコピーされます。 [Cut and Paste](#Cut-and-Paste)を参照してください。

テキストを消去してkillリングに保存しないコマンドは、削除(delete)コマンドとして知られており、名前に‘`delete`’が含まれています。これらは`C-d` (`delete-char`)やDEL (`delete-backward-char`)のように、一度に1文字削除するものや、スペースや改行だけを削除するものが含まれます。重要なデータの有意な量を消去するコマンドには、一般的にkill操作が用いられます。

killとyankでマウスを使うこともできます。[Cut and Paste](#Cut-and-Paste)を参照してください。

### 削除

delete-backward-char
delete-char
削除とは、テキストを消去してkillリングに保存しないという意味です。テキストを削除するたいていのEmacsコマンドは、1文字または空白文字しか消去しません。

`DEL`; `BACKSPACE`  
前の文字を削除します。リージョンがアクティブのときは、リージョンのテキストを削除します(`delete-backward-char`)。

`Delete`  
次の文字を削除します。リージョンがアクティブのときは、リージョンのテキストを削除します(`delete-forward-char`)。

`C-d`  
次の文字を削除します(`delete-char`)。

`M-\`  
ポイントの周囲のスペースとタブを削除します(`delete-horizontal-space`)。

`M-SPC`  
スペースを1つ残して、ポイントの周囲のスペースとタブを削除します(`just-one-space`)。

`C-x C-o`  
現在行の周囲の空行を削除します(`delete-blank-lines`)。

`M-^`  
行間にある改行をインデントと共に削除して2行を1行にします(`delete-indentation`)。

基本的な削除コマンドDEL (`delete-backward-char`)、delete (`delete-forward-char`)、`C-d` (`delete-char`)については既に説明しました。[Erasing](#Erasing)を参照してください。数引数を指定すると、指定した数の文字を削除します。リージョンがアクティブのとき、数引数に1を指定するか省略した場合、DELとdeleteは、リージョンのすべてのテキストを削除します。

M-\\
delete-horizontal-space
M-SPC
just-one-space
cycle-spacing
他の削除コマンドは、空白文字(スペース、タブ、改行)だけを削除するものです。`M-\` (`delete-horizontal-space`)は、ポイントの前後にあるすべてのスペースとタブを削除します。プレフィクス引数を指定すると、ポイントの前にあるスペースとタブだけを削除します。`M-SPC` (`just-one-space`)も同様ですが、前にスペースが何個あるかに関係なく、ポイントの前に1つのスペースを残します。数引数nを指定すると、nが正のときはポイントの前に、n個のスペースを残します。nが負の場合は、スペースとタブに加えて改行も削除し、ポイントの前に-n個のスペースを残します。コマンド`cycle-spacing`は、`just-one-space`のようなコマンドで、よりフレキシブルな動作をします。これは連続で呼び出すと異なる処理を行います。1番目の呼び出しでは`just-one-space`と同様の処理をし、2番目の呼び出しではすべての空白文字を削除し、3番目の呼び出しでは元の空白文字を復元します。

`C-x C-o` (`delete-blank-lines`)は、現在行の下にあるすべての空行を削除します。現在行が空行のときは、現在行の上にあるすべての空行も削除します(空行を1つ、つまり現在行は残します)。単独の空行で実行するとその行を削除します。

`M-^` (`delete-indentation`)は、改行と周囲のスペース(通常1つのスペースを残す)を削除することにより、現在行とその上の行を結合します。[M-^](#Indentation)を参照してください。

delete-duplicate-lines
コマンド`delete-duplicate-lines`は、リージョン内の重複した行を検索して、それぞれ1行を残して削除します。通常は重複した行の最初の行を残しますが、プレフィクス引数`C-u`を指定すると、最後の行を残します。プレフィクス引数`C-u
C-u`を指定すると、隣接した重複行だけを検索します。これは行がソート済みのとき効果的です。プレフィクス引数`C-u C-u
C-u`を指定すると、連続する空行は残します。

### 行のkill

`C-k`  
行の残り、または1行以上をkillします(`kill-line`)。

`C-S-backspace`  
1度に行全体を削除します(`kill-whole-line`)。

C-k
kill-line
もっとも簡単なkillコマンドは、`C-k` (`kill-line`)です。これを行末で使うと、その行を終端している改行をkillして、現在行と次の行を継げます(空行なら削除します)。そうでない場合、`C-k`はポイントから行末までを削除します。ポイントの元の位置が行頭の場合は、空行が残ります。

どちらのケースを適用するか決める際には、行末のスペースとタブは無視されます。ポイントが行の一番最後の非空白文字の後にあるとき、`C-k`は改行をkillすることに注意してください。空でない行全体をkillするときは、行頭で`C-k`を2回タイプしてください。

このコンテキストで“行”とは、スクリーン行ではなく論理行を意味します([Continuation Lines](#Continuation-Lines)を参照してください)。

`C-k`に正の数値nを与えると、n行とそれに続く改行をkillします(現在行のポイントの前にあるテキストはkillされません)。負の引数−nを与えると、現在行のポイントの前にあるテキストと、前のn行をkillします。`C-k`に0を指定すると、現在行のポイントの前にあるテキストをkillします。

kill-whole-line
変数`kill-whole-line`が非`nil`のときは、行頭での`C-k`により行末の改行も含めて行全体がkillされます。この変数は通常`nil`です。

C-S-backspace
kill-whole-line
`C-S-backspace` (`kill-whole-line`)は行中のポイントの位置に関わらず、改行を含めた行全体をkillします。キーシーケンス`C-S-backspace`をタイプできないテキスト端末がたくさんあることに注意してください。

### その他のkillコマンド

`C-w`  
リージョンをkillします(`kill-region`)。

`M-w`  
リージョンをkillリングにコピーします(`kill-ring-save`)。

`M-d`  
次の単語をkillします(`kill-word`)。[Words](#Words)を参照してください。

`M-DEL`  
後方に1単語killします(`backward-kill-word`)。

`C-x DEL`  
センテンスの先頭までを後方にkillします(`backward-kill-sentence`)。[Sentences](#Sentences)を参照してください。

`M-k`  
文の末尾までをkillします(`kill-sentence`)。

`C-M-k`  
後に続く対応のとれた式(balanced expressions)をkillします(`kill-sexp`)。[Expressions](#Expressions)を参照してください。

`M-z char`  
次のcharまでをkillします(`zap-to-char`)。

C-w
kill-region
M-w
kill-ring-save
一般によく使われるkillコマンドは`C-w` (`kill-region`)で、これはリージョンのテキストをkillします([Mark](#Mark)を参照してください)。同様に`M-w` (`kill-ring-save`)は、バッファーからテキストを消去せずに、リージョンのテキストをkillリングにコピーします。`C-w`または`M-w`をタイプしたとき、マークが非アクティブの場合、これらのコマンドはポイントと最後にセットしたマークの間にあるテキストにたいして処理を行います([Using Region](#Using-Region)を参照してください)。

Emacsは特定の構文単位にたいするkillコマンドを提供します。単語(words)にたいしては`M-DEL`と`M-d`([Words](#Words)を参照してください)、対応のとれた式(balanced expressions)にたいしては`C-M-k`([Expressions](#Expressions)を参照してください)、センテンス(sentences: 文)にたいしては`C-x DEL``M-k`([Sentences](#Sentences)を参照してください)です。

M-z
zap-to-char
コマンド`M-z` (`zap-to-char`)は、killと検索が組み合わされています。これは文字を読み取り、ポイントからバッファー内の次にその文字が現れる場所までをkillします。数引数は繰り返し回数です。負の引数の場合は後方に検索することを意味し、ポイントの前のテキストをkillします。

### killのオプション

kill-read-only-ok
read-only text, killing
いくつかの特別なバッファーは、読み取り専用(read-only)のテキストを含んでいて、それらは変更できないのでkillもできません。killコマンドは読み取り専用のバッファーにたいして特別な動作をします。バッファーから実際にテキストを削除せずに、killリングにコピーします。通常はビープ音をならし、その旨のエラーメッセージを表示します。しかし変数`kill-read-only-ok`を非`nil`にセットすると、なぜテキストが消去されないのかをエコーエリアにメッセージ表示します。

kill-do-not-save-duplicates
変数`kill-do-not-save-duplicates`を非`nil`に変更すると、同じものにたいするkillは重複なくkillリングの1つのエントリーとなります。

yank
----

moving text
copying text
kill ring
yanking
pasting
yankするとは、以前killしたテキストを再び挿入するという意味です。テキストを移動またはコピーする通常の方法は、それをkillしてからどこかにyankする方法です。

`C-y`  
最後にkillしたものをポイント位置にyankします(`yank`)。

`M-y`  
yankしたテキストを、それより前にkillしたテキストに置き換えます(`yank-pop`)。[Earlier Kills](#Earlier-Kills)を参照してください。

`C-M-w`  
次のコマンドがkillコマンドのときは、killしたものを、以前にkillしたものに追加します(`append-next-kill`)。[Appending Kills](#Appending-Kills)を参照してください。

C-y
yank
基本的なyankコマンドは、`C-y` (`yank`)です。これはもっとも最近killされたものを挿入し、カーソルを挿入されたテキストの最後に移動します。また挿入されたテキストの先頭にマークをセットして、それを非アクティブにします。これにより`C-u
C-SPC`で簡単にその位置にジャンプできます([Mark Ring](#Mark-Ring)を参照してください)。

`C-u
C-y`のようにプレフィクス引数を指定すると、カーソルを挿入されたテキストの前に移動して、マークをテキストの最後にセットします。他のプレフィクス引数は、何回前のkillかを指定します。たとえば`C-u
4 C-y`は、もっとも最近killされたものから4番目に古いものを挿入します。

グラフィカルなディスプレーでは、`C-y`はまず最後にEmacsがkillした後に、他のアプリケーションがシステムのクリップボードに、何らかのテキストをコピーしていないか調べます。もしコピーしていたなら、かわりにクリップボードのテキストを挿入します。このようにEmacsは効果的に“カット(cut)”や“コピー(copy)”などの、他のアプリケーションで処理されたクリップボード操作を、Emacsのkillのように扱います(ただしkillリングには記録されません)。詳細については、[Cut and Paste](#Cut-and-Paste)を参照してください。

### killリング

killリング(kill ring)とは、以前にkillされたテキストブロックからなるリストです。すべてのバッファーにたいして、killリングは1つしかないので、あるバッファーでkillしたテキストを、他のバッファーにyankすることができます。これはバッファーから他のバッファーへテキストを移動する、通常の方法です(他の方法もいくつかあります。たとえばテキストをレジスターに格納することもできます。[Registers](#Registers)を参照してください。テキストを移動する他の方法については、[Accumulating Text](#Accumulating-Text)を参照してください)。

kill-ring-max
killリングのエントリーの最大数は、変数`kill-ring-max`で制御されます。デフォルトは60です。エントリー数が制限に達しているとき新たにkillすると、Emacsはkillリングの一番古いエントリーを削除して空きを作ります。

kill-ring
killリングの実際の内容は、`kill-ring`という名前の変数に格納されています。killリングのエントリーの内容は、`C-h
v kill-ring`で見ることができます。

### 過去にkillしたテキストをyankする

yanking previous kills
[Yanking](#Yanking)で説明したように、`C-y`に数引数を指定して、最後にkillされたものではないテキストをyankできます。これはkillリングのどのエントリーが欲しいか覚えているとき便利です。もし覚えていないときは、`M-y` (`yank-pop`)コマンドを使って、候補を探すことができます。

M-y
yank-pop
もし前のコマンドがyankコマンドのとき、`M-y`はyankされたテキストを、1つ前にkillされたテキストで置き換えます。つまり2番目に新しいkillされたテキストを復元するには、最初に`C-y`で最後にkillされたテキストをyankし、次に`M-y`でその1回前にkillされたテキストで置き換えます。`M-y`は、`C-y`または他の`M-y`の後しか使えません。

killリングのエントリーを指す(ポイントする)、last yankポインターという概念で、`M-y`を理解できるでしょう。なにかをkillする度に、last yankポインターはリングの先頭に新たに作られたエントリーを指すように移動します。`C-y`は、last yankポインターが指すエントリーをyankします。`M-y`はlast yankポインターが違うエントリーを指すように移動して、バッファーのテキストをポインターが指すテキストに変更します。`M-y`コマンドを繰り返すことにより、リングの任意のエントリーにポインターを移動できるので、任意のエントリーをバッファーに取り込むことができます。やがてリングの最後に到達すると、次の`M-y`により再び最初のエントリーに戻ります。

`M-y`はリング内でlast yankポインターを移動させますが、リング内のエントリーの順番は変更しません。リングのエントリーは、常に最後にkillされたものを先頭に、記憶されているもので一番古いエントリーへと並んでいます。

last-yankポインターを何回進めるかを、`M-y`に数引数で指定できます。負の引数はリングの先頭に向かってポインターを移動させます。リングの先頭では一番古いエントリーに戻り、そこから先頭へと移動します。

望むテキストを見つけてバッファーに取り込んだら、`M-y`コマンドを止めればそのテキストはそこに残ります。このテキストはkillリングのエントリーの単なるコピーなので、それを編集してもリングの中のエントリーは変更されません。新しく何かをkillしない限り、last-yankポインターは同じ位置に留まるので、`C-y`でそのテキストの別のコピーをyankできます。

`C-y`に数引数を指定するときも、yankするエントリーにlast-yankポインターをセットします。

### killしたテキストの追加

appending kills in the ring
通常はkillコマンドを実行するごとに、新しいエントリーがkillリングにpushされます。しかし2回以上の連続するkillコマンドにより、killされたテキストを1つのエントリーとしてまとめ、すべてのテキストを1単位として、あたかもそれがkillされたかのように、1回の`C-y`でyankできます。

つまりテキストを1つの単位としてyankしたいとき、そのテキストすべてを1回でkillする必要はありません。すべてがkillされるまで行から行、単語から単語へとkillを続け、それを一度に取得することができます。

ポイントから前方にkillするコマンドは、直前にkillされたテキストの最後に追加します。ポイントから後方にkillするコマンドは、テキストの先頭に追加します。この方法により前方と後方を併用した連続するkillコマンドは、すべてのkillされたテキストを再配置しなくてもよいように、1つのエントリーにまとめます。数引数を指定してもkillの連続性は途切れません。たとえば以下のようなテキストを含むバッファーがあるとしましょう:

    This is a line ★of sample text.

ポイントの位置は★で示された場所です。`M-d M-DEL M-d
M-DEL`とタイプして、前方と後方へのkillを交互に行うと、最後にkillリングには‘`a line of
sample`’という1つのエントリー、バッファーには‘`This is  text.`’が残ります(‘`is`’と‘`text`’の間には2つのスペースがあることに注意してください。これは`M-SPC`または`M-q`で取り除くことができます)。

同じテキストをkillする別の方法は、`M-b M-b`で単語2つ後方に移動してから、`C-u
M-d`で前方の単語4つをkillする方法です。これはバッファーとkillリングに、正確に同じ結果をもたらします。`M-f M-f C-u
M-DEL`で後方にkillしても結果は同じです。killリングのエントリーは、常にバッファーからkillされる前と同じ順番になります。

C-M-w
append-next-kill
killコマンドと最後のキルコマンドの間に、(単なる数引数ではない)他のコマンドが入ると、killリングには新たなエントリーが作られます。しかし、あらかじめ`C-M-w` (`append-next-kill`)とタイプすることにより、最後にkillされたテキストに追加するように強制できます。`C-M-w`は、後に続くコマンドがkillコマンドであれば、killしたテキストを前にkillしたテキストに付け加えるよう指示します。この方法でも、前方にkillするコマンドの場合は、前にkillされたテキストの最後に追加され、後方にkillするコマンドの場合は、先頭に追加されます。この方法により、1ヶ所にyankするために離れた場所にあるいくつかのテキスト断片を、killして集めることができます。

`M-w` (`kill-ring-save`)の後のkillコマンドは、`M-w`でkillリングにコピーされたテキストへの追加はしません。

グラフィカルなディスプレーでのカットアンドペースト
--------------------------------------------------

cut
copy
paste
ほとんどのグラフィカルなデスクトップ環境では、異なるアプリケーション間のデータ転送(通常はテキスト)に、クリップボード(clipboard)と呼ばれるシステム機能を使います。Xでは他にプライマリー選択(primary selection)とセカンダリー選択(secondary selection)という、同様の機能が利用可能です。Emacsをグラフィカルなディスプレーで実行している場合、killとyankコマンドはこれらの機能に統合されているので、Emacsと他のグラフィカルアプリケーション間で、簡単にテキストを転送できます。

デフォルトでは、Emacsはプログラム間テキスト転送のコーディングシステムとして、UTF-8を使います。もしコピーしたテキストが期待したものでない場合、`C-x
RET x`または`C-x RET
X`とタイプして、他のコーディングシステムを指定できます。`x-select-request-type`をカスタマイズして、異なるデータタイプを要求することもできます。[Communication Coding](#Communication-Coding)を参照してください。

### クリップボードを使う

clipboard
クリップボード(clipboard)とは、ほとんどのグラフィカルなアプリケーションが、“カットアンドペースト”のために使う機能です。もしクリップボードが存在する場合、Emacsのkillおよびyankコマンドもそれを使います。

何らかのテキストを、`C-w` (`kill-region`)のようなコマンドでkillしたり、`M-w` (`kill-ring-save`)のようなコマンドでkillリングにコピーしたとき、そのテキストはクリップボードにも転送されます。

save-interprogram-paste-before-kill
Emacsのkillコマンドがテキストをクリップボードに転送すると、通常クリップボードの既存の内容は失われます。オプションとして、`save-interprogram-paste-before-kill`を`t`に変更できます。これにより、Emacsは古いクリップボードのデータが失われることを防ぐために、最初にクリップボードのデータをkillリングに保存します。これにはデータが大きくなると、メモリー消費が増えるというリスクがあります。

`C-y` (`yank`)のようなyankコマンドもクリップボードを使います。他のアプリケーションがクリップボードを“所有”する場合(たとえばEmacsで最後にkillコマンドを実行した後に、他のアプリケーションでテキストをカットまたはコピーした場合)、Emacsはkillリングではなくクリップボードからyankします。

yank-pop-change-selection
通常killリングを`M-y` (`yank-pop`)で巡回することでは、クリップボードは変更されません。しかし`yank-pop-change-selection`を`t`に変更すると、`M-y`は新しいyankをクリップボードに保存します。

select-enable-clipboard
killおよびyankコマンドがクリップボードにアクセスしないようにするには、変数`select-enable-clipboard`を`nil`に変更してください。

clipboard manager
x-select-enable-clipboard-manager
多くのXデスクトップ環境は、クリップボードマネージャー(clipboard manager)と呼ばれる機能をサポートします。もしEmacsがクリップボードのデータの現在の“持ち主”のときにEmacsを終了し、そのときクリップボードマネージャーが実行されていると、Emacsはクリップボードのデータをクリップボードマネージャーに転送するのでデータは失われません。ある状況において、これはEmacsが終了するが遅くなる原因となります。Emacsがクリップボードマネージャーにデータを転送しないようにするには、変数`x-select-enable-clipboard-manager`を`nil`に変更してください。

通常、クリップボードを通じて渡されるNULバイトを含む文字列は切り詰められるため、Emacsはシステムのクリップボードに転送する前に、そのような文字を“\\\\0”に置き換えます。

select-enable-primary
clipboard-kill-region
clipboard-kill-ring-save
clipboard-yank
Emacs 24以前は、killおよびyankコマンドは、クリップボードではなくプライマリー選択([Primary Selection](#Primary-Selection)を参照してください)を使っていました。もしこのほうがよいなら、`select-enable-clipboard`を`nil`、`select-enable-primary`を`t`、`mouse-drag-copy-region`を`t`に変更してください。この場合は、次のコマンドを使って、クリップボードに明示的にアクセスできます。リージョンをkillしてクリップボードに保存するには`clipboard-kill-region`、リージョンをkillリングにコピーするとともにクリップボードに保存するには`clipboard-kill-ring-save`、クリップボードの内容をポイント位置にyankするには`clipboard-yank`です。

### 他のウィンドウアプリケーションにたいするカットアンドペースト

X cutting and pasting
X selection
primary selection
selection, primary
Xウィンドウシステム下では、プライマリー選択(primary selection)に、Xアプリケーションで最後に選択されたテキスト(通常はマウスのドラッグで選択される)が存在します。一般的に、このテキストは他のXアプリケーションに`mouse-2`をクリックして挿入することができます。プライマリー選択はクリップボードとは別のものです。プライマリー選択の内容は、より脆弱です。なぜなら、クリップボードは明示的なカットまたはコピーだけにより上書きされるのにくらべ、プライマリー選択はマウスでテキストが選択される度に上書きされるからです。

Xの下では、リージョンがアクティブ([Mark](#Mark)を参照してください)になればいつでも、リージョンのテキストはプライマリー選択に保存されます。これは、そのリージョンの選択がマウスでドラッグやクリック([Mouse Commands](#Mouse-Commands)を参照してください)されたのか、キーボードコマンド(たとえば`C-SPC`をタイプしてからポイントを移動したなど。[Setting Mark](#Setting-Mark)を参照してください)なのかによらず適用されます。

select-active-regions
変数`select-active-regions`を`only`に変更すると、Emacsは一時的にアクティブになったリージョン(たとえばマウスやシフト選択など。[Shift Selection](#Shift-Selection)を参照してください)だけをプライマリー選択に保存します。`select-active-regions`を`nil`に変更すると、Emacsはアクティブなリージョンをプライマリー選択に保存しません。

プライマリー選択をEmacsのバッファーに挿入するには、挿入したい場所で`mouse-2` (`mouse-yank-primary`)をクリックします。[Mouse Commands](#Mouse-Commands)を参照してください。

MS-Windows, and primary selection
MS-Windowsはプライマリー選択を提供しませんが、Emacsは単一のEmacsセッション内で選択されたテキストを内部に格納することにより、これをエミュレートします。したがってWindowsでも、プライマリー選択に関するすべての機能とコマンドは、Xと同様に機能します。しかしこれは同一セッションにおけるカットやペーストなどの場合で、Emacsセッションと他のアプリケーション間では機能しません。

### セカンダリー選択

secondary selection
プライマリー選択に加えて、Xウィンドウシステムはセカンダリー選択(secondary selection)として知られる、同様な第2の機能を提供します。最近ではセカンダリー選択を使うXアプリケーションの数は多くありませんが、以下のEmacsコマンドによりアクセスできます:

`M-Drag-mouse-1`  
ボタンを押した場所からボタンを話した場所までを、セカンダリー選択としてセットします(`mouse-set-secondary`)。ドラッグして選択されたテキストは、フェイス`secondary-selection`を使ってハイライトされます。ウィンドウの上端または下端を越えてマウスをドラッグすると、`mouse-set-region`と同様にウィンドウは自動的にスクロールします([Mouse Commands](#Mouse-Commands)を参照してください)。

このコマンドはkillリングを変更しません。

mouse-start-secondary

M-mouse-1

`M-mouse-1`  
セカンダリー選択の始点をセットします(`mouse-start-secondary`)。

mouse-secondary-save-then-kill

M-mouse-3

`M-mouse-3`  
`M-mouse-1`で指定された位置から、クリックされた点を終点とするセカンダリー選択をセットします(`mouse-secondary-save-then-kill`)。これは選択されたテキストをkillリングにも保存します。同じ場所での2回目の`M-mouse-3`は、作成されたセカンダリー選択をkillします。

mouse-yank-secondary

M-mouse-2

`M-mouse-2`  
クリックした場所にセカンダリー選択を挿入し、ポイントをyankしたテキストの最後に配します(`mouse-yank-secondary`)。

`Mouse-1`と同様、`M-mouse-1`のダブルクリックで単語、トリプルクリックで行を処理します。

`mouse-yank-at-point`が非`nil`の場合、`M-mouse-2`はポイント位置にyankします。どこをクリックしたか、さらにはフレームのどのウィンドウをクリックしたかは関係ありません。[Mouse Commands](#Mouse-Commands)を参照してください。

テキストの追加
--------------

append-to-buffer
prepend-to-buffer
copy-to-buffer
append-to-file
accumulating scattered text
テキストのコピーや移動は、それをkillしてyankすることにより通常行います。しかし多くの箇所にあるテキストブロックをコピーしたり、たくさんのテキストの断片を1ヶ所にコピーする便利な方法があります。ここではテキストの断片を、バッファーやファイルに追加するコマンドを説明します。

`M-x append-to-buffer`  
リージョンを指定したバッファーの内容の後に追加(append)します。

`M-x prepend-to-buffer`  
リージョンを指定したバッファーの内容の前に追加(prepend)します。

`M-x copy-to-buffer`  
リージョンを指定したバッファーにコピーして、バッファーの古い内容は削除されます。

`M-x insert-buffer`  
指定したバッファーの内容を、現在のバッファーのポイント位置に挿入します。

`M-x append-to-file`  
リージョンを指定したファイルの内容の最後に追加します。

テキストをバッファーに追加するには、`M-x
append-to-buffer`を使います。これはバッファー名を読み取り、リージョンのコピーを指定したバッファーに挿入します。存在しないバッファーを指定すると、`append-to-buffer`はそのバッファーを作成します。テキストは、そのバッファーのポイント位置に挿入されます。バッファーを編集用に使っていると、コピーされたテキストはその時ポイントがあった位置に挿入されます。

バッファーのポイントは、コピーされたテキストの最後に残ります。連続して`append-to-buffer`を使うと、テキストは指定したバッファーにコピーした順番で追加されていきます。厳密に言うと`append-to-buffer`は既存のバッファーのテキストにたいして、常に追加をする訳ではありません。これはポイントがバッファーの最後にあるときに追加をします。しかしバッファーを変更するのに`append-to-buffer`しか使わない場合、ポイントは常にバッファーの最後に位置することになります。

`M-x
prepend-to-buffer`も`append-to-buffer`と同様ですが、他のバッファーのポイントはコピーされたテキストの前に置かれるので、連続してこのコマンドを使用すると、テキストは逆の順番に追加されます。`M-x
copy-to-buffer`も同様ですが、他のバッファーの既存の内容は削除されるので、バッファーの内容は新しくコピーされたテキストだけになります。

コマンド`M-x
insert-buffer`は、追加するテキストを他のバッファーから取得するために使われます。これはバッファー名の入力を求め、そのバッファーのすべてのテキストのコピーを、現在のバッファーのポイント位置に挿入します。ポイントは挿入されたテキストの先頭になります。挿入されたテキストの最後の位置もマークリングに追加されます。マークは非アクティブになります。バッファーに関する背景情報は、[Buffers](#Buffers)を参照してください。

バッファーのテキストを追加するかわりに、`M-x
append-to-file`でテキストを直接ファイルに追加できます。これはファイル名の入力を求め、リージョンのテキストを指定されたファイルの最後に追加します。ディスク上のファイルはすぐに変更されます。

`append-to-file`は、Emacsがvisitして*いない*ファイルだけに使うべきです。Emacsで編集中のファイルにたいして使用すると、それはEmacsの背後でファイルが変更されることになるため、編集内容が失われる可能性があります。

テキストの移動に関する他の方法はレジスターに格納する方法です。[Registers](#Registers)を参照してください。

矩形領域(Rectangles)
--------------------

rectangle
columns (and rectangles)
killing rectangular areas of text
矩形領域(rectangle)コマンドは、テキストの矩形領域を操作します。矩形領域のテキストとは、特定の行範囲内にある、特定の2つの列の間にある文字すべての文字です。Emacsには矩形領域にたいしてkill、yank、クリアー、スペースやテキストでフィル、削除を行うコマンドがあります。矩形領域コマンドは、複数列のテキストを操作したり、テキストをそのように変更したり戻したりする場合に便利です。

mark rectangle
コマンドで操作する矩形領域を指定するには、一方の角にマークを設定し、その対角にポイントを置きます。このように設定した矩形領域を矩形リージョン(region-rectangle)と呼びます。ポイントとマークが同じ列の場合、矩形リージョンは空になります。ポイントとマークが同じ行の場合、矩形リージョンの高さは1行になります。

矩形リージョンは、リージョンの制御と大体同じ方法で制御できます。しかし、ポイントとマークの組がリージョンとして解釈されるのか、あるいは矩形領域として解釈されるかは、それらを使うコマンドに依存することに注意してください。

`C-x r k`  
矩形リージョンをkillして、最後にkillされた矩形領域として、その内容を保存します(`kill-rectangle`)。

`C-x r M-w`  
矩形リージョンのテキストを、最後にkillされた矩形領域として保存します(`copy-rectangle-as-kill`)。

`C-x r d`  
矩形リージョンのテキストを削除します(`delete-rectangle`)。

`C-x r y`  
最後にkillされた矩形領域の左上隅がポイント位置になるようにyankします(`yank-rectangle`)。

`C-x r o`  
矩形領域にスペースを挿入します(`open-rectangle`)。これにより矩形リージョンの以前の内容は右にずれます。

`C-x r N`  
矩形リージョンの左端に行番号を挿入します(`rectangle-number-lines`)。これにより矩形リージョンの以前の内容は右にずれます。

`C-x r c`  
矩形リージョンの内容をスペースに置き換えてクリアーします(`clear-rectangle`)。

`M-x delete-whitespace-rectangle`  
指定された矩形領域の各行で、矩形領域の左端の列から空白文字を削除します。

`C-x r t string RET`  
矩形領域の各行にたいして、内容をstringに置き換えます(`string-rectangle`)。

`M-x string-insert-rectangle RET string RET`  
矩形領域の各行にたいして、stringを挿入します。

`C-x SPC`  
Rectangle Markモードを切り替えます(`rectangle-mark-mode`)。このモードがアクティブのとき矩形領域はハイライトされ、拡大・縮小が可能になります。標準のkillおよびyankコマンドは、それにたいして操作を行います。

矩形領域の操作は2種類に分類できます。それは矩形領域を消去または挿入するものと、空の矩形領域を作るものです。

C-x r k
C-x r d
kill-rectangle
delete-rectangle
矩形領域のテキストを消去するには2つの方法があります。`C-x r d` (`delete-rectangle`)はテキストを無条件に削除します。`C-x r k` (`kill-rectangle`)はテキストを取り除いて、それを最後にkillされた矩形領域として保存します。両方とも矩形領域の各行の指定したテキストを消去するように、矩形リージョンを消去します。その行の後に続くテキストがある場合、削除による隙間を生めるために後方に移動されます。

矩形領域のkillは普通のkillとは異なります。矩形領域はkillリングには保存されず、一番最後にkillされた矩形領域だけを記録する、特別な場所に保存されます。矩形領域のyankは線形テキストのyankとは大きく異なるので、異なるyankコマンドが使われるからです。矩形領域にたいしてyankのpopは定義されていません。

C-x r M-w
copy-rectangle-as-kill
`C-x r M-w` (`copy-rectangle-as-kill`)は矩形領域用の`M-w`に相当します。これはバッファーからテキストを削除することなく、最後にkillされた矩形領域として、矩形領域を記録します。

C-x r y
yank-rectangle
killされた矩形領域をyankするには、`C-x r y` (`yank-rectangle`)とタイプします。矩形領域の最初の行はポイント位置に挿入されます。矩形領域の2行目はポイントの1行下の位置に挿入され、以下同様に挿入されていきます。影響を受ける行数は、保存された矩形領域の高さにより決定されます。

たとえば1列のリスト2つを2列のリストに変換できます。一方の1列リストを矩形領域としてkillしてもう一方の1列リストの隣にyankすればよいのです。

`C-x r r r`と`C-x r i
r`で、矩形領域をレジスターにコピーしたり取り出したりできます。[Rectangle Registers](#Rectangle-Registers)を参照してください。

C-x r o
open-rectangle
C-x r c
clear-rectangle
空の矩形領域を作るために使うことのできるコマンドが2つあります。`C-x r c` (`clear-rectangle`)は、矩形リージョンの既存のテキストを空白に置き換えます。`C-x r o` (`open-rectangle`)は空白の矩形領域を挿入します。

delete-whitespace-rectangle
`M-x
delete-whitespace-rectangle`は、指定した列を起点に水平方向の空白文字を削除します。これは矩形領域の各行に適用され、開始列は矩形領域の左端です。矩形領域の右端はこのコマンドに影響を及ぼしません。

C-x r N
rectangle
コマンド`C-x r N` (`rectangle-number-lines`)は、矩形領域の左端に行番号を挿入します。通常は矩形領域の最初の行を1として番号が開始されます。プレフィクス引数を指定すると、このコマンドは開始番号と、番号を出力する際の書式文字列(section “Formatting Strings” in The Emacs Lisp Reference Manualを参照してください)の入力を求めます。

C-x r t
string-rectangle
コマンド`C-x r t` (`string-rectangle`)は、矩形リージョンの各行を文字列で置き換えます。文字列の幅は矩形領域と同じ幅である必要はありません。矩形領域の後ろのテキストは、文字列の幅が少ないときは左に、文字列の幅が大きいときは右にシフトされます。

string-insert-rectangle
コマンド`M-x
string-insert-rectangle`は、`string-rectangle`と同様ですが、各行に文字列を挿入し、元の文字列は右にシフトされます。

rectangle-mark-mode
コマンド`C-x SPC` (`rectangle-mark-mode`)は、矩形リージョンをハイライトするか、標準のリージョンをハイライトするかを切り替えます(最初にリージョンをアクティブにする必要があります)。このモードが有効な場合、`C-f`、`C-n`などのコマンドは矩形領域に合ったやり方でリージョンのサイズを変更し、kill、yankは矩形領域を処理します。[Killing](#Killing)を参照してください。このモードはリージョンがアクティブな間だけ持続します。

標準のリージョンとは異なり、バッファー終端を越えたり、TABのような伸長された空白スペースの中間のような、通常はポイントを置けない場所にも矩形リージョンのコーナーを置くことができます。

rectangle-exchange-point-and-mark
exchange-point-and-mark, in rectangle-mark-mode
C-x C-x, in rectangle-mark-mode
そのリージョンがrectangle-mark-modeにある場合、`C-x
C-x`は、矩形リージョンの4隅のコーナーを巡回する、コマンド`rectangle-exchange-point-and-mark`を実行します。これはマークされたテキストにたいする処理を呼び出す前に、矩形リージョンをのサイズを変更したい場合に便利です。

CUAバインド
-----------

cua-mode
cua-mode
CUA key bindings
cua-enable-cua-keys
コマンド`M-x cua-mode`は、多くのアプリケーションで使われている、CUA(Common User Access)互換のキーバンドをセットアップします。

CUAモードが有効な場合、`C-x`、`C-c`、`C-v`、`C-z`などのキーは、カット(kill)、コピー、ペースト(yank)、アンドウのコマンドを呼び出します。`C-x`と`C-c`によるカットとコピーは、リージョンがアクティブなときだけ処理されます。リージョンが非アクティブのときはプレフィクスキーとして動作するので、`C-x
C-c`のような標準のEmacsコマンドは正常に機能します。変数`mark-even-if-inactive`は`C-x`と`C-c`に影響を及ぼさないことに注意してください([Using Region](#Using-Region)を参照してください)。

マークがアクティブのときに`C-x
C-f`のようなEmacsコマンドを入力するには、`Shift`を押しながらプレフィクスキーを押す(例 `S-C-x
C-f`)か、プレフィクスキーを素早く2回タイプ(例 `C-x C-x C-f`)します。

CUAモードがEmacs標準のキーバインドをオーバーライドするのを無効にしつつ、以下で説明するそれ以外のCUAモードの機能は使う場合は、変数`cua-enable-cua-keys`に`nil`をセットしてください。

CUA モードはデフォルトでDelete-Selectionモード([Mouse Commands](#Mouse-Commands)を参照してください)を有効にするので、アクティブなリージョンがあるときテキストをタイプすると、そのテキストで置き換えられます。CUAモードでこれを無効にするには、変数`cua-delete-selection`を`nil`にセットしてください。

rectangle highlighting
CUAモードは矩形領域を明白にハイライトする、強化された矩形領域サポートを提供します。`C-RET`を使うことにより矩形領域の選択が開始され、移動コマンドを使って拡張したり、`C-x`と`C-c`で切り取りとコピーができます。RETにより、矩形領域の四隅に時計方向へカーソルを移動させるので、任意の方向に簡単に領域を拡張できます。タイプされた通常のテキストは、矩形領域の各行の左か右(カーソルのある側)に挿入されます。

この矩形領域サポートは、`cua-rectangle-mark-mode`コマンドを呼び出すことにより、CUAモードを有効にせずに使うこともできます。標準コマンド`rectangle-mark-mode`もあります。[Rectangles](#Rectangles)を参照してください。

CUAモードでは、テキストや矩形領域を簡単にレジスターに保存したり、取り出すことができます。これは1桁の数引数をkill、copy、yankコマンドに指定します。たとえば`C-1
C-c`はリージョンをレジスター`1`にコピーし、`C-2 C-v`はレジスター`2`の内容をyankします。

global mark
CUAモードは、バッファー間での簡単にテキストを移動したりコピーするためのグローバルマーク機能も提供します。`C-S-SPC`を使って、グローバルマークのオンとオフが切り替えられます。グローバルマークがオンのときは、killまたはコピーされたすべてのテキストは自動的にグローバルマークの位置に挿入され、タイプしたテキストも現在のカーソル位置ではなくグローバルマークに挿入されます。

たとえば複数のバッファーから単語をコピーして単語リストを作るには、単語リストを作るバッファーにグローバルマークをセットします。次にリストにしたい単語をマーク(`S-M-f`など)してから、`C-c`か`M-w`でリストにコピーします。そしてRETでリストにコピーされた単語の後ろに改行を挿入すればよいのです。

レジスター
==========

registers
Emacsのレジスター(registers)は、テキストや矩形領域、位置、その他、後で使うものを保存するための区画です。一度テキストや矩形領域をレジスターに保存すれば、それをバッファーに何度もコピーできます。一度場所をレジスターに保存すれば、何度でもその場所にジャンプして戻ることができます。

各レジスターは1文字からなる名前があり、ここではrと表記することにします。rには、英字(‘`a`’など)または数字(‘`1`’など)を使用できます。大文字小文字は区別されるので、レジスター‘`a`’とレジスター‘`A`’は同じではありません。たとえば‘`*`’や‘`C-d`’のような、非英数字にレジスターをセットすることもできます。‘`C-g`’と‘`ESC`’は対話的なコマンドを終了させるために予約済みなので、これらのキーにレジスターをセットすることはできないことに注意してください。

view-register
レジスターには位置、テキスト、矩形領域、数字、ウィンドウの設定、ファイル名が保存できますが、一度に保存できるのは1つです。レジスターに何か保存すると、他の何かをそのレジスターに保存するまで残ります。レジスターrに何が含まれているのか見るには。`M-x
view-register`を使います:

`M-x view-register RET r`  
レジスターrに何が含まれるかの説明を表示します。

register-preview-delay
preview of registers
レジスター名の入力を求めるコマンドはすべて、既存のレジスターを一覧するプレビュー(preview)ウィンドウを遅延表示します。遅延の長さは`register-preview-delay`でカスタマイズできます。遅延を無効にするには、`nil`をセットしてください。この場合、`C-h`かF1で、明示的にプレビューウィンドウを要求できます。

ブックマーク(Bookmarks)はファイルと位置を記録するので、ファイルを再び見るときは記録された位置から閲覧できます。ブックマークも本質的にレジスター同じなので、このチャプターに記載します。

レジスターに位置を保存する
--------------------------

saving position in a register
`C-x r SPC r`  
現在のバッファーのポイント位置をレジスターrに記録します(`point-to-register`)。

`C-x r j r`  
レジスターrに記録されたバッファーの位置にジャンプします(`jump-to-register`)。

C-x r SPC
point-to-register
`C-x r SPC` (`point-to-register`)と、それに続けて文字`r`をタイプすると、ポイント位置と現在のバッファーの両方をレジスターrも保存します。レジスターは他の何かが保存されるまでこの情報を保持します。

C-x r j
jump-to-register
コマンド`C-x r j
r`は、rに記録されたバッファーに切り替えて、記録された位置にポイントを移動します。レジスターの内容は変わらないので、保存した位置に何度でもジャンプできます。

`C-x r j`を使って保存した位置に移動するとき、保存されたバッファがkillされていた場合、`C-x r
j`は同じファイルをvisitしてバッファーを生成しようと試みます。もちろんこれはファイルをvisitしたバッファーだけの動作です。

レジスターにテキストを保存する
------------------------------

saving text in a register
同じテキストのコピーを何回も挿入したいとき、killリングからyankするのは不便です。なぜなら何かkillするたびに、そのエントリーはリングの下の方へ移動してしまうからです。代替として、テキストをレジスターに保存して、後で取り出す方法があります。

`C-x r s r`  
リージョンをレジスターrにコピーします(`copy-to-register`)。

`C-x r i r`  
レジスターrからテキストを挿入します(`insert-register`)。

`M-x append-to-register RET r`  
リージョンをレジスターrのテキストに追加します。

レジスターrの内容がテキストの場合、そのレジスターに追加するのに`C-x r +` (`increment-register`)も使用できます。レジスターrに数値が含まれている場合、コマンド`C-x r
+`は違う動作をすることに注意してください。[Number Registers](#Number-Registers)を参照してください。

`M-x prepend-to-register RET r`  
リージョンをレジスターrの先頭に追加します。

C-x r s
copy-to-register
`C-x r s
r`は、リージョンのテキストのコピーを、rという名前のレジスターに保存します。マークが非アクティブのとき、Emacsはまず最後にセットされたマークをアクティブにします。マークはこのコマンドの最後に非アクティブになります。[Mark](#Mark)を参照してください。同じコマンドにプレフィクス引数を指定した`C-u
C-x r s
r`は、テキストのコピーをレジスターrに保存してから、バッファーのテキストを削除します。これはリージョンのテキストを、レジスターに移動したと考えることができます。

append-to-register
prepend-to-register
`M-x append-to-register RET
r`は、リージョンのテキストのコピーを、rという名前のレジスターにすでに保存されているテキストに追加します。プレフィクス引数を指定した場合、レジスターに追加した後にリージョンを削除します。コマンド`prepend-to-register`も同様ですが、これはリージョンのテキストをレジスターのテキストの*最後*ではなく*先頭*に追加します。

register-separator
`append-to-register`と`prepend-to-register`を使ってテキストを集める場合、セパレーターを使って個々に集めたテキストを分割したい場合があります。そのようなときは`register-separator`を構成して、セパレーター文字列をそのレジスターに保存します。たとえばテキストを収集する過程で、個々のテキストを2つの改行で分けたい場合、以下の設定を使うことができます。

    (setq register-separator ?+)
    (set-register register-separator "\n\n")

C-x r i
insert-register
`C-x r i
r`は、レジスターrのテキストをバッファーに挿入します。通常はポイントをテキストの後に置き、非アクティブのマークをテキストの前にセットします。数引数を指定したときは、ポイントをテキストの前、マークをテキストの後にセットします。

レジスターに矩形領域を保存する
------------------------------

saving rectangle in a register
レジスターには線形のテキストだけでなく、矩形領域も保存できます。バッファーで矩形領域を指定する方法は、[Rectangles](#Rectangles)を参照してください。

`C-x r r r`  
矩形リージョンをレジスターrにコピーします(`copy-rectangle-to-register`)。数引数を指定するとコピー後に矩形リージョンを削除します。

`C-x r i r`  
レジスターrに矩形リージョンが保存されている場合、それを挿入します(`insert-register`)。

前に[Text Registers](#Text-Registers)でも説明した`C-x r i r` (`insert-register`)コマンドは、レジスターに矩形領域が保存されているときはテキストではなく矩形領域を挿入します。

レジスターにウィンドウ設定を保存する
------------------------------------

saving window configuration in a register
window-configuration-to-register
frameset-to-register
C-x r w
C-x r f
選択されたフレームのウィンドウの設定や、すべてのフレームのすべてのウィンドウの設定もレジスターに保存して、後で設定を復元することができます。ウィンドウの設定については、[Windows](#Windows)を参照してください。

`C-x r w r`  
選択されたフレームのウィンドウの設定を、レジスターrに保存します(`window-configuration-to-register`)。

`C-x r f r`  
すべてのフレームおよびフレームに含まれるすべてのウィンドウの状態を、レジスターrに保存します(`frameset-to-register`)。

`C-x r j
r`を使うと、ウィンドウまたはフレームの設定を復元できます。これはカーソル位置を復元するコマンドと同じです。フレームの設定を復元するとき、設定に含まれていないフレームは非表示になります。もしこれらのフレームを削除したいときは、かわりに`C-u
C-x r j r`を使います。

レジスターに数字を保存する
--------------------------

saving number in a register
数字をレジスターに保存して、その数字(10進)をバッファーに挿入したり、増加させるコマンドがあります。これらのコマンドはキーボードマクロで使うと便利です([Keyboard Macros](#Keyboard-Macros)を参照してください)。

`C-u number C-x r n r`  
C-x r n

number-to-register

numberをレジスターrに保存します(`number-to-register`)。

`C-u number C-x r + r`  
C-x r +

increment-register

rに数字が保存しているときは、レジスターの数字をnumberだけ増加させます。コマンド`C-x r +` (`increment-register`)は、rにテキストが保存されているときは異なる動作をすることに注意してください。[Text Registers](#Text-Registers)を参照してください。

`C-x r i r`  
レジスターrの数字をバッファーに挿入します。

`C-x r i`は、他のレジスターの内容をバッファーに挿入するコマンドと同じです。`C-x r
+`に数字の引数を与えない場合、レジスターの値は1増加します。`C-x r n`に数字の引数を与えない場合、レジスターには0が保存されます。

レジスターにファイル名を保存する
--------------------------------

saving file name in a register
特定の名前のファイルを頻繁にvisitする場合、その名前をレジスターにセットしておけば、より便利にファイルをvisitすることができます。以下はnameというファイルをレジスターrにセットするLispコードです:

    (set-register r '(file . name))

たとえば、

    (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

はレジスター‘`z`’にファイル名をセットします。

レジスターrに名前がセットされているファイルをvisitするには、`C-x r j
r`とタイプします。これはある位置にジャンプしたり、フレームの設定を復元するのと同じコマンドです。

キーボードマクロのレジスター
----------------------------

saving keyboard macro in a register
keyboard macros, in registers
C-x C-k x
kmacro-to-register
あるキーボードマクロ([Keyboard Macros](#Keyboard-Macros)を参照してください)を頻繁に実行する必要がある場合、それをレジスターにセットしたり保存することができればより便利でしょう([Save Keyboard Macro](#Save-Keyboard-Macro)を参照してください)。`C-x C-k x r` (`kmacro-to-register`)は、最後のキーボードマクロをレジスターrに保存します。

レジスターrのキーボードマクロを実行するには、`C-x r j
r`とタイプします(これはある位置にジャンプしたりフレームを復元するのと同じコマンドです)。

ブックマーク
------------

bookmarks
ブックマーク(Bookmarks)とは、ジャンプしたい位置を記録するレジスターのようなものです。レジスターとの違いは、長い名前をもつことができ、次のEmacsセッションに自動的に引き継がれることです。ブックマークの典型的な使い方は、さまざまなファイルのどこを読んでいたかを記録することです。

`C-x r m RET`  
visitしているファイルのポイント位置に、ブックマークをセットします。

`C-x r m bookmark RET`  
ポイント位置に、bookmarkという名前のブックマークをセットします(`bookmark-set`)。

`C-x r M bookmark RET`  
`C-x r m`と同様ですが、既存のブックマークを上書きしません。

`C-x r b bookmark RET`  
bookmarkという名前のブックマークにジャンプします(`bookmark-jump`)。

`C-x r l`  
すべてのブックマークを一覧します(`list-bookmarks`)。

`M-x bookmark-save`  
現在のすべてのブックマークの値を、デフォルトのブックマークファイルに保存します。

C-x r m
bookmark-set
C-x r b
bookmark-jump
visitしているファイル内のカレント位置を記録するには、コマンド`C-x r
m`を使用します。これは、ブックマーク名のデフォルトとしてファイル名を使います。ブックマークが指すファイルをもとにブックマークの名前を付ければ、`C-x
r b`で任意のファイルを再びvisitして、同時にブックマーク位置に移動するという操作を楽に行えます。

C-x r M
bookmark-set-no-overwrite
コマンド`C-x r M` (`bookmark-set-no-overwrite`)は`C-x r
m`と同じように機能しますが、指定されたブックマークがすでに存在する場合は、上書きするかわりにエラーをシグナルします。

C-x r l
list-bookmarks
すべてのブックマークのリストを別のバッファーに表示するには、`C-x r l` (`list-bookmarks`)とタイプします。そのバッファーに切り替えて、ブックマークの定義の編集やブックマークに注釈をつけることができます。ブックマークバッファーで`C-h
m`とタイプすれば、特別な編集コマンドに関する情報を見ることができます。

bookmark-save
Emacsを終了するとき、もしブックマークの値を変更していたら、Emacsはブックマークを保存します。`M-x
bookmark-save`コマンドで、いつでもブックマークを保存できます。ブックマークは`~/.emacs.d/bookmarks`というファイルに保存されます(古いバージョンのEmacsとの互換性を保つため、もし`~/.emacs.bmk`というファイルがあればそのファイルに保存します)。ブックマークコマンドは、デフォルトのブックマークファイルを自動的にロードします。この保存とロードにより、ブックマークの内容を次のEmacsセッションに引き継ぐことができるのです。

bookmark-save-flag
`bookmark-save-flag`に1をセットすると、ブックマークをセットするコマンドはブックマークの保存も行ないます。こうすることにより、Emacsがクラッシュしてもブックマークを失わずにすみます。この変数の値が数字の場合、それはブックマークを何回変更したら保存するという意味です。この変数に`nil`をセットすると、Emacsは明示的に`M-x
bookmark-save`を使ったときだけブックマークを保存します。

bookmark-default-file
変数`bookmark-default-file`には、ブックマークを保存するデフォルトのファイルを指定します。

bookmark-search-size
ブックマークの位置は、周囲のコンテキストとともに保存されるので、ファイルが少し変更されていても、`bookmark-jump`は正確な位置を見つけることができます。変数`bookmark-search-size`は、ブックマーク位置のコンテキストの前後何文字を記録するかを指定します。

以下はブックマークを処理する追加のコマンドです:

`M-x bookmark-load RET filename RET`  
bookmark-load

ブックマークのリストを含む、filenameという名前のファイルをロードします。このコマンドは`bookmark-write`と同様に、デフォルトのブックマークファイルに加えて、他のファイルのブックマークを使うことができます。

`M-x bookmark-write RET filename RET`  
bookmark-write

現在のすべてのブックマークをファイルfilenameに保存します。

`M-x bookmark-delete RET bookmark RET`  
bookmark-delete

bookmarkという名前のブックマークを削除します。

`M-x bookmark-insert-location RET bookmark RET`  
bookmark-insert-location

ブックマークbookmarkが指すファイル名をバッファーに挿入します。

`M-x bookmark-insert RET bookmark RET`  
bookmark-insert

ブックマークbookmarkが指すファイルの*内容*をバッファーに挿入します。

ディスプレーの制御
==================

ウィンドウに入りきらない大きなバッファーでは、Emacsはその一部しか表示できません。このチャプターでは、見たい部分のテキストを指定するコマンドや変数と、どのようにしてテキストが表示されるかを説明します。

スクロール
----------

scrolling
ウィンドウがバッファーのすべてのテキストを表示するには小さい場合、その一部だけが表示されます。スクロールコマンドは、バッファーで表示される部分を変更します。

前方(forward)または上(up)へのスクロールは、ウィンドウに表示される部分を先に進めます。これはウィンドウに表示されるバッファーのテキストを、上に移動させるのと同じです。後方(backward)または下(down)へのスクロールは、ウィンドウに表示される部分を前に戻します。これはウィンドウに表示されるバッファーのテキストを下に移動させます。

Emacsでのupとdownは、ウィンドウでテキストが移動する方向に基づいており、テキストにたいしてウィンドウが移動する方向では*ありません*。この用語は現在のscrolling upやscrolling downが広まる前に、Emacsで採用されました。そのためPageDownは、Emacs的には上(up)にスクロールするという、奇妙な結果となりました。

ウィンドウに表示されているバッファー部分には、常にポイントが含まれています。もしウィンドウの下端か上端を越えてポイントを移動させると、ポイントを画面に表示させるために自動的にスクロールが発生します([Auto Scrolling](#Auto-Scrolling)を参照してください)。以下のコマンドで明示的にスクロールができます:

`C-v`; `PageDown`; `next`  
ウィンドウのほぼ全画面分、前方にスクロールします(`scroll-up-command`)。

`M-v`; `PageUp`; `prior`  
後方にスクロールします(`scroll-down-command`)。

C-v
M-v
PageDown
PageUp
next
prior
scroll-up-command
scroll-down-command
`C-v` (`scroll-up-command`)は、ウィンドウ全体の高さに近い量、前方にスクロールします。これにより下端の2行が上端になるようスクロールして、それに続く表示されていなかった行を表示します。ポイントが上端より上になってしまう場合、ウィンドウの新たな上端の行に移動します。The PageDown(またはnext)は、`C-v`と同じです。

`M-v` (`scroll-down-command`)は、同様の方法で後方にスクロールします。PageUp(またはprior)は、`M-v`と同じです。

next-screen-context-lines
スクロールコマンドでオーバーラップして表示される行数は、変数`next-screen-context-lines`で制御され、デフォルトは2です。数引数nを与えたときは、n行スクロールします。Emacsはポイントを変更しないよう試みるので、テキストとポイントは一緒に上または下に動きます。`C-v`に負の引数を与えると、`M-v`のように反対方向へスクロールします。

scroll-error-top-bottom
デフォルトでは、ウィンドウがバッファーの先頭または最後に到達していて、これ以上スクロールできない場合、これらのコマンドは(beep音をならしたり画面をフラッシュして)エラーをシグナルします。変数`scroll-error-top-bottom`を`t`に変更すると、コマンドは可能な限り、つまりバッファーの先頭の文字または最後の文字にポイントを移動します。ポイントがすでにそこにあるときは、エラーをシグナルします。

scroll-preserve-screen-position
scroll-command
property
スクロールしたとき、ポイントが同じスクリーン位置に留まることを好むユーザーもいます。そうすれば同じスクリーンにスクロールして戻ったとき、ポイントが元の位置にあると便利だからです。この動作は変数`scroll-preserve-screen-position`を通じて利用可能です。変数の値が`t`のとき、スクロールコマンドによりポイントがウィンドウの外にでるような場合、Emacsはポイントを先頭行または最終行に移動させるのではなく、同じスクリーン位置にポイントを調整して、カーソルを維持します。その他の非`nil`値の場合、Emacsはスクロールコマンドによりポイントがウィンドウに残っている場合にも、この方法でポイントを調整します。この変数はこのセクションで説明するすべてのスクロールコマンド、同様にマウスホイールによるスクロール([Mouse Commands](#Mouse-Commands)を参照してください)に影響を与えます。一般的にいうと、この変数は`scroll-command`プロパティが非`nil`のコマンドに影響を及ぼします。section “Property Lists” in The Emacs Lisp Reference Manualを参照してください。

fast-but-imprecise-scrolling
ときどき、特に`C-v`や`M-v`のようなキーを押したままにすると、キーボードのオートリピートがアクティブになり、要求された高レートのスクロール要求にEmacsが対応できなくなるときがあります。そのような場合、表示は更新されず、かなり長時間の間、Emacsが応答しなくなる可能性があります。変数`fast-but-imprecise-scrolling`を非`nil`値にセットすることにより、この状況に対処できます。これはスクロールコマンドにフォント表示化([Font Lock](#Font-Lock)を参照してください)を行なわないように指示します。スクロールされるテキストは、それらがデフォルトフェイスをもつと仮定されなくなり、フォント表示化されなくなります。これにより、そのフェイスがすべて同じサイズのフォントを使用していない場合には、(たとえばオートリピートではない)1回のスクロールでも、Emacsが誤ったバッファー位置にスクロールするかもしれません。

scroll-up
scroll-down
scroll-up-line
scroll-down-line
コマンド`M-x scroll-up`および`M-x
scroll-down`は、`scroll-up-command`および`scroll-down-command`と同様に動作しますが、`scroll-error-top-bottom`を考慮しません。これらのコマンドは、Emacs 24以前ではスクロールアップおよびスクロールダウンのためのデフォルトでした。コマンド`M-x
scroll-up-line`および`M-x
scroll-down-line`は、現在のウィンドウを1行スクロールさせます。もしこれらのコマンドを使う場合は、それにキーバインドを割り当てたくなるでしょう([Init Rebinding](#Init-Rebinding)を参照してください)。

センタリング
------------

`C-l`  
選択されているウィンドウで、現在行が中央になるようスクロールします。連続して呼び出すと、次は現在行が上端になり、その次は現在行が下端に、という順番で循環します。画面の再描画が行われる可能性があります(`recenter-top-bottom`)。

`M-x recenter`  
選択されているウィンドウで、現在行が中央になるようにスクロールします。画面の再描画が行われる可能性があります。

`C-M-l`  
有用な情報が表示されるよう、発見的な手法でスクロールします(`reposition-window`)。

C-l
recenter-top-bottom
`C-l` (`recenter-top-bottom`)コマンドは、選択されたウィンドウにたいしてセンタリング(recenters)をします。これにより現在のスクリーン行がウィンドウの中央、または中央に一番近い行になります。

(`C-l
C-l`)のように`C-l`を2回タイプすると、ポイントのある行が上端になるようにスクロールします。`C-l`を3回タイプするとポイントのある行が下端になるようにスクロールします。連続して`C-l`をタイプすることにより、上記の3つの位置を循環してスクロールできます。

recenter-positions
リスト変数`recenter-positions`をカスタマイズすることにより、循環する順序を変更できます。リスト要素にはシンボル`top`、`middle`、`bottom`または数値を指定します。数値に整数を指定すると、現在行が指定したスクリーン行になるようスクロールします。数値に0.0から1.0の浮動小数点数は、ウィンドウの上端から現在行までを割合で指定します。デフォルトは`(middle
top
bottom)`で、これは上述した循環順序です。さらに変数`scroll-margin`を、0以外の値nに変更すると、`C-l`は常にウィンドウの上端または下端からスクリーン行で、n行を残してスクロールします([Auto Scrolling](#Auto-Scrolling)を参照してください)。

`C-l`にプレフィクス引数を指定することもできます。`C-u
C-l`のようにプレフィクス引数だけを指定すると、単にポイントのある行を中央にします。正の引数nは、ポイントのある行がウィンドウの上端からn行目になるようにスクロールします。0を指定すると、ポイントのある行が上端になるようにスクロールします。負の引数-nは、ポイントのある行がウィンドウの下端からn行目になるようにスクロールします。引数を与えたときは、`C-l`は画面をクリアーせず、異なるスクリーン位置への循環もしません。

recenter-redisplay
変数`recenter-redisplay`が非`nil`値の場合、`C-l`はスクリーンのクリアーと再描画を行います。特別な値`tty`(デフォルト)は、これをテキスト端末上のフレームだけに限定します。再描画はスクリーンが何らかの理由により文字化けしてしまったときなどに便利です([Screen Garbled](#Screen-Garbled)を参照してください)。

recenter
より原始的なコマンド`M-x
recenter`は、`recenter-top-bottom`と同じように振る舞いますが、スクリーン位置を循環しません。

C-M-l
reposition-window
`C-M-l` (`reposition-window`)は、有用な情報がスクリーンに表示されるように、現在のウィンドウを発見的な手法によりスクロールします。たとえばLispファイルの場合、このコマンドは可能な限り現在のdefun全体がスクリーン上に表示されるよう試みます。

自動スクロール
--------------

automatic scrolling
ポイントが表示されているテキスト部分から外に移動すると、Emacsは自動スクロール(automatic scrolling)の処理を行います。通常自動スクロールは、ウィンドウの垂直方向の中央にポイントをセンタリングしますが、この振る舞いを変えるいくつかの方法があります。

scroll-conservatively
`scroll-conservatively`に小さい数字nをセットすると、ポイントが少し(n行以下)スクリーンの外に出たら、Emacsはポイントがスクリーンに表示されるのに充分なだけスクロールします。これでもしポイントの表示に失敗した場合、Emacsはそのウィンドウの中央にポイント行が表示されるのに充分なだけのスクロールをします。`scroll-conservatively`に大きな数字(100より大)も数字をセットすると、どれだけポイントを移動させようと、自動スクロールはポイント行を中央にセンタリングしなくなります。Emacsはポイントが表示されるように常にテキストをスクロールします。ウィンドウの上端または下端かはスクロールの方向に依存します。デフォルトでは`scroll-conservatively`は 0で、これは常にポイント行がウィンドウの中央にセンタリングされることを意味します。

scroll-step
自動スクロールを制御する他の方法は、変数`scroll-step`をカスタマイズすることです。この変数の値はポイントがスクリーンから外れたとき、何行を自動スクロールさせるかを決定します。その行数スクロールしてもポイントが表示されない場合、かわりにポイント行が中央にきます。デフォルト値は0で、スクロール後は常にポイント行が中央にきます。

aggressive scrolling
scroll-up-aggressively
scroll-down-aggressively
自動コントロールを制御する3番目の方法は、変数`scroll-up-aggressively`と`scroll-down-aggressively`をカスタマイズすることで、これは直接スクロール後のポイントの垂直位置を指定します。`scroll-up-aggressively`の値には、`nil`(デフォルト)、または0から1までの浮動小数点数fを指定します。ポイントがウィンドウの下端を越えたとき(たとえば前方にスクロールしたとき)、Emacsはウィンドウの高さとウィンドウの下端からポイント行までの割合が、fになるようスクロールします。つまりfを大きくするとより積極的(aggressive)、つまり新しいテキストがより多く表示されることを意味します。デフォルト値`nil`は0.5と同じです。

同様に`scroll-down-aggressively`は、ポイントがウィンドウの上端を越えたとき(たとえば後方にスクロールしたとき)の振る舞いを設定します。値にはスクロール後のウィンドウの上端からポイント行までのマージンを指定します。つまり`scroll-up-aggressively`を大きくすると、より積極的になります。

変数`scroll-conservatively`、`scroll-step`、および`scroll-up-aggressively`と`scroll-down-aggressively`は、互いに矛盾する方法で自動スクロールを制御します。したがって自動スクロールをカスタマイズする場合は、2つ以上の手法を選ぶべきではありません。もし2つ以上の変数をカスタマイズする場合は、`scroll-conservatively`、次に`scroll-step`、そして最後に`scroll-up-aggressively`と`scroll-down-aggressively`という優先順でカスタマイズしてください。

scroll-margin
maximum-scroll-margin
変数`scroll-margin`は(たとえscroll-up-aggressivelyやscroll-down-aggressivelyに、上端または下端からのマージンがウィンドウにたいして占める割合より大きくなるようなfを指定していても)、ポイントがウィンドウの上端または下端にどれだけ近づけるかを制限します。変数の値にはスクリーン行の行数です。もしポイントがウィンドウの上端または下端から指定した行数の位置にくると、Emacsは自動的にスクロールします。デフォルトでは`scroll-margin`は0です。デフォルトではそのウィンドウの高さの1/4に制限されていますが、`maximum-scroll-margin`をカスタマイズすることにより1/2まで増加(または0まで減少)させることができます。

水平スクロール
--------------

horizontal scrolling
auto-hscroll-mode
水平スクロール(Horizontal scrolling)は、ウィンドウの行を右方向に移動させます。そのため左端の近くのテキストは表示されなくなります。ウィンドウのテキストが水平スクロールされると、テキスト行は折り返されるのではなく、切り詰め(truncated)られます。ウィンドウが切り詰められた行を表示しているとき、ポイントがスクリーンの左端か右端を越えて移動すると、Emacsは自動的に水平スクロールを行います。デフォルトではそのウィンドウ内のすべての行は一緒に水平スクロールされますが、変数`auto-hscroll-mode`に特別な値`current-line`をセットした場合は、カーソルを表示する行だけがスクロールされます。自動的な水平スクロールを完全に無効にするには、変数`auto-hscroll-mode`に`nil`をセットしてください。また自動的な水平スクロールがオフになっている場合、ポイントがスクリーンの端を越えると、それを知らせるためにカーソルが表示されなくなることに注意してください(テキスト端末の場合カーソルは端に残されます)。

hscroll-margin
変数`hscroll-margin`は、自動的なスクロールが起こる前に、ポイントがウィンドウの左端または右端に、どれだけ近づけるかを制御します。変数の値は列数で指定します。たとえば変数の値が5のときは、端から5列目にポイントが移動すると、水平スクロールが発生します。

hscroll-step
変数`hscroll-step`はmポイントが端に近づきすぎたときに、何列スクロールするかを決定します。デフォルト値の0は、ポイントがウィンドウの中央になるようにスクロールされることを意味します。正の整数はスクロールされる列数を指定します。浮動小数点数(0から1の値であること)は、スクロールされる量を、ウィンドウの幅にたいする割合で指定します。

以下のコマンドで明示的に水平スクロールすることもできます:

`C-x <`  
現在のウィンドウのテキストを左にスクロールします(`scroll-left`)。

`C-x >`  
右にスクロールします(`scroll-right`)。

C-x &lt;
C-x &gt;
scroll-left
scroll-right
`C-x <` (`scroll-left`)は選択された、ウィンドウをウィンドウ幅から2列少ない列数、左にスクロール(いいかえればウィンドウのテキストは左に移動)します。数引数nを指定すると、n列スクロールします。

テキストが左にスクロールされて、ポイントがウィンドウの左端を越えると、ポイントが表示されているテキストに戻るまで、カーソルはフリーズします。これは`auto-hscroll-mode`の設定とは独立しています(これはテキストを左にスクロールするときのウィンドウの右端での振る舞いだけに影響します)。

`C-x >` (`scroll-right`)は、同様に右にスクロールします。ウィンドウが通常の表示(行の先頭がウィンドウの左端に表示されている状態)のときは、それ以上スクロールできないので何も起こりません。これは`C-x
>`の引数を正確に計算する必要がないことを意味します。充分に大きな引数を与えれば、通常の表示が復元されます。

これらのコマンドでウィンドウを水平方向にスクロールすると、自動水平スクロールの下限値がセットされます。自動スクロールはウィンドウのスクロールを続けますが、前に`scroll-left`にセットされた値を越えて右にスクロールできなくなります。`auto-hscroll-mode`が`current-line`にセットされているときは、カーソルを表示する行以外の行は、最小限度だけスクロールされるでしょう。

ナローイング
------------

widening
restriction
narrowing
accessible portion
ナローイング(Narrowing)とはバッファーのある範囲にフォーカスを置き、他の部分を一時的にアクセス不能にすることを意味します。扱うことのできる範囲のことを、アクセス可能範囲(accessible portion)と呼びます。ナローイングを取り消すと、バッファー全体に再びアクセスできるようになります。これをワイドニング(widening)と呼びます。バッファーにたいして、ナローイングにより境界を設けることを、バッファーの制限(restriction)と呼びます。

ナローイングにより、他の部分に気を取られずに、1つのサブルーチンやパラグラフに集中することが容易になります。ナローイングは、置換コマンドやキーボードマクロの繰り返しにより操作される範囲を制限するためにも使われます。

`C-x n n`  
ポイントとマークの間にナローイングします(`narrow-to-region`)。

`C-x n w`  
バッファー全体をワイドニングして、再びアクセス可能にします(`widen`)。

`C-x n p`  
現在のページにナローイングします(`narrow-to-page`)。

`C-x n d`  
現在のdefunにナローイングします(`narrow-to-defun`)。

バッファーをナローイングしているときは、表示されている範囲がすべてです。残りの部分を見ることはできず、移動もできず(移動コマンドによりアクセス可能範囲の外に移動することはできません)、変更もできません。しかし残りの部分がなくなったわけではないので、ファイルを保存するとアクセス不能範囲のテキストもすべて保存されます。ナローイングが有効なときは、モードラインに‘`Narrow`’という単語が表示されます。

C-x n n
narrow-to-region
主要なナローイングコマンドは、`C-x n n` (`narrow-to-region`)です。これは現在のバッファーを制限するので、現在のリージョンだけがアクセス可能になり、リージョンの前後のすべてのテキストはアクセス不能になります。ポイントとマークは変化しません。

C-x n p
narrow-to-page
C-x n d
narrow-to-defun
かわりに`C-x n p` (`narrow-to-page`)を使うと、現在のページにナローイングされます。ページの定義については、[Pages](#Pages)を参照してください。`C-x
n d` (`narrow-to-defun`)は、ポイントを含むdefunにナローイングします([Defuns](#Defuns)を参照してください)。

C-x n w
widen
ナローイングを取り消す方法は、`C-x n w` (`widen`)です。これにより再びバッファーのテキストすべてにアクセス可能になります。

バッファーのどの範囲にナローイングされているかは、`C-x =`コマンドを使って情報を得ることができます。[Position Info](#Position-Info)を参照してください。

ナローイングは、それを理解していないユーザーを容易に混乱させるので、通常`narrow-to-region`コマンドは無効になっています。このコマンドを使おうとすると、Emacsは確認を求め、有効にするオプションを提供します。このコマンドを有効にすると、それ以降は確認を求められなくなります。[Disabling](#Disabling)を参照してください。

Viewモード
----------

View mode
mode, View
s (View mode)
SPC (View mode)
DEL (View mode)
Viewモードは、バッファーをスクリーン上でスキャンするためのマイナーモードです。このモードは、バッファーを変更せずにスクロールする、便利なコマンドを提供します。Emacsのカーソル移動コマンドとは別に、SPCで前方にスクロール、`S-SPC`またはDELで後方にスクロール、`s`でインクリメンタルサーチができます。

q (View mode)
e (View mode)
View-quit
View-exit
`q` (`View-quit`)とタイプするとViewモードが無効になり、Viewモードが有効になる前のパッファーの位置に戻ります。`e` (`View-exit`)とタイプするとViewモードが無効になり、現在のバッファーと位置は維持されます。

view-buffer
view-file
`M-x
view-buffer`は、既存のEmacsバッファー名を入力として求め、そのバッファーに切り替えてViewモードを有効にします。`M-x
view-file`はファイル名を入力として求め、そのファイルをvisitしてViewモードを有効にします。

Followモード
------------

Follow mode
mode, Follow
follow-mode
windows, synchronizing
synchronizing windows
Followモードは、同じバッファーを表示する2つのウィンドウを、1つの仮想ウィンドウとしてスクロールするマイナーモードです。Followモードを使うには、ウィンドウが1つだけのフレームを選択して、それを`C-x
3`を使って縦に並べて2分割してから、`M-x
follow-mode`とタイプします。それ以降はバッファーをどちらのウィンドウでも編集でき、どちらかのウィンドウをスクロールすると、他方のウィンドウも追従してスクロールします。

Followモードでは、一方のウィンドウで表示されている部分の外にポイントを移動して、もう一方のウィンドウで表示されている部分にポイントを移動させると、そのウィンドウが選択されます。つまり2つのウィンドウを1つの大きなウィンドウとして扱えるのです。

Followモードをオフにするには、もう一度`M-x follow-mode`とタイプしてください。

テキストのフェイス
------------------

faces
Emacsはフェイス(faces)と呼ばれる仕組みを通じて、テキストをいくつかの異なるスタイルで表示できます。フェイスにはfont(フォント)、height(高さ)、weight(太さ)、slant(傾き)、foreground(前景)およびbackground(背景)、underline(アンダーライン)、overline(オーバーライン)などの様々なフェイス属性(face attributes)を指定できます。ほとんどのメジャーモードはFont Lockモードを通じて、テキストに自動的にフェイスを割り当てます。これらのフェイスを割り当てる方法については、[Font Lock](#Font-Lock)を参照してください。

list-faces-display
現在定義されているフェイスと、それがどのような外観なのかを見るには、`M-x
list-faces-display`とタイプします。プレフィクス引数を指定すると、このコマンドは正規表現の入力を求め、その正規表現にマッチするフェイスだけを表示します([Regexps](#Regexps)を参照してください)。

frame-background-mode
あるフェイスが、フレームが異なると違って見えるのことがあり得ます。たとえばいくつかのテキスト端末ではすべてのフェース属性、特に特にfont、height、widthはサポートされておらず、指定できるcolorも限られているものがあります。加えて、ほとんどのEmacsフェースは視認性をよくするために、フレームのバックグラウンドが明るい(light)か暗い(dark)かで属性が異なります。デフォルトでは、Emacsはフレームの現在のバックグラウンドカラーに基づいて、表示するフェイスの属性を自動的に選択します。しかし変数`frame-background-mode`に非`nil`値を与えると、これをオーバーライドできます。値`dark`ではすべてのフレームの背景色が暗い色であるかのように処理し、値`light`ではすべてのフレームの背景色が明るい色であるかのように処理させることができます。

background color
default face
フェイスの属性を変えてフェイスをカスタマイズして、将来のEmacsセッション用にカスタマイズ結果を保存することができます。詳細については、[Face Customization](#Face-Customization)を参照してください。

`default`フェイスはテキストを表示するデフォルトのフェイスで、そのすべての属性は指定されています。バックグラウンドカラーは、フレームのバックグラウンドカラーとしても使用されます。[Colors](#Colors)を参照してください。

cursor
face
他の特別なフェイスとしては、`cursor`フェイスがあります。グラフィカルなディスプレーでは、このフェイスのバックグラウンドカラーは、テキストカーソルを描画するのに使用されます。このフェイスで効果があるのはこの属性だけです。カーソルの下のテキストのフォアグラウンドカラーには、そのテキストのバックグラウンドカラーが使われます。テキスト端末でのテキストカーソルの外観は、`cursor`フェイスではなく端末により決定されます。

特定のフェイスの属性を指定するのにXのリソースを使うこともできます。[Resources](#Resources)を参照してください。

Emacsは可変幅フォント(variable-width fonts)を表示できますが、いくつかのコマンド、特にインデントを行うコマンドは、可変幅の文字幅の表示をうまく処理できません。そのため、ほとんどのフェイスにたいして可変幅フォントを使わないこと、特にそれがFont Lockモードに割り当てられている場合は、使わないことを推奨します。

フェイスのカラー
----------------

color name
RGB triplet
フェイスには、さまざまなフォアグラウンドカラーとバックグラウンドカラーをもたせることができます。フェイスにカラーを指定するとき、たとえばフェイスをカスタマイズ([Face Customization](#Face-Customization)を参照してください)するときは、カラーネーム(color name)か、RGBトリプレット(RGB triplet)で指定することができます。

list-colors-display
list-colors-sort
カラーネームとは、‘`dark orange`’や‘`medium sea
green`’のような、事前に定義された名前です。カラーネームの一覧を見るには、`M-x
list-colors-display`とタイプします。表示されるカラーの順番を制御するには、`list-colors-sort`をカスタマイズします。このコマンドをグラフィカルなディスプレーで実行すると、Emacsで既知のカラーネームのすべてが表示されます(これらは標準のX11のカラーネームで、Xの`rgb.txt`で定義されています)。コマンドをテキスト端末で実行すると、端末で安全に表示することができる一部のカラーだけが表示されます。フェイスには、さまざまなフォアグラウンドカラーとバックグラウンドカラーを持たせることができます。しかしEmacsは、テキスト端末でもX11のカラーネームを理解できます。もしフェイスにX11のカラーネームが指定されている場合、最も近い端末の色で表示されます。

RGBトリプレットは、‘`#RRGGBB`’という形式の文字列で指定します。R、G、Bの各コンポーネントは、そのそのコンポーネントに関連する色の強度を、1桁から4桁(通常は2桁)の16進数で指定します。各コンポーネントは同じ桁数でなければなりません。16進数のAからFは、大文字小文字を区別しません。

`M-x
list-colors-display`は、カラーネームと、それに相当するRGBトリプレットを表示します。たとえば‘`medium sea
green`’は‘`#3CB371`’と同じです。

face colors, setting
set-face-foreground
set-face-background
`M-x set-face-foreground`と`M-x
set-face-background`で、フェイスのフォアグラウンドとバックグラウンドのカラーを変更できます。これらのコマンドは、ミニバッファーでフェイス名とカラーの入力を求め(補完機能あり)、指定したカラーをフェイスにセットします。フェイスのカラーは全フレームに影響しますが、カスタマイズバッファーやXリソースを使うのとは異なり、将来のEmacsセッションには引き継がれません。フレームパラメーターを使って、特定のフレームのフォアグラウンドとバックグラウンドのカラーをセットすることもできます。[Frame Parameters](#Frame-Parameters)を参照してください。

標準フェイス
------------

standard faces
以下はテキストの外見を指定する標準フェイスです。これらのフェイスの効果が欲しい場合は、特定のテキストに適用することができます。

`default`  
このフェイスは特定のフェイスをもたない普通のテキストに使われます。フェイスのバックグラウンドカラーは、フレームのバックグラウンドカラーとして使用されます。

`bold`  
このフェイスは、デフォルトフォントのbold(太字)バージョンです。

`italic`  
このフェイスはデフォルトフォントのitalic(斜体)バージョンです。

`bold-italic`  
このフェイスはデフォルトフォントのbold italic(太字斜体)バージョンです。

`underline`  
このフェイスはunderline(下線)のテキストです。

`fixed-pitch`  
このフェイスはfixed-width font(固定幅フォント)の使用を強制します。もし望むなら、このフェイスから他の固定幅フォントにカスタマイズするのは妥当ですが、可変幅フォントにするべきではありません。

`fixed-pitch-serif`  
このフェイスは`fixed-pitch`と似ていますが、フォントはセリフ(serif: HやIなどの上下のひげ飾り)をもち、伝統的なタイプライター文字に、より似ています。 `variable-pitch` face

`variable-pitch`  
このフェイスはvariable-width font(可変幅フォント)の使用を強制します。 `shadow` face

`shadow`  
このフェースはまわりのテキストに比べて、そのテキストを目立たなくします。通常これはデフォルトの黒または白のフォアグラウンドカラーではなく、グレーが使われます。

以下は特別な目的のために、一時的にテキストの一部をハイライトするのに使われるフェイスの、不完全なリストです(他にも多くのモードが、そのモードの目的のために、独自のフェイスを定義しています)。

`highlight`  
このフェイスはさまざまなコンテキスト、たとえばハイパーリンク上をマウスカーソルが通過したときなどに、テキストをハイライトするのに使われます。

`isearch`  
このフェイスは、現在のIsearch(インクリメンタル検索)のマッチをハイライトするのに使われます([Incremental Search](#Incremental-Search)を参照してください)。

`query-replace`  
このフェイスは、現在の問い合わせ置換(Query Replace)のマッチをハイライトするのに使われます([Replace](#Replace)を参照してください)。

`lazy-highlight`  
このフェイスは、Isearchおよび問い合わせ置換で、カレントのマッチ(現在カーソルがあるマッチ)以外のマッチ(lazy matches)をハイライトするのに使われます。

`region`  
このフェイスは、アクティブなリージョンを表示するのに使われます([Mark](#Mark)を参照してください)。EmacsをGTK+サポートつきでビルドした場合、カラーは現在のGTK+のテーマから提供されます。

`secondary-selection`  
このフェイスは、Xのセカンダリー選択(secondary X selection)を表示するのに使われます([Secondary Selection](#Secondary-Selection)を参照してください)。

`trailing-whitespace`  
このフェイスは、`show-trailing-whitespace`は非`nil`のとき、行末の余分なスペースやタブをハイライトするためのものです([Useless Whitespace](#Useless-Whitespace)を参照してください)。

`escape-glyph`  
このフェイスは、制御文字やエスケープシーケンスを表示するためのものです([Text Display](#Text-Display)を参照してください)。

`homoglyph`  
このフェイスは、類似文字(表示しようとする文字と似ているが異なる文字)を表示するためのものです([Text Display](#Text-Display)を参照)。

`nobreak-space`  
このフェイスは、no-breakスペース文字を表示するためのものです([Text Display](#Text-Display)を参照してください)。

`nobreak-hyphen`  
このフェイスは、no-breakハイフン文字を表示するためのものです([Text Display](#Text-Display)を参照してください)。

以下のフェイスは、Emacsフレームの一部の外見を制御します:

`mode-line`  
mode-line

face

faces for mode lines

このフェイスは、現在選択されているウィンドウのモードラインと、ツールキットメニューが使われていないときのメニューバーに使われます。デフォルトでは、グラフィカルなウィンドウではraised(浮き彫り)効果をだすため影つきで描画され、非ウィンドウの端末ではデフォルトのフェイスを反転して描画されます。

`mode-line-inactive`  
mode-line-inactive

face

`mode-line`と似ていますが、選択されていないウィンドウのモードラインに使われます(`mode-line-in-non-selected-windows`が非`nil`のとき)。このフェイスは`mode-line`を継承するので、フェイスを変更するとすべてのウィンドウのモードラインが影響を受けます。

`mode-line-highlight`  
mode-line-highlight

face

`highlight`と似ていますが、モードライン上でマウスセンシティブ(マウスに感応する)なテキスト範囲に使われます。通常このようなテキスト範囲は上にマウスポインターがくると、ツールチップ([Tooltips](#Tooltips)を参照してください)をポップアップします。

`mode-line-buffer-id`  
mode-line-buffer-id

face

このフェイスは、モードライン上でバッファーを識別する部分に使われます。

`header-line`  
header-line

face

`mode-line`と似ていますが、ウィンドウのヘッダーラインのためのものです。モードラインがウィンドウの一番下に表示されるように、ヘッダーラインはウィンドウの一番上に表示されます。ほとんどのウィンドウはヘッダーラインを持ちません。Infoモードのような特別なモードだけがヘッダーラインを持ちます。

`header-line-highlight`  
header-line-highlight

face

`highlight`や`mode-line-highlight`と似ていますが、ヘッダー行のマウスに感応する部分に使用されます。`header-line`フェイスは`highlight`とは無関係にカスタマイズされるかもしれないので、このフェイスが別に設けられています。

`vertical-border`  
vertical-border

face

このフェイスは、テキスト端末上でウィンドウを縦に分割するとき使われます。

`minibuffer-prompt`  
minibuffer-prompt

face

minibuffer-prompt-properties

このフェイスは、ミニバッファーで入力を求めるプロンプトのテキストに使われます。デフォルトでは、Emacsは自動的にプロンプトのテキストの、テキストプロパティ(section “Text Properties” in the Emacs Lisp Reference Manualを参照してください)のリスト`minibuffer-prompt-properties`に、このフェイスを追加します(この変数はミニバッファーに入ったときに効果をあらわします)。

`fringe`  
fringe

face

グラフィカルなウィンドウでの、左右のフリンジのためのフェイスです(フリンジはEmacsフレームで、テキストエリアとウィンドウの左右の境界線の間にある、狭い領域です)。[Fringes](#Fringes)を参照してください。

`cursor`  
このフェイスの`:background`属性は、テキストカーソルのカラーを指定します。[Cursor Display](#Cursor-Display)を参照してください。

`tooltip`  
このフェイスは、ツールチップのテキストに使われます。デフォルトでは、EmacsがGTK+サポートつきでビルドされた場合、ツールチップはGTK+を通じて描画されるので、このフェイスは効果がありません。[Tooltips](#Tooltips)を参照してください。

`mouse`  
このファイスは、マウスポインターのカラーを決定します。

以下のフェイスは、Emacsフレームの一部の外見を制御するときと同様ですが、テキスト端末またはEmacsをXサポートつき(ただしツールキットサポートなし)でビルドしたときだけ使われます(それ以外の場合、フレームの対応する各要素は広義なシステム設定により決定されます)。

`scroll-bar`  
このフェイスは、スクロールバーの外見を決定します。[Scroll Bars](#Scroll-Bars)を参照してください。

`tool-bar`  
このフェイスは、ツールバーのアイコンのカラーを決定します。[Tool Bars](#Tool-Bars)を参照してください。

`menu`  
menu bar appearance

menu

face, no effect if customized

customization of

menu

face

このフェイスはEmacsメニューのカラーとフォントを決定します。[Menu Bars](#Menu-Bars)を参照してください。

`tty-menu-enabled-face`  
faces for text-mode menus

TTY menu faces

このフェイスは、テキスト端末で利用可能なメニューアイテムを表示するのに使われます。

`tty-menu-disabled-face`  
このフェイスは、テキスト端末で利用不可なメニューアイテムを表示するのに使われます。

`tty-menu-selected-face`  
このフェイスは、テキスト端末でマウスをクリックするか、RETを押せば選択できるメニューアイテムを表示するのに使われます。

テキストのスケール
------------------

adjust buffer face height
text-scale-adjust
C-x C-+
C-x C–
C-x C-=
C-x C-0
現在のバッファーのデフォルトフェイスを大きくするには、`C-x C-+`または`C-x
C-=`をタイプします。小さくするには、`C-x
C--`をタイプします。デフォルトのフェースの大きさ(グローバル)に復元するには、`C-x
C-0`とタイプします。これらのキーは、すべて同じコマンド`text-scale-adjust`にバインドされており、このコマンドは最後のキーを判断して動作を決定します。

これらのコマンドの最後のキーは、`C-x`を前置せずに繰り返すことができます。たとえば`C-x C-= C-=
C-=`は、フェイスの大きさを3段階に大きくします。各ステップで大きくなる倍率は1.2です。この倍率を変更するには、変数`text-scale-mode-step`をカスタマイズします。`text-scale-adjust`コマンドに数引数0を指定すると、`C-x
C-0`とタイプしたのと同様に、デフォルトの大きさに復元します。

increase buffer face height
text-scale-increase
decrease buffer face height
text-scale-decrease
コマンド`text-scale-increase`および`text-scale-decrease`は、`C-x
C-+`および`C-x
C--`と同様、デフォルトフェイスを大きくまたは小さくします。キーをバインドする場合、これらのコマンドは、`text-scale-adjust`より便利でしょう。

set buffer face height
text-scale-set
コマンド`text-scale-set`は、数引数で現在のバッファーのデフォルトフェイスの大きさを、絶対倍率で指定します。

text-scale-mode
上記のコマンドは、現在のフォント倍率が1以外のときは、自動的にマイナーモード`text-scale-mode`を有効にし、そうでない場合は無効にします。

Font Lockモード
---------------

Font Lock mode
mode, Font Lock
syntax highlighting and coloring
Font Lockモードはマイナーモードで、常に特定のバッファーにローカルで、バッファーのテキストにフェイスを割り当てます(またはフォント表示化(fontifies)します)。各バッファーのメジャーモードは、Font Lockモードにどのテキストをフォント表示可するか指示します。たとえばプログラム言語のモードは、コメントや文字列、関数名のような、構文に関連する構成をフォント表示化します。

font-lock-mode
Font Lockモードはデフォルトで有効です。現在のバッファーでこれを切り替えるには、`M-x
font-lock-mode`とタイプします。正の数引数は無条件にFont Lockモードを有効にし、負または0の数引数を指定すると無効になります。

global-font-lock-mode
global-font-lock-mode
`M-x global-font-lock-mode`とタイプすると、すべてのバッファーでFont Lockモードを切り替えます。このセッティングを将来のEmacsセッションに引き継ぐには、変数`global-font-lock-mode`をカスタマイズ([Easy Customization](#Easy-Customization)を参照してください)するか、以下の行をinitファイルに追加します。

    (global-font-lock-mode 0)

Global Font Lockモードを無効にしていたとしても、モードフック(mode hooks)に関数を追加することにより、特定のメジャーモードでFont Lockモードを有効にできます。たとえばCファイルの編集でFont Lockモードを有効にするには、以下のように記述します:

    (add-hook 'c-mode-hook 'font-lock-mode)

Font Lockモードは、`font-lock-string-face`、`font-lock-comment-face`のような、いくつかの特別な名前のフェイスを使って処理を行います。これらすべてを簡単に探す方法には、`M-x
customize-group RET font-lock-faces
RET`を使います。それからカスタマイズバッファーでそれらのフェイスの外見をカスタマイズできます。[Face Customization](#Face-Customization)を参照してください。

font-lock-maximum-decoration
変数`font-lock-maximum-decoration`をカスタマイズして、この機能をサポートするメジャーモードにたいして、Font Lockモードで適用されるフォント表示化のレベルを変更できます。値には数字を指定します(1は最小限のフォント表示化で、3という高いレベルのモードもあります)。`t`は“可能な限り高く”という意味です(デフォルト)。効果を得るには、そのファイルがvisitされる*前*に`font-lock-maximum-decoration`をカスタマイズするべきです。この変数をカスタマイズする時点で、すでにそのファイルをバッファーでvisitしている場合は、そのバッファーをkillしてから、スタマイズ後に再度そのファイルをvisitしてください。

特定のモードに異なる数字を指定することもできます。たとえばC/C++モードにはレベル1を指定して、他のモードにはデフォルトのレベルを適用するには、以下の値を使います

    '((c-mode . 1) (c++-mode . 1)))

incorrect fontification
parenthesis in column zero and fontification
brace in column zero and fontification
コメントと文字列のフォント表示化(または“構文的”なフォント表示化)は、バッファーのテキストの構文構造の解析に依存します。速度向上のため、Lispモードを含めたいくつかのモードでは、特別な慣習に依存しています。たとえば一番左の列の開きカッコ(open-parenthesis)または開き大カッコ(open-brace)は常にdefunの開始であり、すなわち常に文字列またはコメントの外部にあるとみなす、というように解析します。したがって文字列やコメントの中で、一番左の列に開きカッコや開き大カッコを記述するのは避けるべきです。詳細については、[Left Margin Paren](#Left-Margin-Paren)を参照してください。

font-lock-add-keywords
Font Lockは、ほとんどのモードで既存のパターンをハイライトしますが、追加のパターンをフォント表示化したいときもあるでしょう。特定のモードでハイライトするパターンを追加するには、関数`font-lock-add-keywords`を使うことができます。たとえばCコメント中の‘`FIXME:`’という単語をハイライトするには、以下を使います:

    (add-hook 'c-mode-hook
              (lambda ()
               (font-lock-add-keywords nil
                '(("\\<\\(FIXME\\):" 1
                   font-lock-warning-face t)))))

font-lock-remove-keywords
font-lockのハイライトパターンからキーワードを削除するには、関数`font-lock-remove-keywords`を使います。section “Search-based Fontification” in The Emacs Lisp Reference Manualを参照してください。

just-in-time (JIT) font-lock
background syntax highlighting
大きなバッファーのフォント表示化には、長い時間を要することもあります。ファイルをvisitしたとき大きな遅延を避けるには、Emacsが最初はバッファーの表示された部分だけをフォント表示化するようにします。バッファーをスクロールすると、新たに表示される部分がフォント表示化されます。このタイプのFont Lockは、Just-In-Time(またはJIT) Lockと呼ばれます。カスタマイズグループ‘`jit-lock`’の値をカスタマイズすることにより、アイドル状態のときにフォント表示可を行うことも含めて、JIT Lockがどのように振る舞うか制御できます。[Specific Customization](#Specific-Customization)を参照してください。

インタラクティブなハイライト
----------------------------

highlighting by matching
interactive highlighting
Highlight Changes mode
highlight-changes-mode
Highlight Changesモードは、最近変更されたバッファー部分のテキストに、異なるフェイスを与えることによりハイライトするマイナーモードです。Highlight Changesモードを有効または無効にするには、`M-x highlight-changes-mode`を使います。

Hi Lock mode
hi-lock-mode
Hi Lockモードは、指定した正規表現にマッチするテキストをハイライトする、マイナーモードです。たとえば、プログラムのソースファイルで、特定の変数へのすべての参照をハイライトしたり、何らかのプログラムの大量の出力の一部をハイライトしたり、記事中の特定の名前をハイライトするために使用できます。Hi Lockモードを有効または無効にするには、コマンド`M-x hi-lock-mode`を使います。すべてのバッファーでHi Lockモードを有効にするには、`M-x
global-hi-lock-mode`を使うか、`.emacs`ファイルに`(global-hi-lock-mode
1)`と記述してください。

Hi LockモードはFont Lockモード([Font Lock](#Font-Lock)を参照してください)と同じように動作しますが、ハイライトするパターンを明示的に正規表現で指定します。これらは以下のコマンドで制御できます(`C-x
w`で始まるキーバインドは、`M-s
h`で始まるグローバルなバインドが優先されるため推奨されておらず、将来のEmacsのバージョンで廃止されるでしょう)。

`M-s h r regexp RET face RET`; `C-x w h regexp RET face RET`  
M-s h r

C-x w h

highlight-regexp

regexpにマッチするテキストを、フェイスfaceを使ってハイライトします(`highlight-regexp`)。ハイライトはバッファーがロードされている限り残ります。たとえば単語“whim”をデフォルトのフェイス(黄色いバックグラウンドカラー)でハイライトするには、`M-s
h r whim RET RET`とタイプします。ハイライトには任意のフェイスを使うことができますが、Hi Lockモードはモード自身でいくつかのフェイスを提供しており、それらはデフォルト値のリストに事前ロードされています。フェイスの入力プロンプトで`M-n`と`M-p`を使うことにより、それらを巡回することができます。

hi-lock-auto-select-face

オプション`hi-lock-auto-select-face`に非`nil`値をセットすることにより、このコマンド(およびその他のフェイスを読みとるHi Lockコマンド)は、入力を求めることなく、デフォルト値のリストから次のフェイスを自動的に選択します。

このコマンドを複数回使用して、さまざまな正規表現を指定し、それぞれを異なる方法でハイライトできます。

`M-s h u regexp RET`; `C-x w r regexp RET`  
M-s h u

C-x w r

unhighlight-regexp

regexpのハイライトを解除します(`unhighlight-regexp`)。メニューから呼び出した場合、ハイライト解除する正規表現をリストから選択します。キーボードから呼び出した場合は、ミニバッファーを使います。一番最近追加された正規表現を表示し、`M-n`を使って次に古い正規表現、`M-p`で次に新しい正規表現を表示できます(手入力もでき、その場合は補完機能つきです)。ハイライト解除したい正規表現がミニバッファーに表示されたら、`RET`を押してミニバッファーを抜けだし、ハイライトを解除できます。

`M-s h l regexp RET face RET`; `C-x w l regexp RET face RET`  
M-s h l

C-x w l

highlight-lines-matching-regexp

lines, highlighting

highlighting lines of text

regexpとのマッチを含む行全体を、フェイスfaceを使ってハイライトします(`highlight-lines-matching-regexp`)。

`M-s h p phrase RET face RET`; `C-x w p phrase RET face RET`  
M-s h p

C-x w p

highlight-phrase

phrase, highlighting

highlighting phrase

phraseにマッチするフレーズを、フェイスfaceでハイライトします(`highlight-phrase`)。phraseには正規表現を指定できますが、スペースは空白文字にマッチする正規表現に置き換えられます。また、先頭に小文字を使用することにより、大文字小文字を区別しなくなります。

`M-s h .`; `C-x w .`  
M-s h .

C-x w .

highlight-symbol-at-point

symbol, highlighting

highlighting symbol at point

ポイントの近くで見つかったシンボルを、次に利用可能なフェイスでハイライトします(`highlight-symbol-at-point`)。

`M-s h w`; `C-x w b`  
M-s h w

C-x w b

hi-lock-write-interactive-patterns

現在ハイライトを行っている正規表現/フェイスのペアを、バッファーのポイント位置に挿入します。挿入はプログラムを変更してしまわないように、コメント文字列でコメント化されます(このキーバインドは`hi-lock-write-interactive-patterns`コマンドを実行します)。

これらのパターンは、コメントからも逆抽出されます。それは、コメントに記述されたテキストが適正で、`M-x
hi-lock-find-patterns`を呼び出した、あるいはHi Lockモードが有効なときファイルをvisit(これは`hi-lock-find-patterns`を実行します)したときです。

`M-s h f`; `C-x w i`  
M-s h f

C-x w i

hi-lock-find-patterns

正規表現/フェイスのペアを、現在のバッファーのコメントから抽出します(`hi-lock-find-patterns`)。これらのコマンドを使えば、`highlight-regexp`でパターンを対話的に入力、`hi-lock-write-interactive-patterns`でそれをファイルに保存、それらを編集(あるマッチのフェイスを別のフェイスにしたり)、そして最後にこのコマンド(`hi-lock-find-patterns`)で編集済みのパターンを、Hi Lockのハイライトに適用することができます。

hi-lock-file-patterns-policy

変数`hi-lock-file-patterns-policy`はファイルをvisitしたとき、Hi Lockモードがパターンを探して、それを自動的に抽出するべきかを制御します。値には`nil`(ハイライトしない)、`ask`(ユーザーに尋ねる)、または関数を指定します。関数の場合、`hi-lock-find-patterns`はパターンを引数としてその関数を呼び出します。関数が非`nil`を返した場合、パターンを使用します。デフォルトは`ask`です。直接`hi-lock-find-patterns`を呼び出した場合、この変数の値に関係なく、常にパターンはハイライトされることに注意してください。

hi-lock-exclude-modes

現在のメジャーモードのシンボルが、リスト`hi-lock-exclude-modes`のメンバーの場合、`hi-lock-find-patterns`は何もしません。

ウィンドウのフリンジ
--------------------

fringes
set-fringe-style
fringe-mode
fringe-mode (variable)
グラフィカルなディスプレーでは、通常Emacsの各ウィンドウの左右の端に、狭いフリンジ(fringes: 縁、へり)があります。フリンジは、ウィンドウのテキストに関する情報を提供するシンボルの表示に使用されます。`M-x
fringe-mode`とタイプしてフリンジ表示を切り替えたり、幅を変更できます。このコマンドは全フレームのフリンジに影響します。選択されたフレームのフリンジだけを変更するには、`M-x
set-fringe-style`を使います。変数`fringe-mode`をカスタマイズして、フリンジへの変更を永続化できます。

フリンジのもっとも一般的な使われかたは、継続行の表示です([Continuation Lines](#Continuation-Lines)を参照してください)。テキストの1行が複数のスクリーン行に分割されるとき、最初の行を除いた各行の左フリンジには曲矢印が表示され、その行の先頭が実際の行頭ではないことを示します。そして、最後の行を除いた各行の右フリンジにも曲矢印が表示され、その行の最後が実際の行末ではないことを示します。行の方向が右から左([Bidirectional Editing](#Bidirectional-Editing)を参照してください)の場合、フリンジの曲矢印の意味は逆になります。

行が切り詰められているとき([Line Truncation](#Line-Truncation)を参照してください)は水平方向の直矢印を表示して、この行には水平スクロールしなければ見ることのできないテキストがあることを示します。矢印の上でマウスをクリックすれば、矢印の指す方向に水平スクロールします。

フリンジはバッファーの境界([Displaying Boundaries](#Displaying-Boundaries)を参照してください)や、デバッグ([Debuggers](#Debuggers)を参照してください)しているプログラムが実行中であることを示すためにも使われます。

overflow-newline-into-fringe
現在の行がウィンドウの幅と正確に一致して、ポイントがその行の行末にある場合、フリンジにはカーソルが描画されます。これを無効にするには、変数`overflow-newline-into-fringe`を`nil`に変更します。これによりEmacsはウィンドウ幅と同じ長さの行にたいしても、継続または切り詰めを行います。

表示されているウィンドウの片側、または両側のフリンジを削除するために`fringe-mode`をカスタマイズする場合、フリンジ上にに表示する機能は利用できなくなりますが、行の継続と切り詰めの標識は例外です。フリンジが利用できない場合、Emacsは特別なASCII文字([Continuation Lines](#Continuation-Lines)、および[Line Truncation](#Line-Truncation)を参照してください)により、行の継続と切り詰めを示すために、最左および最右の文字セルを使用します。行の継続と切り詰めの標識に使用される文字セルは、この目的のために予約されるので、各行に表示するテキストのための列数は減少します。バッファーのテキストには双方向のテキスト、およびleft-to-right(左から右)とright-to-left(右から左)の両方のパラグラフ([Bidirectional Editing](#Bidirectional-Editing)を参照してください)が含まれるかもしれないので、、片側のフリンジを削除しただけでは依然として2つの文字セルが予約されます。つまり行の継続と切り詰めの標識のために、ウィンドウの両側にそれぞれ1つの文字セルが予約されます。なぜなら、right-to-leftのパラグラフでは、これらの標識はウィンドウの反対側に表示されるからです。

バウンダリーの表示
------------------

indicate-buffer-boundaries
グラフィカルなディスプレーでは、Emacsはバッファーのバウンダリー(boundary: 境界)を、フリンジに表示することもできます。この機能を有効にすると、最初の行と最後の行ではフリンジに、かぎカッコが表示されます。上矢印または下矢印の場合、それはウィンドウをその方向に、もっとスクロールできることを示します。

バッファーローカルな変数`indicate-buffer-boundaries`は、バッファーのバウンダリーととウィンドウのスクロールが、フリンジでどのように表示されるかを制御します。値が`left`(または`right`)の場合、かぎカッコと矢印のビットマップは、左フリンジ(または右フリンジ)に表示されます。

値がalist(association list: 連想リスト。section “Association Lists” in the Emacs Lisp Reference Manualを参照してください)の場合、各要素の`(indicator .
position)`で、標識(indicator)の位置(position)を指定します。indicatorには`top`、`bottom`、`up`、`down`、または`t`(指定されていない標識のデフォルト位置)を指定します。positionには`left`、`right`、または`nil`(標識を表示しない)を指定します。

たとえば`((top . left) (t
.
right))`は、最上行の左フリンジにかぎカッコを表示し、右フリンジには最下行のかぎカッコとスクロール矢印を表示します。左フリンジにかぎカッコだけを表示させる場合は、`((top
.  left)  (bottom . left))`を使います。

不要なスペース
--------------

trailing whitespace
whitespace, trailing
show-trailing-whitespace
意識せずに不必要なスペースを行末に残してしまったり、バッファーの最後に空行を残してしまうことはよくあります。ほとんどの場合、そのような行末の空白文字(trailing whitespace)は何の影響も及ぼしませんが、厄介物になる場合もあります。

trailing-whitespace
face
バッファーローカルな変数`show-trailing-whitespace`を`t`にセットすることにより、行末の空白文字を可視化できます。これによりEmacsはフェイス`trailing-whitespace`で、行末の空白文字を表示します。

この機能は行末に空白文字を含む行の、行末にポイントがあるときは適用されません。厳密にいえば、これも行末の空白文字なのですが、それを特別に表示してしまうと、新しいテキストをタイプするとき面倒です。このような特別なケースでは、ポイントの位置に表示されるカーソルより、空白文字があることが自明だからです。

delete-trailing-whitespace
delete-trailing-lines
`M-x
delete-trailing-whitespace`とタイプすると、すべての行末の空白文字を削除します。このコマンドは、バッファー内の各行の行末にあるすべての余分なスペースと、バッファーの最後にある空行を削除します。バッファー内の空行を削除しない場合は、変数`delete-trailing-lines`を`nil`に変更してください。リージョンがアクティブのときは、リージョン内の各行の行末の余分なスペースを削除します。

indicate-empty-lines
unused lines
fringes, and unused line indication
グラフィカルなディスプレーでは、Emacsはウィンドウの最後の使われていない行の左フリンジに小さなイメージを表示して、それを示すことができます。このイメージはバッファーのテキストが何も含まれていないスクリーン行に表示されるので、バッファーの最後にある空行は、このイメージが表示されないことで見分けることができます。この機能を有効にするにはバッファーローカルな変数`indicate-empty-lines`に非`nil`値をセットします。すべての新しいバッファーでこの機能を有効または無効にするには、この変数のデフォルト値をセットします(例 `(setq-default indicate-empty-lines t)`)

Whitespace mode
mode, Whitespace
whitespace-mode
whitespace-style
whitespace-toggle-options
Whitespaceモードはバッファーローカルなマイナーモードで、バッファー内にある多くの種類の空白文字を視覚化します。これは空白文字を特別なフェイスで描画するか、特別なグリフで表示することにより行われます。このモードを切り替えるには、`M-x
whitespace-mode`とタイプします。視覚化される空白文字の種類は、リスト変数`whitespace-style`により決定されます。`M-x
whitespace-toggle-options`とタイプして、カレントバッファーでこのリスト内の個々の要素のオンとオフを切り替えることができます。以下はリストに指定できる要素の一部です(完全なリストは変数のドキュメントを参照してください)。

`face`  
特別なフェイスを使った視覚化をすべて有効にします。この要素には特別な意味があります。もしこれがリストに含まれていない場合、`space-mark`、`tab-mark`、`newline-mark`を除く他の視覚化は効果がなくなります。

`trailing`  
行末の空白文字をハイライトします。

`tabs`  
タブ文字をハイライトします。

`spaces`  
スペースおよびnon-breaking space文字をハイライトします。

`lines`  
whitespace-line-column

80列以上の行をハイライトします。列の上限を変更するには、変数`whitespace-line-column`をカスタマイズします。

`newline`  
改行をハイライトします。

`empty`  
バッファーの先頭、および/または終端の空行をハイライトします。

`big-indent`  
whitespace-big-indent-regexp

非常に深いインデントをハイライトします。デフォルトでは、少なくとも4個の連続するTAB文字と、32個の連続するスペースからなる、任意のシーケンスがハイライトされます。これを変更するには、正規表現`whitespace-big-indent-regexp`をカスタマイズしてください。

`space-mark`  
スペースとnon-breaking文字を特別なグリフで描画します。

`tab-mark`  
タブ文字を特別なグリフで描画します。

`newline-mark`  
改行文字を特別なグリフで描画します。

global-whitespace-toggle-options
global-whitespace-mode
Global Whitespaceモードは、すべてのバッファーで空白文字を視覚化する、グローバルなマイナーモードです。この機能を個別に切り替えるには、`M-x
global-whitespace-toggle-options`を使用してください。

選択的な表示
------------

selective display
set-selective-display
C-x $
Emacsには、与えられたレベルより多くインデントされた行を隠す機能があります。これをプログラムの概要を理解するのに使うことができます。

現在のバッファーの行を隠すには、数引数nを指定して`C-x $` (`set-selective-display`)をタイプします。すると少なくともn列のインデントをもつ行は、スクリーンに表示されなくなります。隠された行の存在を示すのは、表示されている行末に表示された3つのドット(‘`…`’)だけで、これは1行以上の行が後に隠されていることを意味します。

コマンド`C-n`および`C-p`は、隠された行が存在しないかのように、隠された行をスキップして移動します。

隠された行は依然としてバッファーに存在し、ほとんどの編集コマンドはそれらを見ることができるので、隠されな行にポイントを移動することもありえます。これが起こるとカーソルは前の行の最後、つまり3つのドットの後ろに表示されます。ポイントが表示されている行の行末、つまり改行の前にある場合、カーソルは3つのドットの前に表示されます。

隠された行のすべてを再び表示するには、引数を指定せずに`C-x $`とタイプしてください。

selective-display-ellipses
変数`selective-display-ellipses`に`nil`をセットすると、隠された行があることを示す3つのドットは表示されなくなり、隠された行があることを示す視覚的な表示はなくなります。変数がセットされると、それは自動的にローカルになります。

バッファーのテキストの一部を隠す他の方法については、[Outline Mode](#Outline-Mode)を参照してください。

モードラインのオプション
------------------------

buffer size display
display of buffer size
size-indication-mode
バッファーのパーセント表示posは、ウィンドウの上端がバッファーのどの場所にあるかを100分率で示します。`M-x
size-indication-mode`とタイプしてSize Indicationモードをオンにすることにより、バッファーのサイズを追加で表示できます。サイズは以下のようにパーセント表示のすぐ後に表示されます:

    pos of size

sizeは、バッファーの文字数を人間が理解しやすい形式(‘`k`’は10^3、‘`M`’は10^6、‘`G`’は10^9などの短縮形が使用されます)で表示します。

line number display
display of current line number
line-number-mode
Line Numberモードが有効なとき、ポイント位置の現在の行番号はモードラインに表示されます。`M-x
line-number-mode`コマンドを使って、Line Numberモードのオンとオフを切り替えることができます(通常はオンです)。行番号はそれが何であるかを示す文字‘`L`’とともに、バッファーのパーセント表示posの後ろに表示されます。

Column Number mode
mode, Column Number
column-number-mode
同様に、`M-x column-number-mode`でColumn Numberモードをオンにすることにより、現在の列番号を表示できます。列番号は文字‘`C`’で示されます。しかし両方のモードが有効になっているときは、行番号と列番号は‘`L`’や‘`C`’ではなく、‘`(561,2)`’のようにカッコつきで表示されます。マイナーモードとこれらのコマンドの使い方については、[Minor Modes](#Minor-Modes)を参照してください。

column-number-indicator-zero-based
Column Numberモードでは、列番号はそのウィンドウの左マージンより0からカウントされます。1からカウントした列番号を表示したい場合は、`column-number-indicator-zero-based`を`nil`にセットしてください。

narrowing, and line number display
ナローイング([Narrowing](#Narrowing)を参照してください)によりバッファーを制限している場合、アクセスできる部分にもとづいた行番号が表示されます。そのため、これは`goto-line`の引数として使用するには適しません(ファイル全体にたいする行番号を見るには、`what-line`コマンドを使います)。

line-number-display-limit
バッファーが非常に大きい場合(`line-number-display-limit`の値より大)、速度が遅くなるのでEmacsは行番号を計算しません。そのためモードラインに行番号は表示されません。この制限を取り除くには、`line-number-display-limit`に`nil`をセットします。

line-number-display-limit-width
バッファーの行が長いときも、行番号の計算が遅くなります。この理由により、Emacsはポイントの近くの行の幅の平均文字数が、`line-number-display-limit-width`より大きいときは、行番号を表示しません。デフォルト値は200文字です。

display-time
time (on mode line)
Emacsはオプションで、時刻とシステムロードを、すべてのモードラインで表示できます。この機能を有効にするには、`M-x
display-time`とタイプするか、オプション`display-time-mode`をカスタマイズします。モードラインに追加される情報は以下のような形式です:

    hh:mmPM l.ll

display-time-24hr-format ここでhhとmmは時間と分で、後ろに‘`AM`’と‘`PM`’がつきます。l.llは、過去数分間における、システム全体で実行中または実行準備ができている(例: 利用可能なプロセッサー待ち)プロセスの平均数です(オペレーティングシステムがサポートしないフィールドは表示されません)。時刻を24時間表示にしたいときは、変数`display-time-24hr-format`に`t`をセットしてください。

mail (on mode line)
display-time-use-mail-icon
display-time-mail-face
display-time-mail-file
display-time-mail-directory
もし未読メールがある場合、ロードレベルの後ろに‘`Mail`’という単語が表示されます。グラフィカルなディスプレーでは、`display-time-use-mail-icon`をカスタマイズすることにより、‘`Mail`’のかわりにアイコンを使うことができます。これによりモードラインのスペースが多少節約できます。`display-time-mail-face`をカスタマイズして、メールの表示を目立たせることができます。`display-time-mail-file`を使ってチェックするメールファイルを指定したり、`display-time-mail-directory`で受信メールのディレクトリーを指定できます(ディレクトリー内の空でない普通のファイルは、新しい受信メールと判断されます)。

battery status (on mode line)
display-battery-mode
display-battery-mode
battery-mode-line-format
Emacsをラップトップコンピューターで実行している場合、コマンド`display-battery-mode`を使うか、変数`display-battery-mode`をカスタマイズすることにより、モードラインにバッテリー充電状況を表示できます。変数`battery-mode-line-format`は、バッテリーの充電状況の表示方法を決定します。モードラインに表示されるメッセージの正確さはオペレーティングシステムに依存しており、通常はバッテリーの充電トータルにたいする現在のバッテリー充電率が表示されます。

mode line, 3D appearance
attributes of mode line, changing
non-integral number of lines in a window
グラフィカルなディスプレーでは、モードラインは立体的に描画されます。この効果が気に入らない場合は、`mode-line`フェイスをカスタマイズして、`box`属性に`nil`をセットすることにより無効にできます。[Face Customization](#Face-Customization)を参照してください。

non-selected windows, mode line appearance
デフォルトでは、選択されていないウィンドウのモードラインは、`mode-line-inactive`と呼ばれる、別のフェイスで表示されます。選択されたウィンドウのモードラインだけが、`mode-line`フェイスで表示されます。これにより、どのウィンドウが選択されているかがわかりやすくなります。モードラインがないミニバッファーが選択されているときは、ミニバッファーをアクティブにしたウィンドウのモードラインが、`mode-line`で表示されます。結果として通常のミニバッファーの使用では、モードラインは変化しません。

mode-line-in-non-selected-windows
変数`mode-line-in-non-selected-windows`を`nil`にセットすることにより、`mode-line-inactive`の使用を無効にできます。これによりすべてのモードラインが、`mode-line`フェイスで表示されます。

eol-mnemonic-unix
eol-mnemonic-dos
eol-mnemonic-mac
eol-mnemonic-undecided
モードラインに表示される改行フォーマットは、変数`eol-mnemonic-unix`、`eol-mnemonic-dos`、`eol-mnemonic-mac`、および`eol-mnemonic-undecided`をセットすることにより、カスタマイズできます。

テキストが表示される方法
------------------------

characters (in text)
printing character
ほとんどの文字は、印字文字(printing characters)です。これらの文字がバッファーに存在すると、スクリーンにそのまま表示されます。印字文字にはASCIIの数字、文字、区切り文字、同様に多くの非ASCII文字が含まれます。

tab-width
control characters on display
ASCII文字セットには、印字されない制御文字(control characters)が含まれます。その中でも特別に表示されるものが2つあります。1つ目は改行文字(Unicodeのコードポイント`U+000A`)で、新しい行を開始するのに表示されます。2つ目はタブ文字(`U+0009`)で、次のタブストップ(通常は8文字ごと)までをスペースで表示します。タブを何文字のスペースで表示するかは、バッファーローカルな変数`tab-width`で制御され、1から1000の整数で指定しなければなりません。バッファーのタブ文字がどのように表示されるかは、コマンドとしてのTABの定義には関係ないことに注意してください。

他のASCII制御文字としては、`U+0020`(8進の40、10進の32)より下のコードがあり、それらはカレット(‘`^`’)と、その後ろに非制御文字バージョンの文字を続けて、`escape-glyph`フェイスで表示されます。たとえば文字‘`control-A`’(`U+0001`)は、‘`^A`’と表示されます。

octal escapes
ctl-arrow
コード`U+0080`(8進の200)から`U+009F`(8進の237)までのrawバイトは、`escape-glyph`フェイスにより、8進エスケープシーケンス(octal escape sequences)で表示されます。たとえば文字コード`U+0098`(8進の230)は、‘`\230`’と表示されます。バッファーローカルな変数`ctl-arrow`を`nil`に変更すると、ASCII制御文字も、カレットエスケープシーケンスではなく、8進エスケープシーケンスで表示されます。

nobreak-char-display
non-breaking space
non-breaking hyphen
soft hyphen
escape-glyph
face
nobreak-space
face
非ASCII文字の中には、ASCIIのスペースやハイフン(マイナス記号)と同じ外観を持つものがあります。そのような文字は、意識せずにバッファーに入力されたとき(たとえばyankなどで)、問題となることがあります。たとえばソースコードコンパイラーは通常、非ASCIIのスペースを、空白文字として扱いません。この問題に対処するため、Emacsはそのような文字を特別な方法(`U+00A0`(no-break space)は`nobreak-space`フェイス、`U+00AD`(soft hyphen)、`U+2010`(hyphen)、`U+2011` (non-breaking hyphen)は`nobreak-hyphen`フェイス)で表示します。これを無効にするには、変数`nobreak-char-display`を`nil`に変更します。この変数に非`nil`かつ非`t`の値を与えると、Emacsはハイライトされたバックスラッシュの後に、スペースまたはハイフンを表示します。

特定の文字コードの表示のカスタマイズは、ディスプレーテーブル(display table)によって行われます。section “Display Tables” in The Emacs Lisp Reference Manualを参照してください。

glyphless characters
characters with no font glyphs
glyphless-char
face
グラフィカルなディスプレーでは、Emacsが利用可能なフォントにグリフがない文字がいくつかあります。これらのグリフがない文字(glyphless characters)は、通常16進文字を含むボックスで表示されます。テキスト端末では、端末エンコーディング([Terminal Coding](#Terminal-Coding)を参照してください)で表示できない文字は、通常クエスチョン記号で表示されます。表示方法は、変数`glyphless-char-display-control`で制御できます。これらの文字の表示がより目立つように、`glyphless-char`フェイスをカスタマイズすることもできます。詳細は、section “Glyphless Character Display” in The Emacs Lisp Reference Manualを参照してください。

curly quotes, and terminal capabilities
curved quotes, and terminal capabilities
homoglyph
face
Emacsはカレントのディスプレイでcurved quotes(‘`‘`’と‘`’`’)が表示可能か判断を試みます。デフォルトでは、表示可能ならEmacsはメッセージやヘルプテキスト内のASCIIクォート(‘`` ` ``’と‘`'`’)をcurved quotesに変換します。ユーザーオプション`text-quoting-style`をカスタマイズすることにより、この変換を有効または無効にできます(section “Keys in Documentation” in The Emacs Lisp Reference Manualを参照)。

curved quotes(‘`‘`’、‘`’`’、‘`“`’、‘`”`’)をASCII文字と同様な外観で見ることができる場合、それらは`homoglyph`フェイスで表示されます。表示できないことが既知のcurved quotesは、それらのASCIIによる代替である‘`` ` ``’、‘`'`’、‘`"`’が`homoglyph`で表示されます。

カーソルの表示
--------------

text cursor
visible-cursor
テキスト端末では、カーソルの外見は端末により制御され、大部分はEmacsの制御が及びません。いくつかの端末は、普通の固定的なカーソルと、目立つ点滅カーソルの2種類を提供します。デフォルトではEmacsは目立つカーソルを使い、Emacsを開始または再開したときは、そのカーソルに切り替えます。変数`visible-cursor`が`nil`の場合、Emacsを開始または再開したとき、普通のカーソルを使います。

cursor-type
グラフィカルなディスプレーでは、より多くのテキストカーソルのプロパティを変更できます。カラーを変えるには、フェイス`cursor`の、属性`:background`を変更します(このフェイスの他の属性には、何を指定しても効果はありません。カーソルの下にあるテキストはフレームのバックグラウンドカラーを使って描画されます)。外見を変更するには、バッファーローカルな変数`cursor-type`をカスタマイズします。有効な値は、`box`(デフォルト)、`hollow`(中抜きのボックス)、`bar`(垂直のバー)、`(bar
. n)`(幅がnピクセルの垂直バー), `hbar`(水平バー)、`(hbar
. n)`(高さがnピクセルの水平バー)、または`nil`(カーソルなし)です。

blink-cursor-mode
cursor, blinking
blinking cursor
blink-cursor-mode
blink-cursor-blinks
blink-cursor-alist
デフォルトでは、カーソルは10回点滅する間にEmacsに何も入力がないと、点滅をストップします。そして何らかの入力イベントがあると、また0からカウントを再開します。変数`blink-cursor-blinks`をカスタマイズして、これを制御できます。変数の値には、何の入力もないとき点滅をストップする点滅回数を指定します。変数に0または負の値をセットすると、カーソルはずっと点滅したままになります。カーソルの点滅を無効にするには、変数`blink-cursor-mode`を`nil`に変更するか([Easy Customization](#Easy-Customization)を参照してください)、initファイルに以下の行を追加します:

      (blink-cursor-mode 0)

リスト変数`blink-cursor-alist`をカスタマイズして、カーソルが点滅をストップしたとき、どのように見えるかを変更できます。リストの各要素は、`(on-type
.
off-type)`という形式を指定します。on-typeには、点滅しているときのカーソルを指定します(on-typeには、上で説明したカーソルタイプを指定します)。そしてoff-typeには、点滅していないときのカーソルを指定します。

x-stretch-cursor
wide block cursor
タブ文字のように、特別に幅が広い文字もあります。そのような文字上にカーソルがあるとき、通常はデフォルトの文字幅で描画されます。カーソルを文字幅に伸ばすには、変数`x-stretch-cursor`を非`nil`値に変更してください。

cursor in non-selected windows
cursor-in-non-selected-windows
選択されていないウィンドウのカーソルは、通常点滅していない中抜きのボックスで表示されます(カーソルにバーを使っている場合、より細いバーで表示されます)。選択されていないウィンドウでカーソルを非表示にするには、変数`cursor-in-non-selected-windows`を`nil`に変更してください。

hl-line-mode
global-hl-line-mode
highlight current line
カーソルをよりはっきりと表示させるために、HL Lineモードを使用できます。このモードでは、ポイントを含む行がハイライトされます。現在のバッファーで有効または無効にするには、`M-x
hl-line-mode`を使います。このモードをグローバルに有効または無効にするには、`M-x
global-hl-line-mode`を使用してください。

行の切り詰め
------------

truncation
line truncation
Emacsは行を継続([Continuation Lines](#Continuation-Lines)を参照してください)するかわりに、長い行を切り詰めて表示できます。これは、スクリーンやウィンドウの幅より長い行は、全体が表示されないことを意味します。グラフィカルなディスプレーでは、行が切り詰められている場合、フリンジに小さな直矢印が表示されます。テキスト端末では、右端および/または左端の列に‘`$`’が表示されます。

truncate-lines
toggle-truncate-lines
水平スクロールは、自動的に行の切り詰めを引き起こします([Horizontal Scrolling](#Horizontal-Scrolling)を参照してください)。特定のバッファーにたいして行の切り詰めを明示的に有効にするには、コマンド`M-x
toggle-truncate-lines`を使います。これは変数`truncate-lines`をローカルに変更することで機能します。値が非`nil`のときは、長い行は切り詰められ、`nil`のときは複数のスクリーン行に分けられます。変数`truncate-lines`をセットすると、現在のバッファーにローカルに適用されます。値を変更するまでは、デフォルト値(`nil`)が使われます。

ウィンドウを分割して狭くなりすぎたとき、Emacsは自動的に行の切り詰めを有効にします。これを制御する変数`truncate-partial-width-windows`については、[Split Window](#Split-Window)を参照してください。

Visual Lineモード
-----------------

word wrap
このモードでは、通常の行継続の代わりに、単語での折り返しが使われます。通常の行継続のように、長い論理行は2行以上のスクリーン行に分割されます。しかしEmacsはウィンドウの右端(RTL言語:Right-To-Leftlanguageでは左端)の近くの、単語の境界で折り返すよう試みます。これは単語の途中で折り返さないことにより、可読性を高めるためです。

mode, Visual Line
Visual Line mode
visual-line-mode
global-visual-line-mode
単語での折り返しは、オプションのマイナーモードである、Visual Lineモードで有効になります。現在のバッファーでVisual Lineモードの有効と無効を切り替えるには、`M-x visual-line-mode`とタイプします。メニューバーからVisual Lineモードを有効にすることもできます(Optionsメニューから、サブメニュー‘`Line Wrapping in this
Buffer`’の、メニューアイテム‘`Word Wrap (Visual Line Mode)`’を選択します)。Visual Lineモードが有効なときは、モードラインのモード表示に‘`wrap`’という文字が表示されます。コマンド`M-x
global-visual-line-mode`は、全バッファーのVisual Lineモードを切り替えます。

beginning-of-visual-line
end-of-visual-line
next-logical-line
previous-logical-line
Visual Lineモードでは、いくつかのコマンドは論理行ではなくスクリーン行に作用します。`C-a` (`beginning-of-visual-line`)はスクリーン行の先頭に移動し、`C-e` (`end-of-visual-line`)はスクリーン行の最後に移動、`C-k` (`kill-visual-line`)はテキストをスクリーン行の最後までkillします。

論理行単位で移動するには、コマンド`M-x next-logical-line`または`M-x
previous-logical-line`を使います。これらのコマンドはVisual Lineモードが有効であるかにかかわらず、次または前の論理行に移動します。これらのコマンドを頻繁に使う場合は、キーを割り当てると便利でしょう。[Init Rebinding](#Init-Rebinding)を参照してください。

デフォルトでは、単語の折り返し表示はフリンジに表示されません。Visual Lineモードは、長い論理行を含むファイルを編集するときに使われる場合があり、折り返し行すべてにフリンジの表示をすると見にくくなるためです。これを変更するには、変数`visual-line-fringe-indicators`をカスタマイズしてください。

ディスプレーのカスタマイズ
--------------------------

このセクションでは、Emacsスクリーンの外観を制御するさまざまな変数を説明します。初心者はスキップして構いません。

display-line-numbers
number lines in a buffer
display line numbers
Emacsにバッファー内の各行にたいして行番号を表示させたい場合は、バッファーローカルな変数`display-line-numbers`(デフォルトは`nil`)をカスタマイズします。この変数は行番号表示のさまざまなモードをサポートするために、いくつかの異なる値をもつことができます。

`t`  
バッファーテキストを表示する継続行ではないスクリーン各行の前に、、(絶対)行番号を表示します。その行が継続行の場合、またはスクリーン行全体がディスプレイ文字列(display string)、またはオーバーレイ文字列(overlay string)の場合、その行に番号は振られません。

`relative`  
バッファーテキストを表示する非継続行の前に、相対行番号(relative line number)を表示します。行番号はポイントを表示する行にたいして相対的なので、カレント行から遠ざかるにしたがって、行番号は増加または減少します。

`visual`  
この値により、Emacsにビジュアル的に行をカウントさせます。実際にディスプレイに表示されている行だけがカウントされ、ラップして複数行を占めるスクリーン行は、複数回番号付けされます。表示される番号は、上述の値`relative`のように相対的です。これはOutlineモード([Outline Mode](#Outline-Mode)を参照)のような、テキストをフォールド(fold: 折り畳む)するモードで、正確なスクリーン行の番号により移動するときに役立つでしょう。

その他  
その他の非`nil`値は、`t`として扱われます。

display-line-numbers-mode
global-display-line-numbers-mode
display-line-numbers-type
コマンド`M-x
display-line-numbers-mode`は、行番号表示を切り替える便利な方法を提供します。このモードのグローバル版は、`global-display-line-numbers-mode`です。ユーザーオプション`display-line-numbers-type`は、上述した行番号表示のサブモードのどのモードをアクティブにするかを制御します。

たとえグローバルに`display-line-numbers-mode`をオンにしていても、ミニバッファーやツールチップ内に行番号は表示されないことに注意してください。

display-line-numbers-current-absolute
Emacsが相対行番号を表示しているとき、カレント行(ポイントを表示している行)の前に表示される番号を制御できます。デフォルトでは、Emacsはカレント行にたいしては、他のすべての行が相対行番号であっても、絶対行番号を表示します。変数`display-line-numbers-current-absolute`を`nil`値にカスタマイズした場合、カレント行に表示される番号は0になります。これはカレント行の番号が重要ではなく、大きなバッファー内のテキストにたいして、より多くの水平方向の空きを残したいとき便利でしょう。

display-line-numbers-widen
ナロー([Narrowing](#Narrowing)を参照)されたバッファーでは通常、ナローイングの先頭から番号が開始されます。しかし、変数`display-line-numbers-widen`を非`nil`値にカスタマイズした場合、ナローイングは無視されて、そのバッファーの最初の文字から行番号が開始されます。

display-line-numbers-width-start
display-line-numbers-grow-only
display-line-numbers-width
Selective Display(選択的表示)モード([Selective Display](#Selective-Display)を参照)、およびその他の(OutlineモードやOrgモードのような)ディスプレイから多くの行を隠すモードでは、行番号のために予約済みのスペースにたいする法則性のない計算ミスを避けるために、変数`display-line-numbers-width-start`および`display-line-numbers-grow-only`のカスタマイズ、または`display-line-numbers-width`に十分大きな値をセットしたいと思うかもしれません。

line-number
face
行番号は、特別なフェイス`line-number`で表示されます。カレント行番号は異なるフェイス`line-number-current-line`で表示されるので、ポイントを表示する行を見つける助けとなるように、カレント行番号に異なる外観を与えることができます。

visible-bell
変数`visible-bell`が非`nil`の場合、Emacsは通常ベルサウンドを鳴らす場面で、スクリーン全体を点滅するよう試みます。端末がスクリーンを点滅させる方法を持たないとき、この変数は効果がありません。

echo-keystrokes
変数`echo-keystrokes`は、複数文字キーのエコー表示を制御します。値にはエコーが開始されるまでの秒数を指定します。0の場合、エコーされません。何かエコーされるべきものがあるときは、この変数の値が効果をもちます。[Echo Area](#Echo-Area)を参照してください。

mouse pointer
hourglass pointer display
display-hourglass
hourglass-delay
グラフィカルなディスプレーでは、Emacsはビジーのときにマウスポインターを砂時計で表示します。この機能を無効にするには、変数`display-hourglass`に`nil`をセットします。変数`hourglass-delay`は、砂時計が表示されるまでのビジーな時間を、秒数で指定します。デフォルトは1です。

make-pointer-invisible
マウスポインターがEmacsのフレーム内にある場合、文字をタイプしてテキストを挿入するまでの間、テキストを隠さないよう、Emacsはマウスポインターを非表示にします(正確に言うとマウスポインターの非表示は、自己挿入的(self-inserting)な文字をタイプしたときです。[Inserting Text](#Inserting-Text)を参照してください)。マウスポインターを動かすと、再び表示されます。この機能を無効にするには、変数`make-pointer-invisible`に`nil`をセットしてください。

underline-minimum-offset
x-underline-at-descent-line
グラフィカルなディスプレーでは、変数`underline-minimum-offset`は、アンダーラインされたテキストの、アンダーラインから文字の基底線までの最小距離を、ピクセルで決定します。デフォルトでは値は1です。この変数を増加させると、特定のフォントにおいて、アンダーラインされたテキストの可読性が向上します(しかしEmacsは、カレント行にはアンダーラインを描画しません)。変数`x-underline-at-descent-line`は、テキストにアンダーラインを引く方法を決定します。デフォルトは`nil`で、これはフォントの基底線と同じレベルに描画されることを意味します。これを`t`に変更すると、Emacsはフォントが同じ大きさになるよう、アンダーラインを少し下に描画します。(アンダーラインされるテキストにたいして非デフォルトの行間が指定された場合、Emacsは追加される行間の下にアンダーラインを描画する。section “Line Height” in The Emacs Lisp Reference Manualを参照されたい。)

overline-margin
変数`overline-margin`は、テキストの上のオーバーラインの垂直位置を、オーバーライン自身の高さも含めて、ピクセルで指定します。デフォルトは2です。

tty-suppress-bold-inverse-default-colors
テキスト端末には、bold(太字)かつ反転されたテキストが読みにくいものがあります。関数`tty-suppress-bold-inverse-default-colors`に、引数非`nil`を与えて呼び出すと、このような場合のbold-faceの効果を抑制します。

display-raw-bytes-as-hex
デフォルトでは、rawバイトは8進形式で表示されます。たとえば10進値が128のバイトは`\200`のように表示されます。これを16進形式の`\x80`で表示するよう変更するには、変数`display-raw-bytes-as-hex`を`t`にセットしてください。

検索と置換
==========

searching
finding strings within text
他のエディターと同様、Emacsには文字列を検索(search)するコマンドがあります。Emacsには、文字列を違う文字列で置き換える(replace)コマンドもあります。また、同じことを行いますが、固定文字列ではなくパターンを検索するコマンドもあります。

`xref`の制御下にある複数ファイルにたいして検索したり(([Identifier Search](#Identifier-Search)を参照してください)、Diredの`A`コマンドを通じて検索したり([Operating on Files](#Operating-on-Files)を参照してください)、`grep`コマンドを使った検索([Grep Searching](#Grep-Searching)を参照してください)も可能です。

インクリメンタル検索
--------------------

incremental search
isearch
Emacsにおける重要な検索コマンドは、インクリメンタル検索(isearch: incremental search)です。これは検索する文字列の最初の文字をタイプすると、すぐに検索が開始されます。検索文字列をタイプしていくにつれて、Emacsはその文字列(それまでに入力した文字列)がどこにあるかを表示します。望む場所を特定するのに充分な文字列をタイプしたところで、検索をストップできます。次に何をするかによって、明示的なRETにより検索を終えたり、続けることができます。

`C-s`  
前方にインクリメンタル検索します(`isearch-forward`)。

`C-r`  
後方にインクリメンタル検索します(`isearch-backward`)。

メニューバーの‘`Edit->Search`’メニューからインクリメンタル検索を呼び出すこともできます。

### インクリメンタル検索の基本

`C-s`  
インクリメンタル検索を開始します(`isearch-forward`)。

`C-r`  
逆向きのインクリメンタル検索を開始します(`isearch-backward`)。

C-s
isearch-forward
`C-s` (`isearch-forward`)は、前方へのインクリメンタル検索を開始します。これはキーボードから文字を読み取り、タイプした文字が最初に出現するバッファーの位置に、ポイントを移動します。

たとえば`C-s`とタイプした後に`F`をタイプすると、検索を開始したバッファーのポイント位置より前方にある、最初の`F`にカーソルを移動します。つぎに`O`をタイプすると、前方にある最初の‘`FO`’にカーソルが移動します。この場合、‘`FO`’の‘`F`’は、前に見つかった‘`F`’と同じ位置である必要はありません。もう一度`O`をタイプすると、カーソルは最初の‘`FOO`’に移動します。

faces for highlighting search matches
isearch
face
各ステップでEmacsはカレントマッチ(current match: 現在のマッチ)(検索文字列にマッチしたバッファーのテキスト)を、`isearch`フェイス([Faces](#Faces)を参照してください)でハイライトします。このハイライトをカスタマイズするさまざまなオプションについては、[Search Customizations](#Search-Customizations)を参照してください。その時点での検索文字列はエコーエリアにも表示されます。

isearch input item
input item, isearch
isearch-delete-char
DEL (Incremental search)
検索文字列のタイプ中に間違ったら、DEL(`isearch-delete-char`)とタイプしてください。DELをタイプするたびに、検索の間にエンターした最後の入力がキャンセルされます。検索文字列、ポイント位置、検索の成否、検索の方向、カレント検索結果の他端位置、検索の“ラッピング”を変更するコマンドのタイプ時、Emacsは常に新たな入力アイテム(input item)を記録します。失敗した検索を処理するための詳細は、[Error in Isearch](#Error-in-Isearch)を参照してください。

exit incremental search
incremental search, exiting
isearch-exit
RET (Incremental search)
検索により到達した位置に満足したら、RET (`isearch-exit`)をタイプします。これは検索をストップして、検索により移動した位置にカーソルを残します。検索とは関係ないコマンドも、検索をストップして、そのコマンドが実行されます。つまり`C-a`は検索をexitして行の先頭に移動し、矢印キーをタイプすると検索をexitして対応する移動コマンドが処理される、などとなります。RETで検索を終える必要があるのは、次のコマンドが印字文字をタイプするコマンドのときだけです。DEL、RETおよび他のいくつかの文字(`C-q`、`C-w`、`C-r`、`C-s`、`C-y`、`M-y`、`M-r`、`M-c`、`M-e`、および以下で説明する文字)は、検索で特別な意味を持っています。検索をexitするコマンドを微調整できます。[Not Exiting Isearch](#Not-Exiting-Isearch)を参照してください。

特別な例外として、検索文字列が空のときにRETを入力すると、非インクリメンタル検索([Nonincremental Search](#Nonincremental-Search)を開始します(これは"カスタマイズ可能"です。[Search Customizations](#Search-Customizations)を参照してください)。

isearch-abort
isearch-cancel
C-g C-g (Incremental Search)
ESC ESC ESC (Incremental Search)
検索を中止して検索を開始した位置に戻るには、`ESC ESC ESC` (`isearch-cancel`)、または`C-g C-g` (`isearch-abort`)とタイプしてください。

インクリメンタル検索を終了するとき、ポイントの元の位置をマークをアクティブにせず(ただしマークがすでにアクティブではなかったときだけ)に、マークリングに追加します。これにより、`C-u
C-SPC`、または`C-x C-x`を使って、検索を開始する前の位置に戻ることができます。[Mark Ring](#Mark-Ring)を参照してください(Emacsはマークがすでにアクティブでないときだけ、これを行ないます。検索を開始したときにマークがアクティブな場合は、`C-u
C-SPC`と`C-x C-x`の両方とも、マークに戻ります)。

C-r
isearch-backward
後方に検索するには、`C-s`で検索を開始するかわりに、`C-r` (`isearch-backward`)を使います。前方検索が検索を開始した位置より前方にある最初のマッチを探すように、後方検索は検索を開始した位置より後方にある最後のマッチを探します。

### インクリメンタル検索の繰り返し

C-s (Incremental Search)
C-r (Incremental Search)
isearch-repeat-forward
isearch-repeat-backward
前方に‘`FOO`’を検索してマッチしたが、それは探しているマッチではなく、探しているのはバッファーのもっと前方に出現する‘`FOO`’だとしましょう。ここでもう1度`C-s` (`isearch-repeat-forward`)をタイプすることにより、検索文字列が次に出現する場所に移動します。これは何回でも繰り返すことができます。もしタイプしすぎたときは、`C-s`コマンドをDELで取り消すことができます。同様に後方へのインクリメンタル検索では、`C-r` (`isearch-repeat-backward`)により後方検索が繰り返されます。

lazy search highlighting
インクリメンタル検索中に手を止めて眺めてみると、検索文字列にたいするカレントマッチ以外に、スクリーンに表示されている他のマッチもハイライトされていることがわかります。これは検索するために、何回`C-s`または`C-r`を繰り返せばよいのか予測しやすくするためです。その他のマッチは、カスタマイズ可能なフェイス`lazy-highlight` ([Faces](#Faces)を参照してください)を使って、現在のマッチとは異なってハイライトされます。この機能を無効にするには、`isearch-lazy-highlight`に`nil`をセットしてください。マッチのハイライトに関連するその他のカスタマイズについては、[Search Customizations](#Search-Customizations)を参照してください。

検索を終了した後、同じ文字列を再度検索するには、`C-s
C-s`とタイプします。最初の`C-s`はインクリメンタル検索を呼び出し、2回目の`C-s`は最後に検索した文字列の再検索を意味します。同様に、`C-r
C-r`は最後に検索した文字列を後方に検索します。最後に検索された文字列の決定では、その文字列が`C-s`で検索されたのか、`C-r`で検索されたのかは問題ではありません。

前方に検索していて、検索している対象が検索開始点より後方にあるのに気付いたときは、検索文字列を変更すること無く、`C-r`で後方検索に切り替えることができます。同様に後方検索で`C-s`をタイプすると、前方検索に切り替わります。

search, wrapping around
search, overwrapped
wrapped search
overwrapped search
検索が失敗したとき、バッファーの先頭から検索を再開するには、もう一度`C-s`をタイプします。逆向きの繰り返し検索が失敗したときは、`C-r`でバッファーの最後から検索を再開します。これはwrapping around(巻き直し)と呼ばれ、これが発生すると、‘`Wrapped`’という単語が検索プロンプトに表示されます。検索を続けて元の検索開始ポイントを通過すると、‘`Overwrapped`’に変化します。これはすでに見たマッチを再訪していることを意味します。

search ring
isearch-ring-advance
isearch-ring-retreat
M-n (Incremental search)
M-p (Incremental search)
search-ring-max
以前に検索した文字列を再利用するには、サーチリング(search ring)を使います。コマンド`M-p` (`isearch-ring-retreat`)または`M-n` (`isearch-ring-advance`)で、リングを移動して再使用したい文字列を取り出します。これらのコマンドは、選択されたリング要素の文字列をミニバッファーに残すので、それを編集することができます。`C-s`と`C-r`、またはRETとタイプすると、その文字列を受け入れて、その文字列にたいする検索を開始します。サーチリングの中に保存されている、最近使用された検索文字列の数は、変数`search-ring-max`で指定され、デフォルトは16です。

incremental search, edit search string
interactively edit search string
isearch-edit-string
M-e (Incremental search)
mouse-1 in the minibuffer (Incremental Search)
ミニバッファーの現在の検索文字列を、サーチリングのアイテムで置き換えずに編集するときは、`M-e` (`isearch-edit-string`)とタイプするか、ミニバッファーを`mouse-1`でクリックします。RET、`C-s`、`C-r`とタイプすれば、編集を終了してそれを検索できます。バッファーの検索を開始したポイントの後に続く文字を検索文字列に追加するには、`C-f`または`RIGHT`とタイプしてください。

### インクリメンタル検索でのyank

多くのケースで、ポイントの近くにあるテキストを検索文字列として使いたいことがあるでしょう。このサブセクションで説明されているコマンドにより、これを便利に行なえるようになります。

C-w (Incremental search)
isearch-yank-word-or-char
`C-w` (`isearch-yank-word-or-char`)は、検索された文字列のポイントの次の文字または単語を、検索文字列に追加します。これはポイント位置にあるテキストを検索する、簡単な方法です(コピーする対象を文字または単語のどちらにするかの決定は、発見的に行われます)。

M-s C-e (Incremental search)
isearch-yank-line
同様に`M-s C-e` (`isearch-yank-line`)は、検索文字列にカレント行の残りの部分を追加します。ポイントが既に行末にある場合、次の行が追加されます。プレフィクス引数nを指定すると、次のn行を追加します。

C-y (Incremental search)
M-y (Incremental search)
mouse-2 in the minibuffer (Incremental search)
isearch-yank-kill
isearch-yank-pop
isearch-yank-x-selection
インクリメンタル検索での`C-y` (`isearch-yank-kill`)は、カレントkillを検索文字列に追加します。`C-y`の後に`M-y` (`isearch-yank-pop`)が呼び出されると、追加するテキストを、もっと前にkillされたものに置き換えます。これは通常の`M-y` (`yank-pop`)コマンドと似ています([Yanking](#Yanking)を参照してください)。エコーエリアで`mouse-2`をクリックすることにより、はカレントのX選択([Primary Selection](#Primary-Selection)を参照してください)を検索文字列に追加します(`isearch-yank-x-selection`)。

C-M-w (Incremental search)
C-M-y (Incremental search)
isearch-del-char
isearch-yank-char
`C-M-w` (`isearch-del-char`)は検索文字列の最後の文字を削除し、`C-M-y` (`isearch-yank-char`)は検索されたポイントの後の文字を追加します。ポイントの後ろの文字を追加する他の方法は、`M-e`([Repeat Isearch](#Repeat-Isearch)を参照してください)でミニバッファーに移動してから、検索文字列の最後で`C-f`か`RIGHT`をタイプします。`C-f`か`RIGHT`をタイプするたびに、ポイントの後の文字が検索文字列に順次追加されます。

検索が大文字小文字を区別しない場合は通常、検索文字列にyankされるテキストは小文字に変換されるので、検索は大文字小文字を区別しないままです([case folding](#Lax-Search)を参照してください)。しかし、変数`search-upper-case` ([search-upper-case](#Lax-Search)を参照してください)の値が`not-yanks`以外の場合には、この小文字への変換は無効になります。

### インクリメンタル検索でのエラー

isearch-fail
face
文字列が見つからなかった場合、エコーエリアに‘`Failing
I-Search`’と表示されて、文字列とできるかぎりマッチした位置に、カーソルが移動します。つまり‘`FOOT`’を検索して‘`FOOT`’がない場合、カーソルは‘`FOOL`’という文字列の‘`FOO`’の後ろに移動します。エコーエリアではマッチに失敗した検索文字列の一部が、フェイス`isearch-fail`を使ってハイライトされます。

その時に行うことができる、いくつかの選択肢があります。もし文字列が間違っている場合は、文字列を訂正するために、DELで前の入力アイテム([Basic Isearch](#Basic-Isearch)を参照)を削除、一度に一文字削除するなら`C-M-w`、編集する場合は`M-e`とタイプします。もし見つかった位置が望む位置なら、RETをタイプしてその位置に留まることができます。または`C-g`をタイプして、検索文字列から検索できなかった文字(‘`FOOT`’の中の‘`T`’)を取り除き、検索された部分の文字列(‘`FOOT`’の中の‘`FOO`’)を残します。その位置でもう1回`C-g`をタイプすると、検索全体を取り消し、ポイントは検索を開始した位置に戻ります。

quitting (in search)
C-g (Incremental search)
終了コマンドの`C-g`は、検索において特別な処理を行います。このコマンドの動作は、検索の状況に依存します。もし指定した文字列の検索が成功して、さらに検索文字の入力を待っているとき、`C-g`は検索全体を取り消して、カーソルを検索を開始したときの位置に移動します。検索文字列に検索に失敗した文字が含まれているときに、`C-g`がタイプされたときは、検索文字列から検索に失敗した文字が取り除かれます。後に残るのは検索に成功した文字列で、さらに検索文字の入力を待っているので、先のケースと同様、2回目の`C-g`で検索全体が取り消されます。

### インクリメンタル検索の特別な入力

前のサブセクションで説明した文字に加えて、インクリメンタル検索のときにタイプする文字列の中には、特別な効果をもつものがあります。ここではそれらについて説明します。

lax space matching(「だらしない、ゆるんだ、緩慢な、締まりのない」スペースのマッチング。[lax space matching](#Lax-Search)を参照してください)を切り替えるには、`M-s SPC`とタイプします。

検索でcase sensitivity(大文字小文字を区別するか)を切り替えるには、`M-c`または`M-s
c`とタイプします。[case folding](#Lax-Search)を参照してください。検索文字列が大文字を含む場合、デフォルトではその検索はcase-sensitive(大文字小文字を区別)します。

検索が似ている文字、または等価な文字を考慮するかどうかを切り替えるには、`M-s '`とタイプします。[character folding](#Lax-Search)を参照してください。検索文字列にアクセント付きの文字が含まれる場合、その検索の間、character foldingは無効になります。

invisible text, searching for
M-s i (Incremental search)
isearch-toggle-invisible
非表示のテキストを検索するかしないかは、`M-s i` (`isearch-toggle-invisible`)とタイプして切り替えることができます。[Outline Search](#Outline-Search)を参照してください。

M-r (Incremental Search)
M-s r (Incremental Search)
isearch-toggle-regexp
インクリメンタル検索で、非正規表現による検索と、正規表現による検索を切り替えるには、`M-r`、または`M-s r` (`isearch-toggle-regexp`)とタイプします。[Regexp Search](#Regexp-Search)を参照してください。

シンボルモードを切り替えるには、`M-s _`とタイプします。[Symbol Search](#Symbol-Search)を参照してください。

改行文字を検索するには、検索文字列の途中で`C-j`とタイプします。

非ASCII文字を検索するには、以下の方法の1つを使います:

-   isearch-quote-char
    C-q (Incremental Search)
    `C-q` (`isearch-quote-char`)に続けて、非グラフィック文字か8進数字をタイプします。これは`C-q`を使ってバッファーに文字を挿入するのと同様に、検索文字列にタイプする文字を追加します([Inserting Text](#Inserting-Text)を参照してください)。たとえばインクリメンタル検索で`C-q
    C-s`をタイプすると、検索文字列に文字‘`control-S`’が追加されます。

-   isearch-char-by-name
    C-x 8 RET (Incremental Search)
    `C-x 8 RET` (`isearch-char-by-name`)に続けて、Unicode名か16進のコードポイントをタイプします。これは通常の`insert-char`コマンドと同様に、検索文字列に指定した文字を追加します([Inserting Text](#Inserting-Text)を参照してください)。

-   C-^ (Incremental Search)
    isearch-toggle-input-method
    isearch-toggle-specified-input-method
    入力メソッド(IM: input method)を使います([Input Methods](#Input-Methods)を参照してください)。検索を開始したとき、カレントバッファーで入力メソッドが有効の場合、ミニバッファーで検索もL字列をタイプするときにも、同じメソッドがアクティブになるでしょう。検索文字列をタイプするとき、`C-\\` (`isearch-toggle-input-method`)で、入力メソッドを切り替えることができます。非デフォルトの入力メソッドに切り替えるには、`C-^` (`isearch-toggle-specified-input-method`)を使います。これは入力メソッドの名前を尋ねます。インクリメンタル検索で入力メソッドがアクティブのとき、検索プロンプトには以下のようなニーモニックが含まれます。

        I-search [im]:

    imはアクティブな入力メソッドのニーモニックです。インクリメンタル検索で入力メソッドを有効にすると、カレントバッファーでも入力メソッドが有効のまま残ります。

M-s o (Incremental Search)
isearch-occur
インクリメンタル検索の中で`M-s
o`とタイプすることにより、カレントの検索文字列で`occur`を実行する、`isearch-occur`が呼び出されます。[occur](#Other-Repeating-Search)を参照してください。

isearch-query-replace
isearch-query-replace-regexp
M-% (Incremental search)
C-M-% (Incremental search)
インクリメンタル検索で`M-%` (`isearch-query-replace`)をタイプすると、`query-replace`または`query-replace-regexp`が呼び出され(検索モードに依存します)、現在の検索文字が置換対象になります。負のプレフィクス引数は、後方への置換を意味します。[Query Replace](#Query-Replace)を参照してください。`C-M-%` (`isearch-query-replace-regexp`)とタイプすることにより、カレント検索文字列を置換すべき正規表現として`query-replace-regexp`が呼び出されます。

isearch-complete
M-TAB (Incremental search)
インクリメンタル検索で`M-TAB`をタイプすると、`isearch-complete`が呼び出され、サーチリング(以前に使用された検索文字列)を補完リストとして使って、検索文字列の補完を試みます。[Completion](#Completion)を参照してください。多くのオペレーティングシステムでは、キーシーケンス`M-TAB`はウィンドウマネージャーに捕えられます。その場合、これを使うには`isearch-complete`を、他のキーシーケンスに再バインドする必要があります([Rebinding](#Rebinding)を参照してください)。

M-s h r (Incremental Search)
isearch-highlight-regexp
ディスプレーで最後に検索した文字列にたいするマッチをハイライトしたまま、検索をexitできます。これを行なうには、`M-s h r` (`isearch-highlight-regexp`)とタイプします。これは最後の検索文字列を継承するregexpと、ハイライトに表示するフェイスの入力を求めて、それらを引数として`highlight-regexp` ([Highlight Interactively](#Highlight-Interactively)を参照してください)を実行します。ハイライトを除去するには、`M-s h u` (`unhighlight-regexp`)とタイプしてください。

incremental search, help on special keys
C-h C-h (Incremental Search)
isearch-help-map
isearch-mode-map
インクリメンタル検索がアクティブのとき、`C-h C-h` (`isearch-help-map`)とタイプすると、特別なキーバインドのリストを含む、対話的なヘルプにアクセスできます。これらのキーバインドは、キーマップ`isearch-mode-map`の一部です([Keymaps](#Keymaps)を参照してください)。

### インクリメンタル検索を終了させない

このサブセクションでは、検索で特別な意味をもたないコマンドが、そのコマンドを実行する前に、検索をexitするかどうかを制御する方法を説明します。また、(たとえそれらがインクリメンタル検索の一部ではなくても)カレントのインクリメンタル検索をexitせずにタイプできる、2つのカテゴリーに属するコマンドを説明します。

search-exit-option
インクリメンタル検索によりバインドされていないコマンドをタイプすると通常、そのコマンドを実行する前に検索をexitします。したがって、そのコマンドは検索を呼び出したときのバッファーにたいして処理を行なうことになります。しかし、変数`search-exit-option`を`nil`にカスタマイズした場合、(インクリメンタル検索により解釈されないような)タイプした文字は、単に検索文字列に追加されます。これにより、通常は検索をexitして、その文字にバインドされているコマンドをそのバッファーにたいして呼び出す、`C-a`のような制御文字を検索文字列に含めることができるようになります。

プレフィクス引数  
prefix argument commands, during incremental search

isearch-allow-prefix

インクリメンタル検索でプレフィクス引数を指定したコマンドをタイプすると、デフォルトではその引数は次の検索アクションに適用されるか、検索をexitするコマンドに渡されます。他の言い方をすると、プレフィクス引数の入力自体は、検索を終了させません。

以前のバージョンのEmacsでは、プレフィクス引数の入力は常に検索を終了させていました。この振る舞いに戻すには、変数`isearch-allow-prefix`に`nil`をセットしてください。

`isearch-allow-scroll`が非`nil`のとき(以下を参照)、プレフィクス引数は上で説明したようなデフォルト動作をします。つまり、たとえ`isearch-allow-prefix`が`nil`でも、プレフィクス引数は検索を終了させません。

スクロールコマンド  
scrolling commands, during incremental search

isearch-allow-scroll

通常スクロールコマンドは、インクリメンタル検索を終了させます。変数`isearch-allow-scroll`を非`nil`値に変更すると、スクロールバーや`C-v`、`M-v`、`C-l`のようなスクロールコマンド([Scrolling](#Scrolling)を参照してください)が利用可能になります。これは、これらのコマンドをバウンドされたキーシーケンスで呼び出したときだけ適用されます。つまり`M-x`は依然として検索を終了させます。これらのコマンドには、通常の方法でプレフィクス引数を与えることができます。この機能ではカレントマッチが表示されない位置にスクロールすることはできません。

`isearch-allow-scroll`の機能は、正確にはスクロールではないが、テキストが表示されるスクリーン位置に影響する、`C-x
2` (`split-window-below`)や`C-x ^` (`enlarge-window`)のような、コマンドにも効果を及ぼします。これはコマンド名の`isearch-scroll`プロパティが非`nil`のコマンドに適用されます。そのため、どのコマンドが影響を受けるかは、それらのプロパティを変更して制御できます。

prevent commands from exiting incremental search

たとえば将来のEmacsセッションも含めて、インクリメンタル検索中に`C-h l`を使えれば便利だと思ったら、まず`C-h
c`で何のコマンドが実行されるか調べて([Key Help](#Key-Help)を参照してください)、それが`view-lossage`だとわかります。その後はinitファイルに以下を追加します([Init File](#Init-File)を参照してください)。

    (put 'view-lossage 'isearch-scroll t)

この機能はポイント、バッファー内容、マッチデータ、カレントバッファーや選択されているウィンドウ・フレームを変更しない任意のコマンドに適用できます。そして、そのコマンド自体がインクリメンタル検索を行ってはなりません。この機能は、`isearch-allow-scroll`が`nil`(デフォルト)の場合は無効です。

### ミニバッファーの検索

minibuffer history, searching
ミニバッファーがアクティブのときインクリメンタル検索を開始すると、Emacsはミニバッファーの内容を検索します。通常のバッファーにたいする検索とは異なり、エコーエリアはミニバッファーの表示に使われているので、検索文字列はエコーエリアには表示されません。

ミニバッファーでのインクリメンタル検索が失敗すると、ミニバッファーヒストリーを検索します。[Minibuffer History](#Minibuffer-History)を参照してください。ミニバッファーとミニバッファーのヒストリーは、一番古いヒストリー要素が最初で、カレントのミニバッファーが最後にある、一連のページとして視覚化することができます。前方検索の`C-s`は前方、つまり新しいページを検索し、後方検索の`C-r`は後方、つまり古いページを検索します。普通のバッファーの検索と同様、検索が失敗すると、最後から最初のページ、またはその逆に巻き直して検索します。

カレントマッチがヒストリーの要素にあった場合、ヒストリーの要素はミニバッファーに取り出されます。インクリメンタル検索を正常に終了(たとえばRETをタイプ)すれば、それはミニバッファーに残ります。検索を取り消すのは`C-g`で、これによりミニバッファーの内容は検索を開始したときのものに復元されます。

非インクリメンタル検索
----------------------

nonincremental search
Emacsには、従来式の非インクリメンタル検索もあります。これは検索を開始する前に、検索文字列全体を入力する必要があります。

`C-s RET string RET`  
stringを検索します。

`C-r RET string RET`  
後方にstringを検索します。

非インクリメンタル検索を開始するには、最初に`C-s
RET`をタイプします。これにより、検索文字列を読みとるために、ミニバッファーに移動します。検索文字列の入力を終了して検索を開始するには、RETをタイプします。文字列が見つからなかったとき、検索コマンドはエラーをシグナルします。

`C-s
RET`とタイプすると、`C-s`は通常どおりインクリメンタル検索を呼び出します。しかし、このコマンドは指定した文字列が空のとき、非インクリメンタル検索を行うコマンドを呼び出すよう、プログラムされています(そのような用途以外に空の引数は無意味です)。`C-r
RET`も同様に、後方に非インクリメンタル検索を行なうコマンドを呼び出します。

メニューバーの‘`Edit->Search`’メニューから非インクリメンタル検索を呼び出すこともできます。

search-forward
search-backward
よりシンプルな2つのコマンド、`M-x search-forward`と`M-x
search-backward`を使うこともできます。これらのコマンドは指定した文字をリテラルとして検索し、case folding(検索で大文字小文字を区別するか)を除くlax-search機能([Lax Search](#Lax-Search)を参照してください)をサポートしません。

単語検索
--------

word search
単語検索(word search)は、単語の並びを、その間にある区切り文字の種類とは無関係に検索します。たとえば検索文字列に、1つのスペースで区切られた2つの単語を入力すると、2つの単語を区切るのが、1つまたはそれ以上のスペース、改行文字、およびそれ以外の区切り文字の場合にもマッチします。これはテキスト文書を検索するとき特に有用です。なぜなら検索する単語が改行で区切られているのか、スペースで区切られているのか考慮しなくてもよいからです。プログラミング言語のためのメジャーモード、およびその他の特別なメジャーモード、そのモードの構文的なニーズに適合するように、単語の定義が変更されているかもしれないことに注意してください。

`M-s w`  
インクリメンタル検索がアクティブのとき、単語検索モードに切り替えます(`isearch-toggle-word`)。非アクティブのときは、前方へのインクリメンタルな単語検索を開始します(`isearch-forward-word`)。

`M-s w RET words RET`  
非インクリメンタルな単語検索を使って、wordsを前方検索します。

`M-s w C-r RET words RET`  
非インクリメンタルな単語検索を使って、wordsを後方検索します。

`M-s M-w`  
リージョン内のテキストにたいして、Webを検索します。

isearch-forward-word
isearch-toggle-word
M-s w
前方へのインクリメンタルな単語検索を開始するには、`M-s
w`とタイプします。インクリメンタル検索が非アクティブの場合、これはコマンド`isearch-forward-word`を実行します。インクリメンタル検索がすでにアクティブの場合(前方か後方かにかかわらず)、`M-s
w`は検索の方向と現在の検索文字列は変更せずに、単語検索に切り替えるコマンド`isearch-toggle-word`を実行します。単語検索をオフに切り替えるには、再度`M-s
w`をタイプしてください。

word-search-forward
word-search-backward
非インクリメンタルな単語検索を開始する場合、前方検索は`M-s w RET`、後方検索は`M-s w C-r
RET`をタイプします。これらはコマンド`word-search-forward`、または`word-search-backward`を実行します。

インクリメンタルな単語検索と、非インクリメンタルな単語検索では、マッチを見つける方法に若干の違いがあります。非インクリメンタルな単語検索では、検索文字列の各単語は、単語全体に厳密に一致しなければなりません。インクリメンタルな単語検索では、マッチの規則は緩くなります。検索文字列をタイプするとき、最初と最後の単語は、単語全体にマッチする必要はありません。これはタイプする度にマッチを処理するためです。これは(カーソルがある)カレントマッチ以外のマッチ(lazy matches。[Incremental Search](#Incremental-Search)を参照してください)には適用されません。それらは単語全体がマッチしなければハイライトされません。検索文字列をタイプしている間は、`C-s`のような検索繰り返しキーを使用するまで、検索プロンプトに‘`Pending`’が表示されます。

単語検索コマンドは、character foldingを処理せず、lax whitespace matching([lax space matching](#Lax-Search)を参照してください)が効果をもたないように切り替えます。

M-s M-w
eww-search-words
eww-search-prefix
Internet search
search Internet for keywords
リージョン内のテキストにたいしてWebを検索するには、`M-s
M-w`とタイプします。このコマンドは、変数`eww-search-prefix`により指定されたURLの検索エンジンを使用して、リージョン内の単語にたいするインターネット検索を行ないます(section “EWW” in The Emacs Web Wowser Manualを参照)。リージョンがアクティブでない場合、このコマンドはユーザーに検索するURL、またはキーワードの入力を求めます。

シンボル検索
------------

symbol search
シンボル検索(symbol search)は、通常の検索と似ていますが、検索の境界がシンボルの境界にマッチしていなければなりません。シンボルの意味は、メジャーモードのコンテキストに依存しており、Emacs LispモードでのLispシンボルのように、通常はソースコードのトークンを参照します。たとえばLispシンボル`forward-word`をインクリメンタルなシンボル検索すると、これは`isearch-forward-word`にはマッチしません。そのため、この機能は主にソースコードの検索に有用です。

`M-s _`  
isearch-toggle-symbol

インクリメンタル検索がアクティブのとき、シンボル検索モードに切り替えます(`isearch-toggle-symbol`)。非アクティブのときは、前方へのインクリメンタルなシンボル検索を開始します(`isearch-forward-symbol`)。

`M-s .`  
ポイントの近くにあるシンボルを、検索文字列の初期値に追加して、前方へのインクリメンタルなシンボル検索を開始します。

`M-s _ RET symbol RET`  
symbolにたいして、前方への非インクリメンタルな検索をします。

`M-s _ C-r RET symbol RET`  
symbolにたいして、後方への非インクリメンタルな検索をします。

M-s \_
M-s .
isearch-forward-symbol
isearch-forward-symbol-at-point
前方へのインクリメンタルなシンボル検索を開始するには、`M-s _`(ポイントの近くにシンボルがあるときは`M-s
.`)をタイプします。インクリメンタル検索が非アクティブのときは、コマンド`isearch-forward-symbol`が実行されます。すでにインクリメンタル前方へのインクリメンタルなシンボル検索を開始するには、`M-s
_`(ポイントの近くにシンボルがあるときは`M-s
.`)をタイプします。インクリメンタル検索が非アクティブのときは、コマンド`isearch-forward-symbol`が実行されます。すでにインクリメンタル検索がアクティブのとき、`M-s
_`は検索方向と現在の検索文字列を維持した状態で、シンボル検索に切り替えます(もう一度`M-s
_`をタイプすると、シンボル検索を無効にできます)。インクリメンタルなシンボル検索では、検索み文字列をタイプする間は、検索文字列の先頭がシンボルの先頭にマッチだけが必要であり、`C-s`のような検索繰り返しキーを使用するまでは検索プロンプトに‘`Pending`’が表示されます。

非インクリメンタルなシンボル検索は、前方への検索は`M-s _ RET`、後方への検索は`M-s _ C-r
RET`をタイプします。非インクリメンタル検索では、文字列の先頭と最後が、シンボルの先頭と最後にマッチする必要があります。

シンボル検索コマンドは、character foldingを処理せず、lax whitespace matching([lax space matching](#Lax-Search)を参照してください)が効果をもたないように切り替えます。

正規表現検索
------------

regexp search
search for a regular expression
正規表現(regular expression: regexpと略します)とは、文字列にマッチさせるための代替の文字列クラスを示すパターンです。Emacsはregexpにマッチする検索を、インクリメンタル、非インクリメンタルの両方で提供します。正規表現の構文は、次のセクションで説明します。

`C-M-s`  
インクリメンタルなregexp検索を開始します(`isearch-forward-regexp`)。

`C-M-r`  
逆方向のインクリメンタルなregexp検索を開始します(`isearch-backward-regexp`)。

C-M-s
isearch-forward-regexp
C-M-r
isearch-backward-regexp
regexpにたいするインクリメンタル検索は、`C-M-s` (`isearch-forward-regexp`をタイプするか、プレフィクス引数(引数の値は何でもよい)を指定して、`C-s`を呼び出します。前方へのインクリメンタル検索中は、`M-r`をタイプします。このコマンドは`C-s`と同様に、検索文字列をインクリメンタルに読みとりますが、検索文字列に正確に一致するバッファーのテキストを検索するのではなく、検索文字列をregexpとして扱います。検索文字列にテキストを追加する度に、regexpは長くなり、新しいregexpを検索します。後方へのregexp検索には、`C-M-r`(`isearch-backward-regexp`)またはプレフィクス引数を指定した`C-r`を使います。後方へのインクリメンタル検索中は`M-r`を使います。

regexp-search-ring-max
通常のインクリメンタル検索の特別なキーシーケンス(see [Special Isearch](#Special-Isearch))は、インクリメンタルなregexp検索でも同じようなことを行います。たとえば検索開始直後に`C-s`をタイプすると、最後に行ったインクリメンタル検索で使ったregexpで、前方検索を行います。インクリメンタルなregexpと非regexp検索は、独立したデフォルトを持ちます。これらは別のサーチリングも持っており、これには`M-p`と`M-n`でアクセスできます。サーチリングに保存される検索regexpの最大数は、`regexp-search-ring-max`の値により決定され、デフォルトは16です。

通常のインクリメンタル検索とは異なり、インクリメンタルregexp検索は、デフォルトではlax space matchingを使いません。この機能を切り替えるには、`M-s SPC` (`isearch-toggle-lax-whitespace`)を使います。そうするとインクリメンタルregexp検索でのSPCは、1つ以上の空白文字の並びにマッチするようになります。変数`search-whitespace-regexp`は、lax space matchingにたいするregexpを指定します。[Special Isearch](#Special-Isearch)を参照してください。

通常のインクリメンタル検索とは異なり、インクリメンタルなregexp検索ではcharacter folding([Lax Search](#Lax-Search)を参照してください)を使用できません(インクリメンタルregexp検索の途中で、`M-s '`によりcharacter foldingを切り替えた場合、検索は非regexp検索となり、タイプした検索パターンはリテラル文字列として解釈されます)。

インクリメンタルregexp検索では、検索文字列の追加によりカーソルが前に戻され、最初から検索しなおされることがありえます。たとえば検索文字列‘`foo`’に‘`\|bar`’を追加すると、カーソルは‘`foo`’から、それより前にある最初の‘`bar`’に戻ります。[Regexps](#Regexps)を参照してください。

前方および後方へのregexp検索は、対照的ではありません。なぜならEmacsでのregexpに対するマッチは常に前方へ処理され、regexpの先頭から開始されるからです。したがって前方へのregexp検索は前方にスキャンし、可能性のある開始位置から前方へとマッチを試みます。後方へのregexp検索は後方へスキャンし、可能性のある開始位置から前方へとマッチを試みます。これらの検索手法はミラーイメージではありません。

re-search-forward
re-search-backward
regexpにたいする非インクリメンタルな検索は、コマンド`re-search-forward`および`re-search-backward`で行われます。これらのコマンドは`M-x`から呼び出すか、インクリメンタルregexp検索からの`C-M-s
RET`および`C-M-r
RET`で呼び出します。`M-x`を使用してこれらのコマンドを呼び出した場合は、指定したregexpを厳密に検索するので、case foldingを除くlax-search機能([Lax Search](#Lax-Search)を参照してください)はサポートされません

プレフィクス引数を指定したインクリメンタルregexp検索は、`isearch-forward`や`isearch-backward`のような、通常の文字列を検索します。[Incremental Search](#Incremental-Search)を参照してください。

正規表現の構文
--------------

syntax of regexps
regular expression
regexp
このセクション(および、マニュアル全般)では、ユーザーが通常使う正規表現の機能を説明します。主にLispプログラムで使用される追加の機能については、section “Regular Expressions” in The Emacs Lisp Reference Manualを参照してください。

正規表現は、いくつかの特殊文字と、それ以外の普通の文字からなる構文を持ちます。通常の文字はそれと同じ文字にマッチし、それ以外の文字にはマッチしません。特殊文字は、‘`$^.*+?[\`’です。文字‘`]`’は、文字候補を終了させる場合は特殊文字です(以下参照)。文字‘`-`’は、文字候補の中では特殊文字です。正規表現の中に現れるその他の文字は、前に‘`\`’がついてない限り普通の文字です(Lispプログラム内で正規表現を使う場合、‘`\`’は2つ記述しなければなりません。このセクションの最後にある例を参照してください)。

たとえば‘`f`’は特殊文字ではなく普通の文字なので、正規表現中の‘`f`’は文字列‘`f`’にマッチし、他の文字列にはマッチしません(文字列‘`ff`’にはマッチ*しません*)。同様に正規表現中の‘`o`’は、‘`o`’だけにマッチします(大文字小文字を区別しない場合、これらのregexpは‘`F`’や‘`O`’にもマッチしますが、これを例外としてではなく、“同じ文字列”を一般化したものと考えます)。

2つの正規表現aとbを結合できます。結合した結果は、aが先頭の適当な部分に一致して、bが残りの部分に一致する正規表現となります。些細な例としては、‘`f`’と‘`o`’という正規表現を結合すると、正規表現‘`fo`’となり、これは文字列‘`fo`’だけにマッチします。ここまでは普通です。これより複雑ことを行うには、特殊文字を使う必要があります。以下にリストを示します。

`.` (ピリオド)  
これは改行文字以外の任意の1文字にマッチする特殊文字です。たとえば正規表現‘`a.b`’は、最初が‘`a`’で最後が‘`b`’の3文字の文字列にマッチします。

`*`  
単独では使用されません。これは接尾演算子で、前の正規表現の任意の回数、可能な限り多くの回数を含めた繰り返しを意味します。したがって‘`o*`’は任意の個数の‘`o`’にマッチし、‘`o`’がない場合(0個の場合)も含めてマッチします。

‘`*`’は常に可能な限り*小さな*、前置表現に適用されます。したがって‘`fo*`’は‘`fo`’の繰り返しではなく‘`o`’の繰り返しです。この正規表現は‘`f`’、‘`fo`’、‘`foo`’、...にマッチします。

マッチングにより構成される‘`*`’は、見つけられるだけの反復回数へと、直ちに処理されます。その後でパターンの残りの部分の処理を続けます。これが失敗すると、バックトラッキングが発生します。‘`*`’の反復回数をいくつか捨てて、パターンの残りの部分がマッチするように構成を変更します。たとえば文字列‘`caaar`’にたいして‘`ca*ar`’をマッチさせる場合、まず最初に‘`a*`’を、3つすべての‘`a`’にマッチさせます。しかしパターンの残りの部分は‘`ar`’ですが、マッチさせるために残っているのは‘`r`’だけなので、このマッチは失敗します。かわりに‘`a*`’を2つの‘`a*`’だけにマッチさせます。この選択により、regexpの残りの部分のマッチが成功します。

`+`  
これは‘`*`’と同様に接尾演算子ですが、前置表現に最低1回マッチしなければならない点が異なります。したがって‘`ca+r`’は‘`car`’、‘`caaaar`’にマッチしますが、‘`cr`’にはマッチしません。一方‘`ca*r`’は、これら3つすべての文字列にマッチします。

`?`  
これは‘`*`’と同様に接尾演算子ですが、前置表現が1回出現するか、出現しないかいずれかという点が異なります。したがって‘`ca?r`’は、‘`car`’または‘`cr`’のいずれかになります。

`*?`, `+?`, `??`  
non-greedy regexp matching

これらは上述した演算子の、非貪欲(greedy)なタイプの演算子です。通常の演算子‘`*`’、‘`+`’、‘`?`’は、regexpがマッチする、できる限り長いマッチを行います。しかしこれらの演算子に‘`?`’を後置すると、できる限り短いマッチを行います。

したがって‘`ab*`’と‘`ab*?`’は、両方とも文字列‘`a`’と文字列‘`abbbb`’にマッチしますが、文字列‘`abbb`’にマッチさせたとき、‘`ab*`’は文字列全体(有効な最長マッチ)にマッチしますが、‘`ab*?`’は‘`a`’(有効な最短マッチ)だけにマッチします。

非貪欲な演算子は、与えられた開始位置から開始される、できるだけ短い文字列にマッチします。前方検索では、利用できる一番最初の開始位置は、常にカーソルの位置となります。したがって末尾が改行のテキスト‘`abbab`’にたいして‘`a.*?$`’を検索すると、文字列全体にマッチします。これはマッチが最初の‘`a`’から開始されので、マッチさせることが*できる*のです。

`\{n\}`  
これはn回の繰り返しを指定する接尾演算子です。つまり前置される正規表現に、正確にn回連続でマッチしなければなりません。たとえば‘`x\{4\}`’は、文字列‘`xxxx`’だけにマッチします。

`\{n,m\}`  
これはn回からm回の繰り返しを指定する接尾演算子です。つまり前置される正規表現が、最低n回、最大m回マッチしなければなりません。mが省略されたときは、マッチ回数の上限はありませんが、前置される正規表現は少なくともn回マッチしなければなりません。 ‘`\{0,1\}`’は、‘`?`’と同じです。 ‘`\{0,\}`’は、‘`*`’と同じです. ‘`\{1,\}`’は、‘`+`’と同じです。

`[ … ]`  
これは‘`[`’で始まり‘`]`’で終わる、文字集合(character set)です。

もっとも簡単なケースでは、2つのカッコの間に指定された文字が、マッチできる文字集合となります。したがって‘`[ad]`’は1つの‘`a`’か1つの‘`d`’にマッチし、‘`[ad]*`’は‘`a`’と‘`d`’からなる任意の文字列にマッチします(空の文字列を含む)。結果として‘`c[ad]*r`’は、‘`cr`’、‘`car`’、‘`cdr`’、‘`caddaar`’、...にマッチします。

文字集合には、開始文字と終了文字の間に‘`-`’を記述することにより、文字の範囲を含めることもできます。したがって‘`[a-z]`’は、ASCII小文字となります。文字の範囲と特定の文字の指定を混ぜることもできます。‘`[a-z$%.]`’は任意のASCII小文字と‘`$`’、‘`%`’、‘`.`’にマッチします。別の例としては、‘`[α-ωί]`’はギリシャ文字の小文字すべてにマッチします。

いくつかの特別な文字クラス(character classes)を、文字集合に含めることもできます。文字の候補を含む文字クラスを‘`[:`’と‘`:]`’で囲んで指定します。たとえば‘`[[:alnum:]]`’は、任意のアルファベットと数字にマッチします。文字クラスのリストは、section “Char Classes” in The Emacs Lisp Reference Manualを参照してください。

文字集合に‘`]`’を含めるには、それを最初に記述しなければなりません。たとえば‘`[]a]`’は、‘`]`’または‘`a`’にマッチします。文字集合に‘`-`’を含めるには、‘`-`’を、文字集合の最初または最後に記述するか、文字範囲の外に記述します。したがって‘`[]-]`’は、‘`]`’と‘`-`’の両方にマッチします。

文字集合に‘`^`’を含めるには、集合の最初以外に記述します(最初に記述した場合、補集合を指定したことになります。以下を参照してください)。

大文字小文字を区別しない検索で文字の範囲を使う場合、範囲の先頭と最後を、大文字だけ、または小文字だけで記述するか、先頭と最後をアルファベット以外で記述するべきです。‘`A-z`’のような大文字小文字を混成した範囲指定は不正な定義で、Emacsの将来のバージョンで変更されるかもしれません。

`[^ … ]`  
‘`[^`’は文字の補集合complemented character setを開始します。つまり指定された文字以外がマッチします。したがって‘`[^a-z0-9A-Z]`’は、ASCII文字と数字*以外*にマッチします。

‘`^`’は文字集合で最初以外で使用された場合、特別な意味をもちません。‘`^`’に続く文字は、先頭にあるものとして扱われます(いいかえると‘`-`’と‘`]`’は、ここでは特別な意味をもちません)。

もしマッチしない文字として改行が記述されていなければ、文字の補集合を改行にマッチさせることができます。これは`grep`のようなプログラムにおける、regexpにたいする処理とは対照的です。

`^`  
これは空文字列、ただしテキストの行頭だけにマッチする特殊文字です。それ以外ではマッチに失敗します。したがって‘`^foo`’は行の先頭にある‘`foo`’にマッチします。

歴史的な互換性により、この意味での‘`^`’の使用は、正規表現の先頭か、‘`\(`’または‘`\|`’の後に記述された場合に限ります。

`$`  
‘`^`’と似ていますが、行末だけにマッチします。したがって‘`x+$`’は、行末にある1つ以上の‘`x`’にマッチします。

歴史的な互換性により、この意味での‘`$`’の使用は、正規表現の最後か、‘`\)`’または‘`\|`’の後に記述された場合に限ります。

`\`  
これには2つの機能があります。まず特殊文字(‘`\`’を含む)をクォートすることと、追加の特別な構成を導入することです。

‘`\`’は特殊文字をクォートするので、正規表現中の‘`\$`’は‘`$`’だけにマッチし、‘`\[`’は‘`[`’だけにマッチします。

‘`\`’で始まる特別な構成については、以下のセクションを参照してください。

注意: 歴史的な互換性から、特殊文字はそれが特殊な意味をもたないようなコンテキストで使用された場合は、通常の文字として扱われます。たとえば‘`*foo`’は、‘`*`’が特殊文字として動作するための前置された表現がないので、普通の文字として扱われます。このような振る舞いに依存することは、よい習慣ではありません。特殊文字を記述する場合、それがどこに記述されようとクォートするべきです。

文字集合の候補中では‘`\`’は特別ではなく、‘`-`’と‘`]`’のもつ特別な意味を除去することはありません。したがって、これらの文字が特別な意味をもたないような場所にあるときは、これらの文字をクォートすべきではありません。これでは明確ではないかもしれません。これらの特殊文字が特別な意味を*もつ*場所にあるとき、バックスラッシュを前置することによりクォートされるのです。たとえば‘`[^\]`’(Lispの文字記法では`"[^\\]"`)は、バックスラッシュ以外の任意の一文字にマッチします。

正規表現でのバックスラッシュ
----------------------------

多くの場合、任意の文字を伴う‘`\`’はその文字だけに一致します。しかしいくつか例外があって、‘`\`’で始まる2文字のシーケンスが、特別な意味を持つ場合があります。シーケンス内の2文字目にくる文字は、単独で使った場合には普通の文字として扱われるものです。以下は‘`\`’の構成の表です。

`\|`  
選択肢を指定します。2つの正規表現aとbの間に‘`\|`’を記述すると、それはaまたはbのいずれかにマッチする表現を形成します。これはまずaとのマッチを試み、失敗した場合にbとのマッチを試みます。

したがって‘`foo\|bar`’は、‘`foo`’または‘`bar`’のいずれかにマッチし、それ以外の文字列にはマッチしません。

‘`\|`’は、周囲の一番大きな表現に適用されます。‘`\|`’のグループ化の能力に制限をかけることができるのは、周囲の‘`\(
… \)`’によるグループ化だけです。

複数の‘`\|`’使用を処理するための、完全なバックトラッキング能力が存在します。

`\( … \)`  
3つの目的のためのグループ化構成です:

1.  他の操作に使うために、一連の選択肢‘`\|`’を括ります。したがって‘`\(foo\|bar\)x`’は、‘`foox`’または‘`barx`’のいずれかにマッチします。

2.  接尾演算子‘`*`’、‘`+`’、‘`?`’を適用できるように、複雑な正規表現を括ります。したがって‘`ba\(na\)*`’は、‘`bananana`’のように、(0個以上の)文字列‘`na`’にマッチします。

3.  あとで参照できるように、マッチした部分文字列を記録します。

この最後の使い方は、カッコでグループ化することが重要なのではありません。これは‘`\\( …
\\)`’構成の、2番目の意味とは異なる機能です。実際には、これら2つの機能が衝突することは、通常はありません。もし衝突するようなら、以下で説明する、shy(内気)なグループ化を使うことができます。

`\(?: … \)`  
shy group, in regexp

マッチした部分文字列を記録しない、shy(内気)なグループ化を指定します。マッチした部分文字列は、‘`\d`’により後方参照できません(以下参照)。この機能は正規表現を機械的にまとめるときに役立ちます。これにより後方参照するためのグループにたいする番号づけに影響することなく、文法的な目的によるグループ化を行うことができます。

`\d`  
back reference, in regexp

d番目に‘`\( … \)`’構成にマッチしたテキストと同じテキストにマッチします。これは後方参照(back reference)と呼ばれます。

最後の‘`\( …
\)`’構成の後で、マッチ処理はこの構成にマッチしたテキストの最初と最後を記録します。そして正規表現の後の部分で‘`\`’の後に数字dを使うことにより、d番目の‘`\(
… \)`’構成にマッチしたテキストと同じテキストにマッチさせることができます。

正規表現に記述された最初の9つの‘`\( …
\)`’にマッチしたテキストは、正規表現で開きカッコが出現した順に、1から9までの数字が割り当てられます。そのため‘`\1`’から‘`\9`’を使うことにより、‘`\(
… \)`’構成にマッチした、対応するテキストを参照することができます。

たとえば‘`\(.*\)\1`’は改行を含まない、前半と後半が同一の文字列にマッチします。‘`\(.*\)`’は、そのテキストが何であろうと前半にマッチしますが、‘`\1`’は前半と正確に同じテキストにマッチしなければなりません。

もし特定の‘`\( …
\)`’構成が１回以上マッチする場合(これは‘`*`’が後置されているとき簡単に発生します)、最後のマッチだけが記録されます。

`` \` ``  
空の文字列にマッチしますが、文字列またはバッファー(またはアクセスできる部分)の先頭に限定されます。

`\'`  
空の文字列にマッチしますが、文字列またはバッファー(またはアクセスできる部分)の最後に限定されます。

`\=`  
空の文字列にマッチしますが、ポイント位置に限定されます。

`\b`  
空の文字列にマッチしますが単語の先頭または最後に限定されます。したがって‘`\bfoo\b`’は、区切られた単語‘`foo`’にマッチします。‘`\bballs?\b`’は、別々の単語‘`ball`’または‘`balls`’にマッチします。

‘`\b`’は、そこにどんなテキストが出現しようと、バッファーの先頭または最後にもマッチします。

`\B`  
空の文字列にマッチしますが、単語の最初と最後*以外*にマッチします。

`\<`  
空の文字列にマッチしますが、単語の先頭に限定されます。‘`\<`’は単語の構成文字が続く場合に限り、バッファーの先頭にマッチします。

`\>`  
空の文字列にマッチしますが、単語の最後に限定されます。‘`\<`’は内容が単語の構成文字で終わる場合に限りバッファーの最後にマッチします。

`\w`  
任意の単語構成文字にマッチします。どの文字が該当するかは、構文テーブル(syntax table)により決定されます。section “Syntax Tables” in The Emacs Lisp Reference Manualを参照してください。

`\W`  
単語構成文字以外の任意の文字にマッチします。

`\_<`  
空の文字列にマッチしますが、シンボルの先頭に限られます。シンボルは１文字以上のシンボル構成文字からなります。シンボル構成文字は、‘`w`’と‘`_`’の構文をもつ文字です。‘`\_<`’はシンボル構成文字が続く場合に限り、バッファーの先頭にもマッチします。単語にたいしては、構文テーブル(syntax table)が、どの文字がシンボル構成文字かを判断します。

`\_>`  
空の文字列にマッチしますが、シンボルの最後に限定されます。‘`\_>`’は内容がシンボル構成文字で終わる場合に限り、バッファーの最後にマッチします。

`\sc`  
構文がcである、任意の文字にマッチします。ここでcとは、特定の構文クラスを表す文字です。したがって‘`w`’は単語構成文字、‘`-`’または‘`
`’は空白文字、‘`.`’は通常の区切り文字、などとなります。section “Syntax Tables” in The Emacs Lisp Reference Manualを参照してください。

`\Sc`  
構文がc以外の、任意の文字にマッチします。

categories of characters

characters which belong to a specific language

describe-categories

`\cc`  
カテゴリーcに属する、任意の文字にマッチします。たとえば‘`\cc`’は中国文字、‘`\cg`’はギリシャ文字にマッチします。既知のカテゴリーについての説明は、`M-x
describe-categories RET`をタイプしてください。

`\Cc`  
カテゴリーcに*属さない*、任意の文字にマッチします。

単語と構文に関係する構成は構文テーブルのセッティングにより制御されます。See section “Syntax Tables” in The Emacs Lisp Reference Manual.

正規表現の例
------------

以下にregexpの例を示します。これはEmacsがセンテンスの最後(末尾の空白は含まない)を認識するために、デフォルトで使用するregexp(たとえば変数`sentence-end-base`)と似ています。

    [.?!][]\"')}]*

これには2つの連続する部分があります。1つは‘`.`’、‘`?`’、‘`!`’にマッチする文字です。もう1つは閉じカッコ、クォート、カッコの0回以上の繰り返しです。

検索中のLaxマッチング
---------------------

lax search
character equivalence in search
あなたは通常、タイプした文字と、検索されるテキストの間にある、特定の瑣末な違いを、検索コマンドが無視することを望むでしょう。たとえば長さが異なる空白文字シーケンスは通常、等しいとみなされ、大文字小文字の違いは通常問題にならない、などです。これは等価文字(character equivalence)として知られています。

このセクションではEmacsのlax search(緩い検索)機能と、それを必要に応じて調整する方法について説明します。

lax space matching in search
M-s SPC (Incremental search)
SPC (Incremental search)
isearch-toggle-lax-whitespace
search-whitespace-regexp
デフォルトでは、検索コマンドはlax space matching(緩いスペースマッチング)を行います。これはスペースおよび一連のスペースは、テキスト中の1つまたはそれ以上の空白文字にマッチします(インクリメンタルregexp検索は別のデフォルトをもちます。[Regexp Search](#Regexp-Search)を参照してください)。したがって‘`foo bar`’は‘`foo bar`’、‘`foo  bar`’、‘`foo   bar`’、...にマッチします(‘`foobar`’にはマッチしません)。正確にいうと、Emacsは検索文字列中の一連のスペースを、変数`search-whitespace-regexp`で指定された正規表現にマッチさせます。たとえばスペースを一連の改行とスペースにマッチさせるには、変数に‘`"[[:space:]\n]+"`’をセットします。この変数のデフォルト値は、そのバッファーのメジャーモードに依存します。ほとんどのメジャーモードは、スペース、タブ、フォームフィード文字を空白文字としてクラス化します。

空白文字を正確にマッチさせたい場合は、インクリメンタル検索中に`M-s SPC` (`isearch-toggle-lax-whitespace`)とタイプすることにより、lax space matchingをオフに切り替えることができます。もう1度`M-s SPC`とタイプすると、lax space matchingふぁオンに切り替わります。すべての検索でlax space matchingを無効にするには、`search-whitespace-regexp`を`nil`に変更します。これにより検索文字列の中のスペースは、正確に1つのスペースにマッチするようになります。

case folding in search
case-sensitivity and search
Emacsでの検索では、検索文字列を小文字で指定した場合、デフォルトでは検索するテキストの大文字小文字は区別されません。したがって‘`foo`’を検索すると、‘`Foo`’や‘`fOO`’もマッチします。regexp、特に文字集合でも同様に振る舞います。つまり‘`[ab]`’は、‘`a`’、‘`A`’、‘`b`’、‘`B`’もマッチします。この機能はcase foldingとして知られており、これはインクリメンタル検索と非インクリメンタル検索の両方でサポートされています。

search-upper-case
検索文字列のどこかに大文字があると、検索はcase-sensitive(大文字小文字を区別する)になります。したがって‘`Foo`’を検索すると、‘`foo`’や‘`FOO`’は検索されません。これは正規表現検索でもリテラル文字列検索と同様に適用されます。検索文字列から大文字を削除すると、効果はなくなります。変数`search-upper-case`がこれを制御します。この変数が非`nil`(デフォルト)の場合、検索文字列の中の大文字は、検索をcase-sensitiveにします。これを`nil`にセットすることにより、大文字によるこの効果は無効になります。

case-fold-search
変数`case-fold-search`に`nil`をセットすると、すべての文字は大文字小文字を含めて、完全にマッチしなければなりません。これはバッファーごとの変数で、変数の変更はデフォルト値を変えない限り、通常はカレントバッファーだけが影響を受けます。[Locals](#Locals)を参照してください。これは置換コマンド([Replace](#Replace)を参照してください)や、ミニバッファーのヒストリー検索([Minibuffer History](#Minibuffer-History)を参照してください)を処理する、非インクリメンタル検索にも適用されます。

M-c (Incremental search)
M-s c (Incremental search)
isearch-toggle-case-fold
インクリメンタル検索で`M-c`、または`M-s c` (`isearch-toggle-case-fold`)とタイプすると、検索が大文字小文字を区別するかが、切り替わります。この効果は、現在の検索を超えて引き継がれませんが、カレントの検索にたいして大文字を追加・削除したときの効果をオーバーライドします.

特定のコマンドや操作にたいする検索やマッチングにおいて、大文字小文字の区別を制御する変数がいくつかあります。たとえば`tags-case-fold-search`は、`find-tag`での大文字小文字の区別を制御します。これらの変数を探すには、`M-x
apropos-variable RET case-fold-search RET`とタイプしてください。

character folding in search
equivalent character sequences
case foldingでは、文字の大文字小文字の違いを無視するので、大文字は小文字にマッチし、その逆もマッチします。case foldingを一般化したものがcharacter foldingで、これは類似した文字間の違いの、より広いクラスを無視します。たとえばcharacter foldingでは、文字`a`は`ä`や`á`のようなアクセント付きの類似文字にもマッチし、これらの変種を区別するための特殊記号も無視します。加えて`a`は、`a`に似ている他の文字や、U+249C PARENTHESIZED LATIN SMALL LETTER Aや、U+2100 ACCOUNT OF(これは小さい`c`の上に小さい`a`があるような外観をもちます)のような、文字のグラフィカルな外観の一部に`a`をもつ文字にもマッチします。同様にASCIIのダブルクォート文字`"`は、ダブルクォートの変種としてUnicode標準で定義されている、他のすべての変種にマッチします。最後に、character foldingにより、1つ以上の文字シーケンスは違う長さの他の文字にもマッチするようになります。たとえば2つの文字`ff`は、U+FB00 LATIN SMALL LIGATURE FFにマッチします。文字シーケンスはまったく同じではありませんが、character foldingでのマッチはequivalent character sequences(等価文字シーケンス)として知られています。

M-s ’ (Incremental Search)
isearch-toggle-char-fold
一般的にEmacsの検索コマンドは、デフォルトでは等価な文字シーケンスのマッチのためにcharacter foldingを行ないません。変数`search-default-mode`を`char-fold-to-regexp`にカスタマイズすることにより、この振る舞いを有効にできます。[Search Customizations](#Search-Customizations)を参照してください。インクリメンタル検索では、`M-s '` (`isearch-toggle-char-fold`)とタイプすることによりcharacter foldingが切り替わりますが、これはその検索だけです(置換コマンドは別のオプションによる異なるデフォルトをもちます。[Replacement and Lax Matches](#Replacement-and-Lax-Matches)を参照してください)。

case foldingと同様に、検索文字列の一部として明示的に`ä`のような文字の変種をタイプすることにより、その検索でのcharacter foldingが無効になります。検索文字列からそのような文字を削除すると、この効果はなくなります。

置換コマンド
------------

replacement
search-and-replace commands
string substitution
global substitution
Emacsは検索と置換を行うコマンドをいくつか提供します。単純な`M-x
replace-string`コマンドに加えて、出現する検索パターンごとに置換するかを問い合わせる`M-%` (`query-replace`)も提供します。

置換コマンドは通常、ポイント位置からバッファーの最後までのテキストにたいして処理を行います。リージョンがアクティブのときは、リージョンにたいして処理を行います([Mark](#Mark)を参照してください)。基本的な置換コマンドは1つの検索文字列(またはregexp)を、1つの置換文字列で置き換えます。コマンド`expand-region-abbrevs`を使用して、複数の置換を並行して処理することが可能です([Expanding Abbrevs](#Expanding-Abbrevs)を参照してください)。

### 無条件の置換

replace-string
`M-x replace-string RET string RET newstring RET`  
すべてのstringをnewstringで置換します。

ポイントの後にある‘`foo`’のすべてのインスタンスを‘`bar`’に置換するには、コマンド`M-x
replace-string`に2つの引数‘`foo`’と‘`bar`’を指定します。置換はポイントの後だけで発生するので、バッファー全体を置換したい場合は、最初にバッファーの先頭に移動しなければなりません。バッファーの最後までのすべてが置換されます。置換をバッファーの一部に制限したいときは、そのリージョン部分をアクティブにします。リージョンがアクティブのときは、置換はそのリージョンに制限されます([Mark](#Mark)を参照してください)。

`replace-string`が終了したとき、ポイントは最後に置換された位置に留まります。以前のポイント位置(`replace-string`コマンドを実行した場所)はマークリングに追加されるので(マークは非アクティブ)、`C-u
C-SPC`で戻ることができます。[Mark Ring](#Mark-Ring)を参照してください。

プレフィクス引数を指定すると、置換対象は単語単位に制限されます。

置換コマンドでのcase-sensitivity(大文字小文字の区別)とcharacter foldingについては、[Replacement and Lax Matches](#Replacement-and-Lax-Matches)を参照してください。

### 正規表現の置換

replace-regexp
`M-x replace-string`コマンドは、正確にマッチする単一の文字列を置換します。同様なコマンド`M-x
replace-regexp`は、指定した正規表現パターン([Regexps](#Regexps)を参照してください)にマッチするすべてを置換します。

`M-x replace-regexp RET regexp RET newstring RET`  
regexpにマッチするすべてをnewstringで置換します。

back reference, in regexp replacement
`replace-regexp`では、newstringが定数である必要はありません。regexpにマッチした全体、または部分を参照することができます。newstringでの‘`\&`’は、置換されるマッチ全体を表します。newstringでの‘`\d`’(dは1から始まる数字)は、regexp内でカッコでグループ化されたものの、d番目にマッチします(これは“後方参照(back reference)と呼ばれます”)。‘`\#`’は、このコマンドですでに置換された件数を10進数で参照します。最初の置換では‘`\#`’は‘`0`’で、2番目の置換では‘`1`’、...のようになります。たとえば、

    M-x replace-regexp RET c[ad]+r RET \&-safe RET

これは‘`cadr`’を‘`cadr-safe`’に、‘`cddr`’を‘`cddr-safe`’に置き換えます。

    M-x replace-regexp RET \(c[ad]+r\)-safe RET \1 RET

これは逆向きの置換をします。置換するテキストに‘`\`’を含めるときは、‘`\\`’と入力しなければなりません。

置換する文字列の一部を毎回手入力したいときは、置換文字列で‘`\?`’を使用します。すると置換ごとにミニバッファーで置換文字列を編集できます(ポイント位置は‘`\?`’を記述した場所です。)

このサブセクションの残りの部分は、Lispの知識が必要となる特別な処理を念頭に書かれています。大半の読者はスキップしても構いません。

置換文字列の一部を計算するために、Lisp式を使うことができます。これを行うには、置換文字列の中で、‘`\,`’に続けてLisp式を記述します。各置換において式の値が計算され、それをクォートされていない文字列に変換します(もし文字列の場合は、その文字列の内容が使われることを意味します)。そしてそれを置換文字列内で、式が記述された場所に使用します。もし式がシンボルのときは、シンボル名と、置換文字列中のシンボル名の後にあるの間に1つスペースは、両方シンボルの値に置換されます。

このような式の中では、いくつかの特別なシーケンスを使うことができます。式の中での‘`\&`’や‘`\d`’は、通常のようにマッチした文字列全体と、部分マッチした文字列を参照します。dには複数桁の数字を記述でき、カッコでグループ化されたd番目の正規表現がマッチしなかったとき、‘`\d`’は`nil`になります。‘`\#&`’と‘`\#d`’を使って、それらのマッチを数字で参照することもできます(これはマッチまたは部分マッチが数字書式の場合に有効です)。ここでの‘`\#`’も、すでに置換された数を意味します。

‘`x`’と‘`y`’の入れ替えは、以下の方法で行うことができます:

    M-x replace-regexp RET \(x\)\|y RET
    \,(if \1 "y" "x") RET

‘`\,`’により置換する文字列を計算するには、`format`関数が便利なときがあります(section “Formatting Strings” in The Emacs Lisp Reference Manualを参照してください)。たとえば73列目から80列目(もしそこに何もなければ)に、‘`ABC00042`’のような連番を振りたいときは、以下を使うことができます。

    M-x replace-regexp RET ^.\{0,72\}$ RET
    \,(format "%-72sABC%05d" \& \#) RET

### 置換コマンドとLaxマッチ

このサブセクションではlaxマッチに関する置換コマンドの振る舞いと、それをカスタマイズする方法を説明します。一般的には、ほとんどの置換は、それと同等な検索コマンドに比べて、デフォルトではより厳密なマッチを行ないます。

lax space matching in replace commands
replace-lax-whitespace
インクリメンタル検索とは異なり、置換コマンドはデフォルトではlax space matching(緩いスペースマッチング)を行いません([lax space matching](#Lax-Search)を参照してください)。置換でlax space matchingを有効にするには、変数`replace-lax-whitespace`を非`nil`に変更してください(これはEmacsが置換文字列ではなく、置換するテキストを検索する方法だけに影響を与えます)。

replace-regexp-lax-whitespace
`query-replace-regexp`がパターンを検索するときlax whitespace matchingを使うかどうかを制御するのは、それに対応する変数`replace-regexp-lax-whitespace`です。

case folding in replace commands
置換コマンドの最初の引数がすべて小文字の場合、置換のための検索において大文字小文字の違いを無視します。これは`case-fold-search`が非`nil`の場合です。`case-fold-search`を`nil`にセットすると、すべての検索において常に大文字小文字の違いが有効になります。

case-replace
さらにnewstringのすべて、または一部が小文字の場合、置換コマンドは大文字小文字が出現するパターンを維持しようと試みます。したがって以下のコマンド、

    M-x replace-string RET foo RET bar RET

は小文字の‘`foo`’を小文字の‘`bar`’で置換し、すべて大文字の‘`FOO`’を‘`BAR`’、そして最初が大文字の‘`Foo`’を‘`Bar`’に置換します。(これら3つの候補、すなわち小文字、すべて大文字、先頭が大文字は、`replace-string`が認識できる唯一のパターンです)。

置換文字列に大文字が使われている場合、テキストが挿入されるときは、常に大文字のままとなります。大文字が最初の引数で使用されている場合、大文字小文字の変換なしで、2番目の引数に与えられたとおりに置換されます。同様に`case-replace`と`case-fold-search`の両方が`nil`にセットされている場合、大文字小文字の変換なしで置換されます。

character folding in replace commands
デフォルトでは置換コマンドは、置換するテキストを探すとき、character folding([character folding](#Lax-Search)を参照してください)を使用しません。`query-replace`と`replace-string`でのマッチングでcharacter foldingを有効にするには、変数`replace-char-fold`に非`nil`値をセットします(このセッティングは、Emacsが置換するテキストを探す方法だけに影響し、置換するテキストには影響を与えません。また、`replace-regexp`にも影響を与えません)。

### 問い合わせつき置換

query replace
`M-% string RET newstring RET`  
任意のstringをnewstringで置換します。

`C-M-% regexp RET newstring RET`  
regexpにたいする任意のマッチをnewstringで置換します。

M-%
query-replace
‘`foo`’を‘`bar`’に置換するとき、すべてではなく、そのうちのいくつかだけを置換したいときは、`M-%` (`query-replace`)を使います。このコマンドは‘`foo`’を1つずつ検索して、それを置換するかを毎回尋ねます。この問い合わせを別とすれば、`query-replace`は`replace-string`と同様に機能します([Unconditional Replace](#Unconditional-Replace)を参照してください)。通常のように、`case-replace`が非`nil`のときは、大文字小文字を区別します([Replacement and Lax Matches](#Replacement-and-Lax-Matches)を参照してください)。数引数を指定すると、単語区切り文字で区切られた単語だけを考慮します。負のプレフィクス引数は後方に置換します。

C-M-%
query-replace-regexp
`C-M-%` (`query-replace-regexp`)は、regexpの検索と置換を行います。これは`query-replace`のように問い合わせを行う以外は、`replace-regexp`と同様に機能します。

query-replace-from-to-separator
これらのコマンドで行なった以前の置換を再利用できます。`query-replace`や`query-replace-regexp`が検索文字列の入力を求めるプロンプトを表示しているとき、`M-p`と`M-n`を使用することにより、‘`from
->
to`’という形式で、以前の置換を表示できます。ここでfromは検索パターン、toはそれの置換、これらの間に表示されるセパレータは変数`query-replace-from-to-separator`の値により決定されます。望む置換が表示されたら、RETとタイプしてそれを選択します。この変数の値が`nil`の場合、置換はコマンドヒストリーに追加されず、再利用できません。

faces for highlighting query replace
query-replace
face
lazy-highlight
face, in replace
query-replace-highlight
query-replace-lazy-highlight
query-replace-show-replacement
これらのコマンドは、カレントのマッチを、フェイス`query-replace`を使ってハイライトします。変数`query-replace-highlight`を`nil`にセットすることにより、このハイライトを無効にできます。他のマッチのハイライトにはインクリメンタル検索([Incremental Search](#Incremental-Search)を参照してください)と同様に、フェイス`lazy-highlight`が使われます。変数`query-replace-lazy-highlight`を`nil`にセットすることにより、このハイライトを無効にできます。デフォルトでは`query-replace-regexp`は、カレントマッチを置換する展開後の文字列を、ミニバッファーに表示します。特別なシーケンス‘`\&`’および‘`\n`’を展開せずに維持するには、`query-replace-show-replacement`変数をカスタマイズしてください。

query-replace-skip-read-only
変数`query-replace-skip-read-only`に非`nil`がセットされている場合、置換コマンドはread-only(読み取り専用)のテキスト内のマッチを無視します。デフォルトでは、それらを無視しません。

以下は文字列またはregexpにたいするマッチが表示されているときにタイプできる文字です:

`SPC`; `y`  
マッチをnewstringで置き換えます。

`DEL`; `Delete`; `BACKSPACE`; `n`  
カレントマッチを置換せずに次のマッチへスキップします。

`, (カンマ)`  
カレントマッチを置換して、結果を表示します。そして次に何をするかを文字入力するよう促します。置換がすでに行われているので、この状況ではDELとSPCは等価で、どちらも次のマッチへ移動します。

ここで`C-r`(以下を参照)をタイプして、置換されたテキストを編集できます。`C-x
u`をタイプして、置換を取り消すこともできます。これは`query-replace`を終了させるので、さらに置換を行う場合は、`C-x
ESC ESC RET`で置換を再開しなければなりません([Repetition](#Repetition)を参照してください)。

`RET`; `q`  
これ以上の置換を行わずに終了します。

`. (ピリオド)`  
カレントマッチを置換してから、これ以上の検索を行わずに終了します。

`!`  
これ以上の問い合わせをせずに、残りのマッチをすべて置換します。

`^`  
前のマッチの位置に戻ります。これは間違えて変更したときや、再検証したい場合に使います。

`u`  
最後の置換をアンドゥ(undo: 取り消し)して、その置換が行われた位置に戻ります。

`U`  
すべての置換をアンドゥして、最初の置換が行われた位置に戻ります。

`C-r`  
再帰編集レベル(recursive editing level)に入ります。これはマッチをnewstringで置換するだけでなく、編集したい場合に使用します。編集を終えたら`C-M-c`で再帰編集レベルを抜けて、次のマッチを処理します。[Recursive Edit](#Recursive-Edit)を参照してください。

`C-w`  
マッチを削除してから、`C-r`と同様に再帰編集レベルに入ります。これはstringを削除してから、テキストを挿入することにより置換を行う場合に使用します。編集を終えたら`C-M-c`で再帰編集レベルを抜けて、次のマッチを処理します。

`e`  
置換文字列をミニバッファーで編集します。RETでミニバッファーを抜けると、カレントマッチをミニバッファーの内容で置換します。この新しい置換文字列は、残りのマッチにたいしても適用されます。

`C-l`  
スクリーンを再描画します。その後でカレントマッチにたいして何を行うか、別の文字をタイプして指定しなければなりません。

`Y (大文字)`  
複数バッファーの置換で、残りのバッファーの、残りのマッチをすべて置換します(これは選択したファイルにたいして問い合わせつきの置換を行う、Diredの`Q`コマンドと似ています)。これはすべての一連の問い合わせにたいして、これ以上のユーザーとの対話なしに“yes”を答えます。

`N (大文字)`  
複数バッファーの置換で、カレントバッファーの残りのマッチを置換せずに、次のバッファーへスキップします。これはカレントバッファーのマッチにたいする問い合わせに“no”を答えて、次のバッファーへと処理を続けます。

`C-h`; `?`; `F1`  
上述したオプションの要約を表示します。その後でカレントマッチにたいして何を行うか、別の文字をタイプして指定しなければなりません。

これらのエイリアス文字以外の文字は、`query-replace`を終了してから、キーシーケンスの残りの部分を読みとります。したがって`C-k`とタイプすると、`query-replace`を終了してから、行末までをkillします。特に、`C-g`は単に`query-replace`をexitします。

一度終了した`query-replace`を再開するには、`C-x ESC
ESC`を使います。`query-replace`は引数の読み取りにミニバッファーを使っているので、このキーシーケンスで再開させることができます。[C-x ESC ESC](#Repetition)を参照してください。

invisible text, and query-replace
オプション`search-invisible`は、`query-replace`が非表示のテキストを扱う方法を決定します。[Outline Search](#Outline-Search)を参照してください。

選択されたファイルにたいして問い合わせつきの置換を行う、Diredの`Q`コマンドについては、[Operating on Files](#Operating-on-Files)を参照してください。regexpにマッチするファイル名にたいして、ファイル名の変更、ファイルのコピー、ファイルのリンクを行うDiredのコマンドについては、[Transforming File Names](#Transforming-File-Names)を参照してください。

その他の検索およびループコマンド
--------------------------------

ここでは正規表現にたいするマッチを検索する、その他のコマンドを説明します。これらのコマンドは、パターンに大文字が含まれていないカ、`case-fold-search`が非`nil`のときは、マッチングで大文字小文字を区別しません。常にバッファー全体を検索する`multi-occur`と`multi-occur-in-matching-buffers`をのぞき、これらはすべて、ポイント位置からバッファーの最後まで、リージョンがアクティブなときはそのリージョンにたいして処理を行います。

`M-x multi-isearch-buffers`  
１つ以上のバッファー名の入力を求め(RETで終了)、それらのバッファーにたいして複数バッファーのインクリメンタル検索を開始します(あるバッファーでの検索に失敗すると、次の`C-s`により、指定された次のバッファーへと検索を試みます)。プレフィクス引数を指定すると、regexpの入力を求め、regexpにマッチするバッファーにたいして、複数バッファーでのインクリメンタル検索を開始します。

multi-isearch-buffers-regexp

`M-x multi-isearch-buffers-regexp`  
このコマンドは`multi-isearch-buffers`と同様ですが、インクリメンタルなregexp検索を行います。

multi-isearch-files

isearch multiple files

multiple-file isearch

`M-x multi-isearch-files`  
１つ以上のファイル名の入力を求め(RETで終了)、それらのファイルにたいして複数ファイルのインクリメンタル検索を開始します(あるファイルで検索に失敗すると、次の`C-s`により、指定された次のファイルへと検索を試みます)。プレフィクス引数を指定すると、regexpの入力を求め、regexpにマッチするファイルにたいして、複数ファイルでのインクリメンタル検索を開始します。

multi-isearch-files-regexp

`M-x multi-isearch-files-regexp`  
このコマンドは`multi-isearch-files`と同様ですが、インクリメンタルなregexp検索を行います。

バッファーローカルな変数`multi-isearch-next-buffer-function`をセットするいくつかのモード(たとえばChange Logモード)では、複数ファイルにたいするインクリメンタル検索は自動的にアクティブになります。

Occur mode

mode, Occur

match (face name)

list-matching-lines-default-context-lines

list-matching-lines-jump-to-current-line

M-s o

occur

`M-x occur`; `M-s o`  
regexpの入力を求め、それへのマッチを含むバッファー内の各行をリスト表示します。プロンプトで`M-n`をタイプした場合は、前のインクリメンタル検索から検索文字列を再利用できます。マッチするテキストは、`match`フェイスを使用してハイライトされます。数引数nを指定すると、そのコンテキストでマッチした各行の、前後n行を表示します。

コンテキスト行のデフォルト行数は、変数`list-matching-lines-default-context-lines`により指定されます。`list-matching-lines-jump-to-current-line`が非`nil`のとき、カレント行はフェイス`list-matching-lines-current-line-face`でハイライト表示され、ポイントはその行の最初のマッチの後にセットされます。

インクリメンタル検索がアクティブのときは`M-s o`を実行して、カレントのサーチリングを使うこともできます。

あなたがタイプしたregexpにたいするマッチは完全な行を含むように拡張され、1つ前のマッチの終了の前から開始するマッチは考慮されないことに注意してください。

RET (Occur mode)

o (Occur mode)

C-o (Occur mode)

`*Occur*`バッファーでは、エントリーをクリックするか、ポイントをそこに移動してRETをタイプすることにより、検索されたバッファーの対応する位置をvisitします。`o`と`C-o`はマッチを他のウィンドウに表示します(`C-o`はそのウィンドウを選択しません)。かわりに`` C-x
` `` (`next-error`)コマンドを使うことにより、マッチした場所を1つ1つvisitできます([Compilation Mode](#Compilation-Mode)を参照してください)。

Occur Edit mode

mode, Occur Edit

`*Occur*`バッファーで`e`をタイプすることにより、Occur Editモードに切り替えます。このモードではエントリーにたいする編集結果が、元のバッファーのテキストに適用されます。`C-c
C-c`とタイプすることにより、Occurモードに戻ります。

list-matching-lines

コマンド`M-x list-matching-lines`は、`M-x occur`の別名です。

multi-occur

`M-x multi-occur`  
このコマンドは`occur`と同じですが、複数のバッファーを検索する点が異なります。このコマンドは、1つずつバッファー名の入力を求めます。

multi-occur-in-matching-buffers

`M-x multi-occur-in-matching-buffers`  
このコマンドは`multi-occur`と似ていますが、visitしているファイル名にマッチする正規表現を指定することにより、検索するバッファーを指定する点が異なります。プレフィクス引数を指定すると、正規表現にマッチするバッファー名となります。

how-many

`M-x how-many`  
regexpの入力を求め、バッファーのポイント位置以降に、何個のマッチがあるか表示します。リージョンがアクティブのときは、リージョンにたいして操作を行います。

flush-lines

`M-x flush-lines`  
regexpの入力を求め、ポイント以降にあるテキストにたいして、マッチが含まれている行を削除します。カレント行のポイント以降にマッチする文字列が含まれているときは、カレント行を削除します。リージョンがアクティブのときは、リージョンにたいして操作を行います。行の一部ににリージョンが含まれていて、さらにマッチの全体がリージョンに含まれているとき、その行は削除されます。

マッチが行をまたいでいる場合、`flush-lines`はそれらの行すべてを削除します。このコマンドは行を削除してから、次のマッチを検索します。したがって、1行にマッチ全体と、次の行にまたがるマッチが両方含まれるとき、次の行にまたがるマッチは無視されます。

keep-lines

`M-x keep-lines`  
regexpの入力を求め、ポイント以降にあるテキストにたいして、マッチを*含まない*行を削除します。ポイントが行の先頭でない場合、このコマンドは常にカレント行を維持します。リージョンがアクティブのときは、リージョンにたいして操作を行います。このコマンドは一部がリージョンに含まれるだけの行は削除しません(行を終端する改行は、その行の一部と判断します)。

マッチが行をまたぐ場合、このコマンドはそれらすべての行を維持します。

必要に応じて検索を調整する
--------------------------

search customizations
このセクションでは、他では説明されていない、その他の検索に関連した機能を説明します。

default search mode
search mode, default
インクリメンタル検索にたいするデフォルトの検索モードは、変数`search-default-mode`により指定されます。この変数には、`nil`、`t`、または関数を指定できます。`nil`の場合、デフォルトのモードはcharacter foldingなしのリテラル検索です。しかし、case foldingにたいしては`case-fold-search`、lax-whitespace matchにたいしては`search-whitespace-regexp`により決定されます([Lax Search](#Lax-Search)を参照してください)。値が`t`の場合、インクリメンタル検索のデフォルトはregexp検索になります。デフォルト値には、case foldingとlax-whitespace matchingだけを行なう関数が指定されています。

search-highlight
継続的なインクリメンタル検索でのカレントマッチは、`isearch`フェイスでハイライトされます。変数`search-highlight`を`nil`にセットすることにより、このハイライトを無効にできます。

lazy highlighting customizations
isearch-lazy-highlight
lazy-highlight
face
ディスプレーに表示されている、検索文字列にたいするその他のマッチは、`lazy-highlight`フェイスを使用してハイライトされます。変数`isearch-lazy-highlight`をセットして、このハイライトを無効にできます。以下はlazy-highlightをカスタマイズする、その他の変数です:

`lazy-highlight-initial-delay`  
表示されているマッチをハイライトするまでwaitする秒数です。

`lazy-highlight-interval`  
マッチをハイライトする秒数です。

`lazy-highlight-max-at-a-time`  
入力をチェックする前にハイライトする、マッチの最大数です。大きな数を指定するとハイライトに時間を要するかもしれず、その間に検索を継続するために`C-s`や`C-r`をタイプしても、それらすべてのマッチのハイライトを終了するまで、Emacsは反応しないでしょう。したがって小さな数を指定することにより、Emacsの反応を改善できます。

search-nonincremental-instead
インクリメンタル検索で検索文字列が空のときにRETを入力すると、通常これは非インクリメンタル検索を開始します(実際には、これにより検索文字列の編集が開始され、次のRETで検索を行ないます)。しかし、変数`search-nonincremental-instead`を`nil`にセットした場合、検索文字列が空でも、RETのタイプは常にインクリメンタル検索をexitします。

isearch-hide-immediately
デフォルトではインクリメンタル検索および問い合わせ付き置換コマンドは不可視のテキストにもマッチしますが、そのようなマッチは隠され、不可視のテキストの外にできるだけ早くカレントマッチを移動させます。変数`isearch-hide-immediately`を`nil`にカスタマイズした場合、マッチが見つかった任意の不可視テキストは、検索または置換コマンドがexitするまで表示され続けます。

search display on slow terminals
search-slow-speed
search-slow-window-lines
遅い回線で接続されたリモートマシンのディスプレーなど、遅い端末でインクリメンタルな検索をすると、検索によりディスプレーの大きな範囲を再描画しなければならないことが、煩わしくなるかもしれません。Emacsは、遅い端末にたいして特別なディスプレーモードを提供します。これは検索が別の小さなウィンドウをポップアップして、マッチの周辺テキストをそのウィンドウに表示します。小さいウィンドウは早く表示できるので、遅いスピードの影響による煩わしさは軽減されます。変数`search-slow-speed`は、Emacsがこのディスプレーモードを使用する、ボーレートの下限値を決定します。変数`search-slow-window-lines`は、Emacsがポップアップして検索結果を表示するウィンドウの行数を制御します(デフォルトは1)。このウィンドウは通常、検索を開始したバッファーを表示するウィンドウの下部にポップアップされますが、`search-slow-window-lines`の値が負の場合、ウィンドウは上部に配され、`search-slow-window-lines`の絶対値が表示される行数になります。

タイプミスを訂正するコマンド
============================

typos, fixing
mistakes, correcting
このチャプターでは、編集中に間違いに気付いたときに便利なコマンドを説明します。これらのコマンドの中でもっとも基本的なのは、undoコマンド`C-/`です(これは`C-x
u`と`C-_`にもバインドされています)。これは1つのコマンドやコマンドの一部(`query-replace`の場合など)、または連続するいくつかの文字の挿入を取り消します。連続して`C-/`を繰り返すと、前へ前へと変更を取り消し、undo情報が利用できる限界までさかのぼって、変更を取り消します。

ここで説明するコマンドとは別に、DEL (`delete-backward-char`)のような削除コマンドでもテキストを消去できます。これらのコマンドは、このマニュアルの前のチャプターで説明しています。[Erasing](#Erasing)を参照してください。

Undo(取り消し)
--------------

undo
changes, undoing
undo(取り消し)コマンドは、バッファーのテキストにたいする最後の変更を無効にします。バッファーはそれぞれ変更を個別に記録しており、undoコマンドは常にカレントバッファーに適用されます。バッファーのレコードにより、バッファーにたいするすべての変更をundoできます。通常、個々の変種コマンドは、undoレコードに個別のエントリーを作成しますが、`query-replace`のようないくつかのコマンドは、undo操作に柔軟性をもたせるために、コマンドによる変更を複数のエントリーに分割します。連続した文字の挿入コマンドは、undo操作の冗長性をなくすために、通常1つのundoレコードにまとめられます。

`C-/`; `C-x u`; `C-_`  
カレントバッファーのundoレコードの、1エントリーでundoします(`undo`)。

C-x u
C-\_
C-/
undo
undoを開始するには、`C-/`(またはエイリアスの`C-_`か`C-x
u`)をタイプします[6]。これは一番最近のバッファーにたいする変更を取り消して、バッファーが変更される前の位置にポイントを戻します。連続して`C-/`(またはそれのエイリアス)を繰り返すと、現在のバッファーにたいする変更を、前へ前へとさかのぼって取り消します。すでに記録されている変更がすべて取り消されているとき、undoコマンドはエラーをシグナルします。

redo
undo-only
undo以外のコマンドは、undoコマンドの順序性を損ないます。undo以外のコマンドを開始した時点から、undoしてきた一連のundoコマンド全体が、undoレコードとして記録されます。したがってundoした変更を再適用するには、undoの順序性を損なわないような`C-f`のようなコマンドをタイプしてから、`C-/`を1回以上タイプして、undoコマンドをundoしていきます。

以前のundoコマンドを再実行せずにundoを再開したいときは、かわりに`M-x
undo-only`を使います。これは`undo`と同様ですが、すでにundoした変更を再実行しません。

バッファーをうっかり変更してしまったのに気付いたら、モードラインのアスタリスクが表示されなくなるまで`C-/`を繰り返しタイプするのが、もっとも簡単な復旧方法です。undoコマンドによりモードラインのアスタリスクが消えたとき、それはバッファーの内容がファイルを最後に読み込んだとき、または保存したときと同じ内容だということを意味します。バッファーを意図して変更したか覚えていないときは、`C-/`を1回タイプします。最後の変更がundoされたのを確認して、それが意図した変更なのか確かめます。もしそれが意図しない変更だったならundoしたままにします。意図した変更だった場合、上で説明した方法で変更を再実行します。

かわりに`M-x
revert-buffer`を使用して、そのバッファーが最後にvisitされたとき、または最後に保存されたとき以降のすべての変更を破棄できます([Reverting](#Reverting)を参照)。

selective undo
C-u C-/
アクティブなリージョンがあるとき、`undo`は選択的なundo(selective undo)を行います。これはバッファー全体ではなく、リージョンにたいして一番最近の変更をundoします。しかしTransient Markモードがオフのとき([Disabled Transient Mark](#Disabled-Transient-Mark)を参照してください)、`C-/`は、リージョンではなく、常にバッファー全体を操作します。この場合`undo`コマンドにプレフィクス引数を指定（`C-u
C-/`)することにより、選択的なundoができます。同じリージョンにたいしてさらに変更をundoしたいときは、`undo`コマンドを繰り返します(プレフィクス引数は必要ありません)。

undoレコードを作らない、特別なバッファーがいくつかあります。それは名前がスペースで始まるバッファーです。これらのバッファーはEmacsにより内部的に使用されており、通常ユーザーが閲覧したり編集しないテキストを保持します。

undo-limit
undo-strong-limit
undo-outer-limit
undo limit
バッファーにたいするundo情報が大きくなりすぎたとき、Emacsは一番古いレコードを、時々(ガベージコレクション(garbage collection)の間)廃棄します。変数`undo-limit`、`undo-strong-limit`、`undo-outer-limit`をセットすることにより、どれだけのundo情報を保持するか指定することができます。これらの値はバイト数で指定します。

変数`undo-limit`は、ソフトリミットをセットします。Emacsはこのサイズに達するまでのコマンドのundoデータを保持します。制限を超えることもあり得ますが、これを超える古いデータは保持しません。デフォルト値は80000です。変数`undo-strong-limit`は、厳密なリミット(stricter limit)をセットします。この制限を超えるような以前のコマンド(一番最近のコマンドではない)は記憶されません。`undo-strong-limit`のデフォルト値は120000です。

これらの変数の値にかかわらず、一番最近の変更はundo情報が`undo-outer-limit`(通常は12,000,000)より大きくならない限り、廃棄されることはありません。もしこれを超えるような場合、Emacsはundoデータを廃棄して、それにたいする警告を発します。これは一番最近のコマンドをundoできない唯一の状況です。これが発生した場合、将来同じことが起こらないように`undo-outer-limit`の値を増やすことができます。しかしコマンドがそのような大きなundoデータを作るとは考えられない場合、それは多分バグなので、それを報告すべきです。[Reporting Bugs](#Bugs)を参照してください。

テキストの入れ替え
------------------

`C-t`  
2つの文字を入れ替えます(`transpose-chars`)。

`M-t`  
2つの単語を入れ替えます(`transpose-words`)。

`C-M-t`  
バランスのとれた2つの式を入れ替えます(`transpose-sexps`)。

`C-x C-t`  
2つの行を入れ替えます(`transpose-lines`)。

C-t
transpose-chars
2つの文字を入れ違いに入力してしまう間違いはよくありますが、それらが隣接しているときは`C-t`(`transpose-chars`)コマンドで訂正できます。通常`C-t`はポイントの左右にある文字を入れ替えます。行末でこのコマンドを使う場合、最後の文字と改行を入れ替えるのはおそらく無意味なので、`C-t`は行末の2文字を入れ替えます。このような入れ違いミスにすぐ気付いたときは、`C-t`だけで訂正できます。すぐに間違いに気付かなかった場合、`C-t`をタイプする前に、入れ替えて入力してしまった文字の間にカーソルを移動しなければなりません。単語の最後の文字とスペースを入れ替えて入力してしまった場合、そこに戻るには単語移動コマンド(`M-f`、`M-b`など)が良い方法です。それ以外では、逆向きの検索(`C-r`)が最善な方法の場合があります。[Search](#Search)を参照してください。

C-x C-t
transpose-lines
M-t
transpose-words
`M-t`は、ポイントの前にある単語と、後にある単語を入れ替えます(`transpose-words`)。このコマンドはポイントより後方、またはポイントがある単語を前方に移動して、ポイントをその後に移動します。文字の間にある区切り文字は移動しません。たとえば‘`FOO,
BAR`’は、‘`BAR FOO,`’ではなく、‘`BAR, FOO`’に入れ替わります。

`C-M-t` (`transpose-sexps`)も似ていますが、これは2つの式([Expressions](#Expressions)を参照してください)を入れ替えます。そして`C-x
C-t` (`transpose-lines`)は、行を入れ替えます。これらは`M-t`と同様に動作しますが、入れ替えを行うテキスト単位が異なります。

入れ替えコマンドに数引数を指定すると、反復回数になります。これは入れ替えコマンドに、ポイントより前(またはポイントがある)の移動させる文字(または単語、式、行)を、何文字(または単語、式、行)後に移動させるか指示します。たとえば`C-u
3
C-t`は、ポイントの前にある文字を3文字後ろに移動します。つまり‘`f★oobar`’は‘`oobf★ar`’に変更されます。これは`C-t`を3回繰り返したのと同じです`C-u
- 4 M-t`はポイントの前にある単語を、後方に単語4つ分移動します。`C-u -
C-M-t`は、引数を指定しない`C-M-t`の効果を取り消します。

数引数0には特別な意味が割り当てられています(繰り返し回数としては、0に意味がありません)。これはポイントの後ろで終わる文字(または単語、式、行)を、マーク位置で終わる文字(または単語、式、行)と入れ替えます。

大文字小文字の変換
------------------

`M-- M-l`  
最後に入力した単語を小文字に変換します。`Meta--`はメタとマイナスであることに注意して下さい。

`M-- M-u`  
最後に入力した単語をすべて大文字に変換します。

`M-- M-c`  
最後に入力した単語の先頭を大文字、それ以外を小文字に変換します。

M-
-
M-l
M-
-
M-u
M-
-
M-c
単語の大文字小文字を間違えてタイプするのは、とても一般的な間違えです。そのため、単語の大文字小文字の変換コマンド`M-l`、`M-u`、`M-c`に負の数引数を指定すると、カーソルを移動しないという特性があります。最後に入力した単語のタイプミスに気付いたら、単に大文字小文字を変換して、タイプを続けることができます。[Case](#Case)を参照してください。

スペルのチェックと訂正
----------------------

spelling, checking and correcting
checking spelling
correcting spelling
このセクションでは、1つの単語、またはバッファーの一部のスペルをチェックするコマンドを説明します。これらのコマンドはHunspell、Aspell、Ispell、またはEnchantのうちのいずれかのスペルチェッカープログラムがインストールされている場合だけ機能します。これらのプログラムはEmacsの一部ではありませんが、GNU/Linuxまたは他のフリーなオペレーティングシステムには、通常1つはインストールされています。 section “Aspell” in The Aspell Manualを参照してください。

`M-$`  
ポイントがある単語スペルの、チェックと訂正をします(`ispell-word`)。リージョンがアクティブのときは、リージョンに含まれるすべての単語にたいして行います。

`M-x ispell`  
バッファーにある単語スペルの、チェックと訂正をします。リージョンがアクティブのときは、リージョンに含まれるすべての単語にたいして行います。

`M-x ispell-buffer`  
バッファーにある単語スペルの、チェックと訂正をします。

`M-x ispell-region`  
リージョンにある単語スペルの、チェックと訂正をします。

`M-x ispell-message`  
メールメッセージのドラフト(引用部分を除く)にたいして、単語スペルのチェックと訂正をします。

`M-x ispell-change-dictionary RET dict RET`  
スペルチェッカーのプロセスを再起動して、dictを辞書として使用させます。

`M-x ispell-kill-ispell`  
スペルチェッカーのサブプロセスをkillします。

`M-TAB`; `ESC TAB`; `C-M-i`  
ポイントの前にある単語を、スペル辞書をもとに補完します(`ispell-complete-word`)。

`M-x flyspell-mode`  
スペルミスした単語をハイライトする、Flyspellモードを有効にします。

`M-x flyspell-prog-mode`  
コメントと文字列にたいして、Flyspellモードを有効にします。

M-$
ispell-word
ポイントの前または周囲にある単語スペルをチェックしたり訂正するには、`M-$` (`ispell-word`)をタイプします。リージョンがアクティブのときは、リージョン内のすべての単語スペルをチェックします。[Mark](#Mark)を参照してください(Transient Markモードがオフのとき、`M-$`はリージョンを無視して、常にポイントの前または周囲の単語にたいして動作します。[Disabled Transient Mark](#Disabled-Transient-Mark)を参照してください)。

ispell
ispell-buffer
ispell-region
spell-checking the active region
同様に、コマンド`M-x
ispell`はリージョンがアクティブのときはリージョン、それ以外のときはバッファー全体にたいして、スペルチェックを行います。コマンド`M-x
ispell-buffer`および`M-x
ispell-region`は、スペルチェックをバッファー全体にたいして行うのか、リージョンにたいして行うかを明示します。このコマンドはバッファー全体をチェックしますが、インデントされているテキストと、以前のメッセージの引用と思われるテキストはチェックしません。[Sending Mail](#Sending-Mail)を参照してください。

これらのコマンドは、正しくないと思われる単語に出会うと、それをどうするかを尋ねます。通常は番号が振られた近い単語(near-misses: 正しくないと思われる単語に似た単語)のリストを表示します。これにたいして1文字をタイプして応答しなければなりません。以下は有効な応答文字です。

`数字`  
今回だけは近い単語の一覧で単語を置き換えます。近い単語には番号が振られており、選択するにはその番号をタイプします。

`SPC`  
その単語を間違いと判断することは変更しませんが、その単語をここでは変更せずスキップします。

`r new RET`  
今回は単語をnewで置き換えます(置換文字列にスペルエラーがないか再スキャンされます)。

`R new RET`  
単語をnewで置き換え、`query-replace`を実行します。これによりバッファーの他の箇所の間違えを置換できます(置換にスペルエラーがないか再スキャンされます)。

`a`  
正しくないと思われる単語を正しいものとして受け入れますが、それは今回の編集セッションに限られます。

`A`  
正しくないと思われる単語を正しいものとして受け入れますが、それは今回の編集セッションとそのバッファーに限られます。

`i`  
この単語をプライベートな辞書ファイルに挿入するので、今後(将来のセッションを含めて)はその単語を正しいと認識します。

`m`  
`i`と同様ですが、辞書の補完情報も指定できます。

`u`  
この単語の小文字バージョンを、プライベートな辞書ファイルに挿入します。

`l word RET`  
wordにマッチする単語を辞書から探します。これらの単語は近い単語の新しいリストになるので、置換で数字をタイプして選択できるようになります。wordにはワイルドカードとして‘`*`’を使うことができます。

`C-g`; `X`  
対話的なスペルチェックを終了します(ポイントはチェックされた単語の位置に残されます)。`C-u M-$`でチェックを再開できます。

`x`  
対話的なスペルチェックを終了します(ポイントはチェックを開始したときの位置に戻ります)。

`q`  
対話的なスペルチェックを終了して、スペルチェッカーのサブプロセスをkillします。

`?`  
オプションの一覧を表示します。

ispell-complete-word
Textモードおよびそれに関連するモードでは、`M-TAB` (`ispell-complete-word`)で、スペル訂正にもとづくバッファー内補完を行います。単語の最初の部分を入力してから`M-TAB`をタイプすると、補完一覧が表示されます(ウィンドウマネージャーが`M-TAB`を横取りしてしまう場合は、`ESC
TAB`または`C-M-i`をタイプします)。補完対象には番号か文字が振られているので、その番号か文字をタイプして選択します。

ispell
program
ispell-kill-ispell
1度プロセスが開始されれば、スペルチェッカーのサブプロセスは待機状態で実行を続けるので、一連のスペルチェックコマンドは素早く完了します。プロセスを終了させたいときは`M-x
ispell-kill-ispell`を使います。スペルの訂正を行うとき以外プロセスがCPU時間を使うことはないので、これは通常必要ありません。

ispell-dictionary
ispell-local-dictionary
ispell-personal-dictionary
ispell-change-dictionary
スペルチェッカーは、スペルを2つの辞書から探します。それは標準辞書と個人用辞書です。標準辞書は変数`ispell-local-dictionary`で指定されます。これが`nil`のときは、変数`ispell-dictionary`で指定されます。両方が`nil`のとき、スペルプログラムは既定の辞書を使います。コマンド`M-x
ispell-change-dictionary`は、バッファーにたいする標準辞書をセットしてからサブプロセスを再起動することにより、これにより異なる標準辞書を使うことができます。個人用の辞書は、変数`ispell-personal-dictionary`で指定します。これが`nil`のとき、スペルプログラムは個人辞書を、各スペルチェッカーが指定する既定の場所から探します。

ispell-complete-word-dict
単語の補完には別の辞書が使われます。変数`ispell-complete-word-dict`は、この辞書のファイル名を指定します。補完辞書は、単語の変化形を検知するためにスペルチェックが使用する、単語にたいするroot語(接辞を含まない語)とaffix語(接辞語)に関する情報を使用できないので、、別の辞書でなければなりません。補完辞書はもたないが、スペルチェック辞書はあもつ言語もいくつかあります。

Flyspell mode
mode, Flyspell
flyspell-mode
Flyspellモードは、タイプしたテキストのスペルをタイプ時に自動的にチェックするマイナーモードです。認識できない単語を見つけると、その単語をハイライトします。`M-x
flyspell-mode`とタイプすると、カレントバッファーのFlyspellモードを切り替えます。すべてのTextバッファーでFlyspellモードを有効にするには、`text-mode-hook`に、`flyspell-mode`を追加します。[Hooks](#Hooks)を参照してください。Flyspellモードは、ユーザーの移動にしたがって各単語をチェックする必要があるので、カーソル移動やスクロールコマンドにより速度低下するかもしれないことに注意してください。タイプしていないテキストや移動と関係ないテキストの自動チェックも行いません。それを行うためには、`flyspell-region`や`flyspell-buffer`を使用してください。

flyspell-correct-word
flyspell-auto-correct-word
flyspell-correct-word-before-point
Flyspellモードが間違ったスペルの単語をハイライトしているとき、それを`mouse-2` (`flyspell-correct-word`)でクリックして、可能な定性とアクションを表示するメニューを表示できます。加えて`C-.`、または`ESC-TAB` (`flyspell-auto-correct-word`)はポイント位置の単語にたいする可能な訂正を提案し、`C-c $` (`flyspell-correct-word-before-point`)は可能な訂正のメニューをポップアップします。もちろん、間違ったスペルの単語を、常にお好みの方法で手修正できます。

flyspell-prog-mode
Flyspell Progモードは通常のFlyspellモードと同じように機能しますが、コメントと文字列に含まれた単語だけをチェックします。この機能はプログラムを編集する場合に便利です。`M-x
flyspell-prog-mode`をタイプして、現在のバッファーにたいするこのモードの有効と無効を切り替えます。すべてのプログラミングに関連したモードでこのモードを有効にするには、`prog-mode-hook`に`flyspell-prog-mode`を追加します([Hooks](#Hooks)を参照してください)。

キーボードマクロ
================

defining keyboard macros
keyboard macro
このチャプターでは一連の編集コマンドを記録して、後で簡単に繰り返す方法を説明します。

キーボードマクロ(keyboard macro)とは、Emacsのユーザーにより定義される、一連のキー入力からなるコマンドです。たとえば`C-n M-d
C-d`を40回繰り返しタイプしていることに気付いたとしましょう。`C-n M-d
C-d`を行うキーボードマクロを定義して、それを39回以上繰り返すことにより、作業スピードをあげることができます。

キーボードマクロは、コマンドを実行・記録することにより定義します。違う言い方をすると、キーボードマクロの定義では、初回はマクロの定義が実行されるということです。この方法により、頭だけで考えるのではなく、コマンドの影響を目で見ることができます。コマンド列の入力を終了して定義を終了するときは、キーボードマクロが定義されるとともに、入力したコマンド列の影響としてマクロが1回実行されたことになります。その後はマクロを呼び出すことにより、コマンド列全体を実行することができます。

キーボードマクロは、LispではなくEmacsコマンド言語(Emacs command language)で記述されている点が、通常のEmacsコマンドと異なります。しかしEmacsコマンド言語は、高度なことや一般的なことを記述するプログラム言語として、充分にパワフルとはいえません。そのような事項には、Lispを使わなければなりません。

基本的な使い方
--------------

`F3`; `C-x (`  
キーボードマクロの定義を開始します(`kmacro-start-macro-or-insert-counter`)。

`F4`; `C-x e`  
キーボードマクロを定義しているときは定義を終了します。それ以外の場合は一番最近のキーボードマクロを実行します(`kmacro-end-or-call-macro`)。

`C-u F3`; `C-u C-x (`  
最後のキーボードマクロを再実行してから、キーをマクロ定義に追加します。

`C-u C-u F3`; `C-u C-u C-x (`  
最後のキーボードマクロを再実行せずに、キーをマクロ定義に追加します。

`C-x C-k r`  
リージョンの中の各行の行頭にたいして、最後のキーボードマクロを実行します(`apply-macro-to-region-lines`)。

F3
F4
kmacro-start-macro-or-insert-counter
kmacro-end-or-call-macro
kmacro-end-and-call-macro
キーボードマクロの定義を開始するには、F3をタイプします。それからはキーを入力して実行を続けますが、それは同時にマクロ定義の一部になります。その間は、モードラインに‘`Def`’が表示されて、マクロの定義中であることを示します。終了するときはF4 (`kmacro-end-or-call-macro`)をタイプして、定義を終了します。たとえば、

    F3 M-f foo F4

これは1単語前方に移動してから、‘`foo`’を挿入するマクロを定義します。F3とF4は、マクロの一部とはならないことに注意してください。

マクロを定義した後は、F4でそれを呼び出すことができます。上記の例では、それは`M-f foo` againをタイプしたのと同じ効果をもちます(F4コマンドの2つの役割に注意してください。これはマクロを定義しているときはマクロの定義を終了し、そうでないときは最後のマクロを呼び出します)。F4に数引数‘`n`’を与えることもできます。これはマクロを‘`n`’回呼び出すことを意味します。引数に0を与えると、エラーになるか、`C-g`(MS-DOSでは`C-BREAK`)をタイプするまで、マクロを永久に繰り返します。

上記の例は、キーボードマクロを使った便利なトリックをデモンストレイトする例です。テキストの一定間隔の位置にたいして繰り返し操作を行いたいときは、マクロの一部に移動コマンドを含めます。この例ではマクロの繰り返しにより、連続する単語の後ろに文字列‘`foo`’を挿入していきます。

キーボードマクロの定義を終了した後でも、`C-u
F3`をタイプすることにより、マクロの定義にキーストロークを追加できます。これはF3に続けてマクロの定義を再タイプするのと同じです。結果として、そのマクロの以前の定義が再実行されることになります。変数`kmacro-execute-before-append`を`nil`に変更すると、既存のマクロにキーストロークが追加されるまでは実行されません(デフォルトは`t`)。最後に実行したキーボードマクロを再実行することなく、定義の最後にキーストロークを追加するには、`C-u
C-u F3`をタイプしてください。

コマンドがミニバッファーから引数を読みとる場合、ミニバッファーにたいする入力は、コマンドと一緒にマクロの一部となります。したがってマクロを再生すると、そのコマンドの引数は入力されたのと同じになります。たとえば、

    F3 C-a C-k C-x b foo RET C-y C-x b RET F4

これはカレント行をkillして、バッファー‘`foo`’にそれをyankした後、元のバッファーに戻ります。

ほとんどのキーボードコマンドは、キーボードマクロの定義で普通に機能しますが、いくつか例外があります。`C-g` (`keyboard-quit`)をタイプすると、キーボードマクロの定義が終了します。`C-M-c` (`exit-recursive-edit`)は信頼できません。これはマクロの中で再帰編集(recursive edit)を開始したときは期待通りに再帰編集から抜け出しますが、キーボードマクロの呼び出し前に開始された再帰編集を抜け出すには、キーボードマクロからも抜け出す必要があります。同様に、マウスイベントもキーボードマクロで使用できますが。信頼はできません。マクロによりマウスイベントが再生されるときは、マクロを定義したときのマウス位置が使用されます。この効果は予測が困難です。

apply-macro-to-region-lines
C-x C-k r
コマンド`C-x C-k r` (`apply-macro-to-region-lines`)は、リージョン内の各行のにたいして、最後に定義されたキーボードマクロを繰り返します。これは1行ずつポイントをリージョン内の行頭に移動してからマクロを実行します。

C-x (
C-x )
C-x e
kmacro-start-macro
kmacro-end-macro
上記で説明したF3とF4に加えて、Emacsはキーボードマクロを定義したり実行するための、古いキーバインドもサポートします。F3と同様にマクロ定義を開始するには、`C-x
(` (`kmacro-start-macro`)とタイプします。プレフィクス引数を指定すると、最後のキーボードマクロの定義に追加します。マクロ定義を終了するには`C-x
)` (`kmacro-end-macro`)とタイプします。一番最近のマクロを実行するには、`C-x e` (`kmacro-end-and-call-macro`)とタイプします。マクロ定義中に`C-x
e`を入力すると、マクロ定義を終了してからすぐに実行されます。`C-x
e`をタイプした後すぐに`e`をタイプすることにより、そのマクロを１回以上繰り返すことができます。(マクロの実行に使用されるときの)F4と同様、`C-x
e`には繰り返し回数を引数指定できます。

`C-x
)`に、繰り返し回数を引数として与えることができます。これはマクロを定義した後、すぐにマクロが繰り返されることを意味します。マクロの定義は、定義することによりマクロが実行されるので、最初の1回として数えられます。したがって`C-u
4 C-x )`は、マクロを3回すぐに追加実行します。

キーボードマクロリング
----------------------

すべての定義されたキーボードマクロは、キーボードマクロリング(keyboard macro ring)に記録されます。キーボードマクロリングはすべてのバッファーで共有され、1つだけしかありません。

`C-x C-k C-k`  
リングの先頭にあるキーボードマクロを実行します(`kmacro-end-or-call-macro-repeat`)。

`C-x C-k C-n`  
キーボードマクロリングを、次のマクロ(古く定義されたもの)にローテートします(`kmacro-cycle-ring-next`)。

`C-x C-k C-p`  
キーボードマクロリングを前のマクロ(新しく定義されたもの)にローテートします(`kmacro-cycle-ring-previous`)。

キーボードマクロリングを操作するすべてのコマンドは、同じ`C-x
C-k`を使います。これらのコマンドでは、すぐ後にコマンドを実行して繰り返す場合には、互いに`C-x
C-k`プレフィクスを必要としません。たとえば、

    C-x C-k C-p C-p C-k C-k C-k C-n C-n C-k C-p C-k C-d

これは、キーボードマクロリングを2つ前のマクロが先頭にくるようにローテートして、3回実行します。次にキーボードマクロリングをローテートして、元は先頭だったマクロを先頭に戻して１回実行します。次にキーボードマクロリングを1つ前のマクロが先頭にくるようにローテートして、それを実行します。そして最後にそれを削除しています。

kmacro-end-or-call-macro-repeat
C-x C-k C-k
コマンド`C-x C-k C-k` (`kmacro-end-or-call-macro-repeat`)は、マクロリングの先頭にあるキーボードマクロを実行します。もう一度すぐに`C-k`をタイプすると、マクロを繰り返すことができます。すぐに`C-n`か`C-p`をタイプすれば、マクロリングをローテートすることができます。

キーボードマクロを定義しているとき、`C-x C-k
C-k`はF4と同様に振る舞いますが、すぐ後にタイプされた場合は異なります。このセクションで説明するほとんどのキーバインドは、`C-x
C-k`プレフィクスが必要ない場合があります。たとえば、すぐに`C-k`をタイプした場合は、マクロを再実行します。

kmacro-cycle-ring-next
C-x C-k C-n
kmacro-cycle-ring-previous
C-x C-k C-p
コマンド`C-x C-k C-n` (`kmacro-cycle-ring-next`)および`C-x C-k C-p` (`kmacro-cycle-ring-previous`)は、マクロリングをローテートして、次または前のキーボードマクロをリングの先頭に移動させます。新しく先頭となったマクロの定義は、エコーエリアに表示されます。お望みのマクロが先頭にくるまで、すぐに`C-n`または`C-p`を繰り返しタイプすれば、マクロリングのローテートを続けることができます。新しくマクロリングの先頭にきたマクロを実行するには、単に`C-k`をタイプします。

Emacsはマクロリングの先頭を、最後に定義されたキーボードマクロとして扱います。たとえば、そのマクロはF4で実行でき、`C-x
C-k n`で名前をつけることができます。

kmacro-ring-max
キーボードマクロリングに格納できるマクロの最大数は、カスタマイズ可能な変数`kmacro-ring-max`により決定されます。

キーボードマクロカウンター
--------------------------

キーボードマクロには、それぞれカウンターが割り当てられています。これはマクロの定義を開始したとき0に初期化されます。このカレントカウンター(current counter)の数値をバッファーに挿入することもできます。カレントカウンターの数値は、マクロが呼び出された回数にもとづきます。バッファーにカウンターの値が挿入される度に通常、カウンターは増加します。

カレントカウンターに加えて、前回カレントカウンターが増加またはセットされたときにもっていた値を記録する、前回カウンター(previous counter)も保守します。`C-u 0 C-x C-k
C-i`により増分値0でカレントカウンターを増加させると、カレントカウンターの値も前回カウンターの値として記録されることに注意してください。

`F3`  
キーボードマクロの定義では、キーボードマクロカウンターの値をバッファーに挿入します(`kmacro-start-macro-or-insert-counter`)。

`C-x C-k C-i`  
キーボードマクロカウンターの値をバッファーに挿入します(`kmacro-insert-counter`)。

`C-x C-k C-c`  
キーボードマクロカウンターをセットします(`kmacro-set-counter`)。

`C-x C-k C-a`  
プレフィクス引数をキーボードマクロカウンターに加えます(`kmacro-add-counter`)。

`C-x C-k C-f`  
挿入するキーボードマクロカウンターの書式を指定します(`kmacro-set-format`)。

kmacro-insert-counter
C-x C-k C-i
キーボードマクロを定義しているとき、コマンドF3 (`kmacro-start-macro-or-insert-counter`)は、キーボードマクロカウンターの現在の値をバッファーに挿入して、カウンターを1増加させます(マクロを定義していないとき、F3はマクロの定義を開始します。[Basic Keyboard Macro](#Basic-Keyboard-Macro)を参照してください)。異なる増分の指定には、数引数を使うことができます。単にプレフィクス`C-u`を指定すると、前回カウンターの値を挿入して、カレントカウンターの値は変化しません。

例として数字が振られたリストを構築するために、キーボードマクロカウンターを使う方法を見てみましょう。以下のキーシーケンスを考えてください:

    F3 C-a F3 . SPC F4

マクロ定義の一部として、現在の行の先頭に文字列‘`0.
`’が挿入されます。バッファーの他の箇所でF4でマクロを呼び出すと、その行の先頭に文字列‘`1.
`’が挿入されます。その後に呼び出すと‘`2. `’、‘`3. `’、...が挿入されます。

コマンド`C-x C-k C-i` (`kmacro-insert-counter`)は、F3と同様のことを行いますが、これはキーボードマクロの定義外でも使用できます。キーボードマクロが定義中でなく実行もされていない場合、これはキーボードマクロリングの先頭にあるマクロのカウンター値を挿入および増加します。

kmacro-set-counter
C-x C-k C-c
コマンド`C-x C-k C-c` (`kmacro-set-counter`)は現在のマクロカウンターを、数引数の値にセットします。マクロ内で使用した場合、マクロ実行ごとに処理します。プレフィクス引数に単に`C-u`を指定した場合、マクロの現在の繰り返し実行おいて、カウンターが最初にもっていた値に、カウンターをリセットします(この繰り返しにおける増加を取り消します)。

kmacro-add-counter
C-x C-k C-a
コマンド`C-x C-k C-a` (`kmacro-add-counter`)は、プレフィクス引数を現在のマクロカウンターに加えます。単に`C-u`を引数に指定すると、任意のキーボードマクロにより最後に挿入された値に、カウンターをリセットします(通常これを使うときは、最後の挿入は同じマクロによる同じカウンターです)。

kmacro-set-format
C-x C-k C-f
コマンド`C-x C-k C-f` (`kmacro-set-format`)は、マクロカウンターを挿入するときに使われる書式の入力を求めます。デフォルトの書式は‘`%d`’で、これはパディングなしの10進数字が挿入されることを意味します。ミニバッファーに何も入力せずにexitすることにより、このデフォルト書式にリセットできます。`format`関数(この関数はさらに1つの整数の引数をとります)が受け入れる書式文字列を指定できます(section “Formatting Strings” in The Emacs Lisp Reference Manualを参照してください)。ミニバッファーに書式文字列を入力するときは、書式文字列をダブルクォーテーションで括らないでください。

キーボードマクロの定義および実行がされていないときにこのコマンドを使うと、新しい書式はそれ以降のマクロ定義すべてに影響を及ぼします。既存のマクロは、それが定義されたときの書式を使いつづけます。キーボードマクロ定義中に書式をセットすると、そのマクロが定義されている箇所に影響を及ぼしますが、それ以降のマクロには影響を与えません。マクロの実行においては、そのマクロ定義の時点の書式が使われます。マクロの実行中にマクロ書式を変更すると、これは定義中における書式の変更と同様、それ以降のマクロに影響を与えません。

`C-x C-k C-f`によりセットされた書式は、レジスターに格納された数字の挿入には影響しません。

マクロの繰り返しにおいてレジスターを増加してカウンターとして使う場合、これはキーボードマクロカウンターと同じことです。[Number Registers](#Number-Registers)を参照してください。大抵の用途では、キーボードマクロカウンターを使う方が単純です。

変化のあるマクロの実行
----------------------

キーボードマクロで、`query-replace`のように変更を行うか応答を求める効果を作ることができます。

`C-x q`  
マクロ実行中にこの箇所に到達すると確認を求めます(`kbd-macro-query`)。

C-x q
kbd-macro-query
マクロ定義中に問い合わせを行いたい箇所で`C-x q`をタイプします。マクロ定義中は`C-x
q`は何も行いませんが、後でマクロを実行すると`C-x q`は実行を続けるか対話的に確認を求めます。

以下は`C-x q`にたいする有効な応答です:

SPC (または`y`)  
キーボードマクロの実行を続けます。

DEL (または`n`)  
マクロのこの繰り返しでの残りの部分をスキップして、次の繰り返しを開始します。

RET (または`q`)  
マクロのこの繰り返しでの残りの部分をスキップして、これ以上の繰り返しを取り消します。

`C-r`  
マクロの一部ではない編集を行うことができる、再帰編集レベル(recursive editing level)に入ります。`C-M-c`を使って再帰編集を抜けると、キーボードマクロを続行するか再び確認を求められます。ここでSPCをタイプすると、マクロ定義の残りの部分が実行されます。マクロの残りの部分が期待したように動作するためにポイントとテキストを残すのは、ユーザーの責任です。

`C-x q`に数引数を指定した`C-u C-x
q`は、完全に異なる関数を実行します。これはマクロ定義中およびマクロ実行中の両方で、キーボード入力を読みとる再帰編集に入ります。定義中のときは、再帰編集の中で行った編集はマクロの一部とはなりません。マクロ実行中は、再帰編集により各繰り返しにおいて特別な編集を行う機会が与えられます。[Recursive Edit](#Recursive-Edit)を参照してください。

キーボードマクロの命名と保存
----------------------------

`C-x C-k n`  
一番最近定義したキーボードマクロに、名前(持続期間はEmacsセッション中)を与えます(`kmacro-name-last-macro`)。

`C-x C-k b`  
一番最近定義したキーボードマクロを、キーにバインド(持続期間はEmacsセッション中)します(`kmacro-bind-to-key`)。

`M-x insert-kbd-macro`  
キーボードマクロの定義を、Lispコードとしてバッファーに挿入します。

saving keyboard macros
kmacro-name-last-macro
C-x C-k n
キーボードマクロを後で使うために保存するには、`C-x C-k n` (`kmacro-name-last-macro`)を使って、それに名前を与えることができます。これはミニバッファーを使って名前を引数として読み取り、最後のキーボードマクロの現在の定義を実行するための、名前を定義します(後でこのマクロの定義を追加した場合、その名前のマクロ定義は変更されません)。マクロ名はLispシンボルで、`M-x`で呼び出せ、`global-set-key`でキーにバインドできる有効な名前をつけます。キーボードマクロ以外に定義されている名前を指定すると、エラーメッセージが表示され何も変更はされません。

binding keyboard macros
kmacro-bind-to-key
C-x C-k b
`C-x C-k b` (`kmacro-bind-to-key`)の後に、バインドしたいキーシーケンスを続けることにより、最後のキーボードマクロ(の現在の定義)をキーにバインドすることもできます。グローバルキーマップ(global keymap)の任意のキーシーケンスにバインドできますが、大部分のキーシーケンスはすでに他のバインドをもっているので、キーシーケンスの選択は慎重に行う必要があります。任意のキーマップで既存のバインドをもつキーシーケンスにバインドしようとすると、既存のバインドを置き換える前に確認を求めます。

既存のバインドの上書きに起因する問題を避けるには、キーシーケンス`C-x C-k 0`から`C-x C-k 9`と、`C-x
C-k A`から`C-x C-k
Z`を使います。これらのキーシーケンスは、キーボードマクロのバインド用に予約されています。これらのキーシーケンスにバインドするには、キーシーケンス全体ではなく数字か文字だけをタイプすればバインドできます。たとえば、

    C-x C-k b 4

これは最後のキーボードマクロをキーシーケンス`C-x C-k 4`にバインドします。

insert-kbd-macro
1度マクロにコマンド名をつければ、その定義をファイルに保存できます。それは他の編集セッションでも使用できます。最初に定義を保存したいファイルをvisitします。次に以下のコマンドを使います:

    M-x insert-kbd-macro RET macroname RET

これは後で実行するとき、今と同じ定義のマクロとなるLispコードをバッファーに挿入します(これを行うためにLispコードを理解する必要はありません。なぜならあなたのかわりに`insert-kbd-macro`がLispコードを記述するからです)。それからファイルを保存します。後でそのファイルを`load-file` ([Lisp Libraries](#Lisp-Libraries)を参照してください)でロードできます。initファイル`~/.emacs` ([Init File](#Init-File)を参照してください)に保存すれば、そのマクロはEmacsを実行する度に定義されます。

`insert-kbd-macro`に数引数を与えると、(もしあれば)macronameにバインドしたキーを記録するためのLispコードが追加されるので、ファイルをロードしたとき同じキーにマクロが割り当てられます。

キーボードマクロの編集
----------------------

`C-x C-k C-e`  
最後に定義されたキーボードマクロを編集します(`kmacro-edit-macro`)。

`C-x C-k e name RET`  
以前に定義されたキーボードマクロnameを編集します(`edit-kbd-macro`)。

`C-x C-k l`  
過去300回分のキーストロークを、キーボードマクロとして編集します(`kmacro-edit-lossage`)。

kmacro-edit-macro
C-x C-k C-e
C-x C-k RET
`C-x C-k C-e`または`C-x C-k RET` (`kmacro-edit-macro`)をとタイプして、最後のキーボードマクロを編集できます。これはマクロ定義をバッファーに整形出力して、それを編集するために特化したモードに入ります。そのバッファーで`C-h
m`をタイプすると、マクロを編集する方法の詳細が表示されます。編集を終了するには`C-c C-c`をタイプしてください。

edit-kbd-macro
C-x C-k e
名前をつけたキーボードマクロ、またはキーにバインドしたマクロは、`C-x C-k e` (`edit-kbd-macro`)とタイプして編集できます。このコマンドに続けてそのマクロを呼び出すときのキー入力(`C-x
e`、`M-x name`、またはその他のキーシーケンス)を入力します。

kmacro-edit-lossage
C-x C-k l
`C-x C-k l` (`kmacro-edit-lossage`)とタイプして、最近300回のキーストロークをマクロとして編集できます。

キーボードマクロのステップ編集
------------------------------

kmacro-step-edit-macro
C-x C-k SPC
`C-x C-k SPC` (`kmacro-step-edit-macro`)とタイプして、最後のキーボードマクロをインタラクティブに1コマンドずつ再生および編集できます。マクロを`q`または`C-g`で終了しなければ、編集されたマクロでマクロリングの最後のマクロを置き換えます。

このマクロ編集機能は、最初(または次)に実行されるコマンドと、それにたいする操作を尋ねるプロンプトをミニバッファーに表示します。`?`を入力すれば、オプションの要約を表示できます。以下のオプションが利用可能です:

-   SPCおよび`y`は、現在のコマンドを実行して、キーボードマクロの次のコマンドに進みます。

-   `n`、`d`、およびDELは、現在のコマンドをスキップして削除します。

-   `f`は、キーボードマクロの実行において現在のコマンドをスキップしますが、マクロから削除はしません。

-   TABは、現在のコマンドと、現在のコマンドのすぐ後に続く同じようなコマンドを実行します。たとえば連続する文字の挿入(`self-insert-command`に相当)には、TABが使われます。

-   `c`は、(これ以上の編集は行わずに)キーボードマクロの最後まで実行を続けます。実行が正常に終了した場合、編集されたマクロで元のキーボードマクロを置き換えます。

-   `C-k`は、キーボードマクロの残りの部分をスキップおよび削除して、ステップ編集を終了し、編集されたマクロで元のキーボードマクロを置き換えます。

-   `q`および`C-g`は、キーボードマクロのステップ編集を取り消して、キーボードマクロにたいして行った編集を破棄します。

-   `i key…
    C-j`は、一連のキーシーケンス(最後の`C-j`は含まれません)を読み取って実行し、キーボードマクロの現在のコマンドの前に挿入します(現在のコマンドはスキップしません)。

-   `I
    key…`は、1つのキーシーケンスを読み取って実行し、キーボードマクロの現在のコマンドの前に挿入します(現在のコマンドはスキップしません)。

-   `r key…
    C-j`は、一連のキーシーケンス(最後の`C-j`は含まれません)を読み取って実行し、現在のコマンドをそれで置き換えます(実行は挿入されたキーシーケンスの次に移ります)。

-   `R
    key…`は、1つのキーシーケンスを読み取って実行し、キーボードマクロの現在のコマンドを、そのキーシーケンスで置き換えます(実行は挿入されたキーシーケンスの次に移ります)。

-   `a key…
    C-j`は、現在のコマンドを実行してから、一連のキーシーケンス(最後の`C-j`は含まれません)を読み取って実行してから、それをキーボードマクロの現在のコマンドの後ろに挿入します(実行は現在のコマンドと、その後ろに挿入されたキーシーケンスの次に移ります)。

-   `A key…
    C-j`は、キーボードマクロの残りのコマンドを実行してから、一連のキーシーケンス(最後の`C-j`は含まれません)を読み取って実行し、それらをキーボードマクロの最後に追加します。それからステップ編集を終了し、編集されたマクロで元の元のキーボードマクロを置き換えます。

ファイルの処理
==============

files
オペレーティングシステムはファイルにデータを永続化するので、Emacsで編集するテキストの大部分はファイルから読み込んで、最終的にファイルに格納します。

ファイルを編集するには、Emacsにファイルを読み込み、ファイルのテキストを含むバッファーを準備するよう、指示しなければなりません。これを、ファイルのvisit(訪問)と呼びます。編集コマンドは直接バッファーのテキスト、つまりEmacs内部のコピーに適用されます。変更がファイルに反映されるのは、バッファーをファイルに保存(save)したときだけです。

ファイルのvisitや保存に加え、Emacsはファイルの削除、コピー、名前の変更、ファイルへの追加、ファイルの複数バージョンの保持、ディレクトリーの操作を行うことができます。

ファイルの名前
--------------

file names
default file name
ファイルを操作するEmacsコマンドの多くは、ミニバッファー([Minibuffer File](#Minibuffer-File)を)を使って、ファイル名の指定を求めます。

ミニバッファーでは、通常の補完およびヒストリーコマンドを使うことができます([Minibuffer](#Minibuffer)を参照してください)。ファイル名の補完では、ファイル名の拡張子が変数`completion-ignored-extensions`に含まれているファイルは無視されます([Completion Options](#Completion-Options)を参照してください)。またほとんどのコマンドは、ファイルの読み込みにおいて、確認をともなう寛大な補完(permissive completion with confirmation)を使います。この補完では、存在しないファイル名が許されますが、存在しないファイル名の入力を完了するためにRETをタイプすると、Emacsは‘`[Confirm]`’を表示し、この確認に同意するために2番目のRETをタイプしなければなりません。詳細については、[Completion Exit](#Completion-Exit)を参照してください。

ミニバッファーのヒストリーコマンドは、ファイル名を読み取るための特別な機能をいくつか提供します。[Minibuffer History](#Minibuffer-History)を参照してください。

default directory, of a buffer
default-directory
それぞれのバッファーは、バッファーローカルな変数`default-directory`に、デフォルトのディレクトリーを格納しています。ミニバッファーを使ってファイル名を読み取るとき、通常Emacsはミニバッファーの初期内容として、デフォルトディレクトリーを挿入します。変数`insert-default-directory`を`nil`に変更することにより、この挿入を抑制できます。常にEmacsは任意の相対パスで指定されたファイル名を、デフォルトディレクトリーにたいする相対パスとみなします。たとえばディレクトリーを指定しないファイル名は、デフォルトディレクトリーのファイルを指定します。

cd
pwd
ファイルをvisitするとき、Emacsはvisitしているバッファーの`default-directory`に、そのファイルのディレクトリーをセットします。`C-x
b`のようなコマンドを通じて、ファイルをvisitしていないバッファーを新たに作成すると、通常そのバッファーのデフォルトディレクトリーは、現在のバッファーのデフォルトディレクトリーをコピーします。現在のバッファーの`default-directory`の値を見るために、`M-x
pwd`コマンドを使用できます。`M-x
cd`コマンドはディレクトリー名の入力を求め、バッファーの`default-directory`もそのディレクトリーをセットします(これを行うことによりバッファーのファイル名は変更されません)。

例として、ファイル`/u/rms/gnu/gnu.tasks`をvisitしているとします。このときデフォルトディレクトリーは`/u/rms/gnu/`にセットされます。ファイル名を読み取るコマンドを呼び出して、ミニバッファーでディレクトリー名を省略して単に‘`foo`’と入力すると、これはファイル`/u/rms/gnu/foo`を指定したことになります。‘`../.login`’と入力すると`/u/rms/.login`、‘`new/foo`’と入力すると`/u/rms/gnu/new/foo`を指定したことになります。

ミニバッファーにファイル名をタイプするとき、2つのショートカットを使うことができます。2つのスラッシュは、2番目のスラッシュの前にあるすべてを無視します。そして‘`~/`’は、ユーザーのホームディレクトリーです。[Minibuffer File](#Minibuffer-File)を参照してください。

environment variables in file names
expansion of environment variables
$
in file names
文字‘`$`’は、ファイル名を置き換える環境変数の代用として使われます。環境変数の名前は、‘`$`’の後ろのすべての英数字から構成されます。‘`$`’の後ろの、大カッコ(braces)に囲まれた変数名も使用できます。たとえばシェルコマンド`export
FOO=rms/hacks`は、名前がFOOの環境変数をセットするために使われます。すると`/u/$FOO/test.c`と`/u/${FOO}/test.c`はどちらも、`/u/rms/hacks/test.c`の省略形となります。環境変数が定義されていないときは、何の置き換えも発生せず、文字‘`$`’はそれ自身を意味します。Emacs外部でセットされた環境変数は、それがEmacsの開始前に適用されたときだけ、Emacsに影響を与えることに注意してください。

‘`$`’により環境変数が展開されるようなとき、名前に‘`$`’を含むファイルにアクセスする場合は、‘`$$`’とタイプします。1つの‘`$`’が環境変数を展開するのと同時に、2つのペアは1つの‘`$`’に変換されます。かわりにファイル名を‘`/:`’でクォートすることもできます([Quoted File Names](#Quoted-File-Names)を参照してください)。名前が文字‘`~`’で始まるファイル名も、‘`/:`’でクォートするべきです。

ファイル名に非ASCII文字を含めることができます。[File Name Coding](#File-Name-Coding)を参照してください。

ファイルのvisit(訪問)
---------------------

visiting files
open file
`C-x C-f`  
ファイルをvisitします(`find-file`)。

`C-x C-r`  
変更を許さない閲覧用として、ファイルをvisitします(`find-file-read-only`)。

`C-x C-v`  
最後にvisitしたファイルとは異なるファイルを、かわりにvisitします(`find-alternate-file`)。

`C-x 4 f`  
別のウィンドウでファイルをvisitします(`find-file-other-window`)。選択されたウィンドウに表示されているものは変更しません。

`C-x 5 f`  
新しいフレームでファイルをvisitします(`find-file-other-frame`)。選択されたフレームに表示されているものは変更しません。

`M-x find-file-literally`  
内容を変換せずにファイルをvisitします。

files, visiting and saving
saving files
ファイルをVisiting(訪問)するとは、そのファイル内容をEmacsのバッファーに読み込むことを意味するので、それを編集することができます。Emacsはvisitするファイルごとに、新しいバッファーを作成します。

C-x C-f
find-file
ファイルをvisitするには、`C-x C-f` (`find-file`)とタイプして、visitしたいファイルの名前をミニバッファーで入力します。ミニバッファーでは、`C-g`をタイプして、コマンドを中止することができます。ミニバッファーでのファイル名の入力についての詳細は、[File Names](#File-Names)を参照してください。

ファイルは存在するが、システムが読み込みを許さない場合、エコーエリアにエラーメッセージが表示されます(GNUおよびUnixシステムでは、‘`su`’や‘`sudo`’のような方法を使用して、そのようなファイルをvisitできるかもしれない。[Remote Files](#Remote-Files)を参照されたい。) それ以外の場合、スクリーンに新しいテキストが表示され、モードラインバッファー名が表示されることで、`C-x
C-f`が成功したことを知ることができます。通常Emacsは、ファイル名からディレクトリー名を省いて、バッファー名を作ります。たとえば`/usr/rms/emacs.tex`という名前のファイルは、バッファー名‘`emacs.tex`’となります。その名前のバッファーがすでにある場合、Emacsは一意な名前を作ります。通常の方法はディレクトリー名にもとづく接尾辞の追加です(たとえば‘`<rms>`’、‘`<tmp>`’など)が、違う方法を選択することもできます。[Uniquify](#Uniquify)を参照してください。

creating files
新しいファイルを作成するには、同じコマンド`C-x C-f`を使ってvisitするだけです。Emacsはエコーエリアに‘`(New
file)`’と表示しますが、他の点では既存の空のファイルをvisitしたのと同じく振る舞います。

modified (buffer)
ファイルをvisitした後で編集コマンドにより行われた変更は、Emacsのバッファーに反映されます。バッファーを保存(save)するまでは、visitしているファイルに影響はありません。バッファーが保存されていない変更を含むとき、そのバッファーが変更されている(modified)といいます。これはバッファーを保存しなければ、その変更が失われることを意味します。モードラインの左余白の近くに2つのアスタリスクが表示され、バッファーが変更されていることを示します。

すでにEmacsがvisitしているファイルをvisitした場合、`C-x
C-f`は他のコピーを作らず既存のバッファーに切り替えます。切り替えを行う前に、最後にvisitまたは保存した後にファイルが変更されているか確認します。もしファイルが変更されているとき、Emacsはそれの再読み込みを提案します。

large-file-warning-threshold
file, warning when size is large
size of file, warning when visiting
maximum buffer size exceeded, error message
`large-file-warning-threshold` (デフォルトは10000000で、これは約10MB)より大きなファイルのvisitを試みると、Emacsは最初に確認を求めます。`y`を応えることにより、ファイルのvisitを続けます。しかしEmacsは、Emacsバッファーの最大サイズ(Emacsが割り当てられるメモリー量の制限と、Emacsが扱える整数により制限されます)を超えるバッファーは、visitできないことに注意してください。この場合、Emacsは最大バッファーサイズを超えた旨を知らせるエラーメッセージを表示します。

wildcard characters in file names
find-file-wildcards
ファイル名にシェル形式のワイルドカード文字が含まれている場合、Emacsはそれにマッチするすべてのファイルをvisitします。(大文字小文字を区別しないファイルシステムでは、Emacsは大文字小文字に関係なくワイルドカードをマッチします)。ワイルドカードには‘`?`’、‘`*`’および‘`[…]`’シーケンスが含まれます。ミニバッファーでワイルドカード‘`?`’をファイル名に入力するには、`C-q
?`とタイプする必要があります。ワイルドカード文字を実際に名前に含むファイルをvisitする方法についての情報は、[Quoted File Names](#Quoted-File-Names)を参照してください。`find-file-wildcards`をカスタマイズして、ワイルドカード機能を無効にすることができます。

C-x C-v
find-alternate-file
無意識に間違ったファイル名をタイプして違うファイルをvisitした場合、`C-x C-v` (`find-alternate-file`)で実際に望むファイルをvisitできます。`C-x C-v`は`C-x
C-f`と似ていますが、これは現在のバッファーをkillします(変更されている場合は最初に保存するか確認を求めます)。`C-x
C-v`がvisitするファイルの名前を読み取るときは、ミニバッファーにデフォルトのファイル名全体を挿入して、ポイントをディレクトリー名の後に置きます。これは名前を少し間違えた場合などに便利です。

find-file-run-dired
実際はディレクトリーであるファイルをvisitしたとき、EmacsはEmacsのディレクトリーブラウザーのDiredを呼び出します。[Dired](#Dired)を参照してください。この振る舞いは、変数`find-file-run-dired`を`nil`にセットすることにより無効にできます。この場合、ディレクトリーをvisitするとエラーになります。

実際には他のファイルの集まりであるようなアーカイブファイル(file archives)の場合、アーカイブされたメンバーを操作できる、Diredに似た環境を呼び出す特別なモードでvisitします。これらの機能については、[File Archives](#File-Archives)を参照してください。

オペレーティングシステムが変更を許していない、または読み取り専用にしているファイルをvisitした場合、Emacsもバッファーを読み取り専用にするので、保存すると問題を起こすような変更を防ぐことができます。`C-x
C-q` (`read-only-mode`)で、バッファーを書き込み可能にできます。[Misc Buffer](#Misc-Buffer)を参照してください。

C-x C-r
find-file-read-only
予期せぬ入力による変更を防ぐために、読み込み専用でファイルをvisitしたい場合は、`C-x C-f`のかわりにコマンド`C-x
C-r` (`find-file-read-only`)でvisitします。

C-x 4 f
find-file-other-window
`C-x 4 f` (`find-file-other-window`)は`C-x
C-f`と同様ですが、指定したファイルを含むバッファーは、別のウィンドウで選択されます。`C-x 4
f`の前に選択されていたウィンドウは、すでに表示していたのと同じバッファーの表示を続けます。1つのウィンドウしか表示されていないときにこのコマンドを使うと、これはウィンドウを2つに分割し、1つのウィンドウには前に表示されていたのと同じバッファー、別の1つには新しい要求されたファイルを表示します。[Windows](#Windows)を参照してください。

C-x 5 f
find-file-other-frame
`C-x 5 f` (`find-file-other-frame`)も同様ですが、新しいフレームををオープンするか、指定したファイルをすでに表示している既存のフレームを選択します。[Frames](#Frames)を参照してください。

file selection dialog
グラフィカルなディスプレーでは、ファイルをvisitする追加の方法が２つあります。1つ目は、Emacsが適したGUIツールキットによりビルドされているとき、マウスによるコマンドの呼び出し(メニューバーやツールバーのクリックによる)は、ミニバッファーでファイル名の入力を求める代わりに、そのツールキット標準のファイル選択(file selection)ダイアログを表示します。GNU/LinuxおよびUnixプラットフォームでは、GTK+、LessTif、Motifツールキットとともに構築されていると、Emacsはこれを行います。MS-WindowsとMacでは、GUIバージョンのデフォルトにより行われます。これをカスタマイズする情報については、[Dialog Boxes](#Dialog-Boxes)を参照してください。

2つ目は、Emacsはのドラッグアンドドロップ(drag and drop)サポートで、通常のEmacsウィンドウにファイルをドロップすることにより、そのウィンドウでファイルをvisitします。例外としてDiredバッファーを表示しているウィンドウにファイルをドロップすると、表示されているディレクトリーにファイルを移動またはコピーします。詳細については[Drag and Drop](#Drag-and-Drop)と[Misc Dired Features](#Misc-Dired-Features)を参照してください。

テキスト端末、およびGUIツールキットなしでビルドされているグラフィカルなディスプレーでは、アイテム‘`Visit New
File`’と‘`Open File`’をもつメニューバーの‘`File`’メニューから、、ファイルをvisitできます。

文字エンコーディングと使用されている改行規則を検知するために、Emacsは自動的に内容をスキャンします。そして、それらをEmacsの内部エンコーディングとバッファーの改行規則に変換します。バッファーを保存するとき、Emacsは逆の変換を行い、元のエンコーディングと改行規則でファイルをディスクに書き込みます。[Coding Systems](#Coding-Systems)を参照してください。

find-file-literally
ファイルにたいして特別なエンコーディングや変換を行わずに、非ASCII文字のシーケンスとして編集したいときは、`M-x
find-file-literally`コマンドを使います。これは`C-x C-f`と同様ですが、フォーマット変換(section “Format Conversion” in the Emacs Lisp Reference Manualを参照してください)、文字コード変換([Coding Systems](#Coding-Systems)を参照してください)、自動解凍([Compressed Files](#Compressed-Files)を参照してください)を行わず、`require-final-newline`による最後の改行も追加しません([Customize Save](#Customize-Save)を参照してください)。同じファイルをすでに通常(非リテラル)の方法でvisitしている場合、このコマンドはそれをリテラル(そのままの文字の列)としてvisitするかを尋ねます。

find-file-hook
find-file-not-found-functions
2つの特別なフック変数により、ファイルをvisitする操作を変更して拡張することができます。存在しないファイルをvisitすることにより、`find-file-not-found-functions`の関数が実行されます。この変数は関数のリストを保有し、それらはどれか1つが非`nil`を返すまで、(引数を指定せずに)1つずつ呼び出されます。これはノーマルフックではないため、その事実を示すために名前の最後が‘`-hook`’ではなく、‘`-functions`’で終わっています。

ファイルが存在するしないにかかわらず、ファイルをvisitするのに成功すると、引数なしで関数`find-file-hook`を呼び出します。この変数はノーマルフックです。ファイルが存在しない場合、最初に`find-file-not-found-functions`を実行します。[Hooks](#Hooks)を参照してください。

ファイルを編集するために自動的にメジャーモードを指定し([Choosing Modes](#Choosing-Modes)を参照してください)、そのファイルのために特別なローカル変数を定義する方法がいくつかあります([File Variables](#File-Variables)を参照してください)。

ファイルの保存
--------------

Emacsでのバッファーの保存(Saving)は、バッファーの内容を、そのバッファーによりvisitされているファイルに書き戻すことを意味します。

### ファイルを保存するコマンド

ファイルの保存と書き込みに関するコマンドが、いくつかあります。

`C-x C-s`  
現在のバッファーを、そのファイルに保存します(`save-buffer`)。

`C-x s`  
任意、またはすべてのバッファーを、それらのファイルに保存します(`save-some-buffers`)。

`M-~`  
現在のバッファーが変更されたことを忘れます(`not-modified`)。プレフィクス引数(`C-u`)を指定すると、現在のバッファーを変更済みとマークします。

`C-x C-w`  
現在のバッファーを、指定したファイル名で保存します(`write-file`)。

`M-x set-visited-file-name`  
現在のバッファーが保存される場所で、ファイル名を変更します。

C-x C-s
save-buffer
ファイルを保存して変更を永続化させたいときは、`C-x C-s` (`save-buffer`)とタイプします。保存が完了すると、`C-x C-s`は以下のようなメッセージを表示します:

    Wrote /u/rms/gnu/gnu.tasks

現在のバッファーが変更されていない(新規作成されたとき、または最後に変更されたときから変更していない)場合、保存しても意味がないので実際の保存は行われません。かわりに`C-x
C-s`は、エコーエリアに以下のようなメッセージを表示します:

    (No changes need to be saved)

`C-u C-x
C-s`のようにプレフィクス引数を指定すると、Emacsはそのバッファーを次回の保存が行われるときバックアップするようマークします。[Backup](#Backup)を参照してください。

C-x s
save-some-buffers
コマンド`C-x s` (`save-some-buffers`)は、任意、またはすべての変更されたバッファーの保存を提案します。これはバッファーごとに何を行うか尋ねます。使用できる応答は、`query-replace`と同様です。

`y`  
このバッファーを保存し、残りのバッファーについて尋ねます。

`n`  
このバッファーは保存せずに、残りのバッファーについて尋ねます。

`!`  
このバッファーを保存し、残りのバッファーを尋ねることなくすべて保存します。

`RET`  
これ以上の保存をせずに、`save-some-buffers`を終了します。

`.`  
このバッファーを保存したら、他のバッファーをどうするか尋ねることなく、`save-some-buffers`を終了します。

`C-r`  
現在尋ねられているバッファーを閲覧します。Viewモードから抜けると、再び`save-some-buffers`はどうするか尋ねます。

`d`  
そのバッファーに対応するファイルとDiffをとり、どのような変更を保存するのか確認できます。これはコマンド`diff-buffer-with-file` ([Comparing Files](#Comparing-Files)を参照してください)を呼び出します。

`C-h`  
これらのオプションについての、ヘルプメッセージを表示します。

save-some-buffers-default-predicate `save-some-buffers-default-predicate`の値をカスタマイズして、どのバッファーにたいしてEmacsが問い合わせるか制御できます。

Emacsを終了するキーシーケンス`C-x C-c`は、`save-some-buffers`を呼び出すので、同じ質問をします。

M-~
not-modified
バッファーを変更したが変更を保存したくないとき、保存されるのを防ぐためにできることがいくつかあります(それ以外の`C-x
s`または`C-x C-c`で間違って保存してしまうのはあなたの責任です)。まずできることは、`M-~` (`not-modified`)とタイプすることで、これはバッファーが変更されているというマークをクリアーします。これを行うと、保存コマンドに、バッファーが保存を必要しないと信じこませることができます(‘`~`’は数学のシンボルで、“not(否定)”として使われることがあります。したがって`M-~`はメタと“not”になります。)。かわりにファイルからテキストを読み込むことにより、ファイルをvisitまたは保存された後に行った、すべての変更を取り消すことができます。これはリバート(reverting: 復元)と呼ばれます。[Reverting](#Reverting)を参照してください(undoコマンド`C-x
u`を繰り返すことにより、変更がすべての変更を取り消すこともできますが、リバートの方が簡単です)。

set-visited-file-name
`M-x
set-visited-file-name`は、現在のバッファーがvisitしているファイルの名前を変更します。このコマンドはミニバッファーを使って、新しいファイル名を読み取ります。その後に、そのバッファーがそのファイル名のファイルをvisitしているとマークし、バッファー名も合わせて変更します。`set-visited-file-name`は、新しくvisitするファイルへの保存はしません。これは後で保存するときのために、Emacs内のレコードを変更するだけです。これはバッファーを変更されている(modified)とマークするので、そのバッファーでの*将来*の`C-x
C-s`で、保存が行われます。

C-x C-w
write-file
バッファーにたいして、違うファイルをvisitしているとマークしてすぐに保存したい場合は、`C-x C-w` (`write-file`)を使います。このコマンドは、`set-visited-file-name`の後すぐに`C-x
C-s`をするのと同じですが、`C-x
C-w`はファイルが存在するとき確認を求める点が異なります。ファイルをvisitしていないバッファーでの`C-x C-s`は、`C-x
C-w`と同じ効果をもちます。したがってファイル名を読み取り、バッファーがそのファイルをvisitしているとマークした後、バッファー内容をそのファイルに保存します。ファイルをvisitしていないバッファーのデフォルトファイル名は、バッファー名と、バッファーのデフォルトディレクトリーから合成されます([File Names](#File-Names)を参照してください)。

新しいファイル名が何らかのメジャーモードに関連する場合、大抵は`C-x
C-w`によりそのメジャーモードへの切り替えが行われます。コマンド`set-visited-file-name`もこれを行います。[Choosing Modes](#Choosing-Modes)を参照してください。

Emacsがファイルを保存する際、ディスクの最新バージョンのファイル日付を確認して、それがEmacsが最後に読み込み、または書き込みしたときと異なる場合、Emacsはその事実をユーザーに知らせます。なぜならそれはおそらく同時編集による問題を示しており、それをすぐにユーザーに知らせる必要があるからです。[Simultaneous Editing](#Interlocking)を参照してください。

### バックアップファイル

backup file
make-backup-files
ほとんどのオペレーティングシステムでは、ファイルを書き換えるとファイルに入っていたそれまでの記録は、自動的に破棄されます。したがって、Emacsでファイルを保存すると、ファイルの古い内容は捨てられます。しかし実際に保存する前に、Emacsが慎重に古い内容をバックアップ(backup)ファイルと呼ばれる別のファイルにコピーすれば、古い内容は失われません。

Emacsは最初にバッファーからファイルに保存されたときだけ、バックアップファイルを作成します。その後ファイルを何回保存しようと、バックアップは変更されません。しかしバッファーをkillしてから、そのファイルを再びvisitすると、新しいバックアップファイルが作成されます。

ほとんどのファイルにたいして、変数`make-backup-files`はバックアップファイルを作るかを決定します。ほとんどのオペレーティングシステムでは、デフォルト値は`t`なので、Emacsはバックアップファイルを書き込みます。

バージョンコントロールシステム(version control system: [Version Control](#Version-Control)を参照してください)で管理されているファイルにたいして、バックアップファイルを作るかは、変数`vc-make-backup-files`により決定されます。バージョンコントロールシステムに以前のバージョンがある場合、バックアップファイルを作るのは不必要なので、デフォルト値は`nil`です。 [General VC Options](#General-VC-Options)を参照してください。

選択できるオプションは、Emacsにファイルごとに1つのバックアップを作らせる方法と、編集するファイルごとに番号がついた、一連のファイルを作る方法があります。[Backup Names](#Backup-Names)を参照してください。

backup-enable-predicate
temporary-file-directory
small-temporary-file-directory
変数`backup-enable-predicate`のデフォルト値は、一時的なファイルのために使われるディレクトリー(変数`temporary-file-directory`または`small-temporary-file-directory`で指定されます)のファイルは、バックアップしないような値になっています。

前に保存されたバッファーにたいしても、バッファーから他のバックアップファイルを作るよう、Emacsに明示的に指示することができます。バッファーを`C-u
C-x C-s`で保存すると、この保存したバージョンが、次にバックアップするときのバックアップになります。`C-u C-u C-x
C-s`はバッファーを保存しますが、最初に元のファイル内容を新しいバックアップファイルとします。`C-u C-u C-u C-x
C-s`は両方を行います。まず前の内容でバックアップを作成し、次回に保存したときは、今回保存したものをバックアップにします。

backup-directory-alist
変数`backup-directory-alist`をカスタマイズして、指定したパターンにマッチする特定のファイルにたいして、指定したディレクトリーにバックアップを作成させることができます。典型的な使い方は、要素`("."
.
dir)`を追加することにより、すべてのバックアップを絶対パスdirに作る方法です。異なるディレクトリーにある同じ名前のファイルによる、バックアップファイルの名前の衝突を避けるため、Emacsはバックアップファイルの名前を変更します。`("."
.
".~")`を追加すると、これは元のファイルがあるディレクトリーに、非表示の`.~`というディレクトリーを作って、そこにバックアップを作成します。Emacsはバックアップを作るため、必要ならディレクトリーを作成します。

#### 単一または番号つきバックアップ

backup file names
names of backup files
~
, in names of backup files
tilde (
~
) at end of backup file name
Emacsのバックアップファイル作成では、バックアップの名前は通常、編集されるファイル名の後ろに‘`~`’をつけて作成されます。したがって`eval.c`のバックアップファイルは、`eval.c~`になります。

~/.emacs.d/%backup%~
アクセスコントロールによりEmacsが通常の名前でバックアップファイルを書き込めない場合、`~/.emacs.d/%backup%~`というバックアップファイルに書き込みます。この1つのファイルしか存在しないので、一番最近作られたバックアップだけが利用可能です。

Emacsは番号つきバックアップファイル(numbered backup files)を作ることもできます。番号つきバックアップファイルの名前は、元のファイル名の後ろに‘`.~`’と番号と‘`~`’をつけたものです。したがって`eval.c`のバックアップファイルは、`eval.c.~1~`、`eval.c.~2~`、...、`eval.c.~259~`、...となります。

version-control
変数`version-control`は、単一のバックアップファイルを作るか、複数の番号つきバックアップファイルを作るかを決定します。有効な値は以下のとおりです:

`nil`  
すでに番号つきバックアップのあるファイルにたいしては、番号つきバックアップを作ります。それ以外は単独のバックアップをつくります。これがデフォルトです。

`t`  
番号つきバックアップを作ります。

`never`  
番号つきバックアップをつくらず、常に単一のバックアップを作ります。

この変数をセットする通常の方法は、initファイルやcustomizationバッファーを通じて、グローバルにセットする方法です。しかし特定のバッファーにローカルに`version-control`をセットして、そのバッファーのバックアップ作成を制御することができます([Locals](#Locals)を参照してください)。特定のファイルをvisitするとき、常にEmacsに`version-control`をローカルにセットさせることができます([File Variables](#File-Variables)を参照してください)。Rmailモードのようないくつかのモードは、この変数をセットします。

VERSION\_CONTROL
environment variable
さまざまなGNUユーティリティーにたいして、何をすべきか指示する環境変数VERSION\_CONTROLをセットすると、Emacsも開始時にこの環境変数にしたがって、Lisp変数`version-control`をセットします。環境変数の値が‘`t`’または‘`numbered`’のときは、`version-control`は`t`になります。値が‘`nil`’または‘`existing`’のときは、`version-control`は`nil`になります。もし‘`never`’または‘`simple`’のときは、`version-control`は`never`になります。

make-backup-file-name-function
変数`make-backup-file-name-function`に適切なLisp関数をセットすることにより、Emacsがバックアップファイル名を作る通常の方法をオーバーライドできます。

#### バックアップの自動削除

ディスク容量の過度な消費を防ぐため、Emacsは自動的に番号つきバックアップを削除することができます。一般的にEmacsは一番古いバックアップと、一番新しいバックアップをいくつか保持し、その間にあるバックアップを削除します。これは新しいバックアップが作られる度に行なわれます。

kept-old-versions
kept-new-versions
2つの変数`kept-old-versions`および`kept-new-versions`が、この削除を制御します。これらの変数の値は順に、削除せずに残す一番古い番号(小さい番号)のバックアップと、一番新しい番号(大きい番号)で、新しいバックアップが作られる度に評価されます。中間のバックアップ(一番古いものと一番新しいものを除いたもの)は、余分なバージョンで、これらのバックアップは削除されます。これらの変数の値は余分なバージョンを削除するとき、つまり新しいバックアップが作られた直後に使われます。新しく作られたバックアップは、`kept-new-versions`のカウントに含まれます。デフォルトでは、両方の変数の値は2です。

delete-old-versions
`delete-old-versions`が`t`のとき、Emacsは何も尋ねずに余分なバックアップファイルを削除します。`nil`(デフォルト)のとき、Emacsは余分なバージョンのバックアップを削除するか尋ねます。他の値の場合、Emacsはバックアップの自動削除をしません。

Diredの`.`(ピリオド)コマンドでも、古いバージョンを削除できます。[Flagging Many Files](#Flagging-Many-Files)を参照してください。

#### コピー vs. リネーム

バックアップファイルは、古いファイルをコピーまたはリネームすることで作ることができます。コピーとリネームは、古いファイルが複数の名前をもつ場合(ハードリンクされている場合)に、異なる効果をもちます。古いファイルがバックアップファイルにリネームされた場合、ハードリンクされた別の名前で参照されるファイルは、バックアップファイルとなります。かわりに古いファイルをコピーすると、ハードリンクされた別の名前で参照されるファイルは、編集中のファイルのままで、それらの名前でアクセスする内容は新しい内容となります。

バックアップファイルを作る方法は、編集中のファイルの所有者とグループにも影響します。コピーが使われた場合、それらは変化しません。リネームが使われた場合、そのユーザーがファイルの所有者となり、ファイルのグループはデフォルト(オペレーティングシステムごとにグループのデフォルトは異なります)のグループになります。

backup-by-copying
backup-by-copying-when-linked
backup-by-copying-when-mismatch
backup-by-copying-when-privileged-mismatch
file ownership, and backup
backup, and user-id
リネームとコピーの選択は、以下の変数により行われます:

-   変数`backup-by-copying`が非`nil`(デフォルトは`nil`)の場合、コピーが使用されます。

-   上記以外の場合、変数`backup-by-copying-when-linked`が非`nil`(デフォルトは`nil`)で、ファイルが複数の名前をもつ場合は、コピーが使用されます。

-   上記以外の場合、変数`backup-by-copying-when-mismatch`が非`nil`(デフォルトは`t`)で、リネームによりファイルの所有者かグループが変更される場合は、コピーが使用されます。

    `backup-by-copying-when-mismatch`を`nil`に変更すると、Emacsはファイルの所有者のユーザーIDの数字をチェックします。もしこの数字が`backup-by-copying-when-privileged-mismatch`の値より大きい場合、`backup-by-copying-when-mismatch`が非`nil`であるかのように振る舞います。

-   上記以外の場合、リネームがデフォルトの選択となります。

ファイルがバージョンコントロールシステムで管理されている場合([Version Control](#Version-Control)を参照してください)、通常、Emacsは普通の方法でそのファイルのバックアップを作りません。しかしコミット(チェックインとも呼ばれる。see [VCS Concepts](#VCS-Concepts)を参照されたい)は、バックアップを作るのと似たところがあります。これらの操作は通常ハードリンクをこわし、同じファイルにたいする別のファイル名でのvisitを切断します。Emacsにできることはありません。バージョンコントロールシステムがこれを行うのです。

### ファイル保存のカスタマイズ

require-final-newline
変数`require-final-newline`の値が`t`のとき、ファイルの保存または書き込みにより、ファイルの終端に改行がないときは、何も尋ねずに改行を追加します。値が`visit`の場合、Emacsはファイルをvisitした直後に、終端に改行がないファイルの改行を追加します(これによりバッファーは変更されたとマークされます。undoはできません)。値が`visit-save`の場合、Emacsはそのような改行をvisitと保存のときに追加します。値が`nil`の場合、Emacsはファイルの終端を変更しません。それ以外の非`nil`値は、改行を追加するかをEmacsが尋ねることを意味します。デフォルトは`nil`です。

mode-require-final-newline
ファイルの終端に常に改行があると想定する、特定の種類のファイルのためにデザインされたメジャーモードがいくつかあります。そのようなメジャーモードは、変数`require-final-newline`に、変数`mode-require-final-newline`の値(デフォルトは`t`)をセットします。後者の変数の値をセットすることにより、これらのモードが終端の改行を取り扱う方法を制御できます。

write-region-inhibit-fsync
通常プログラムがファイルに書き込むとき、オペレーティングシステムはデータをディスクにコミットする前に、ファイルのデータをメインメモリーにキャッシュします。これにより大幅にパフォーマンスを向上できます。たとえばラップトップを使っている場合、ファイルを書き込む度にディスクをスピンアップ(spin-up)しなくて済みます。しかし、キャッシュをディスクにコミットする前にオペレーティングシステムがクラッシュすることにより、データを失うリスクもあります。

このリスクを減少させるため、Emacsはファイルを保存した後に`fsync`システムコールを呼び出すことができます。`fsync`により、データを失うリスクを皆無にすることはできません。その理由の一部は、多くのシステムは`fsync`を正しく実装していないことであり、他の理由の一部はEmacsのファイル保存手段は通常ディレクトリー更新に頼っており、これは`fsync`が正しく実装されていても、クラッシュを生き延びることはできないでしょう。

`write-region-inhibit-fsync`変数は、ファイルを保存した後にEmacsが`fsync`を呼び出すかを制御します。この変数のデフォルト値は、Emacsを対話的に使用しているときは`nil`、バッチモードの時は`t`です([Batch Mode](#Initial-Options)を参照)。

Emacsは自動保存ファイルの書き込みに`fsync`を使うことはありません。なぜなら、それらのファイルのデータは、いずれにせよ失われるものだからです。

### 同時編集からの保護

file dates
simultaneous editing
同時編集(Simultaneous editing)は、2人のユーザーが同じファイルをvisitして、両者が変更と保存を行ったときに発生します。これが発生していることを誰も知らせなければ、最初に保存したユーザーは、後で自分の変更が失われていることに気付くでしょう。

いくつかのシステムでは、Emacsは2番目のユーザーがファイルの変更を開始すると、すぐに警告を発します。また、すべてのシステムにおいて、Emacsはファイルを保存するときにチェックして、他のユーザーの変更を上書きすることを警告します。ファイルを保存するかわりに適切な訂正アクションをとることにより、他のユーザーの変更を失わなわずに済みます。

ask-user-about-lock
locking files
.\#, lock file names
file locking
ファイルをvisitしているEmacsバッファーで最初の変更を行うとき、Emacsはファイルがロック(locked)されていることを記録します(これは同じディレクトリーにある、特別な内容の、特別な名前のシンボリックリンク[7]を作ることにより行われます。詳細はを参照のこと)。変更を保存したとき、Emacsはロックを解除します。このアイデアは、ファイルをvisitしているEmacsバッファーに保存されていない変更があるとき、ファイルはロックされているとするものです。

create-lockfiles
変数`create-lockfiles`を`nil`にセットすることにより、ロックファイルの作成を抑制することができます。**警告:**これにより、この機能が提供する利点を失うことになります。

collision
他のユーザーによりロックされているファイルをvisitしているバッファーの変更を開始すると、衝突(collision)が起こります。Emacsが衝突を検知すると、Lisp関数`ask-user-about-lock`を呼び出して、何を行うか尋ねます。カスタマイズのためにこの関数を再定義できます。この関数の標準定義は、ユーザーに質問をして、3つの有効な応えを受け取ります。

`s`  
ロックを横取りします。すでにファイルを変更したユーザーはロックを失い、あなたがロックを取得します。

`p`  
続行します。他のユーザーがロックしている如何にかかわらずファイルの編集を続けます。

`q`  
終了します。これはエラー(`file-locked`)を引き起こし、バッファーの内容は変更されません。あなたが試みた修正は実際には行われません。

Emacsまたはオペレーティングシステムがクラッシュすると、偽のロックファイルが残ることがあり、このような偽のロックファイルによる警告を受けることがあります。偽の衝突だと確信できるときは、Emacsにとにかく実行させる`p`を使います。

ロックはファイル名にもとづいて機能するので、ファイルが複数の名前を持っていて、2人のユーザーがそれぞれ別のファイル名で同時編集を行うことを、Emacsが防ぐことはできないことに注意してください。

ロックファイルに書き込みできない状況がいくつかあります。たとえばシステム権限不足や他の理由により、Emacsがロックファイルが作成できない場合です。このような場合でも保存を試みたときに、ファイルの最終変更日時をチェックすることにより、Emacsは衝突を検知できます。最後にEmacsがvisitまたは保存したときからファイルが変更されているとき、それは他の何らかの手段によりファイルが変更されたことを示し、Emacsが保存を行うことによりそれらが失われることを意味します。そのようなときEmacsは警告メッセージを表示して、保存する前に確認を求めます。保存するときは`yes`、保存を取り消すときは`no`または`C-g`と応えてください。

すでに同時編集が発生しているとき、バッファーとファイルを比較する方法の1つは、`M-x
diff-buffer-with-file`コマンドです。[Comparing Files](#Comparing-Files)を参照してください。

### ファイルのシャドーイング

shadow files
file shadows
shadow-initialize
特定のファイルと等しいshadowコピーを１つ以上の場所、ことによると異なるマシン間で保持するように計画できます。これを行うにはまず、shadowファイルグループをセットアップしなければなりません。これはリストにあるサイト間で共有される同じ名前のファイルのセットです。ファイルグループは永続的で、将来のEmacsセッションでも、現在のセッションと同様に適用されます。一度グループをセットアップすると、Emacsを終了する度に、編集したファイルをグループの他のファイルにコピーします。`M-x
shadow-copy-files`をタイプすることにより、Emacsを終了せずにコピーすることもできます。

shadow cluster
shadowクラスターは、ディレクトリーを共有するホストのグループなので、それらのコピーは、そのディレクトリーにあるすべてのファイルを更新するのに充分です。shadowクラスターはそれぞれ名前を持ち、プライマリーホスト(コピーを行うホスト)のネットワークアドレスと、プライマリーホスト以外でクラスターに含めるホストを選択するための正規表現を指定します。`M-x
shadow-define-cluster`によりshadowクラスターを定義できます。

`M-x shadow-initialize`  
ファイルのシャドーイング(shadowing)をセットアップします。

`M-x shadow-define-literal-group`  
サイト間で共有される単一のファイルを定義します。

`M-x shadow-define-regexp-group`  
ファイルのグループがマッチするすべてのファイルを、ホスト間で共有するようにします。

`M-x shadow-define-cluster RET name RET`  
shadowファイルのクラスターnameを定義します。

`M-x shadow-copy-files`  
すべての保留中のshadowファイルをコピーします。

`M-x shadow-cancel`  
ファイルにたいするshadow指示を取り消します。

shadowファイルグループをセットアップするには、`M-x
shadow-define-literal-group`または`M-x
shadow-define-regexp-group`を使います。詳細な情報は、これらの関数のドキュメント文字列を参照してください。

ファイルをshadowにコピーする前に、Emacsは確認を求めます。“no”を応えることにより、その時だけはコピーを回避できます。特定のファイルにたいして今後もshadowingを取り消したい場合、`M-x
shadow-cancel`を使うことにより、shadowファイルグループを削除または変更します。

MS Widowsでは、ファイルのシャドーイングは利用できません。

### タイムスタンプの自動更新

time stamps
modification dates
locale, date format
ファイルにタイムスタンプを書き込むことができます。これによりファイルを編集・保存する度に、タイムスタンプが自動的に更新されます。タイムスタンプは、ファイルの最初の8行になければならず、以下のような形式、

    Time-stamp: <>

または以下のような形式です:

    Time-stamp: " "

time-stamp
その後、フック`before-save-hook`に関数`time-stamp`を追加します([Hooks](#Hooks)を参照してください)。ファイルを保存するとき、この関数は現在の日時で自動的にタイムスタンプを更新します。コマンド`M-x
time-stamp`を使って、手動でタイムスタンプを更新することもできます。デフォルトではタイムスタンプの書式は、localeのセッティング([Environment](#Environment)を参照してください)と、タイムゾーン(section “Time of Day” in The Emacs Lisp Reference Manualを参照してください)にしたがいます。カスタマイズに関しては、Customグループの`time-stamp`を参照してください。

バッファーのリバート
--------------------

revert-buffer
drastic changes
reread a file
ファイルをvisitしているバッファーにたいして、広範な変更をした後に気が変わったときは、リバート(revert: 復元)することにより。変更をファイルの保存されたバージョンに戻すことができます。間違えてリバートしてしまうことにより、大量の作業結果を失うこともあり得るので、Emacsは最初に確認を求めます。

`revert-buffer`コマンドは、ファイルが少ししか変更されていないときは、前にポイントがあったテキスト部分とだいたい同じ位置にポイントを置くよう試みます。しかし広範な変更を行っていた場合、ポイントは大きく異なる場所に置かれることになります。

リバートはバッファーをnot modified(変更されていない)とマークします。しかし、これはリバートされた変更を単一の変更として、そのバッファーのundoヒストリーに追加します([Undo](#Undo)を参照)。したがって、リバート後に気が変わってリバートされた変更を元に戻したくなった場合は、`C-/`またはそのエイリアスをタイプして、それを行うことができます。

ファイルに関連付けられていない、Diredバッファーのようなバッファーでも、リバートすることができます。それらの場合、リバートはその内容を再計算することを意味します。`C-x
b`で明示的に作成したバッファーは、リバートできません。リバートを試みると`revert-buffer`はエラーを報告します。

revert-without-query
自動的かつ頻繁に変更されるファイル、たとえば実行を続けるプロセスのログ出力などを編集しているとき、Emacsが確認なしにリバートできたら便利でしょう。このような振る舞いをさせるには、変数`revert-without-query`に正規表現のリストをセットします。ファイル名がそれらの正規表現の1つにマッチしたとき、`find-file`および`revert-buffer`は、バッファーが変更されていないときは、ファイルが変更される度に自動的にリバートします(もしテキストを編集していた場合、変更を放棄するのはおそらく正しくありません)。

Global Auto Revert mode
mode, Global Auto Revert
Auto Revert mode
mode, Auto Revert
global-auto-revert-mode
auto-revert-mode
auto-revert-tail-mode
auto-revert-interval
auto-revert-remote-files
auto-revert-verbose
Emacsにバッファーを定期的にリバートするよう、指示することもできます。特定のバッファーにたいしてこれを行うには、`M-x
auto-revert-mode`とタイプして、マイナーモードのAuto-Revertモードを有効にします。カレントバッファーがvisitしているファイルがディスク上で変更されたとき、自動的にリバートします。すべてのバッファーにたいして同じことを行うには、`M-x
global-auto-revert-mode`とタイプして、Global Auto-Revertモードを有効にします。これらのマイナーモードはリモートのファイルにたいするチェックやリバートはしません。なぜならそれは通常とても遅いからです。この動作は、変数`auto-revert-remote-files`を非`nil`にセットすることにより変更できます。

file notifications
auto-revert-use-notify
デフォルトでは、Auto-Revertモードはファイル通知(file notifications)を使用して機能します。これにより、ファイルシステムへの変更が、OSからEmacsに報告されます。変数`auto-revert-use-notify`を`nil`にカスタマイズして、ファイル通知を無効にできます。その場合、Emacsは5秒ごとにポーリングして、ファイルの変更をチェックするでしょう。変数`auto-revert-interval`を通じて、ポーリングの間隔を変更できます。

すべてのシステムでファイル通知がサポートされている訳ではありません。サポートされないシステムでは、`auto-revert-use-notify`はデフォルトで`nil`です。

Auto-Revertモードの1つの使い方は、システムログのようなファイルを“tail”することです。これにより、それらのファイルにたいする、他のプログラムによる変更を、継続的に表示できます。これを行うには、ポイントをバッファーの最後に移動します。そうすればファイル内容が変更されても、ポイントはその位置に留まります。しかし、ファイルがファイルの終端方向に向かって変更されるだけだと確信できるときは、かわりにAuto-Revert Tailモード(`auto-revert-tail-mode`)を使います。このモードは、これをより効果的に行います。Auto-Revert Tailモードは、リモートのファイルにたいしても機能します。

バッファーが自動リバートされたとき、メッセージが生成されます。これは`auto-revert-verbose`を非`nil`にセットすることにより、抑制できます。

Diredバッファー([Dired](#Dired)を参照)では、Auto-Revertモードはそのバッファーのディレクトリーでファイルが作成、または削除されたとき更新を行います。

バージョンコントロールシステムの下にあるファイルを、以前のバージョンにリバーとするコマンドについては、[VC Undo](#VC-Undo)を参照してください。バージョンコントロールシステムの下にあるファイルをvisitしているときの自動リバートの特性については、[VC Mode Line](#VC-Mode-Line)を参照してください。

非ファイルバッファーの自動リバート
----------------------------------

通常Global Auto Revertモードは、ファイルのバッファーだけをリバートします。非ファイルバッファーにたいして自動リバートを行うには、2つの方法があります。1つはそれらのバッファーにたいしてAuto Revertモードを有効にする方法です(`M-x
auto-revert-mode`を使います)。もう1つは`global-auto-revert-non-file-buffers`に非`nil`値をセットする方法です。後者はそれが実装されているすべての種類のバッファーにたいして、自動リバートを有効にします(以下のメニューにリストされています)。

ファイルバッファーと同様、非ファイルバッファーはそれらにたいして作業を行っているときや、リバートすると失われてしまう情報が含まれているとき、通常はリバートすべきではありません。したがって、それらがmodified(変更されている)のときはリバートしません。非ファイルバッファーが変更されているとマークするのは、ファイルバッファーのときより通常難しいので、トリッキーになり得ます。

他のトリッキーな点に関する詳細は、効率の問題です。自動リバートはしばしばバッファーにたいするすべての可能な変更を検知しようとせず、広範または簡単に検知できる変更だけを検知します。したがって、非ファイルバッファーに自動リバートを有効にすることは、バッファーのすべての情報が最新であると常に保証はしませんし、手動によるリバートを無用にする必要もないからです。

それとは反対に、特定のバッファーは`auto-revert-interval`で指定された秒数ごとに自動的にリバートします(これは現在のところBuffer Menuだけに適用されます)。この場合、自動リバートはリバートの際、`auto-revert-verbose`が非`nil`でも、何もメッセージを表示しません。

詳細はバッファーの特性に依存し、それらは対応するセクションで説明されています。

### Buffer Menuの自動リバート

非ファイルバッファーの自動リバートが有効なとき、必要性の有無にかかわらず、Buffer Menu ([Several Buffers](#Several-Buffers)を参照) は`auto-revert-interval`で指定された秒数ごとに自動的にリバートされます。(リバートする必要があるかチェックするのは、恐らく実際にリバートするより長い時間を要する)。

Buffer Menuがmodifiedと不適切にマークされたときは、`g`により手動でリバートして自動リバートを再開します。しかし特定のバッファーにたいして削除や表示のマークをつけた場合は、慎重になる必要があります。なぜならリバートはすべてのマークを消去するからです。マークの追加はバッファーのmodifiedフラグをセットするという事実は、自動的なマークの消去からの自動リバートを防ぎます。

### Diredバッファーの自動リバート

Diredバッファーは、バッファーのメインディレクトリーのファイルリストが変化したとき(たとえば新しいファイルの追加や削除)だけ、自動リバートします。特定のファイルの情報が変化したとき(たとえばサイズの変化)や、サブディレクトリーへの追加は自動リバートしません。*すべて*のリストされた情報が最新であることを確実にするには、Diredバッファーで自動リバートが*有効であっても*、手動で`g`を使ってリバートする必要があります。メインディレクトリーにリストされているファイルへの変更や保存で、実際に自動リバートが起こるのに気付くかもしれません。これはファイルの変更や保存は、たとえばバックアップファイルやauto-saveファイルにより、高い確率でディレクトリー自身を変更するからです。しかし、これは保証されているわけではありません。

Diredバッファーがmodifiedとマークされ、残したい変更がない場合、大抵は`g`でバッファーを手動でリバートすることにより、自動リバートを再開できます。しかし1つ例外があります。ファイルにフラグやマークをつけた場合、安全にバッファーをリバートできます。これはフラグやマークを消去しません(もちろんマークされたファイルが削除されていない場合です)。しかしバッファーはリバートの後でさえmodifiedの状態に留まるので、自動リバートは再開しません。これは、もしファイルにたいしてフラグやマークをつけた場合、それはバッファーにたいして作業をしており、警告なしにバッファーが変更されることを望まないだろうからです。マークやフラグがある状態で自動リバートを再開したいときは、`M-~`を使ってバッファーをnon-modifiedとマークします。しかしマークやフラグの追加・削除・変更により、バッファーは再びmodifiedとマークされます。

現在のところ、リモートのDiredバッファーは、自動リバートされません。特定のファイルだけをリストするように、シェルのワイルドカードやファイル引数を与えられたDiredバッファーも同じです。`*Find*`および`*Locate*`は、どちらも自動リバートしません。

Diredバッファーの自動リバートは、いくつかのシステムでは満足に機能しないかもしれないことに注意してください。

自動保存－災害にたいする防御
----------------------------

Auto Save mode
mode, Auto Save
crashes
Emacsは定期的に、visitしているファイルを、実際に使っているファイルを変更せずに、別のファイルに自動的に保存するときがあります。これは自動保存(auto-saving)と呼ばれます。これはシステムがクラッシュしたとき、失われてしまう作業をある程度以下に制限するためのものです。

Emacsが自動保存するときだと決定すると、各バッファーを判断して、それらのバッファーの自動保存が有効で、最後に自動保存されてから変更されている場合は、自動保存します。ファイルが実際に自動保存されている場合は、自動保存の間、エコーエリアに‘`Auto-saving...`’というメッセージが表示されます。自動保存の間のエラーはキャッチされるので、ユーザーがタイプして実行したコマンドに、干渉することはありません。

### 自動保存ファイル

自動保存は通常、visitしているファイルへの保存はしません。なぜなら永続化したくない変更を保存するのは、好ましくないからです。そのかわりに、自動保存はauto-saveファイルと呼ばれる別のファイルに保存し、visitしているファイルへの変更は、保存を明示的に要求したとき(`C-x
C-s`など)に行います。

auto-saveファイルの名前は通常、visitしているファイル名の前後に‘`#`’をつけて作られます。したがって`foo.c`というファイルをvisitしているバッファーは、`#foo.c#`というファイルに自動保存されます。ファイルをvisitしていないバッファーのほとんどは、明示的に要求した場合だけ自動保存されます。それらのバッファーが自動保存されるとき、auto-saveファイル名は、バッファー名の前後に‘`#`’をつけて、その後ろに数字と文字を付け加えて一意な名前にします。たとえば送信メッセージを作成する`*mail*`バッファーは、`#*mail*#704juu`のような名前のファイルに、自動保存されます。Emacsの一部(関数`make-auto-save-file-name`および`auto-save-file-name-p`)を違った方法で再プログラムしない限り、auto-saveファイル名はこの方法で作成されますバッファーの自動保存に使われるファイル名は、そのバッファーの自動保存をオンにしたときに計算されます。

auto-save for remote files
auto-save-file-name-transforms
変数`auto-save-file-name-transforms`は、auto-saveファイル名をある程度制御することを許します。これに一連の正規表現を指定して置換することにより、auto-saveファイル名を変更します。デフォルト値は、リモートのファイル([Remote Files](#Remote-Files)を参照してください)を、ローカルマシンの一時ディレクトリーのauto-saveファイルに変換します。

大きなバッファーから大量のテキストを削除したとき、そのバッファーにたいする自動保存は一時的にオフになります。これは、もしテキストをうっかり削除してしまった場合、それがauto-saveファイルに含まれていて、そこから探せる方が便利だからです。これが発生した後、再び自動保存を有効にするには、バッファーを`C-x
C-s`で保存するか、`C-u 1 M-x auto-save-mode`を使います。

auto-save-visited-mode
別のauto-saveファイルではなく、visitしているファイル自体に自動保存したい場合は、グローバルなマイナーモード`auto-save-visited-mode`を有効にします。このモードでは、自動保存は明示的な保存と等価です。このモードは上述の`auto-save`と直交(orthogonal)するモードであり、両方同時に有効にできることに注意してください。しかし、いくつかのバッファーで`auto-save`モードがアクティブで、かつ時代遅れの`auto-save-visited-file-name`変数が非`nil`値の場合、そのバッファーは`auto-save-visited-mode`の影響を受けないでしょう。

`auto-save-visited-mode`モードの自動保存処理の間隔は、変数`auto-save-visited-interval`を使用してカスタマイズできます。`auto-save-interval`と`auto-save-timeout`は、`auto-save-visited-mode`に影響を与えません。これらの変数の詳細は、[Auto Save Control](#Auto-Save-Control)を参照してください。

delete-auto-save-files
バッファーのauto-saveファイルは、そのバッファーをvisitしているファイルに保存したとき削除されます(変数`delete-auto-save-files`を`nil`にセットすることにより、これを禁じることができます)。`C-x
C-w`または`set-visited-file-name`で、visitされているファイル名を変更することにより、あたらしくvisitされているファイル名にもとづいてauto-saveファイル名はリネームされます。

### 自動保存の制御

auto-save-default
auto-save-mode
ファイルをvisitする度に、そのファイルバッファーの自動保存は、オンになります(バッチモードでは異なります。[Initial Options](#Initial-Options)を参照してください)。この変数のデフォルトは`t`なので、ファイルをvisitしているバッファーの自動保存は通常、常に行われます。現在のバッファーの自動保存を切り替えるには、`M-x
auto-save-mode`とタイプします。Auto Saveモードはバッファーローカルに動作するマイナーモードです([Minor Modes](#Minor-Modes)を参照してください)。

auto-save-interval
Emacsは最後に自動保存されてから何文字タイプしたかにもとづいて、定期的に自動保存を行います。変数`auto-save-interval`は、自動保存と自動保存の間に何文字タイプされたかを指定します。デフォルトは300です。Emacsは小さすぎる値は受け付けません。`auto-save-interval`を20より小さな値にカスタマイズした場合、Emacsは20と指定されたかのように振る舞います。

auto-save-timeout
自動保存はタイピングをストップしたときも行われます。デフォルトでは30秒アイドル状態が続くと実行されます。(このときEmacsはガベージコレクションも実行します; section “Garbage Collection” in The Emacs Lisp Reference Manualを参照してください)。この間隔を変更するには、変数`auto-save-timeout`をカスタマイズします。実際の実行間隔は、現在のバッファーの大きさに応じて長くなります。これは、自動保存が実感できるほど時間がかかるような大きなバッファーを編集しているときは、それをなるべく無くすようにする狙いです。アイドル状態のときの自動保存は、2つの事を達成します。最初に、端末を少しの間離れるときなどに、すべての作業の保存を保証します。次に、実際にタイプしているときは自動保存を避けます。

auto-save-visited-interval
`auto-save-visited-mode`が有効なとき、Emacsはアイドル5秒後に、ファイルをvisitしているバッファーを自動保存するでしょう。アイドル時の間隔は、変数`auto-save-visited-interval`でカスタマイズできます。

Emacsは、致命的なエラーが発生したときも自動保存を行います。これには‘`kill
%emacs`’のようなコマンドによるEmacsジョブのkill、電話回線やネットワーク回線の切断が含まれます。

do-auto-save
コマンド`M-x do-auto-save`により、明示的に自動保存を行うことができます。

### 自動保存からのデータ復旧

recover-file
コマンド`M-x recover-file RET file
RET`により、auto-saveファイルの内容を使って、失われたデータを復旧できます。これはfileをvisitして、(確認を求めた後で)auto-saveファイル`#file#`の内容をリストアします。その後`C-x
C-s`で復旧したテキストを、file自身に保存できます。たとえばファイル`foo.c`を、そのauto-saveファイル`#foo.c#`で復旧するには、以下のようにします:

    M-x recover-file RET foo.c RET
    yes RET
    C-x C-s

`M-x
recover-file`は確認を求める前に、指定したファイルとauto-saveファイルのあるディレクトリー一覧を表示するので、ファイルのサイズや日付を確認できます。auto-saveの方が古い場合、`M-x
recover-file`はそれを読み込むように提案しません。

recover-session
Emacsまたはコンピューターがクラッシュしたとき、`M-x
recover-session`コマンドで編集していたすべてのファイルを、それらのauto-saveファイルで復旧できます。これは最初に中断されたセッションの記録された一覧を表示します。ポイントを移動して選択してから、`C-c
C-c`をタイプします。

`recover-session`は、そのセッションの間に編集されていた各ファイルについて、ファイルを復旧するか尋ねます。`y`と応えると`recover-file`を呼び出し、通常の方法で復旧を行います。これは元のファイルとauto-saveファイルの日付を表示して、ファイルの復旧を行うかもう1度尋ねます。

`recover-session`が完了すると、復旧を選択したファイルがEmacsバッファーに表示されます。実際にファイル自体を 更新するためには、これらを保存するのが唯一の方法です。

auto-save-list-file-prefix
Emacsは中断されたセッションについての情報を、ディレクトリー`~/.emacs.d/auto-save-list/`の、`.saves-pid-hostname~`という名前のファイルに記録します。`auto-save-list-file-prefix`を`nil`にセットすると、復旧用にセッションが記録されなくなります。

ファイルのエイリアス
--------------------

symbolic links (visiting)
hard links (visiting)
シンボリックリンクとハードリンクは、同じファイルを参照するためにいくつかの名前を使うことを可能にします。ハードリンクは、ファイルを直接参照する他の名前です。それらすべての名前は同じように有効で、それらの間に優先順位はありません。対照的にシンボリックリンクは、ある種の定義されたエイリアス(別名)です。`foo`が`bar`へのシンボリックリンクの場合、そのファイルをどちらの名前でも参照できますが、`bar`が実際の名前で、`foo`はエイリアスに過ぎません。シンボリックリンクがディレクトリーを指すときは、さらに複雑なケースが発生します。

find-file-existing-other-name
find-file-suppress-same-file-warnings
Emacsがすでに異なる名前でvisitしている場合、通常はエコーエリアにメッセージを表示して、そのファイルをvisitしている既存のバッファーを使います。これはハードリンクおよびシンボリックリンクをサポートしているシステム、または長いファイル名を切り詰めるシステムで長い名前のファイルを使っている場合、またはファイル名の大文字小文字を区別しないシステムで発生します。変数`find-file-suppress-same-file-warnings`を非`nil`値にセットすることにより、メッセージを表示しないようにできます。変数`find-file-existing-other-name`を`nil`にセットすれば、この機能全体を無効にできます。その場合、同じファイルを異なる名前でvisitすると、それぞれのファイル名で別々のバッファーが使われます。

find-file-visit-truename
truenames of files
file truenames
変数`find-file-visit-truename`が非`nil`の場合、バッファー用に記録されるファイル名は、指定した名前ではなく、ファイルの本当の名前(これはすべてのシンボリックリンクを対象の名前で置き換えて作られます)が使われます。`find-file-visit-truename`をセットするは、`find-file-existing-other-name`にも暗に影響します。

directory name abbreviation
directory-abbrev-alist
シンボリックリンクを通じてアクセスされるようなディレクトリーにたいしては通常、優先的にリンクされた名前をEmacsに表示させたいときがあります。これを行うには`directory-abbrev-alist`をカスタマイズします。このリストの各要素は`(from
.
to)`という書式です。これはディレクトリー名にfromが出現したときは常に、fromをtoで置き換えることを意味します。文字列fromは正規表現です([Regexps](#Regexps)を参照してください)。正規表現はディレクトリー名の最初の文字にマッチさせる必要があるので、‘`` \` ``’で始まります(埋め込みの改行をサポートするディレクトリー名の場合は、‘`^`’で無効にします)。toには同じディレクトリーを指す、絶対パスによる普通のディレクトリー名を指定する必要があります。文字列toでホームディレクトリーを指定するのに、‘`~`’を使用しないでください。Emacsはこれらの変換を個別に行います。以下は通常シンボリックリンク`/fsf`でアクセスされる、`/home/fsf`を指定する例です:

    (("\\`/home/fsf" . "/fsf"))

ファイルディレクトリー
----------------------

file directory
directory listing
ファイルシステムは、ファイルをディレクトリーにグループ化します。ディレクトリーリストは、ディレクトリーに含まれるファイルのリストです。Emacsはディレクトリーを作成および削除するコマンドを提供し、簡単な形式(ファイル名のみ)、および詳細な形式(サイズ、日付、その他の属性を含む)のディレクトリーリストを作成します。EmacsにはDiredと呼ばれるディレクトリーブラウザーも含まれています。詳細は[Dired](#Dired)(`C-x
d`で呼び出せる)を参照してください。

`C-x C-d dir-or-pattern RET`  
簡単なディレクトリーリストを表示します(`list-directory`)。

`C-u C-x C-d dir-or-pattern RET`  
詳細なディレクトリーリストを表示します。

`M-x make-directory RET dirname RET`  
dirnameという名前の新しいディレクトリーを作成します。

`M-x delete-directory RET dirname RET`  
dirnameという名前のディレクトリーを削除します。もし空でない場合、それらを再帰的に削除するか尋ねます。

list-directory
C-x C-d
ディレクトリーリストを表示するコマンドは、`C-x C-d` (`list-directory`)です。これはミニバッファーを使って、リストを表示するディレクトリーと、リストするファイルを指定するワイルドカードが含まれたパターンの両方により、ファイル名を読み取ります。たとえば

    C-x C-d /u2/emacs/etc RET

これはディレクトリー`/u2/emacs/etc`のファイルをリストします。以下はファイル名のパターンを指定する例です。

    C-x C-d /u2/emacs/src/*.c RET

通常、`C-x
C-d`は名前だけを含む、簡単なディレクトリーリストを表示します。数引数(値は関係なし)は、サイズ、日付、所有者を含む詳細な一覧を作成するよう指示します。

list-directory-brief-switches
list-directory-verbose-switches
ディレクトリーリストのテキストは、主に下位プロセスとして`ls`を実行することにより取得されます。2つのEmacs変数が、`ls`に指定するスイッチを制御します。`list-directory-brief-switches`には、簡単な一覧に使うためのスイッチを文字列で指定します(デフォルトは`"-CF"`)。`list-directory-verbose-switches`には、詳細な一覧に使うためのスイッチを文字列で指定します(デフォルトは`"-l"`)。

directory-free-space-program
directory-free-space-args
詳細なディレクトリー一覧では、Emacsはディレクトリーが含まれるディスクの空き容量についての情報を追加します。変数`directory-free-space-program`および`directory-free-space-args`を通じて、ローカルファイルシステムにたいしてこれが行われる方法をカスタマイズできます。`directory-free-space-program`には実行するプログラム(デフォルトは`df`)、そのプログラムに渡す引数は`directory-free-space-args`(デフォルトはシステム依存)を指定します(MS-WindowsおよびMS-DOSでは、これら2つの変数は無視され、同様な機能をもつEmacsの内部実装がかわりに使用される)。

コマンド`M-x
delete-directory`は、ミニバッファーを使ってディレクトリー名の入力を求め、空のときはディレクトリーを削除します。ディレクトリーが空でない場合、再帰的に削除するか確認を求めます。“Trash(ごみ箱)”(または“Recycle Bin”)の機能をもつシステムでは、変数`delete-by-moving-to-trash`を`t`に変更することにより、指定したディレクトリーを無条件に削除するかわりに、ごみ箱に移動します。ごみ箱の使い方についての情報は、[Misc File Ops](#Misc-File-Ops)を参照してください。

ファイルの比較
--------------

comparing files
diff
diff-switches
コマンド`M-x
diff`は、ミニバッファーを使って2つのファイル名の入力を求め、`*diff*`という名前のバッファーに、2つのファイルの違いを表示します。これは`diff`プログラムに、変数`diff-switches`で指定されたオプションを指定して実行することにより機能します。`diff-switches`には文字列を指定します。デフォルトはunified context diff形式を指定する`"-u"`です。プログラムについての情報は、section “Diff” in Comparing and Merging Filesを参照してください。

`diff`コマンドの出力は、Diffモードと呼ばれるメジャーモードを使って表示されます。[Diff Mode](#Diff-Mode)を参照してください。

(より高機能な)代替物は`M-x ediff`です(section “Ediff” in The Ediff Manualを参照)。

diff-backup
コマンド`M-x
diff-backup`は指定したファイルと、そのファイルの一番最近のバックアップを比較します。バックアップファイル名を指定したときは、`diff-backup`は指定されたバックアップファイルと、それの元となるファイルを比較します。それ以外の点は`M-x
diff`と同じです。

diff-buffer-with-file
コマンド`M-x
diff-buffer-with-file`は指定されたバッファーと、それに対応するファイルを比較します。これはバッファーを保存すると、ファイルにどのような変更がされるかを表示します。

compare-windows
コマンド`M-x
compare-windows`はカレントウィンドウと、カレントウィンドウの前に選択されていたウィンドウを比較します(Emacsのウィンドウについての詳細は、[Windows](#Windows)を参照してください)。比較はそれぞれのウィンドウのポイント位置から、それぞれのバッファーのポイントの初期位置を、対応するバッファーのマークリング([Mark Ring](#Mark-Ring)を参照)にpushした後に開始されます。それから各ウィンドウのポイントを1文字ずつ前方に移動していきます。文字がマッチしなくなるとコマンドは終了します。

コマンドを開始したとき、2つのウィンドウのポイントの後ろのテキストがマッチしない場合、`M-x
compare-windows`は2つのウィンドウでマッチするテキストが見つかるまでポイントを進めてから終了します。したがって`M-x
compare-windows`を繰り返し使うと、毎回1つのマッチする範囲をスキップするか、次の開始点を探します。

compare-ignore-case
compare-ignore-whitespace
数引数を指定すると、`compare-windows`は空白文字の違いを無視します。変数`compare-ignore-case`が非`nil`の場合、大文字小文字の違いを無視して比較します。変数`compare-ignore-whitespace`が非`nil`の場合、`compare-windows`はデフォルトでは空白文字の違いを無視しますが、数引数が指定されたときは、その回のコマンド呼び出しでは、これをオフにします。

Smerge mode
smerge-mode
failed merges
merges, failed
comparing 3 files (
diff3
)
`M-x
smerge-mode`を使って、Smergeモードに切り替えることができます。これは`diff3`プログラムの出力を編集するマイナーモードです。これは通常、バージョン管理システムと、バージョン管理システムの外でのupdateをマージするとき、ファイルへの変更が競合して失敗した結果です。Smergeモードは特定の変更を選択することにより、競合を解決するコマンドを提供します。

ファイルをマージする強力なインターフェースを提供するEmerge機能については、 [Emerge](#Emerge)を参照してください。

Diffモード
----------

Diff mode
diff-mode
patches, editing
Diffモードは、`M-x
diff`や他の同様なコマンドの出力のために使用されるメジャーモードです。この種の出力はpatchと呼ばれます。なぜならそれが特定の変更を自動的に適用するために、`patch`コマンドに渡されるからです。手動でDiffモードを選択するには、`M-x
diff-mode`とタイプします。

hunk, diff
パッチに指定された変更は、hunk(欲張り)にグループ化されます。これは変更された行を１行以上含むテキストと、それに隣接するテキストです。hunksもまた、変更のコンテキストを提供するために、変更されていない行も含みます。それぞれのhunkにはhunkヘッダーが前についていて、これはhunkの変更が発生した、古い行番号と、新しい行番号が指定されます。Diffモードは実際のhunkの内容と区別するため、hunkヘッダーをハイライトします。

パッチ内の最初のhunkの前にはファイルヘッダーがあり、それはそのファイルの新たなバージョンと古いバージョンの名前と、それらのタイムスタンプを示します。パッチが複数ファイルの変更を表す場合、各ファイルがそのファイルの変更の最初のhunkの前にそのようなヘッダーをもつことになります。

diff-update-on-the-fly
他のバッファーと同様に、Diffモードのバッファーを編集することができます(もし読み込み専用の場合、最初にそれを書き込み可にする必要があります。[Misc Buffer](#Misc-Buffer)を参照のこと)。hunkを編集すると、Diffモードはpatchを正しい状態に保ち、`patch`により正しく適用できるように、hunkヘッダーの行番号を自動的に修正しようと試みます。自動的な行番号の修正を無効にするには、変数`diff-update-on-the-fly`を`nil`に変更してください。

Diffモードは、`` C-x
` ``やエラーメッセージを処理する他のコマンドによりコンパイラーのエラーメッセージとして扱われるようにhunkをアレンジします([Compilation Mode](#Compilation-Mode)を参照)。したがって、対応するソースの位置をvisitするために、Compilationモードのコマンドを使用できます。

それに加えてDiffモードは、移動、操作、patchの一部を適用するために、以下のコマンドを提供します:

`M-n`  
diff-hunk-next

次のhunk-startに移動します(`diff-hunk-next`)。プレフィクス引数を指定した場合は、次のn番目のhunkに前方へ移動します。

diff-auto-refine-mode

mode, Diff Auto-Refine

Diff Auto-Refine mode

このコマンドには副作用があります。これは移動先のhunkをrefines(不純物を取り除く)して、よりよい粒度で変更をハイライトします。この機能を無効にするには`M-x
diff-auto-refine-mode`とタイプして、マイナーモードのDiff Auto-Refineモードをオフに切り替えます。デフォルトでDiff Auto-Refineモードを無効にするには、以下をinitファイルに追加します([Hooks](#Hooks)を参照してください):

    (add-hook 'diff-mode-hook
              (lambda () (diff-auto-refine-mode -1)))

`M-p`  
diff-hunk-prev

前のhunkが開始される位置に移動します(`diff-hunk-prev`)。プレフィクス引数を指定した場合は、前のn番目のhunkに後方へ移動します。これは`M-n`と同様、Diff Auto-Refineモードが無効でなければ、移動先のhunkをrefiningする副作用があります。

`M-}`  
diff-file-next

複数ファイルへのpatchで、次のファイルが開始される位置に移動します(`diff-file-next`)。プレフィクス引数を指定した場合は、次のn番目のファイルの先頭へ、前方に移動します。

`M-{`  
diff-file-prev

複数ファイルへのpatchで、前のファイルが開始される位置に移動します(`diff-file-prev`)。プレフィクス引数を指定した場合は、前のn番目のファイルの先頭へ、後方に移動します。

`M-k`  
diff-hunk-kill

ポイントがある位置のhunkをkillします(`diff-hunk-kill`)。

`M-K`  
diff-file-kill

複数ファイルへのpatchで、現在のファイル部分をkillします(`diff-file-kill`)。

`C-c C-a`  
diff-apply-hunk

patches, applying

そのhunkを、ターゲットファイルに適用します(`diff-apply-hunk`)。`C-u`によるプレフィクス引数を与えた場合は、このhunkをリバート(“新しい”バージョンを“古い”バージョンに変更するリバースhunkを適用する)します。`diff-jump-to-old-file`が非`nil`なら、かわりにｓのhunkを“古い”バージョンに適用します。

`C-c C-b`  
diff-refine-hunk

ポイント位置のhunkの変更を、よりよい粒度でハイライトします(`diff-refine-hunk`)。これにより変更された各行について実際に変更された箇所を確実に見ることができます。

`C-c C-c`  
diff-goto-source

diff-jump-to-old-file

そのhunkに対応するソースファイルの該当行にジャンプします(`diff-goto-source`)。デフォルトでは、ファイルヘッダーの最初に示される、“新しい”バージョンのファイルにジャンプします。プレフィクス引数を与えた場合は、かわりに“古い”バージョンにジャンプします。`diff-jump-to-old-file`が非`nil`なら、このコマンドはデフォルトで“古い”バージョンにジャンプし、プレフィクス引数の意味も逆になります。プレフィクス引数が8より大(たとえば`C-u
C-u C-c
C-c`とタイプした場合)なら、このコマンドは次回呼び出しにたいして`diff-jump-to-old-file`のセットも行います。

`C-c C-e`  
diff-ediff-patch

このパッチでEdiffセッションを開始します。section “Ediff” in The Ediff Manualを参照してください。

`C-c C-n`  
diff-restrict-view

表示を現在のhunkに制限します(`diff-restrict-view`)。[Narrowing](#Narrowing)を参照してください。プレフィクス引数を指定すると、複数ファイルへのpatchで、表示を現在のファイルに制限します。制限を解除するには、`C-x
n w` (`widen`)を使います。

`C-c C-r`  
diff-reverse-direction

バッファー全体にたいする比較方向を逆転します(`diff-reverse-direction`)。プレフィクス引数を与えた場合は、カレントリージョンの内部でのみ方向を逆転します([Mark](#Mark)を参照)。方向の逆転とは、hunkとファイル冒頭のヘッダーを、“新しい”バージョンから“古い”バージョンにするパッチを生成するように変更することを意味します。

`C-c C-s`  
diff-split-hunk

ポイント位置でhunkを2つの別個のhunkに分割します(`diff-split-hunk`)。これはhunkヘッダーの挿入ち、カレントhunkのヘッダーの変更を行います。これは手動でpatchを編集するために有用で、`diff`プログラムに`-u`または`--unified`オプションを指定して生成された、unified diff format(統一diffフォーマット)だけで機能します。`diff`に`-c`または`--context`オプションを指定して生成された、context diff format(コンテキストdiffフォーマット)のhunkを分割するには、最初に`C-c C-u`で、バッファーをunified diff formatに変換する必要があります。

`C-c C-d`  
diff-unified-&gt;context

バッファー全体を、context diff formatに変換します(`diff-unified->context`)。プレフィクス引数を指定すると、リージョンのhunkだけを変換します。

`C-c C-u`  
diff-context-&gt;unified

バッファー全体をunified diff formatに変換します(`diff-context->unified`)。プレフィクス引数を指定すると、unified formatからcontext formatに変換します。マークがアクティブのときは、リージョンのhunkだけを変換します。

`C-c C-w`  
diff-ignore-whitespace-hunk

空白文字の変更を無視して、カレントhunkを再生成します(`diff-ignore-whitespace-hunk`)。

`C-x 4 A`  
diff-add-change-log-entries-other-window

add-change-log-entry-other-window, in Diff mode

それぞれのhunkについて、`C-x 4 a`が行うようにChangeLog([Change Log](#Change-Log)を参照してください)のエントリーを生成します(`diff-add-change-log-entries-other-window`)。これは、あとで実際に変更の説明を記入できるように、変更ログの雛形を作ります。Diffモードでの`C-x
4
a`自体は、現在のhunkのファイルのためのものですが、関数名はpatch自体から取得します。これはpatchにより削除される関数のための、ログエントリーを作るのに有用です。

trailing whitespace, in patches
diff-delete-trailing-whitespace
patchには変更された行の行末に、無意識に入力された望んでいない空白文字が含まれている場合があります。この問題を扱うには2つの方法があります。1つ目はDiffバッファーでWhitespaceモード([Useless Whitespace](#Useless-Whitespace)を参照してください)を有効にする方法で、これは自動的に変更された行の行末にある空白文字をハイライトします。2つ目はコマンド`M-x
diff-delete-trailing-whitespace`を使う方法で、patchにより変更された行の行末の空白文字を検索して、patchとpatchされたソースファイルの両方からそれを取り除きます。このコマンドは変更を保存しないので、ユーザーが変更を保存するか決定することができます(変更されたファイルはエコーエリアに表示されます)。プレフィクス引数を指定すると、patchされた(“新しい”)ファイルではなく、元の(“古い”)ソースファイルを変更しようと試みます。

ファイルのコピー、命名、リネーム。
----------------------------------

Emacsにはファイルをコピー、命名、リネームするためのコマンドがいくつかあります。これらはすべてミニバッファーを使用してold(またはtarget)とnewの2つのファイル名を読み取り、それらをコピー、またはファイル名に調整します。これらのコマンドは、ワイルドカードを含むファイル名は許容しません。

これらすべてのコマンドは、引数newが単なるディレクトリー名(section “Directory Names” in the Emacs Lisp Reference Manualを参照)の場合には、そのディレクトリーを実際の新しい名前として、oldをそれの非ディレクトリー成分とします。たとえば、コマンド`M-x
rename-file RET ~/foo RET /tmp/
RET`は、`~/foo`を`/tmp/foo`にリネームします。GNU、およびその他のPOSIXシステムでは、ディレクトリー名は‘`/`’で終端されます。

これらのコマンドはすべて、新しいファイル名がすでに存在する場合は確認を求めます。

copy-file
copying files
`M-x copy-file`はファイルoldのコンテンツを、ファイルnewにコピーします。

copy-directory
`M-x copy-directory`は、シェルコマンド`cp
-r`と同じようにディレクトリーをコピーします。newがディレクトリー名の場合、このコマンドはoldディレクトリーのコピーを作成して、それをnewの下に配します。それ以外では、このコマンドはoldのコンテンツを、新しいnewという名前のディレクトリーにすべてコピーします。

renaming files
rename-file
`M-x
rename-file`は、ファイルoldをnewにリネームします。すでにファイル名newが存在する場合、確認に`yes`と答えなければリネームは行われません。なぜなら、名前newの古い内容が失われてしまうからです。oldとnewが異なるファイルシステム上にある場合は、ファイルoldがコピーされた後に削除されます。

ファイルがバージョンコントロール([Version Control](#Version-Control)を参照してください)の配下にある時は、`M-x
rename-file`のかわりに`M-x vc-rename-file`を使ってリネームします。[VC Delete/Rename](#VC-Delete_002fRename)を参照してください。

add-name-to-file
hard links (creation)
`M-x
add-name-to-file`は、既存のファイルの古い名前を削除せずに、新しい名前を追加します。新しい名前は、既存のファイルのハードリンクとして作成されます。新しい名前は、そのファイルがあるのと同じファイルシステムになければなりません。MS-Windowsでは、このコマンドはファイルがNTFSファイルシステムにあるときだけ機能します。MS-DOS、およびその他いくつかのリモートシステムタイプでは、ファイルをコピーすることにより機能します。

make-symbolic-link
symbolic links (creation)
`M-x
make-symbolic-link`は、targetを指すnewという名前のシンボリックリンクを作成します。これにより、今後newというファイルを開こうとすると、その時点でtargetという名前のファイルが何であれ、ファイルのオープンが行われたときは、そのファイルを開きます。その時点でtargetという名前のファイルが存在しないときはエラーになります。このコマンドは引数targetを展開しないので、リンクの対象を相対パスで指定できます。しかし、このコマンドはtarget内の先頭の‘`~`’は展開するので、簡単にホームディレクトリーを指定できます。また、先頭の‘`/:`’は取り除くので、リテラル‘`~`’および‘`/:`’で始まる相対パスを指定することができます。[Quoted File Names](#Quoted-File-Names)を参照してください。MS-Windowsでは、このコマンドはMS Windows Vista以降だけで機能します。newがリモートのときは、そのシステムタイプに依存して機能します。

その他のファイル操作
--------------------

Emacsには、ファイルを操作する他のコマンドがたくさん存在します。それらはすべて1つのファイルを操作します。ファイル名にワイルドカードは指定できません。

delete-file
deletion (of files)
`M-x
delete-file`はファイルの入力を求め、そのファイルを削除します。1つのディレクトリーにある、複数のファイルを削除する場合、`delete-file`よりDiredを使う方が便利でしょう。[Dired Deletion](#Dired-Deletion)を参照してください。

trash
recycle bin
move-file-to-trash
`M-x move-file-to-trash`は、ファイルをシステムのTrash(またはRecycle Bin)に移動します。この機能は、ほとんどのオペレーティングシステムで利用可能です。Trashに移動されたファイルは、後で気が変わったとき元に戻すことができます(trashに移動されたファイルのリストアはシステムに依存する)。

delete-by-moving-to-trash
デフォルトでは、Emacsの削除コマンドはTrashを*使いません*。一般的な削除コマンドでTrash(それが利用可能な場合)を使うには、変数`delete-by-moving-to-trash`を`t`に変更します。これはコマンド`M-x
delete-file`と`M-x delete-directory` ([Directories](#Directories)を参照してください)、およびDired ([Dired Deletion](#Dired-Deletion)を参照してください)の削除コマンドに影響を与えます。`M-x delete-file`および`M-x
delete-directory`にプレフィクス引数を与えると、`delete-by-moving-to-trash`の値にかかわらず、Trashを使わずに完全に削除します。

ファイルがバージョンコントロール([Version Control](#Version-Control)を参照してください)の配下にある時は、`M-x
delete-file`のかわりに`M-x vc-delete-file`を使って、ファイルを削除します。[VC Delete/Rename](#VC-Delete_002fRename)を参照してください。

C-x i
insert-file
`M-x insert-file`(`C-x
i`も)は、指定したファイルの内容のコピーを、現在のポイント位置に挿入し、ポイントの位置は変更せずに挿入された内容の前に残します。挿入した内容の後の位置はマークリングに追加され、マークは非アクティブになります([Mark Ring](#Mark-Ring)を参照してください)。

insert-file-literally
`M-x insert-file-literally`も`M-x
insert-file`と同様ですが、ファイルはliterally(そのまま)挿入されます。つまり`M-x
find-file-literally`コマンド([Visiting](#Visiting)を参照してください)と同様に、特別なエンコーディングや変換なしに、ASCII文字の並びとして扱われます。

write-region
`M-x write-region`は`M-x
insert-file`の逆です。このコマンドはリージョンの内容を、指定されたファイルにコピーします。`M-x
append-to-file`はリージョンのテキストを、指定されたファイルの末尾に加えます。[Accumulating Text](#Accumulating-Text)を参照してください。変数`write-region-inhibit-fsync`の値は、これらのコマンドおよびファイルの保存に影響を与えます。[Customize Save](#Customize-Save)を参照してください。

set-file-modes
file modes
file permissions
`M-x set-file-modes`はファイル名と、その後にファイルモード(file mode)を読み込んで、指定されたファイルにそのファイルモードを適用します。ファイルモード(またはファイルパーミッション(file permissions)とも呼ばれます)は、ファイルが読み込み可能か、書き込み可能か、実行可能か、そしてそれは誰にたいしてなのかを決定します。このコマンドは、`chmod`コマンドに指定する形式の、シンボルまたは8進のファイルモードを読み取ります。たとえば‘`u+x`’は、そのファイルを所有するユーザーに実行可能の権限を追加することを意味します。ファイルモードをサポートしないオペレーティングシステムでは、効果はありません。`chmod`はこの関数の便利なエイリアスです。

圧縮ファイルへのアクセス
------------------------

compression
uncompression
Auto Compression mode
mode, Auto Compression
gzip
Emacsは、圧縮されたファイルをvisitするとき、自動的に解凍します。また、それらのファイルを変更して保存するときも、自動的に再圧縮します。Emacsは圧縮ファイルを名前で認識します。ファイル名が‘`.gz`’で終わっていれば、それはファイルが`gzip`で圧縮されていることを示します。他の拡張子の場合は、他の圧縮プログラムを示します。

自動的な解凍と圧縮は、Emacsがファイル内容を操作するすべてに適用されます。これにはvisit、保存、内容のバッファーへの挿入、ロード、バイトコンパイルが含まれます。

auto-compression-mode
auto-compression-mode
この機能を無効にするには、コマンド`M-x
auto-compression-mode`とタイプします。変数`auto-compression-mode`をカスタマイズすることにより、永続的に無効にすることができます。

ファイルアーカイブ
------------------

mode, tar
Tar mode
file archives
名前が‘`.tar`’で終わるファイルは通常、`tar`プログラムで作られたアーカイブです。Emacsはそれらを、Tarモードと呼ばれる特別なモードで表示します。これは内容をDiredに似たリストで提供します([Dired](#Dired)を参照してください)。リストの移動はDiredのときと同様で、アーカイブに含まれるファイルをvisitできます。しかしTarモードでは、Diredコマンドのすべてが利用可能ではありません。

Auto Compressionモードが有効な場合([Compressed Files](#Compressed-Files)を参照してください)、Tarモードは圧縮アーカイブ(ファイルの拡張子が‘`.tgz`’、`.tar.Z`、`.tar.gz`)も使うことができます。

キー`e`、`f`、RETはすべて、ファイルをファイル自身のバッファーに展開します。それをバッファーで編集して、バッファーを保存すると、編集されたバージョンでTarバッファーのものを置き換えます。Tarバッファーでファイル名をマウスでクリックしても、同様なことが行えます。`v`はファイルをバッファーにViewモードで展開します([View Mode](#View-Mode)を参照してください)。`o`は、ファイルを展開して他のウィンドウで表示するので、ファイルの編集とアーカイブの操作を同時に行うことができます。

キー`I`は、新しい(標準)ファイルをアーカイブに追加します。ファイルは最初は空ですが、上記のコマンドを使用してすぐに編集することができます。このコマンドはカレントのファイルの前に新しいファイルを挿入するので、Tarバッファーの最上行で使用すると、新しいファイルがアーカイブの最上行となり、バッファーの最後で使用すると、新しいファイルがアーカイブの最下行になります。

Diredと同様に、`d`は後で`x`を使ったときにファイルを削除するためにマークし、`u`はマークを外します。`C`はファイルをアーカイブからディスクにコピーし、`R`はアーカイブのファイルをリネームします。`g`はバッファーをディスク上のアーカイブでリバートします。キー`M`、`G`、`O`は、ファイルのパーミッションビット、グループ、所有者を変更します。

Tarバッファーの保存により、構成要素に変更が施された、新しいバージョンのアーカイブをディスクに書き込みます。

Tarモードを使うのに、`tar`プログラムは必要ありません。Emacsは直接アーカイブを読み込みます。しかし圧縮アーカイブへのアクセスには、適切な解凍プログラムが必要です。

Archive mode
mode, archive
arc
jar
zip
rar
lzh
zoo
7z
Java class archives
unzip archives
`arc`、`jar`、`lzh`、`zip`、`rar`、`7z`、`zoo`、および自己解凍実行形式の`exe`には、互いに似通った異なるArchiveモードが使われます。

ArchiveモードのキーバインドはTarモードと同様で、それに加えてキー`m`は後に続く操作のためにファイルをマークし、`M-DEL`はマークされたファイルのマークをすべて外します。キー`a`は、1行に収まらないようなアーカイブの、詳細なファイル情報の表示を切り替えます。ファイルのリネーム、ファイルモードや所有者の変更をサポートするアーカイブ書式は、いくつかに限られます。

Tarモードとは異なり、Archiveモードはアーカイブの展開と格納に、アーカイブプログラムを実行します。しかし、展開したりアーカイブ内のファイルを操作するときだけこれらのプログラムが必要で、アーカイブの目録を見るには必要ありません。プログラム名とセットできるオプションの詳細は、Customizeグループ‘`Archive`’でセットできます([Customization Groups](#Customization-Groups)を参照してください)。

リモートファイル
----------------

Tramp
FTP
remote file access
他のマシンにあるファイルを、特別なファイル名構文を使って参照できます:

    /method:host:filename
    /method:user@host:filename
    /method:user@host#port:filename

このリクエストを発行するために、Emacsは`ssh`のような、リモートログインプログラムを使います。どのmethodを使うかは、常にファイル名で指定しなければなりません。たとえば`/ssh:user@host:filename`は`ssh`を使います。ファイル名のmethodに擬似methodの‘`-`’を使用したとき、Emacsは以下によりmethodを選択します:

1.  ホスト名が‘`ftp.`’(ドット付き)で始まるとき、EmacsはFTPを使います。

2.  ユーザー名が‘`ftp`’または‘`anonymous`’のとき、EmacsはFTPを使います。

3.  変数`tramp-default-method`が‘`ftp`’にセットされているとき、EmacsはFTPを使います。

4.  `ssh-agent`が実行されているとき、Emacsは`scp`を使います。

5.  上記以外の場合、Emacsは`ssh`を使います。

disabling remote files
変数`tramp-mode`を`nil`にセットすることにより、リモートファイル名の機能を完全にオフにすることができます。個別のケースについて機能をオフにするには、ファイル名を‘`/:`’でクォートします([Quoted File Names](#Quoted-File-Names)を参照してください)。

ange-ftp
FTPを通じたリモートファイルへのアクセスは、以下で説明するAnge-FTPパッケージで処理されます。他の方法によりリモートファイルへのアクセスはTrampパッケージにより処理され、これにはそれ自身のマニュアルがあります。section “The Tramp Manual” in The Tramp Manualを参照してください。

ange-ftp-default-user
user name for remote file access
Ange-FTPパッケージでは、リモートファイル名にユーザー名userがしているときは、FTPを通じてその名前でログインします。userが指定されていないとき、Emacsはローカルシステムのユーザー名でログインします。しかし変数`ange-ftp-default-user`に文字列がセットされているときは、かわりにその文字列を使用します。Emacsは、ログイン時にパスワードの入力も求めます。

backups for remote files
ange-ftp-make-backup-files
パフォーマンス的な理由により、FTPを通じたファイルのアクセス時に、デフォルトではEmacsはバックアップファイルを作成しません。バックアップを作成するには、変数`ange-ftp-make-backup-files`を非`nil`値に変更してください。

デフォルトではリモートファイルの自動保存ファイルは、変数`auto-save-file-name-transforms`で指定された、ローカルマシンの一時ディレクトリーに作成されます。[Auto Save Files](#Auto-Save-Files)を参照してください。

anonymous FTP
ange-ftp-generate-anonymous-password
匿名FTPでアクセスできるファイルをvisitするには、特別なユーザー名‘`anonymous`’または‘`ftp`’を使います。これらのユーザー名にたいするパスワードは、特別に処理されます。これは変数`ange-ftp-generate-anonymous-password`により制御されます。この変数の値が文字列の場合、その文字列がパスワードとして使用されます。非`nil`(デフォルト)の場合、`user-mail-address`の値が使用されます。`nil`の場合、Emacsは通常どおりパスワードの入力を求めます([Passwords](#Passwords)を参照してください)。

firewall, and accessing remote files
gateway, and remote file access with
ange-ftp
ange-ftp-smart-gateway
ange-ftp-gateway-host
セキュリティー上の理由で、リモートマシンとの間にあるファイアーウォール(firewall)により、ファイルにアクセスできないときがあります。対象ファイルにアクセスできるマシンからゲートウェイ(gateway)マシンにログインできて、FTPサーバーがゲートウェイ機能をサポートしている場合は、リモートファイル名を使うことができます。これを行うには変数`ange-ftp-gateway-host`にゲートウェイマシンの名前をセットして、`ange-ftp-smart-gateway`を`t`にセットする必要があります。それ以外の場合でもリモートファイル名が機能するようにできますが、その方法は複雑です。これらの方法は、`M-x
finder-commentary RET ange-ftp RET`とタイプして読むことができます。

ファイル名のクォート
--------------------

quoting file names
file names, quote special characters
特殊な文字や構文を含むファイルにたいする特別な効果を防ぐために、絶対ファイル名をクォートできます。これを行うには先頭に‘`/:`’を追加します。

たとえばリモートにあるように見える名前の、ローカルなファイルの名前をクォートすることにより、リモートファイル名として扱われないようにすることができます。したがって名前が`/foo:`というディレクトリーがあり、そこに`bar`という名前のファイルがある場合、Emacsでは、そのファイルを‘`/:/foo:/bar`’という名前で参照できます。

リモートファイル名もローカル部分の特殊文字だけをクォートしたい場合はローカル部分だけをクォートできます。たとえば‘`/ssh:baz:/:/foo:/bar`’は、ホスト`baz`上のディレクトリー`/foo:`のファイル`bar`を参照します。

‘`/:`’は、‘`~`’がユーザーのホームディレクトリーを意味する、特別な文字として扱われることを防ぐこともできます。たとえば`/:/tmp/~hack`は、ディレクトリー`/tmp`のファイル`~hack`を参照します。

‘`/:`’によるクォートは、ミニバッファーでの名前に‘`$`’を含むファイル名の入力にも使用できます。これが機能するには、ミニバッファーの最初の内容が‘`/:`’で始まらなければなりません(2回‘`$`’を記述することでも同様な効果が得られます。詳細は[File Names with $](#File-Names-with-_0024)を参照してください)。

ファイルをvisitするときに、ワイルドカードをクォートすることもできます。たとえば`/:/tmp/foo*bar`は、ファイル`/tmp/foo*bar`をvisitします。

同じ効果を得るための別の方法は、`/tmp/foo[*]bar`と入力する方法です。これは`/tmp/foo*bar`だけにマッチするワイルドカード指定です。しかしクォートしなくても同じ結果が得られるので、ワイルドカード文字をクォートする必要がない場合がたくさんあります。たとえば`/tmp`の中に‘`foo`’で始まり‘`bar`’で終わるファイルが`foo*bar`だけの場合、`/tmp/foo*bar`と指定することにより、`/tmp/foo*bar`だけをvisitすることができます。

ファイル名キャッシュ
--------------------

file name caching
cache of file names
find
C-TAB
file-cache-minibuffer-complete
ファイル名キャッシュ(file name cache)により、ファイルがどこにあるか正確に覚えていなくても、名前でファイルがどこにあるかを簡単に指定することができます。ファイル名をミニバッファーでタイプするとき、`C-TAB` (`file-cache-minibuffer-complete`)で、ファイル名キャッシュを使ったファイル名を補完が行なわれます。`C-TAB`を繰り返すと、最初にタイプした内容から補完できる利用可能な候補を順番に表示します(しかし`C-TAB`文字は、多くのテキスト端末でタイプできないことに注意してください)。

ファイル名キャッシュは自動的に充填されません。かわりに以下のコマンドを使ってファイル名をキャッシュにロードします。

file-cache-add-directory
`M-x file-cache-add-directory RET directory RET`  
directoryの各ファイルを、ファイル名キャッシュに加えます。

`M-x file-cache-add-directory-using-find RET directory RET`  
directoryの各ファイルを、ファイル名キャッシュに加えるとともに、ネストされたサブディレクトリーのすべてのファイルを、ファイル名キャッシュに加えます。

`M-x file-cache-add-directory-using-locate RET directory RET`  
directoryの各ファイルを、ファイル名キャッシュに加えるとともに、ネストされたサブディレクトリーのすべてのファイルを、ファイル名キャッシュに加えます。ファイルの検索には、`locate`を使用します。

`M-x file-cache-add-directory-list RET variable RET`  
variableにリストされた各ディレクトリーのファイル名を、ファイル名キャッシュに加えます。variableはLisp変数で、`load-path`と同様、値はディレクトリーのリストです。

`M-x file-cache-clear-cache RET`  
キャッシュをクリアーして、すべてのファイル名を削除します。

ファイル名キャッシュは永続的ではありません。キャッシュが維持されるのはEmacsのセッションの間だけです。キャッシュの内容は、`file-cache-display`コマンドで閲覧できます。

ファイル検索の便利な機能
------------------------

このセクションでは、最近開いたファイルの検索、バッファーからのファイル名の読み取り、イメージファイルの閲覧などの、便利な機能を紹介します。

recentf-mode
recentf-mode
recentf-save-list
recentf-edit-list
`M-x
recentf-mode`でRecentfモードを有効にすると、‘`File`’メニューに最近開いたファイルを含むサブメニューが含まれるようになります。`M-x
recentf-save-list`は現在の`recent-file-list`をファイルに保存し、`M-x
recentf-edit-list`でそれを編集できます。

`M-x
ffap`コマンドは、`find-file`を一般化した、より強力なデフォルト決定のための機能で、基本的にはポイント位置のテキストにもとづいて決定を行ないます。Partial Completionモードは`find-file`を拡張する、`ffap`とともに使用できるその他の機能を提案します。[Completion Options](#Completion-Options)を参照してください。

image-mode
image-toggle-display
image-next-file
image-previous-file
images, viewing
イメージファイルをvisitすることにより、Imageモードが選択されます。このメジャーモードでは、`C-c C-c` (`image-toggle-display`)とタイプすることにより、Emacsバッファーでファイルのイメージ表示と、イメージの元となるテキスト(またはraw byte)表示を切り替えることができます。さらに`C-c C-x` (`image-toggle-hex-display`)とタイプすると、Emacsバッファー内でイメージとしてファイルを表示、または16進表記で表示を切り替えることができます。ファイルのイメージ表示は、Emacsがそのようなイメージの表示をサポートするようにコンパイルされているときだけ機能します。イメージがフレームの高さまたは幅より大きい場合、通常のポイント移動キー(`C-f`、`C-p`、...)は、イメージの他の部分の表示に使われます。`n` (`image-next-file`)および`p` (`image-previous-file`)を押すことにより、同じディレクトリーにある次または前のイメージをvisitします。

image-toggle-animation
image-next-frame
image-previous-frame
image-goto-frame
image-increase-speed
image-decrease-speed
image-reset-speed
image-reverse-speed
image-animate-loop
image animation
animated images
アニメーションが可能なイメージの場合、コマンドRET (`image-toggle-animation`)で、アニメーションの開始と停止ができます。オプション`image-animate-loop`が非`nil`でなければ、アニメーションの再生は1回です。`f` (`image-next-frame`)と`b` (`image-previous-frame`)により、アニメーションの各フレームを切り替えることができます。これらのコマンドは数引数を指定することにより、指定した数の分だけ先のフレームを表示できます。`F` (`image-goto-frame`)により、特定のフレームを指定することができます。フレームは1からインデックスがつきます。`a
+` (`image-increase-speed`)とタイプすると、アニメーションのスピードが早くなり、`a -` (`image-decrease-speed`)で遅くなります。また`a r` (`image-reverse-speed`)で逆再生されます。コマンド`a 0` (`image-reset-speed`)は、スピードを元の値にリセットします。

ImageMagick support
imagemagick-enabled-types
imagemagick-types-inhibit
EmacsがImageMagickのサポートつきでコンパイルされている場合、さまざまなイメージを描画するのに、ImageMagickを使うことができます。変数`imagemagick-enabled-types`は、EmacsがImageMagickを使って描画できるイメージの種類のリストです。リストの各要素は、ImageMagick内部でのイメージ種類にたいする名前で、シンボルまたは等価な文字列で指定します(たとえば`BMP`は`.bmp`イメージです)。利用可能なイメージの種類にたいしてImageMagickを有効にするには、`imagemagick-enabled-types`を`t`に変更します。変数`imagemagick-types-inhibit`は、変数`imagemagick-enabled-types`の値にかかわらずmImageMagickを使わずに描画するイメージ種類のリストです(リストのデフォルトには`C`および`HTML`などが含まれ、これらはImageMagickはイメージとして描画できるが、Emacsはイメージとして描画しないものです)。ImageMagickを完全に無効にするには、`imagemagick-types-inhibit`を`t`に変更してください。

thumbs-mode
mode, Thumbs
Image-Diredパッケージはイメージをサムネールとして表示するのにも使用されます。[Image-Dired](#Image_002dDired)を参照してください。

ファイルセット
--------------

filesets
sets of files
filesets-init
定期的に特定のファイルのグループを編集する場合、それらをファイルセット(fileset)として定義できます。これによりvisit、`query-replace`、シェルコマンドなどの特別な操作を、すべてのファイルに一度に行うことができます。ファイルセットを使うには、initファイル([Init File](#Init-File)を参照)に、式`(filesets-init)`を追加しなければなりません。これはメニューバーの‘`File`’メニューに、サブメニュー‘`Filesets`’を追加します。

filesets-add-buffer
filesets-remove-buffer
ファイルセットを定義する一番簡単な方法は、ファイルを1つずつ追加する方法です。ファイルセットnameにファイルを追加するには、そのファイルをvisitして`M-x
filesets-add-buffer RET name
RET`をタイプします。ファイルセットnameが存在しない場合、現在のファイルだけを含む新しいファイルセットを作成します。コマンド`M-x
filesets-remove-buffer`は、ファイルセットから現在のファイルを削除します。

`M-x filesets-edit`(または‘`Filesets`’メニューの‘`Edit
Filesets`’を選択)で、ファイルセットを直接編集することもできます。編集はCustomizeバッファーで行われます([Easy Customization](#Easy-Customization)を参照してください)。ファイルセットは通常、単純なファイルのリストですが、ファイル名にマッチする正規表現で、ファイルセットを定義することもできます。より複雑なファイルセットの例は、Customizeバッファーに記されています。将来のEmacsセッションで同じファイルセットを使うには、‘`Save
for future sessions`’を選択するのを忘れないでください。

コマンド`M-x filesets-open`を使って、ファイルセットのすべてのファイルをvisitし、それらを`M-x
filesets-close`で閉じることができます。`M-x
filesets-run-cmd`を使って、ファイルセットのすべてのファイルにたいして、シェルコマンドを実行します。これらのコマンドは‘`Filesets`’メニューからも利用可能で、メニューには既存のファイルセットが、サブメニューとして表示されています。

異なるコンセプトのファイルセット(バージョンコントロール操作のためにグループにまとめられたファイル)については、[Version Control](#Version-Control)を参照してください。この種のファイルセットには名前がなく、Emacsセッション間で引き継がれません。

複数バッファーの使用
====================

buffers
Emacsで編集するテキストは、バッファー(buffer)と呼ばれるオブジェクトの中に存在します。ファイルをvisitするたびに、そのファイルのテキストを保持するために、バッファーが使われます。Diredを呼び出すたびに、ディレクトリーリストを保持するためにバッファーが使われます。`C-x
m`でメッセージを送信すると、メッセージのテキストを保持するためにバッファーが使われます。コマンドのドキュメントは、`*Help*`という名前のバッファーに表示されます。

それぞれのバッファーは、任意の長さの一意な名前を持っています。バッファーがウインドウに表示されているとき、バッファーの名前はモードライン([Mode Line](#Mode-Line)を参照してください)に表示されます。バッファー名での大文字と小文字の違いは重要です。ほとんどの場合、ほとんどのバッファーはvisitしているファイルから作られ、それらの名前はファイル名から生成されます。しかし、新しい空のバッファーを、任意の名前で作成することもできます。新しく開始されたEmacsにはいくつかのバッファーがあり、それらの中には`*scratch*`という名前の、Lisp式を評価するのに使用されるバッファーも含まれます。そのバッファーはファイルに関連付けられていません([Lisp Interaction](#Lisp-Interaction)を参照してください)。

selected buffer
current buffer
選択されるバッファーは、常に1つだけです。そのバッファーをカレントバッファー(current buffer: 現在のバッファー)と呼びます。「コマンドは“そのバッファー(the buffer)”を操作します」という言い方をするときがあります。これはカレントバッファーを操作するというのが、本当の意味です。Emacsのウィンドウが1つだけのとき、そのウィンドウに表示されているバッファーがカレントになります。複数のウィンドウがあるとき、選択されたウィンドウに表示されているバッファーがカレントになります。[Windows](#Windows)を参照してください。

buffer contents
contents of a buffer
バッファーのコンテンツ(contents: 内容)とは、オプションでテキストプロパティ([Text properties](#International-Chars)を参照)のセットをもつ一連の文字から構成されます。テキストプロパティにより、文字により多くの情報を指定できます。

バッファーのテキスト的な内容は別として、それぞれのバッファーはいくつかの情報を記録しています。それらは、(もしあれば)visitしているファイルは何か、変更されているか、有効なメジャーモードとマイナーモードは何か([Modes](#Modes)を参照してください)、などの情報です。これらは、バッファーローカルな変数(buffer-local variables)に格納され、これらの変数はバッファーごとに異なる値をもつことができます。[Locals](#Locals)を参照してください。

buffer size, maximum
バッファーのサイズは、いくつかの最大値を超えて大きくすることはできません。これは一番大きいバッファーの位置が、Emacsの整数(Emacs integers)で表されることにより定義されます。なぜならEmacsはそのデータ型を使用して、バッファーの位置を追跡するからです。通常の64ビットマシンでは、バッファーの最大サイズはバイト、およそ2EiBです。通常の32ビットマシンでは、バッファーの最大サイズは通常バイト、およそ512MiBです。バッファーのサイズはシステムのメモリー量によっても制限されます。

バッファーの作成と選択
----------------------

change buffers
switch buffers
`C-x b buffer RET`  
bufferという名前のバッファーを、選択または作成します(`switch-to-buffer`)。

`C-x 4 b buffer RET`  
同様ですが、他のウィンドウでbufferを選択します(`switch-to-buffer-other-window`)。

`C-x 5 b buffer RET`  
同様ですが、別のフレームでbufferを選択します(`switch-to-buffer-other-frame`)。

`C-x LEFT`  
バッファーリストの、前のバッファーを選択します(`previous-buffer`)。

`C-x RIGHT`  
バッファーリストの、次のバッファーを選択します(`next-buffer`)。

`C-u M-g M-g`; `C-u M-g g`  
数字nを読み取って、カレントバッファーではない、一番最近選択された、別のウィンドウにあるバッファーの、n行目に移動します。

C-x b
switch-to-buffer
`C-x b` (`switch-to-buffer`)コマンドは、ミニバッファーを使ってバッファー名を読み取ります。それからそのバッファーをカレントとして、現在選択されたウィンドウに表示します。空の入力は、そのとき他のウィンドウに表示されていない、一番最近カレントだったバッファーを指定します。

バッファー名を入力するとき、通常の補完とヒストリーコマンドを使うことができます([Minibuffer](#Minibuffer)を参照してください)。`C-x
b`および関連するコマンドは、ミニバッファーの補完に、確認つきの寛大な補完(permissive completion with confirmation)を使うことに注意してください。存在しないバッファー名にたいする補完の後、すぐにRETをタイプすると、Emacsは‘`[Confirm]`’を出力し、バッファー名を確定するために2回目のRETをタイプしなければなりません。詳細は、[Completion Exit](#Completion-Exit)を参照してください。その他の補完オプションと機能についての詳細は、[Completion Options](#Completion-Options)を参照してください。

存在しないバッファーを指定すると、`C-x
b`はファイルをvisitしていない新しい空のバッファーを作成し、編集用にそのバッファーを選択します。変数`major-mode`は、新しいバッファーのメジャーモードのデフォルトを決定します。デフォルトでは、これはFundamentalモードです。[Major Modes](#Major-Modes)を参照してください。新しいバッファーを作る1つの理由は、それを一時的なノートとして使うためです。これを保存しようと試みると、Emacsは保存に使うファイル名を尋ね、バッファーのメジャーモードは、ファイル名にもとづきメジャーモードを再割り当てします([Choosing Modes](#Choosing-Modes)を参照してください)。

C-x LEFT
C-x RIGHT
next-buffer
previous-buffer
少ないバッファーの切り替えでは、コマンド`C-x LEFT`および`C-x
RIGHT`を使うのが便利です。`C-x LEFT` (`previous-buffer`)は前のバッファー(現在のフレームの一番最近選択されたバッファー順)、`C-x
RIGHT` (`next-buffer`)は逆方向のバッファーに移動します。

C-x 4 b
switch-to-buffer-other-window
現在のウィンドウとは別のウィンドウにバッファーを選択するには、`C-x 4 b` (`switch-to-buffer-other-window`)とタイプします。これはミニバッファーを使ってバッファー名の入力を求め、選択されているウィンドウではない別のウィンドウに、そのバッファーを表示して、そのウィンドウを選択します。

C-x 5 b
switch-to-buffer-other-frame
同様に`C-x 5 b` (`switch-to-buffer-other-frame`)はバッファー名の入力を求め、他のフレーム([Frames](#Frames)を参照)にそのバッファーを表示して、そのフレームを選択します。他のウィンドウまたはフレームにすでにバッファーが表示されている場合、Emacsは新しく作成するのではなく、そのウィンドウまたはフレームを選択します。

`C-x 4 b`および`C-x 5
b`コマンドが表示するウィンドウまたはフレームを取得する方法については、[Displaying Buffers](#Displaying-Buffers)を参照してください。

これらに加えて、`C-x
C-f`や、その他のファイルをvisitするコマンドでも、すでにファイルをvisitしているバッファーに切り替えることができます。[Visiting](#Visiting)を参照してください。

goto-line, with an argument
プレフィクス引数だけを指定した`C-u M-g M-g` `goto-line`は、ミニバッファーを使って数字nを読み取り、別のウィンドウにあるカレントバッファー以外の、一番最近選択されたバッファーを選択して、ポイントをそのバッファーのn行目の先頭に移動します。これは他のバッファーの行番号を参照するバッファーで特に有用です。ポイントが数字の直後にある場合、`goto-line`はnのデフォルトとしてその数字を使います。ただの`C-u`ではないプレフィクス引数では、異なる振る舞いをすることに注意してください。`C-u
4 M-g
M-g`はミニバッファーから数字を読み取らず、*カレントバッファー*の4行目にジャンプします(プレフィクス引数を指定しない`M-g
M-g`は、数字nを読み取ってカレントバッファーのn行目に移動することを思い出してください。[Moving Point](#Moving-Point)を参照してください)。

Emacsはスペースで開始される名前のバッファーを、内部的な用途のために使用しています。それらのバッファーは特別な方法で扱われます。たとえば、それらのバッファーではundo情報が記録されません。そのようなバッファー名を使うことは避けるのが最良です。

既存のバッファーを一覧する
--------------------------

`C-x C-b`  
既存のバッファーをリストします(`list-buffers`)。

listing current buffers
C-x C-b
list-buffers
既存のバッファーのリストを表示するには、`C-x C-b`とタイプします。これにより、`*Buffer
List*`という名前のバッファーにバッファーメニューがポップアップします。リストの各行にはバッファー名、サイズ、メジャーモード、visitしているファイルが表示されます。バッファーは、カレントだった順でリストされます。したがって、一番最近カレントだったバッファーが先頭に表示されます。このセクションでは、バッファーリストが表示される方法と、リスト内に示されるさまざまなものの解釈の仕方について説明します。`*Buffer
List*`バッファーの特別なモードと、利用可能なコマンドについては、[Several Buffers](#Several-Buffers)を参照してください。

行の最初のフィールドの‘`.`’は、そのバッファーがカレントであることを示します。‘`%`’は読み取り専用バッファーであることを示します。‘`*`’はそのバッファーが変更されていることを示します。いくつかのバッファーが変更されていて、それらを保存するべきだと思ったときは、`C-x
s` ([Save Commands](#Save-Commands)を参照してください)で保存します。以下はバッファーリストの例です:

    CRM Buffer                Size  Mode              File
    . * .emacs                3294  Emacs-Lisp        ~/.emacs
     %  *Help*                 101  Help
        search.c             86055  C                 ~/cvs/emacs/src/search.c
     %  src                  20959  Dired by name     ~/cvs/emacs/src/
      * *mail*                  42  Mail
     %  HELLO                 1607  Fundamental       ~/cvs/emacs/etc/HELLO
     %  NEWS                481184  Outline           ~/cvs/emacs/etc/NEWS
        *scratch*              191  Lisp Interaction
      * *Messages*            1554  Messages

この例でバッファー`*Help*`は、ヘルプを要求されたことにより作成されます([Help](#Help)を参照してください)。これはファイルをvisitしていません。バッファー`src`は、ディレクトリー`~/cvs/emacs/src/`にたいして、Diredが作成したバッファーです。ファイルをvisitしているバッファーだけを一覧するには、`C-u
C-x C-b`のように、コマンドにプレフィクス引数を与えます。

`list-buffers`は名前がスペースで始まるバッファーを省略します(そのバッファーがファイルをvisitしていない限り)。これらのバッファーは、Emacsにより内部的に使用されます。

その他のバッファー操作
----------------------

`C-x C-q`  
バッファーの読み取り専用の状態を切り替えます(`read-only-mode`)。

`M-x rename-buffer RET buffer RET`  
カレントバッファーの名前を変更します。

`M-x rename-uniquely`  
カレントバッファーの末尾に‘`<number>`’を加えてリネームします。

`M-x view-buffer RET buffer RET`  
バッファーbufferをスクロールして閲覧します。[View Mode](#View-Mode)を参照してください。

C-x C-q
buffer-read-only
read-only buffer
バッファーを読み取り専用にすることができます、これはバッファーのテキストにたいして挿入や削除を行うコマンドが許されないことを意味します(とはいえ、他の`C-x
RET f`のようなコマンドは、バッファーを変更済みとマークすることは可能。[Text Coding](#Text-Coding)を参照されたい)。読み取り専用バッファーのモードラインでは、左余白の近くに‘`%%`’または‘`%*`’が表示されます。[Mode Line](#Mode-Line)を参照してください。読み取り専用バッファーは通常、DiredやRmailのように、そのバッファーのテキストを操作する専用コマンドをもつ、サブシステムにより作成されます。アクセスが制御されているファイルをvisitしたときも、そのバッファーに書き込めない旨が通知されます。

read-only-mode
view-read-only
コマンド`C-x C-q` (`read-only-mode`)は、読み取り専用バッファーを書き込み可能に、書き込み可能なバッファーを読み取り専用にします。これは各バッファーにローカルな変数`buffer-read-only`をセットすることにより機能します(値が非`nil`のときバッファーは読み取り専用)。オプション`view-read-only`を非`nil`値に変更すると、`C-x
C-q`でバッファーを読み取り専用にしたとき、そのバッファーでViewモードが有効になります([View Mode](#View-Mode)を参照してください)。

rename-buffer
`M-x
rename-buffer`は、カレントバッファーの名前をリネームします。新しい名前はミニバッファーで指定します。デフォルトはありません。他のバッファーで使用済の名前を指定するとエラーとなり、リネームされません。

rename-uniquely
`M-x
rename-uniquely`は、カレントバッファーの後ろに数字を追加して、似てはいるが異なる名前を作成します。このコマンドに引数は必要ありません。これは複数のshellバッファーを作成するのに便利です。`*shell*`バッファーをリネームしてから、再度`M-x
shell`を行うと、これは新しく`*shell*`という名前のバッファーを作成します。一方リネームされた古いshellバッファーは、新しい名前で実行を続けます。この方法はmailバッファー、compilationバッファー、そして特定の名前で特別なバッファーを作成するEmacs機能に適しています(これらの機能のいくつか、たとえば`M-x
compile`、`M-x
grep`などでは、コマンドを再度実行する前に他のバッファーに切り替える必要があります。さもないとカレントバッファーの名前を変更せずに、そのバッファーを再使用します)。

コマンド`M-x append-to-buffer`および`M-x
insert-buffer`も、あるバッファーから他のバッファーへテキストをコピーするのに使用できます。[Accumulating Text](#Accumulating-Text)を参照してください。

バッファーのkill
----------------

killing buffers
close buffer
close file
しばらくの間、Emacsセッションを続けていると、多くのバッファーが溜まってしまう場合があります。必要のないバッファーをkillしたほうがよいと思うかもしれません(他のエディターではこの操作をclose(閉じる)と呼び、“バッファーを閉じる”とか、ファイルをvisitしているバッファーでは“ファイルを閉じる”のように表現するものもあります)。ほとんどのオペレーティングシステムでは、バッファーをkillすることにより、バッファーのためにEmacsが使用していたメモリーをオペレーティングシステムに解放するので、他のプログラムがそれを使えるようになります。以下はバッファーをkillするコマンドです:

`C-x k buffer RET`  
バッファーbufferをkillします(`kill-buffer`)。

`M-x kill-some-buffers`  
バッファーを1つずつkillするか尋ねます。

`M-x kill-matching-buffers`  
正規表現にマッチするすべてのバッファーをkillするか尋ねます。

kill-buffer
C-x k
`C-x k` (`kill-buffer`)は、ミニバッファーで指定した名前のバッファーを1つkillします。RETだけをタイプしたときはデフォルトが使われ、これはカレントバッファーをkillします。カレントバッファーをkillすると、最近カレントだったが、今は別のウィンドウにも表示されていないバッファーがカレントになります。ファイルをvisitしているバッファーが変更されているとき、それをkillしようとすると確認を求められます。そのバッファーをkillする前に、確認に`yes`を応えなければkillできません。

kill-some-buffers
コマンド`M-x
kill-some-buffers`は、各バッファーについて1つずつ確認を求めます。`yes`と応えると、`kill-buffer`と同様にバッファーをkillすることを意味します。このコマンドは名前がスペースで始まる、Emacsが内部的に使用するバッファーは無視します。

kill-matching-buffers
コマンド`M-x
kill-matching-buffers`は、正規表現の入力を求め、名前がその正規表現にマッチするすべてのバッファーをkillします。[Regexps](#Regexps)を参照してください。`kill-some-buffers`と同様、このコマンドはkillする前に確認を求めます。このコマンドは通常、名前がスペースで始まる、Emacsが内部的に使うバッファーを無視します。内部的なバッファーも同じようにkillするには、プレフィクス引数を指定して`kill-matching-buffers`を呼び出します。

さまざまなバッファーをkillするにはBuffer Menu機能も便利です。[Several Buffers](#Several-Buffers)を参照してください。

kill-buffer-hook
バッファーがkillされるときに特別な処理を行いたい場合、フック`kill-buffer-hook`にフック関数を追加できます([Hooks](#Hooks)を参照してください)。

clean-buffer-list
(多くの人がそうしているように)何日間も1つのEmacsセッションを使っていると、何日か前に使ったバッファーが溜まってくるかもしれません。コマンド`M-x
clean-buffer-list`は、それらを一掃するのに便利です。これは長い間使用されていない、変更されていないバッファーをすべてkillします。3日間表示されていない普通のバッファーはkillされます。しかし自動的にkillされるべきではない特定のバッファーを指定したり、使われていない時間が短いバッファーでもkillするように指定できます。これらのデフォルト、およびこのコマンドの挙動の他の動向は、`clean-buffer-list`のドキュメント文字列で説明されている、いくつかのオプションをカスタマイズすることにより制御できます。

Midnight mode
midnight-mode
midnight-hook
Midnightモードを有効にすることにより、1日ごとにバッファーを一掃することもできます。Midnightモードは毎日真夜中に`clean-buffer-list`、またはノーマルフック`midnight-hook`に指定された関数を実行します([Hooks](#Hooks)を参照してください)。Midnightモードを有効にするには、Customizationバッファーを使って変数`midnight-mode`を`t`にセットします。[Easy Customization](#Easy-Customization)を参照してください。

複数バッファーにたいする操作
----------------------------

Buffer Menu
`M-x buffer-menu`  
すべてのEmacsバッファーの、バッファーリストの編集を開始します。

`M-x buffer-menu-other-window`  
同様ですが、別のウィンドウで行います。

`C-x C-b` ([List Buffers](#List-Buffers)を参照してください)でオープンされるBuffer Menuは、単にバッファーを一覧するだけではありません。これはDiredに似たインターフェースで、バッファーにたいしてさまざまな操作を行うことができます。ここでは、バッファーの保存、kill(Diredとの一貫性を保つため、ここではそれらを削除(delete)する、と呼びます)、表示ができます。

buffer-menu
buffer-menu-other-window
Buffer Menuを使うには`C-x C-b`とタイプして、`*Buffer
List*`バッファーが表示されたウィンドウに切り替えます。`M-x buffer-menu`とタイプして、選択されたウィンドウにBuffer Menuを開くこともできます。コマンド`M-x buffer-menu-other-window`は、Buffer Menuを別のウィンドウに開いて、そのウィンドウを選択します。

Buffer Menuは読み取り専用バッファーで、このセクションで説明する特別なコマンドだけを通じて変更します。このバッファーでは、通常のカーソル移動コマンドを使うことができます。以下のコマンドは、バッファーのカレント行に適用されます。

`d`  
Buffer-menu-delete

d (Buffer Menu)

そのバッファーの削除(kill)フラグをセットしてから、ポイントを次の行に移動します(`Buffer-menu-delete`)。削除フラグは、各行のバッファー名の前の文字‘`D`’により示されます。削除は`x`コマンド(以下参照)をタイプしたときだけ発生します。

`C-d`  
Buffer-menu-delete-backwards

C-d (Buffer Menu)

`d`と同様ですが、ポイントを下ではなく上に移動します(`Buffer-menu-delete-backwards`)。

`s`  
Buffer-menu-save

s (Buffer Menu)

そのバッファーの保存フラグをセットします(`Buffer-menu-save`)。保存フラグは各行のバッファー名の前の文字‘`S`’により示されます。保存は`x`コマンド(以下参照)をタイプしたときだけ発生します。同じバッファーに保存と削除の両方をリクエストできます。

`x`  
Buffer-menu-execute

x (Buffer Menu)

すべての削除および保存フラグを処理します(`Buffer-menu-execute`)。

`u`  
Buffer-menu-unmark

u (Buffer Menu)

カレント行のすべてのフラグを取り除いてから、下に移動します(`Buffer-menu-unmark`)。プレフィックス引数を指定した場合は、フラグを取り除いた後、上に移動します。

`DEL`  
Buffer-menu-backup-unmark

DEL (Buffer Menu)

前の行に移動して、その行のすべてのフラグを取り除きます(`Buffer-menu-backup-unmark`)。

`M-DEL`  
Buffer-menu-unmark-all-buffers

M-DEL (Buffer Menu)

すべて行から特定のフラグを取り除きます(`Buffer-menu-unmark-all-buffers`)。これは、1文字の入力を求めて、その文字でマークされたバッファーのマークを取り除きます。RETをタイプした場合は、すべてのマークを取り除きます。

`U`  
Buffer-menu-unmark-all

U (Buffer Menu)

すべての行のすべてのフラグを取り除いてから、下に移動します(`Buffer-menu-unmark-all`)。

フラグを取り除くコマンド`d`と`C-d`には、繰り返し回数として数引数を指定できます。

以下のコマンドは、カレント行にリストされたバッファーを即座に処理します。これらのコマンドにも、繰り返し回数を数引数として指定できます。

`~`  
Buffer-menu-not-modified

~ (Buffer Menu)

バッファーを変更されていない(unmodified)とマークします(`Buffer-menu-not-modified`)。[Save Commands](#Save-Commands)を参照してください。

`%`  
Buffer-menu-toggle-read-only

% (Buffer Menu)

バッファーの読み取り専用属性を切り替えます(`Buffer-menu-toggle-read-only`)。[Misc Buffer](#Misc-Buffer)を参照してください。

`t`  
Buffer-menu-visit-tags-table

t (Buffer Menu)

そのバッファーを、tagsテーブルとしてvisitします(`Buffer-menu-visit-tags-table`)。[Select Tags Table](#Select-Tags-Table)を参照してください。

以下は、他のバッファーを選択するために使われるコマンドです:

`q`  
quit-window

q (Buffer Menu)

Buffer Menuメニューを閉じます(`quit-window`)。一番最近に表示されていたバッファーが、その場所に表示されます。

`RET`; `f`  
Buffer-menu-this-window

f (Buffer Menu)

RET (Buffer Menu)

そのウィンドウの`*Buffer
List*`バッファーを置き換えて。この行のバッファーを選択します(`Buffer-menu-this-window`)。

`o`  
Buffer-menu-other-window

o (Buffer Menu)

`C-x 4 b`のように`*Buffer
List*`を表示したまま、その行のバッファーを他のウィンドウで選択します(`Buffer-menu-other-window`)。

`C-o`  
Buffer-menu-switch-other-window

C-o (Buffer Menu)

この行のバッファーを他のウィンドウで表示しますが、選択はしません(`Buffer-menu-switch-other-window`)。

`1`  
Buffer-menu-1-window

1 (Buffer Menu)

この行のバッファーを、フレーム全体のウィンドウで選択します(`Buffer-menu-1-window`)。

`2`  
Buffer-menu-2-window

2 (Buffer Menu)

現在のフレームを2つのウィンドウにセットアップして、この行のバッファーを一方のウィンドウで選択し、もう一方のウィンドウに以前のカレントバッファー(`*Buffer
List*`)は除く)を表示します(`Buffer-menu-2-window`)。

`b`  
Buffer-menu-bury

b (Buffer Menu)

この行のバッファーをbury(つまりバッファーリストの最後)に移動します(`Buffer-menu-bury`)。

`m`  
Buffer-menu-mark

m (Buffer Menu)

`v`コマンドで抜けるとき、この行のバッファーを他のウィンドウで表示されるようにマークします(`Buffer-menu-mark`)。表示フラグは行の先頭に文字‘`>`’で示されます(1つのバッファーが削除と表示のフラグを両方もつことはないでしょう)。

`v`  
Buffer-menu-select

v (Buffer Menu)

この行のバッファーを選択し、`m`コマンドでフラグづけされたバッファーも他のウィンドウで表示します(`Buffer-menu-select`)。バッファーにフラグをつけていないとき、このコマンドは`1`と等価です。

以下はバッファーリスト全体に影響を与えるコマンドです:

`S`  
tabulated-list-sort

S (Buffer Menu)

ポイントがある列の数値にしたがって、Buffer Menu全体をソートします。数引数nを指定すると、n番目の列でソートします(`tabulated-list-sort`)。

`T`  
Buffer-menu-toggle-files-only

T (Buffer Menu)

非ファイルバッファーを削除または再挿入します(`Buffer-menu-toggle-files-only`)。このコマンドは、そのようなバッファーがバッファーリストに含まれるか否かを切り替えます。

バッファー`*Buffer
List*`は通常、バッファーの作成およびkillにより自動的に更新はされません(内容は単なるテキストです)。バッファーを作成・削除・リネームした場合、それが行われたか確かめるために`*Buffer
List*`を更新するには、`g` (`revert-buffer`)とタイプします。このバッファーのAuto Revertモードを有効にすれば、このバッファーが変更されたとマークされない限り、`auto-revert-interval`秒ごとに定期的に更新させることができます。Global Auto Revertモードは、`global-auto-revert-non-file-buffers`が非`nil`のときだけ、`*Buffer
List*`バッファーに適用されます。 詳細は、[global-auto-revert-non-file-buffers](#Autorevert)を参照してください。

インダイレクトバッファー
------------------------

indirect buffer
base buffer
インダイレクトバッファー(indirect buffer: 間接バッファー)は、そのインダイレクトバッファーのベースバッファー(base buffer: 基底バッファー)と呼ばれる、他のバッファーのテキストを共有します。ある点においては、ファイルに置けるシンボリックリンクの、バッファー版に例えることができます。

`M-x make-indirect-buffer RET base-buffer RET indirect-name RET`  
ベースバッファーbase-bufferの、インダイレクトバッファーindirect-nameを作成します。 clone-indirect-buffer

`M-x clone-indirect-buffer RET`  
カレントバッファーの、インダイレクトバッファーを作成します。

`C-x 4 c`  
C-x 4 c

clone-indirect-buffer-other-window

カレントバッファーのインダイレクトバッファーを作成して、それを別のウィンドウで選択します(`clone-indirect-buffer-other-window`)。

インダイレクトバッファーのテキストは、常にベースバッファーのテキストと等しく、どちらかを編集すると、その変更はすぐにもう一方から見えるようになります。しかし他の観点では、インダイレクトバッファーとベースバッファーは、完全に分離されています。これらのバッファーは異なる名前、異なるポイント値、異なるナローイング、異なるマーカー、異なるメジャーモード、異なるローカル変数をもつことができます。

インダイレクトバッファーはファイルをvisitできませんが、ベースバッファーはvisitできます。インダイレクトバッファーの保存を試みると、それは実際にはベースバッファーの保存として機能します。ベースバッファーをkillするとインダイレクトバッファーもkillされますが、インダイレクトバッファーのkillは、ベースバッファーに影響を与えません。

インダイレクトバッファーの1つの使い方としては、アウトラインの複数の視点からの表示です。[Outline Views](#Outline-Views)を参照してください。

clone-indirect-buffer-hook
手早くインダイレクトバッファーを作成するには、コマンド`M-x
clone-indirect-buffer`を使う方法があります。これはカレントバッファーをベースバッファーとする、インダイレクトバッファーを作成して選択します。数引数を指定すると、インダイレクトバッファーの名前の入力を求めます。指定しない場合、カレントバッファー名の後ろに‘`<n>`’を付加した名前を使います。`C-x
4 c` (`clone-indirect-buffer-other-window`)は、`M-x
clone-indirect-buffer`と同様に機能しますが、新しいバッファーを他のウィンドウで選択します。これらの関数はインダイレクトバッファーを作成した後、フック`clone-indirect-buffer-hook`を実行します。

インダイレクトバッファーを作成する、より一般的な方法はコマンド`M-x
make-indirect-buffer`です。これはバッファーbase-bufferから、名前がindirect-nameのインダイレクトバッファーを作成します。これらの名前は、ミニバッファーを使って入力が求められます。

バッファー処理の便利な機能とカスタマイズ
----------------------------------------

このセクションではバッファーを切り替えをもっと便利にする、モードと機能をいくつか説明します。

### バッファー名を一意にする

unique buffer names
directories in buffer names
同じ名前のファイルを複数のバッファーでvisitしているとき、Emacsはバッファーに区別可能な名前をつけなければなりません。デフォルトの方法はファイルをディレクトリーの一部を後ろに追加する方法です。たとえば同時にファイル`/foo/bar/mumble/name`と`/baz/quux/mumble/name`をvisitしている場合、バッファーの名前は‘`name<bar/mumble>`’と‘`name<quux/mumble>`’になるでしょう。Emacsは名前を一意にするために必要な分だけ、ディレクトリー名の一部を追加します。

uniquify-buffer-name-style
オプション`uniquify-buffer-name-style`をカスタマイズして、一意なバッファー名を構築するための異なるスタイルを選択することができます。

命名方法`forward`は、バッファー名の先頭部分に、ファイルのディレクトリー名の一部を含めます。この方法を使うとファイル`/u/rms/tmp/Makefile`と`/usr/projects/zaphod/Makefile`をvisitしているバッファーの名前は、‘`tmp/Makefile`’と‘`zaphod/Makefile`’になるでしょう。

対照的に命名方法`post-forward`は、バッファーを‘`Makefile|tmp`’および‘`Makefile|zaphod`’と名づけます。デフォルトの`post-forward-angle-brackets`は、`post-forward`と同様ですが、一意なパスを山形カッコ(angle brackets)で囲います。命名方法`reverse`では、‘`Makefile\tmp`’および‘`Makefile\zaphod`’となります。`post-forward`と`reverse`の重要な違いは、2つのファイルを区別するのに1つのディレクトリ名では不足するときです。`reverse`はディレクトリー名を逆順にして命名するので、ファイル`/top/middle/file`は‘`file\middle\top`’となります。一方`post-forward`はディレクトリー名を正順でファイル名に追加するので‘`file|top/middle`’となります。`uniquify-buffer-name-style`が`nil`にセットされていると、バッファー名の後ろに単に‘`<2>`’、‘`<3>`’と加えることにより、バッファー名を作成します。

タイプする前にバッファー名に*注意*すれば、バッファー名にディレクトリー名を付加する方法に重要な違いはありません。しかしルールを知った経験豊富なユーザーは、それほど注意する必要はないでしょう。そして、その場合いずれかのルールでバッファー名が表示されていれば，思い出し利用するのが容易になることでしょう。

### 素早いミニバッファーの選択

icomplete-mode
Icomplete mode
グローバルなマイナーモードのIcompleteモードは、ミニバッファーで利用可能な補完候補を素早く選択する便利な方法を提供します。これが有効な場合、ミニバッファーでタイプすることにより、すでにタイプした文字にマッチする、利用可能な候補を連続で表示します。

`C-j`とタイプすることにより、常にリストの最初の補完候補を選択できます。つまり特定の補完候補を選択するには、まずその候補をリストの先頭にすることです。これを行うには2つの方法があります。1つ目の方法は、補完候補の名前をさらにタイプすることにより、違う候補が含まれないように、希望する補完候補にリストを絞りこむ方法です。もう1つは`C-.`および`C-,`を使って、望む候補が先頭にくるまでリストをローテートする方法です。

`M-TAB`は`C-j`のようにリストの最初の補完候補を選択しますが、ミニバッファーを抜けないので、さらに編集を続けることができます。これはファイル名の入力で通常使われます。`M-TAB`により、いくつかのディレクトリー階層をたどることができます。

Icompleteモードを有効にするには、`M-x
icomplete-mode`とタイプするか、変数`icomplete-mode`を`t`にカスタマイズします([Easy Customization](#Easy-Customization)を参照してください)。

### バッファーメニューのカスタマイズ

bs-show
buffer list, customizable
`M-x bs-show`  
`M-x list-buffers`と同様にバッファーリストを作成しますが、カスタマイズが可能です。

`M-x ibuffer`  
バッファーのリストを作成して、Dired様式でそれらを操作できるようにします。

bs-customize
`M-x bs-show`は、通常`C-x
C-b`で表示されるのと同じようなバッファーリストを表示しますが、これはより柔軟な方法で表示をカスタマイズできます。たとえば、表示すべきバッファー属性のリスト、バッファー名の列幅の最小と最大、決して表示されないバッファーや常に表示するバッファー名にたいする正規表現を指定することができます。通常のバッファーリストよりこちらのほうが好ましい場合、このコマンドを`C-x
C-b`にバインドできます。このバッファーリストをカスタマイズするには、Customグループの`bs`([Easy Customization](#Easy-Customization)を参照)を使用するか、`bs-customize`を呼び出してください。

msb-mode
mode, MSB
MSB mode
mouse-buffer-menu
C-Down-mouse-1
MSBグローバルマイナーモード(“MSB”は“mouse select buffer”が由来)は、カスタマイズ可能なマウスによる別のBuffer Menuを、好みに応じて提供します。これは通常`C-Down-mouse-1`、または`C-F10`にバインドされている`mouse-buffer-menu`と、そのコマンドを置き換えます。メニューはCustomグループ`msb`でカスタマイズが可能です。

ibuffer
IBufferとは、バッファーのリストを閲覧して、フィルタリング、マーキング、さまざまな方法によるソート、およびバッファーにたいする処理を含む、Dired([Dired](#Dired)を参照)に似た操作をバッファーに行うメジャーモードです。

複数ウィンドウ
==============

windows in Emacs
multiple windows in Emacs
Emacsのフレームは、2つ以上のウィンドウに分割できます。複数のウィンドウで異なるバッファーを表示したり、1つのバッファーの異なる部分を表示できます。複数フレームは自ずと複数ウィンドウになります。なぜならフレームには、それぞれウィンドウがあるからです。ウィンドウは1つのフレームだけに属します。

Emacsウィンドウの概念
---------------------

Emacsの各ウィンドウには、常に1つのEmacsバッファーが表示されます。1つのバッファーは、複数のウィンドウに表示される場合があります。この場合、バッファーのテキストへの任意の変更は、それが表示されているすべてのウィンドウで表示されます。しかし各ウィンドウは独自にポイント値をもっているので、ウィンドウごとにバッファーの異なる部分を表示できます。

selected window
常に1つのEmacsウィンドウが、選択されたウィンドウとなります。このウィンドウに表示されているバッファーが、カレントバッファーとなります。グラフィカルなディスプレーでは、選択されたウィンドウのカーソルは、点滅する塗りつぶされたカーソルとなり、選択されていないウィンドウでは、中抜きボックスのカーソルになります。テキスト端末では、カーソルは選択されたウィンドウだけで描画されます。[Cursor Display](#Cursor-Display)を参照してください。

ポイントを移動するコマンドは、選択されたEmacsウィンドウのポイント値だけに影響します。他のEmacsウィンドウのポイント値は、たとえ同じバッファーを表示していたとしても変更されません。これと同じことは、`C-x
b`のようなバッファー切り替えコマンドについても言えます。これらは他のウィンドウには影響を与えません。しかし`C-x 4
b`のような、別のウィンドウを選択して、バッファーを切り替えるコマンドもあります。(たとえば)`C-h f` (`describe-function`)や`C-x C-b` (`list-buffers`)を含む、ウィンドウで情報を表示するコマンドは、選択されたウィンドウに影響を与えることなく、通常は選択されていないウィンドウ内にバッファーを表示することにより機能します。

複数ウィンドウで同じバッファーを表示しているとき、これらは異なるリージョンを持ちます。なぜなら、それらは異なるポイント値を持つことができるからです。しかしバッファーごとにマーク位置は1つだけなので、これらは同じマーク位置をもちます。

それぞれのウィンドウには、独自のモードラインがあり、それにはバッファー名、変更状態、そのウィンドウに表示されているバッファーのメジャーモードとマイナーモードが表示されます。選択されたウィンドウのモードラインは、異なる色で表示されます。詳細については、[Mode Line](#Mode-Line)を参照してください。

ウィンドウの分割
----------------

`C-x 2`  
選択されたウィンドウを上下に2分割します(`split-window-below`)。

`C-x 3`  
選択されたウィンドウを左右に2分割します(`split-window-right`)。

`C-mouse-2`  
ウィンドウのモードライン上では、ウィンドウを分割します。

C-x 2
split-window-below
`C-x 2` (`split-window-below`)は、選択されたウィンドウを上下に2つのウィンドウに分割します。分割した後は、上が選択されたウィンドウになり、新たに分割されたウィンドウが下になります。2つのウィンドウは最初同じポイント値をもち、(可能な限り)同じバッファー部分を表示します。必要ならポイントをスクリーン上に残したまま、ウィンドウをスクロールできます。デフォルトでは2つのウィンドウの高さは、元のウィンドウの高さの半分になります。正の数引数は上のウィンドウの高さが何行分かを指定し、負の数引数は下のウィンドウが何行分の高さかを指定します。

split-window-keep-point
変数`split-window-keep-point`を`nil`に変更すると、`C-x
2`はスクリーンに表示されるテキストができるだけ前と同じになるように、ウィンドウに表示されるバッファー部分と、各ウィンドウのポイント位置を調整します。さらにポイントが元のウィンドウの下半分にあったときは、上ではなく下のウィンドウが選択されます。

C-x 3
split-window-right
`C-x 3` (`split-window-right`)は、選択されたウィンドウを左右に2つのウィンドウに分割します。左のウィンドウが選択されたウィンドウとなり、右のウィンドウには同じバッファーの同じ部分が表示され、ポイント位置も同じです。正の数引数は左のウィンドウの幅を列数で指定し、負の数引数は右のウィンドウの幅を数引数で指定します。

truncate-partial-width-windows
ウィンドウを`C-x
3`で分割すると、分割されたウィンドウの幅はフレーム全体の幅より小さくなります。ウィンドウの幅が狭くなりすぎると、継続行が使われたバッファーを読むことが困難になる場合があります([Continuation Lines](#Continuation-Lines)を参照してください)。したがってウィンドウの幅が50列より狭くなったとき、Emacsは自動的に行を切り詰めに切り替えます。この切り詰めは、変数`truncate-lines`の値に関係なく発生します([Line Truncation](#Line-Truncation)を参照してください)。`truncate-lines`のかわりに、この自動切り詰めを制御するのは、変数`truncate-partial-width-windows`です。この変数の値が正の整数(デフォルトは50)の場合、それは自動的な行切り詰めが発生する前の、分割ウィンドウの最小のトータル幅(total width)を指定します。この値が`nil`の場合、自動的な行切り詰めは無効です。他の非`nil`値では、分割されたウィンドウの幅に関係なく、Emacsは行を切り詰めます。ウィンドウのトータル幅(total width)とは、`window-total-width` (section “Window Sizes” in The Emacs Lisp Reference Manualを参照してください)で報告される列単位の値で、これにはフリンジと、継続および切り詰めのためのグリフ、マージン、スクロールバーが含まれます。

テキスト端末では、左右に分割されたウィンドウを垂直に分割する分割線は、`vertical-border`フェイスで描画されます。

C-mouse-2 (mode line)
C-mouse-2 (scroll bar)
ウィンドウのモードライン上で`C-mouse-2`をクリックすると、クリックした位置に垂直分割線を配してウィンドウを分割します。Emacsがコンパイルされた方法に依存しますが、ウィンドウのスクロールバー上で`C-mouse-2`をクリックすると、クリックした位置に水平分割線を配してウィンドウを分割します(この機能は、EmacsがGTK+のスクロールバーを使っているときは機能しません)。

window-resize-pixelwise
デフォルトでは、ウィンドウを分割したとき、Emacsは分割されたウィンドウのサイズをフレームのデフォルトフォントの整数倍にします。これによりスクリーンが正確に2分割されない場合があります。変数`window-resize-pixelwise`を非`nil`値にセットすると、Emacsは分割されたウィンドウのサイズを、同じピクセル数にします(元のサイズが奇数のピクセル数の場合、1ピクセル増減されます)。フレームのピクセル数がフレームの文字サイズ倍でない場合、このオプションが`nil`でも、少なくとも1つのウィンドウがピクセル幅のサイズ変更をされることに注意してください。

他のウィンドウの使用
--------------------

`C-x o`  
他のウィンドウを選択します(`other-window`)。

`C-M-v`  
次のウィンドウをスクロールします(`scroll-other-window`)。

`Mouse-1`  
ウィンドウのテキスト領域を`mouse-1`でクリックすると、そのウィンドウを選択してクリックした位置にポイントを移動します。モードラインをクリックすると、ポイントを移動せずにそのウィンドウを選択します。

C-x o
other-window
キーボードで`C-x o` (`other-window`)をタイプして、ウィンドウを切り替えることができます。`o`は“other”のoで、0(ゼロ)ではありません。2つ以上のウィンドウがある時、このコマンドはすべてのウィンドウを順繰りに選択します(一般的に上からした、左から右)。一番右または一番下のウィンドウの後は、左上のウィンドウに戻ります。数引数は上記の順番で何番目のウィンドウに移動するかを意味します。負の引数は逆向きで同じことを行います。ミニバッファーがアクティブのとき、ミニバッファーウィンドウはこの順番では最後のウィンドウになります。ミニバッファーのウィンドウから他のウィンドウに切り替えて、後からミニバッファーに戻って引数の入力を終了させることができます。[Minibuffer Edit](#Minibuffer-Edit)を参照してください。

C-M-v
scroll-other-window
通常のスクロールコマンド([Display](#Display)を参照してください)は、選択されたウィンドウだけに適用されますが、次のウィンドウをスクロールするコマンドが1つあります。`C-M-v` (`scroll-other-window`)は、`C-x
o`が選択するウィンドウをスクロールします(このコマンドは`C-v`のように正または負の引数をとります。ミニバッファーでの`C-M-v`は、ミニバッファーに関連付けられたヘルプウィンドウがあれば、標準的な次のウィンドウではなくヘルプウィンドウをスクロールします。[Minibuffer Edit](#Minibuffer-Edit)を参照してください)。

mouse-autoselect-window
`mouse-autoselect-window`を非`nil`値にセットしている場合、マウスが選択されたウィンドウ以外のウィンドウに移動すると、そのウィンドウが選択されます。この機能はデフォルトでオフです。

他のウィンドウでの表示
----------------------

selecting buffers in other windows
C-x 4
`C-x
4`は、異なるウィンドウ(他の既存のウィンドウや、選択されたウィンドウを分割することにより新たに作成されたウィンドウ)のバッファーに切り替える、さまざまなコマンドのプレフィクスキーです。Emacsがウィンドウを選択または作成する方法については、[Window Choice](#Window-Choice)を参照してください。

`C-x 4 b bufname RET`  
他のウィンドウのバッファーbufnameを選択します(`switch-to-buffer-other-window`)。[Select Buffer](#Select-Buffer)を参照してください。

display-buffer (command)

`C-x 4 C-o bufname RET`  
C-x 4 C-o

バッファーbufnameを選択せずに、別のウィンドウに表示します(`display-buffer`)。ウィンドウが選択される方法についての詳細は、[Displaying Buffers](#Displaying-Buffers)を参照してください。

`C-x 4 f filename RET`  
ファイルfilenameをvisitして、他のウィンドウでバッファーを選択します(`find-file-other-window`). [Visiting](#Visiting)を参照してください。

`C-x 4 d directory RET`  
directoryのDiredバッファーを、別のウィンドウで選択します(`dired-other-window`)。[Dired](#Dired)を参照してください。

`C-x 4 m`  
`C-x m` ([Sending Mail](#Sending-Mail)を参照してください)と同様に、メールメッセージの編集を開始しますが、別のウィンドウで行います(`compose-mail-other-window`)。

find-tag-other-window

`C-x 4 .`  
`M-.` ([Xref](#Xref)を参照してください)と同様に、識別子の定義を検索しますが、別のウィンドウで行います(`xref-find-definitions-other-window`)。

`C-x 4 r filename RET`  
ファイルfilenameを読み取り専用でvisitして、別のウィンドウでバッファーを選択します(`find-file-read-only-other-window`)。[Visiting](#Visiting)を参照してください。

ウィンドウの削除とリサイズ
--------------------------

delete window
deleting windows
`C-x 0`  
選択されたウィンドウを削除します(`delete-window`)。

`C-x 1`  
フレームから選択されたウィンドウ以外のすべてのウィンドウを削除します(`delete-other-windows`)。

`C-x 4 0`  
選択されていたウィンドウを削除して、それに表示されていたバッファーをkillします(`kill-buffer-and-window`)。このキーシーケンスの最後の文字はゼロです。

`M-x delete-windows-on RET buffer RET`  
指定されたbufferを表示しているウィンドウを削除します。

`C-x ^`  
選択されたウィンドウの高さを増やします(`enlarge-window`)。

`C-x }`  
選択されたウィンドウの幅を増やします(`enlarge-window-horizontally`)。

`C-x {`  
選択されたウィンドウの幅を減らします(`shrink-window-horizontally`)。

`C-x -`  
バッファーに多くの行数が必要ない場合、そのウィンドウを縮小します(`shrink-window-if-larger-than-buffer`)。

`C-x +`  
すべてのウィンドウの高さを同じにします(`balance-windows`)。

C-x 0
delete-window
選択されたウィンドウを削除するには、`C-x 0` (`delete-window`)とタイプします(これはゼロです)。一度ウィンドウが削除されると、そのウィンドウが占めていたスペースは隣接したウィンドウに与えられます(しかしミニバッファーの場合、それがアクティブな場合でも適用されません)。ウィンドウの削除は、ウィンドウを表示用に使っていたバッファーに影響を与えません。そのバッファーは存在し続け、`C-x
b`で切り替えることができます。

kill-buffer-and-window
C-x 4 0
`C-x 4 0` (`kill-buffer-and-window`)は、コマンド`C-x
0`より強力なコマンドです。これはカレントバッファーをkillしてから、選択されたウィンドウを削除します。

C-x 1
delete-other-windows
`C-x 1` (`delete-other-windows`)は、選択されたウィンドウ*以外*のすべてのウィンドウを削除します。選択されたウィンドウはフレーム全体に拡張されます(このコマンドは、ミニバッファーのウィンドウがアクティブのとき使うことができません。これを試みるとエラーがシグナルされます)。

`M-x
delete-windows-on`は、特定のバッファーを表示するウィンドウを削除します。これは、そのバッファーの入力を求めます(デフォルトはカレントバッファー)。`C-u
0`のようにプレフィックス引数が0の場合、このコマンドはカレントディスプレイ上のフレームのウィンドウだけを削除します。

resize window
resizing windows
C-x ^
enlarge-window
C-x }
window-min-height
コマンド`C-x ^` (`enlarge-window`)は、フレームの高さを変えずに垂直方向に隣接するウィンドウのスペースを縮小して、選択されたウィンドウの高さを増やします。正の数引数を与えると、このコマンドは指定した行数分ウィンドウの高さを増やします。負の数引数を与えると、指定した行数分ウィンドウの高さを増やします。垂直方向に隣接するウィンドウが存在しない場合(たとえばウィンドウの高さがフレーム全体の高さと同じとき)、エラーをシグナルします。このコマンドは変数`window-min-height`(デフォルトは4)で指定された、最小行数よりウィンドウの高さを縮小しようとしても、エラーをシグナルします。

enlarge-window-horizontally
shrink-window-horizontally
window-min-width
同様に`C-x }` (`enlarge-window-horizontally`)は、選択されたウィンドウの幅を増やし、`C-x {` (`shrink-window-horizontally`)は幅を減らします。これらのコマンドは、変数`window-min-width`(デフォルトは10)で指定された最小列数よりウィンドウの幅を縮小すると、エラーをシグナルします。

モードライン([Mode Line Mouse](#Mode-Line-Mouse)を参照してください)、またはウィンドウ分割線(window dividers。[Window Dividers](#Window-Dividers)を参照してください)をマウスでクリックすることにより、ウィンドウの高さの変更およびウィンドウの分割や削除を行なう、別の方法を提供します。

C-x -
shrink-window-if-larger-than-buffer
`C-x -` (`shrink-window-if-larger-than-buffer`)は、バッファー全体を表示するのに必要な高さより選択されたウィンドウの高さが大きいときは、選択されたウィンドウの高さを減らします。余った行数はフレームの他のウィンドウに与えられます。

C-x +
balance-windows
`C-x +` (`balance-windows`)を使って、選択されたフレームのすべてのウィンドウの高さを均等にすることもできます。

ウィンドウでのバッファーの表示
------------------------------

ユーザーのコマンドの結果として、任意のバッファーが表示またはポップアップされるのは、Emacsでは一般的な処理です。コマンドがこれを行うには、いくつかの異なる方法があります。

`C-x C-f` (`find-file`)のような多くのコマンドは、デフォルトでは選択されたウィンドウを“乗っ取って”バッファーを表示します。

選択されたウィンドウを乗っ取らずに、たとえばウィンドウを分割して新しいウィドウを作り、そこにバッファーを表示するといったような、利口な表示を試みるコマンドがいくつかあります。さまざまなヘルプコマンド([Help](#Help))を含む、そのようなコマンドは内部的に`display-buffer`を呼び出すことにより機能します。詳細は、[Window Choice](#Window-Choice)を参照してください

他のコマンドは`display-buffer`と同じことを行いますが、それに加えてバッファーの編集を開始できるように、表示されたウィンドウを選択します。コマンド`` C-x
` `` (`next-error`)が1つの例です([Compilation Mode](#Compilation-Mode)を参照してください)。そのようなコマンドは、内部的に関数`pop-to-buffer`を呼び出すことにより機能します。section “Switching to a Buffer in a Window” in The Emacs Lisp Reference Manualを参照してください。

名前が`-other-window`で終わるコマンドは、`display-buffer`と同じように振る舞います。例外はそれらが決して選択されたウィンドウに表示しない点です。これらのコマンドのいくつかは、プレフィクスキー`C-x
4`にバインドされています([Pop Up Window](#Pop-Up-Window)を参照してください)。

名前が`-other-frame`で終わるコマンドは、`display-buffer`と同じように振る舞います。例外は、i)選択されたウィンドウに決して表示しない、ii)望むバッファーを表示するために新たなフレームを作成するか、他のフレーム上のウィンドウを使用する、という2点です。これらのコマンドのいくつかは、プレフィクスキー`C-x
5`にバインドされています。

### `display-buffer`が機能する方法

display-buffer, detailed description
`display-buffer`コマンド(およびこのコマンドを内部的に呼び出すコマンド)は、以下で与えられたステップに従って、表示するウィンドウを選択します。このステップの順番を変更する方法については、section “Choosing a Window for Displaying a Buffer” in The Emacs Lisp Reference Manualを参照してください。

-   他に考慮されるべき点とは無関係に、そのバッファーが選択されたウィンドウ内に表示されるべき場合は、選択されたウィンドウを再利用します。デフォルトではこのステップはスキップされますが、オプション`display-buffer-alist` (section “Choosing a Window for Displaying a Buffer” in The Emacs Lisp Reference Manualを参照)にバッファー名にマッチする正規表現を追加して、アクション関数`display-buffer-same-window` (section “Action Functions for Buffer Display” in The Emacs Lisp Reference Manualを参照)でそれを参照することにより、Emacsにスキップしないよう告げることができます。たとえば、選択されたウィンドウ内に優先的にバッファー`*scratch*`を表示するには、以下のように記述します:

        (customize-set-variable
         'display-buffer-alist
         '("\\*scratch\\*" (display-buffer-same-window)))

    デフォルトでは、`display-buffer-alist`は`nil`です。

-   上記以外の場合、バッファーがすでに既存のウィンドウに表示されているときは、そのウィンドウを再利用します。通常は選択されたフレームのウィンドウだけが考慮されますが、対応するアクションalist`reusable-frames`エントリー(section “Action Alists for Buffer Display” in The Emacs Lisp Reference Manualを参照)を使用している場合は、他のフレームのウィンドウも再利用可能です。これを行う例は、次のステップを参照してください。

-   上記以外の場合、オプションで新しいフレームを作成して、バッファーをそこに表示します。デフォルトではこのステップはスキップされます。これを有効にするには、以下のようにオプション`display-buffer-base-action` (section “Choosing a Window for Displaying a Buffer” in The Emacs Lisp Reference Manualを参照)の値を変更してください:

        (customize-set-variable
         'display-buffer-base-action
         '((display-buffer-reuse-window display-buffer-pop-up-frame)
           (reusable-frames . 0)))

    このカスタマイズでは、すべての可視およびアイコン化されたフレーム上の再利用可能なウィンドウを検索するステップを先行して試みるでしょう。

-   上記以外の場合、選択されたフレームのウィンドウを分割することにより、新しいウィンドウを作成して、バッファーを新しく作成したウィンドウに表示しようと試みます。

    split-height-threshold
    split-width-threshold
    分割は垂直または水平に行われる可能性があり、それは変数`split-height-threshold`および`split-width-threshold`に依存します。これらの変数には整数値を指定します。`split-height-threshold`が選択されたウィンドウの高さより小さい場合、分割により下が新しいウィンドウになります。上記以外の場合、`split-width-threshold`が選択されたウィンドウの幅より小さい場合、分割により右が新しいウィンドウになります。どちらの条件も適用できなかったとき、Emacsは分割により下を新しいウィンドウにしようと試みますが、それは選択されたウィンドウが以前に分割されていなかった場合に限られます(過剰な分割を避けるため)。

-   上記以外の場合、そのウィンドウに前に表示されていたバッファーを表示します。通常は選択されたフレームのウィンドウだけが考慮されますが、適正なアクションalistエントリー`reusable-frames` (上記参照)により、他のフレームのウィンドウかもしれません。

-   上記以外の場合、選択されたフレームの既存のウィンドウのバッファーを表示します。

-   何らかの理由により上記すべてが失敗した場合、新しいフレームを作成して、そこにバッファーを表示します。

### 編集不可バッファーの表示

temporary windows
ウィンドウに表示されるバッファーの中には、編集のためではなく閲覧するためのものがあります。Helpコマンド(see [Help](#Help))は通常、この目的のために`*Help*`と呼ばれるバッファーを使用し、ミニバッファーの補完(see [Completion](#Completion))は別の`*Completions*`と呼ばれるバッファーなどを使用します。このようなバッファーは通常、短時間しか表示されません。

Emacsは通常、このような一時的に表示されるウィンドウを、前のサブセクションで説明したように`display-buffer`を通じて表示します。一方、`*Completions*`バッファーは通常、そのフレームにいくつウィンドウが表示されているかに関わらず、選択されたフレームの最下のウィンドウに表示されます。

一時的なバッファーを他のやり方でEmacsに表示させたい場合、変数`display-buffer-alist` (section “Choosing a Window for Displaying a Buffer” in The Emacs Lisp Reference Manualを参照)をカスタマイズしてください。たとえば、常に選択されたウィンドウの下に`*Completions*`を表示するには、初期化ファイル([Init File](#Init-File)を参照)で以下のフォームを使用します:

    (customize-set-variable
     'display-buffer-alist
     '(("\\*Completions\\*" display-buffer-below-selected)))

temp-buffer-resize-mode
Emacsは通常、バッファーの内容のすべてを表示するのに必要な大きさのウィンドウを作成するという点において、`*Completions*`バッファーは特別です。たとえば`*Help*`バッファーなど、他の一時表示でこのようなウィンドウのリサイズを行なうには、マイナーモード([Minor Modes](#Minor-Modes)を参照)の`temp-buffer-resize-mode` (section “Temporary Displays” in The Emacs Lisp Reference Manualを参照)に切り替えます。

temp-buffer-max-height
temp-buffer-max-width
`temp-buffer-resize-mode`でリサイズされるウィンドウの最大サイズは、オプション`temp-buffer-max-height`と`temp-buffer-max-width` (see section “Temporary Displays” in The Emacs Lisp Reference Manual)で制御できます。最大サイズは、ウィンドウが含まれるフレームのサイズを超えることはできません。

ウィンドウ処理のための便利な機能
--------------------------------

winner-mode
Winner mode
mode, Winner
undoing window configuration changes
window configuration changes, undoing
Winnerモードは、ウィンドウの設定変更(たとえばフレームのウィンドウがどのように分割されたか)を記録するグローバルマイナーモードなので、それらをundoできます。Winnerモードは`M-x
winner-mode`、または変数`winner-mode`をカスタマイズすることにより、切り替えることができます。このモードが有効な場合、`C-c
left` (`winner-undo`)は、左のウィンドウの設定変更をundoします。undoしてから気が変わった場合、`C-c
right` (`M-x winner-redo`)を使って、undoした変更を再実行することができます。

Followモード(`M-x
follow-mode`)は、複数のウィンドウの同じバッファーを同期するので、バッファーの隣接した部分が常に表示されます。[Follow Mode](#Follow-Mode)を参照してください。

Windmove package
directional window selection
windmove-right
windmove-default-keybindings
Windmoveパッケージは、フレーム内の隣接したウィンドウ間を直接移動するコマンドを定義します。rightの部分をleft、up、downに置き換えると、対応する方向の隣接するウィンドウを選択します。`M-x
windmove-default-keybindings`は、これらのコマンドを`S-right`などにバインドします。これにより、これらのキーを使ったシフト選択が無効になります([Shift Selection](#Shift-Selection)を参照してください)。

コマンド`M-x compare-windows`は、異なるウィンドウに表示されたテキストを比較します。[Comparing Files](#Comparing-Files)を参照してください。

scroll-all-mode
scrolling windows together
Scroll-all mode
mode, Scroll-all
Scroll Allモード(`M-x
scroll-all-mode`)は、スクロールおよびポイント移動コマンドが、表示されているすべてのウィンドウに適用されるグローバルマイナーモードです。

フレームとグラフィカルなディスプレー
====================================

frames
Emacsがグラフィカルなディスプレー(たとえばXウィンドウシステム)で開始されたときは、システムレベルのグラフィカルな表示領域(display region)を占有します。このマニュアルではこれをフレームと呼び、“ウィンドウ”という言葉はフレームでバッファーを表示する部分のために使います。フレームには最初1つのウィンドウが含まれていますが、これを複数のウィンドウに分割することができます。フレームには通常、メニューバー、ツールバー、エコーエリアも含まれます。

追加のフレームを作ることもできます([Creating Frames](#Creating-Frames)を参照してください)。同じEmacsセッションで作られたすべてのフレームは、背後にあるバッファーや、その他のデータにアクセスします。たとえば１つ以上のフレームで表示されているバッファーは、あるフレームに表示されているものに変更を加えると、即座に他のフレームに反映されます。

`C-x
C-c`とタイプすると、現在表示されているすべてのフレームを閉じて、他に表示されているフレームがなければ、Emacsセッションを終了します([Exiting](#Exiting)を参照してください)。選択されたフレームだけを閉じるには、`C-x
5 0`(これは`o`ではなくゼロです)とタイプします。

このセクションでは、グラフィカルなディスプレーに特有の機能(特にマウスコマンド)と、複数フレームを管理する機能について説明します。テキスト端末では、これらの機能の多くは利用できません。しかしテキスト端末で複数のフレームを作ることは可能です。そのようなフレームは1度に１つだけ表示され、テキスト画面全体を占有します([Non-Window Terminals](#Non_002dWindow-Terminals)を参照してください)。テキスト端末の中には、マウスを使うことが可能なものがいくつかあります(GNUおよびUnix systemsでこれを行うには、[Text-Only Mouse](#Text_002dOnly-Mouse)を、MS-DOSでこれを使うには、 [MS-DOS Mouse](#MS_002dDOS-Mouse)を参照してください )。メニューはすべてのテキスト端末でサポートされています。

編集のためのマウスコマンド
--------------------------

mouse buttons (what they do)
mouse, selecting text using
mouse-1
mouse-2
mouse-3
`mouse-1`  
クリックした場所にポイントを移動します(`mouse-set-point`)。

`Drag-mouse-1`  
ドラッグにより選択されたテキストを取り囲むリージョンをアクティブ化して、そのテキストをプライマリー選択に置きます(`mouse-set-region`)。

`mouse-2`  
クリックした場所にポイントを移動して、そこにプライマリー選択の内容を挿入します(`mouse-yank-primary`)。

`mouse-3`  
リージョンがアクティブなときは、近くにあるリージョンの終端をクリックした位置に移動します。アクティブでないときは現在のポイントにマークをセットして、ポイントをクリックした位置に移動します。結果となるリージョンはkillリングに保存されます。2回目のクリックでリージョンをkillします(`mouse-save-then-kill`)。

mouse-set-point
もっとも基本的なマウスコマンドは`mouse-set-point`で、これはウィンドウのテキスト領域でマウスの左ボタン、`mouse-1`をクリックすることにより呼び出されます。これはポイントをクリックされた位置に移動します。そのウィンドウが選択されたウィンドウでなかったとき、そのウィンドウが選択されたウィンドウになります。`mouse-1`をダブルクリックして、リージョンをアクティブにすることもできます([Word and Line Mouse](#Word-and-Line-Mouse)を参照)。

x-mouse-click-focus-ignore-position
クリックしたフレームが選択されたフレームでなかった場合は通常、クリックされたフレームが選択されたフレームになるのに加えて、ウィンドウも選択されてカーソルがセットされます。Xウィンドウシステムでは、変数`x-mouse-click-focus-ignore-position`を`t`にセットすることにより、これを変更できます。この場合、選択されていないフレームへの最初のクリックではフレームだけを選択し、他は変更しません。次にクリックするとそのウィンドウを選択してカーソルをその位置にセットします。

mouse, dragging
mouse-set-region
`mouse-1`を押してテキストの周辺をドラッグすると、最初にマウスボタンを押した位置にマークが置かれ、ボタンを離した位置にポイントがセットされ([Mark](#Mark)を参照してください)、その領域がアクティブになります(`mouse-set-region`)。それに加えてリージョンのテキストがプライマリー選択となります([Primary Selection](#Primary-Selection)を参照してください)。

mouse-drag-copy-region
変数`mouse-drag-copy-region`を非`nil`値に変更すると、テキストの周囲をドラッグすることにより、そのテキストをkillリングに追加します。デフォルトは`nil`です。

mouse-scroll-min-lines
ドラッグしている途中でマウスがウィンドウの上または下を超えた場合、マウスがウィンドウ内に戻るまで、ウィンドウが一定の割合でスクロールします。この方法により、スクリーン全体に収まらないリージョンを選択できます。1度に何行スクロールするかは、マウスがウィンドウの縁からどれだけ離れたかに依存します。変数`mouse-scroll-min-lines`は、最小ステップサイズを指定します。

mouse-yank-primary
mouse-yank-at-click
マウスの真ん中のボタン、`mouse-2`をクリックすると、クリックした位置にポイントを移動して、プライマリー選択の内容を挿入します(`mouse-yank-primary`)。[Primary Selection](#Primary-Selection)を参照してください。この振る舞いは、他のXアプリケーションと一貫性があります。かわりに`mouse-2`を、`mouse-yank-at-click`にバインドできます。これはクリックした位置にyankするコマンドです。

mouse-yank-at-point
変数`mouse-yank-at-point`を非`nil`値に変更すると、`mouse-2`はポイントを移動しません。これはどこをクリックしたか、フレームのどのウィンドウをクリックしたかに関係なく、ポイントのある位置にテキストを挿入します。この変数は`mouse-yank-primary`と`mouse-yank-at-click`の両方に影響します。

mouse-save-then-kill
マウスの右ボタン、`mouse-3`をクリックすると、コマンド`mouse-save-then-kill`が実行されます。これはどこをクリックしたかと、リージョンの状態に依存していくつかのアクションを処理します。

-   アクティブなリージョンがないときは、`mouse-3`のクリックにより、ポイントがあった位置にマークをセットし、クリックした位置にポイントを置いて、リージョンをアクティブにします。

-   リージョンがアクティブなときは、`mouse-3`のクリックにより、クリックした位置に近いリージョンの終端を、クリックした位置に調整します。調整されたリージョンのテキストは、killリングにコピーされます。元のリージョンのテキストがすでにkillリングにある場合は、それを置き換えます。

-   元のリージョンが`mouse-1`のダブルクリックまたはトリプルクリックで選択されたものである場合、リージョンは単語全体、または行全体にたいして定義されているので([Word and Line Mouse](#Word-and-Line-Mouse)を参照してください)、`mouse-3`によるリージョンの調整も単語全体または行全体を単位として行われます。

-   同じ場所で連続して2回`mouse-3`を使うことにより、すでに選択されているリージョンをkillできます。したがってマウスでテキストをkillする簡単な方法は、まずリージョンの始端を決めるため`mouse-1`をクリックして、もう一方の終端で`mouse-3`を2回クリックします。テキストを削除せずにkillリングにコピーするには、`mouse-3`を1回だけクリックするか、テキスト範囲をドラッグします。その後は適当な場所でyankしてコピーできます。

`mouse-save-then-kill`コマンドは、変数`mouse-drag-copy-region`の値にもしたがいます(上記参照)。変数の値が非`nil`のときは、コマンドがアクティブなリージョンをセットまたは調整したとき、常にリージョンのテキストはkillリングにも追加されます。一番最近のkillリングのエントリーが同じ方法で追加されたものである場合、新しいエントリーを作成せず、そのエントリーを置き換えます。

上記で説明した任意のマウスコマンドを使ってセットしたリージョンは、シフト選択以外のマウス移動コマンド、および通常のマークを非アクティブ化する方法により、マークが非アクティブになります。[Shift Selection](#Shift-Selection)を参照してください。

mouse wheel
mouse-wheel-mode
Mouse Wheel minor mode
mode, Mouse Wheel
mouse-wheel-follow-mouse
mouse-wheel-scroll-amount
mouse-wheel-progressive-speed
スクロールに使うことができる“ホイール”があるマウスもいくつかあります。Emacsはデフォルトで、マウスホイールによるウィンドウのスクロールを、ほとんどのグラフィカルなディスプレーでサポートします。この機能を切り替えるには、`M-x
mouse-wheel-mode`を使います。変数`mouse-wheel-follow-mouse`および`mouse-wheel-scroll-amount`は、(どこでホイールによるスクロール操作が行われたかによる)スクロール対象の選択方法と、バッファーがスクロールされる量を決定します。変数`mouse-wheel-progressive-speed`は、スクロールの早さがホイールを移動した早さにリンクするかを決定します。

mouse-wheel-tilt-scroll
mouse-wheel-flip-direction
チルトホイール(横スクロール)つきのマウスの場合、Emacsは水平スクロールもサポートします。この機能はデフォルトではオフで、変数`mouse-wheel-tilt-scroll`でオンになります。水平スクロールの方向を逆転したい場合は、変数`mwheel-flip-direction`を非`nil`値にカスタマイズしてください。

単語と行にたいするマウスコマンド
--------------------------------

以下の`mouse-1`の変種は、1度に単語全体または行全体を選択します。Emacsは選択されたテキスト周辺のリージョンをアクティブにして、killリングにもコピーされます。

`Double-mouse-1`  
クリックした単語や文字周辺のテキストを選択します。

シンボルの構文をもつ文字(C modeでのアンダースコアーなど)をダブルクリックすると、シンボルを取り囲むその文字を選択します。開きカッコ(または閉じカッコ)の構文をもつ文字をダブルクリックすると、そのカッコで始まる(または終わる)グループを選択します。区切り文字の構文をもつ文字(Cのシングルクォーテーションやダブルクォーテーション)をダブルクリックすると、文字列定数を選択します(Emacsはその文字により開始するのか(または終了するのか)を、発見的な手法を使って見つけ出します)。

カッコによるグループ化、または文字列の区切り文字の先頭をダブルクリックすると、そのリージョンの最後にポイントが移動します。新たな位置を表示するために必要なら、バッファーの表示を前方にスクロールします。カッコによるグループ化、または文字列の区切り文字の終端をダブルクリックしても、デフォルトではポイントはそのリージョンの終端に留まり、リージョンの先頭がウィンドウ上端より上にある場合は表示されません。必要ならバッファーの表示を後方にスクロールすてリージョンの先頭に移動するように変更するには、ユーザーオプション`mouse-select-region-move-to-beginning`を非`nil`にセットしてください。

`Double-Drag-mouse-1`  
単語全体を単位として、ドラッグした箇所のテキストを選択します。

`Triple-mouse-1`  
クリックした行を選択します。

`Triple-Drag-mouse-1`  
行全体を単位として、ドラッグした箇所のテキストを選択します。

マウスで参照をフォローする
--------------------------

mouse-1 (on buttons)
mouse-2 (on buttons)
hyperlinks
links
text buttons
buttons
mouse-highlight
Emacsのバッファーにはボタンや、アクティブ化(例えばクリック)したとき何らかのアクション(例えば参照をフォローする)を行う、ハイパーリンクを含むものがあります。ボタンのテキストは通常、アンダーラインが引かれていたり、周囲にボックスが描かれて、視覚的にハイライトされています。ボタンの上にマウスを移動すると、マウスカーソルの形状が変化して、ボタンがライトアップされます。変数`mouse-highlight`を`nil`に変更すると、Emacsはこのハイライト機能を無効にします。

ボタンをアクティブにするには、ポイントをそこに移動してRETをタイプするか、`mouse-1`または`mouse-2`でボタンをクリックします。たとえばDiredバッファーでは、ファイル名がボタンです。これをアクティブにすることにより、Emacsはそのファイルをvisitします([Dired](#Dired)を参照してください)。`*Compilation*`バッファーでは、各エラーメッセージがボタンです。これをアクティブにすることにより、そのエラーにたいするソースコードをvisitします([Compilation](#Compilation)を参照してください)。

ボタンを`mouse-1`でクリックすると、ボタンがアクティブになりますが、マウスボタンを押してから離すまで一定時間(厳密に言うと450ミリ秒以上)が経過すると、Emacsはボタンをアクティブにせず、ポイントをクリックした場所に移動します。この方法によりボタンをアクティブにせずにポイントを移動するのに、マウスを使用できます。マウスをボタンの上にドラッグすると、通常どおりリージョンをセットして、ボタンはアクティブにしません。

ボタンにたいして`mouse-1`がどのように適用されるかは、`mouse-1-click-follows-link`をカスタマイズすることにより変更できます。変数の値が正の整数の場合、それはボタンのアクティブ化を取り消すのに、何ミリ秒マウスボタンを押しつづける必要があるかを指定します。前のパラグラフで説明したように、デフォルトは450です。値が`nil`の場合、`mouse-1`は単にクリックした場所にポイントを移動するだけで、ボタンをアクティブにしません。値が`double`の場合、シングルクリックでポイントのセット、ダブルクリックでボタンをアクティブにします。

mouse-1-click-in-non-selected-windows
選択されていないウィンドウのボタンでも通常、`mouse-1`でクリックすればボタンがアクティブになります。変数`mouse-1-click-in-non-selected-windows`を`nil`に変更した場合、選択されていないウィンドウのボタンを`mouse-1`でクリックすると、クリックした位置にポイントを移動してウィンドウを選択しますが、ボタンはアクティブになりません。

メニューにたいするマウスクリック
--------------------------------

CtrlおよびSHIFTで修飾されたマウスクリックにより、メニューが表示されるものがいくつかあります。

`C-mouse-1`  
C-mouse-1

このメニューはバッファーを選択するためのものです。

MSB(“mouse select buffer”)グローバルマイナーモードは、このメニューをスマートで、よりカスタマイズ可能なものにします。 [Buffer Menus](#Buffer-Menus)を参照してください。

`C-mouse-2`  
C-mouse-2

このメニューには、フェイスや他のテキストプロパティーをテストしたり、それらを設定するものが含まれます(後者は主にEnriched textを編集するのに便利です。[Enriched Text](#Enriched-Text)を参照してください)。

`C-mouse-3`  
C-mouse-3

このメニューは、モードに特有なメニューです。Menu-barモードがオンの場合、ほとんどのモードでは、このメニューに、そのモード特有なメニューバーのメニューと同じアイテムを表示します。このボタンに異なるメニューを指定するモードもいくつかあります。Menu-barモードがオフの場合、このメニューにはモード特有のメニューだけでなく、本来メニューバーに含まれるべきすべてのアイテムが含まれるので、メニューバーを表示せずに、それらにアクセスすることができます。

`S-mouse-1`  
このメニューはそのウィンドウのバッファーの、デフォルトのフェイスを変更するためのものです。[Text Scale](#Text-Scale)を参照してください。

グラフィカルなアプリケーションには、`mouse-3`をモード特有なメニューに使うものもいくつかあります。`mouse-3`で`mouse-save-then-kill`コマンドを実行するかわりに、Emacsにこのようなメニューを表示させるには、以下の行をinitファイルに追加して`mouse-3`をリバインドします([Init Rebinding](#Init-Rebinding)を参照してください)。

    (global-set-key [mouse-3] 'mouse-popup-menubar-stuff)

モードラインのマウスコマンド
----------------------------

mode line, mouse
mouse on mode line
ウィンドウのモードラインをマウスでクリックして、ウィンドウを選択したり操作することができます。

モードラインのいくつかの領域、たとえばバッファー名や、メジャーモードおよびマイナーモードは、独自のマウスバインディングをもっています。これらの領域にマウスを移動すると、その領域がハイライトされ、特別なバインディングが表示されます([Tooltips](#Tooltips)を参照してください)。このセクションのコマンドは、それらの領域には適用できません。

`mouse-1`  
mouse-1 (mode line)

モードラインを`mouse-1`でクリックすると、それが属するウィンドウを選択します。モードライン上で`mouse-1`でドラッグすることにより、それを移動することができるので、ウィンドウの高さを変更することができます。マウスでの高さの変更により、ウィンドウが削除されることはありません。ウィンドウの高さが定められた最小値より小さくなる場合は、拒絶されます。

`mouse-2`  
mouse-2 (mode line)

モードラインを`mouse-2`でクリックすると、そのウィンドウがフレーム全体に表示されます。

`mouse-3`  
mouse-3 (mode line)

モードラインを`mouse-3`でクリックすると、それが属するウィンドウを削除します。フレームにウィンドウが1つしかないときは、何もしません。

`C-mouse-2`  
モードラインを`C-mouse-2`でクリックすると、クリックした位置でウィンドウを左右に分割します([Split Window](#Split-Window)を参照してください)。

mouse-1 (scroll bar)
さらに、左右に並んだモードラインの間にある分割線を、`mouse-1`でクリックしてドラッグすることにより、垂直の境界線を左右に移動できます。

ウィンドウのサイズ変更は、`window-resize-pixelwise`の値に影響されることに注意してください。詳細は[Split Window](#Split-Window)を参照してください。

フレームの作成
--------------

creating frames
C-x 5
プレフィクスキー`C-x 5`は、`C-x 4`に類似しています。`C-x
4`コマンドが、選択されたフレームの別ウィンドウにバッファーを表示するのにたいして、`C-x
5`は異なるフレームを使います。可視またはアイコン化(“最小化”とも言われる。section “Visibility of Frames” in The Emacs Lisp Reference Manualを参照)されたフレームで、すでに要求されたバッファーが表示されている場合、そのフレームを手前に表示して非アイコン化(“最小化解除”)されます。それ以外の場合は、新しいフレームが現在の表示端末に作成されます。

以下の`C-x 5`コマンドは、選択するバッファーを検索したり作成する方法が異なります。

`C-x 5 2`  
C-x 5 2

make-frame-command

新しいフレームを作成します(`make-frame-command`)。

`C-x 5 b bufname RET`  
バッファーbufnameを他のフレームで選択します。これは`switch-to-buffer-other-frame`を実行します。

`C-x 5 f filename RET`  
ファイルfilenameをvisitして、そのバッファーを他のフレームで選択します。これは`find-file-other-frame`を実行します。[Visiting](#Visiting)を参照してください。

`C-x 5 d directory RET`  
ディレクトリーdirectoryにたいするDiredバッファーを、他のフレームで選択します。これは`dired-other-frame`を実行します。[Dired](#Dired)を参照してください。

`C-x 5 m`  
他のフレームでメールメッセージの作成を開始します。これは`compose-mail-other-frame`を実行します。これは`C-x
m`の異なるフレーム版です。[Sending Mail](#Sending-Mail)を参照してください。

`C-x 5 .`  
他のフレームで識別子の定義を検索します。これは`xref-find-definitions-other-frame`を実行する、`M-.`の複数フレーム版です。[Xref](#Xref)を参照してください。

`C-x 5 r filename RET`  
C-x 5 r

find-file-read-only-other-frame

ファイルfilenameを読み取り専用でvisitして、そのバッファーを他のフレームで選択します。これは`find-file-read-only-other-frame`を実行します。[Visiting](#Visiting)を参照してください。

フレームパラメーター(frame parameters)を指定することにより、新しく作成されるフレームの外見と動作を制御できます。[Frame Parameters](#Frame-Parameters)を参照してください。

フレームコマンド
----------------

以下のコマンドは、フレームを削除したり操作するために使われます:

`C-x 5 0`  
C-x 5 0

delete-frame

選択されたフレームを削除します(`delete-frame`)。1つしかフレームがないときは、エラーをシグナルします。

`C-z`  
C-z (X windows)

選択されたEmacsフレームを最小化(またはアイコン化)します(`suspend-frame`)。[Exiting](#Exiting)を参照してください。

`C-x 5 o`  
C-x 5 o

other-frame

他のフレームを選択して手前に表示します。このコマンドを繰り返すと、端末のすべてのフレームを循環することができます。

`C-x 5 1`  
C-x 5 1

delete-other-frames

現在の端末の、選択されたフレーム以外のすべてのフレームを削除します。

`M-F10`  
M-F10

toggle-frame-maximized

カレントフレームの最大化を切り替えます。フレームが最大化されているときはスクリーン全体に表示されます。

`F11`  
F11

toggle-frame-fullscreen

カレントフレームのフルスクリーンモードを切り替えます(フルスクリーンと最大化の違いは、前者がウィンドウマネージャーの装飾を隠すことで、これによりEmacs自身のスクリーンスペースが若干増えます)。

frame-resize-pixelwise
フレームを本当に最大化またはフルスクリーンにするためには、変数`frame-resize-pixelwise`を非`nil`値にカスタマイズする必要があるウィンドウマネージャーもいくつかあります。この変数を非`nil`値にセットすると、一般的にフレームのサイズ変更を行や列の整数倍ではなく、ピクセル単位で行うことができます。

`C-x 5 0` (`delete-frame`)コマンドは、選択されたフレームを削除します。しかしEmacsセッションとの対話能力が失われるのを防ぐため、Emacsセッションの最後のフレームの削除は拒絶します。Emacsがデーモンとして実行されているとき([Emacs Server](#Emacs-Server)を参照してください)は、普通の対話的なフレームがすべて削除された後も、常に仮想的なフレーム(virtual frame)が残ります。この場合、`C-x 5
0`は最後の対話的なフレームを削除できます。Emacsセッションに再接続するには、`emacsclient`を使うことができます。

`C-x 5 1` (`delete-other-frames`)コマンドは、現在の端末(端末にはグラフィカルなディスプレーとテキスト端末の両方が含まれます)の、カレントのフレーム以外のすべてのフレームを削除します。[Non-Window Terminals](#Non_002dWindow-Terminals)を参照してください)。他のグラフィカルなディスプレー、またはテキスト端末で開いたフレームをもっている場合、これらは削除されません。

focus-follows-mouse
`C-x 5 o` (`other-frame`)コマンドは、現在の端末の次のフレームを選択します。EmacsをXウィンドウシステム上のウィンドウマネージャーで使っていて、どんなフレームだろうと、マウスカーソルが上にくるとそのフレームを選択(またはフォーカスを与える)するようになっている場合、このコマンドが正常に機能するために、変数`focus-follows-mouse`を`t`に変更する必要があります。これは`C-x
5 o`を呼び出し、マウスカーソルを選択されたフレームにワープさせます。

フォント
--------

fonts
デフォルトでは、Emacsはグラフィカルなディスプレーでテキストを表示するのに、10ポイントのmonospaceフォントを使います。違うフォントを指定する異なる方法がいくつかあります:

-   ‘`Options`’メニューの‘`Set Default
    Font`’をクリックします。これは既存のグラフィカルなフレームすべてのデフォルトを、選択したフォントにします。これを将来のセッションのために保存するには、‘`Options`’メニューの‘`Save
    Options`’をクリックしてください。

-   以下のように、`font`パラメーターを指定するように、変数`default-frame-alist`を変更する行をinitファイルに追加します:

        (add-to-list 'default-frame-alist
                     '(font . "DejaVu Sans Mono-10"))

    これはこのinitファイルで再起動した後の、Emacsが作るすべてのグラフィカルなフレームのデフォルトを、指定したフォントにします。

-   X defaults file
    X resources file
    以下のようにXリソースファイルに、Xリソースセッティング‘`emacs.font`’を追加します:

        emacs.font: DejaVu Sans Mono-12

    Xリソースファイルが効果を表すには、Xを再起動するか`xrdb`コマンドを使わなければなりません。[Resources](#Resources)を参照してください。Xリソースファイルでは、フォント名をクォートしないでください。

-   EmacsをGNOMEデスクトップで実行している場合、変数`font-use-system-font`を`t`(デフォルトは`nil`)にセットして、Emacsにデフォルトのシステムフォントを使うように指示できます。これが機能するには、EmacsがGsetting(または古いGconf)のサポートつきでコンパイルされていなければなりません。

-   コマンドラインオプション‘`-fn`’(または‘`--font`’)を使います。[Font X](#Font-X)を参照してください。

現在使っているフォントをチェックするには、`C-u C-x
=`コマンドが有用です。これはポイント位置の文字の説明と、それを描画しているフォント名を表示します。

fontconfig
Xでは、フォント名を表現する異なる方法がいくつか存在します。1番目はFontconfigパターンを使う方法です。Fontconfigパターンは以下の形式をもちます:

    fontname[-fontsize][:name1=values1][:name2=values2]...

このフォーマットでは、大カッコ(brackets)の中の要素は省略可能です。fontnameは、‘`Monospace`’や‘`DejaVu
Sans
Mono`’のような、フォントのファミリー名です。fontsizeは、フォントのポイントサイズ(1プリンターポイントはおよそ1/72インチです)で、エントリー‘`name=values`’は、フォントのslantやweightなどのセッティングを指定します。valuesには1つの値か、カンマで区切られた値のリストを指定します。それらに加えていくつかのプロパティー値は、ある種のプロパティー名だけで有効なものがあり、それらについては‘`name=`’部分を省略できます。

以下は、一般的なフォントプロパティーの一覧です:

‘`slant`’  
‘`italic`’、‘`oblique`’、‘`roman`’のうちの、どれか1つです。

‘`weight`’  
‘`light`’、‘`medium`’、‘`demibold`’、‘`bold`’、‘`black`’のうちの、どれか1つです。

‘`style`’  
slantとweightを組み合わせた、特別なstyleを定義するフォントがいくつかあります。たとえば‘`Dejavu
Sans`’は、‘`book`’ styleを定義し、これはslantおよびweightプロパティーをオーバーライドします。

‘`width`’  
‘`condensed`’、‘`normal`’、‘`expanded`’のうちの、どれか1つです。

‘`spacing`’  
‘`monospace`’、‘`proportional`’、‘`dual-width`’、‘`charcell`’のうちの、どれか1つです。

以下はFontconfigパターンの例です:

    Monospace
    Monospace-12
    Monospace-12:bold
    DejaVu Sans Mono:bold:italic
    Monospace-12:weight=bold:slant=italic

Fontconfigパターンの、より詳細な説明は、Fontconfigのマニュアルを参照してください。これはFontconfigとともに配布されており、<https://fontconfig.org/fontconfig-user.html>からオンラインで利用可能です。

GTK font pattern
フォントを指定する2番目の方法は、GTKフォントパターンを使う方法です。これらは以下の構文を使います。

    fontname [properties] [fontsize]

fontnameはファミリー名、propertiesはスペースで区切られたプロパティー値のリストで、fontsizeはポイントサイズです。GTKフォントパターンで指定するプロパティーは以下のようなものでしょう:

-   Slantプロパティー: ‘`Italic`’、‘`Oblique`’。省略したときはデフォルトのslant(roman)が暗に指定されます。

-   Weightプロパティー: ‘`Bold`’、‘`Book`’、‘`Light`’、‘`Medium`’、‘`Semi-bold`’、‘`Ultra-light`’。省略したときは‘`Medium`’ weightが暗に指定されます。

-   Widthプロパティー: ‘`Semi-Condensed`’、‘`Condensed`’。省略したときはデフォルトのwidthが使用されます。

以下にGTKフォントパターンの例をいくつか示します:

    Monospace 12
    Monospace Bold Italic 12

XLFD
X Logical Font Description
フォントを指定する3番目の方法は、XLFD(X Logical Font Description)を使う方法です。これはXでフォントを指定する際の伝統的な手法です。以下のように、各XLFDは14の単語か数字をダッシュで区切ったものからなります:

    -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1

XLFDでのワイルドカード文字(‘`*`’)は、任意の文字の並び(noneを含む)にマッチし、‘`?`’は任意の1文字にマッチします。しかしマッチングは実装依存で、長い名前の中のダッシュにたいするワイルドカードのマッチが不正確なことがあります。信頼できる結果を得るためには、14個すべてのダッシュを指定して、ワイルドカードを1つのフィールドだけに使います。XLFDでは大文字小文字の違いは重要ではありません。XLFDの構文は以下のとおりです:

    -maker-family-weight-slant-widthtype-style…
    …-pixels-height-horiz-vert-spacing-width-registry-encoding

エントリーは以下の意味をもちます:

maker  
フォントのmanufacturer(製造者名)です。

family  
フォントのファミリー名です(たとえば‘`courier`’)。

weight  
フォントのweightで、通常は‘`bold`’、‘`medium`’、‘`light`’のどれかです。他の値をサポートするフォント名もいくつかあります。

slant  
フォントのslantで、通常は‘`r`’(roman)、‘`i`’(italic)、‘`o`’(oblique)、‘`ri`’(reverse italic)、‘`ot`’(other)のどれかです。他の値をサポートするフォント名もいくつかあります。

widthtype  
フォントのwidthで、通常は‘`normal`’、‘`condensed`’、‘`semicondensed`’、‘`extended`’のどれかです。他の値をサポートするフォント名もいくつかあります。

style  
オプションの追加のstyle名です。通常これは空で、ほとんどのXLFDでは、この位置に2つのハイフンを続けて指定します。style名には、‘`ja`’や‘`ko`’のような、ISO-639 language nameの2文字を指定することもできます。CJKスクリプトをサポートするいくつかのフォントは、style名の部分にこの記述をもちます。

pixels  
フォントのheightをピクセルで指定します。

height  
プリンターのポイントの1/10を単位とした、スクリーン上のフォントのheightです。フォントのポイントサイズの10倍です。垂直解像度(vertical resolution)を与えれば、heightとpixelsは比例します。したがって一方を指定して、もう一方に‘`*`’を指定するのが一般的です。

horiz  
フォントが意図するインチあたりのピクセル数で表した、水平解像度(horizontal resolution)です。

vert  
フォントが意図するインチあたりのピクセル数で表した、垂直解像度(vertical resolution)です。通常、システムのフォント解像度は、スクリーンにたいして正しい値になっています。したがって、これとhorizには‘`*`’を指定するのが普通です。

spacing  
これには‘`m`’(monospace)、‘`p`’(proportional)、‘`c`’(character cell)を指定します。

width  
ピクセル単位で表した文字の平均widthの10倍です。

registry; encoding  
フォントを描画するXフォント文字セット(X font character set)です(Xフォント文字セットはEmacs文字セットと同じではありませんが、似ています)。フォントの選択をチェックするのに、`xfontsel`コマンドを使うことができます。通常は、registryに‘`iso8859`’、encodingに‘`1`’を使うべきです。

フォントを指定する4番目の方法は、フォントニックネーム(font nickname)を使う方法です。特定のフォントは通常のフォント指定のかわりに、短いニックネームをもつものがあります。たとえば‘`6x13`’は以下と同じです

    -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1

client-side fonts
server-side fonts
X上でのEmacsは、2つのタイプのフォントを認識します。1つはクライアントサイドのフォントで、これはXftおよびFontconfigライブラリーにより提供されます。もう1つはサーバーサイドのフォントで、これはXサーバー自身により提供されます。ほとんどのクライアントサイドフォントは、アンチエイリアシング(antialiasing)やサブピクセルンティング(subpixel hinting)などの、サーバーサイドフォントにはない、進んだフォント機能をサポートします。FontconfigとGTKパターンは、クライアントサイドフォントだけにマッチします。

listing system fonts
すべての文字が同じ幅をもつ固定幅フォントを使いたいと思うでしょう。XftおよびFontconfigフォントでは、`fc-list`コマンドを使って、以下のようにして利用可能な固定幅フォントを一覧することができます。

    fc-list :spacing=mono
    fc-list :spacing=charcell

サーバーサイドのXフォントにたいしては、`xlsfonts`プログラムを使って、以下のようにして利用可能な固定幅フォントを一覧することができます。

    xlsfonts -fn '*x*' | grep -E '^[0-9]+x[0-9]+'
    xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-m*'
    xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-c*'

XLFDのspacingフィールドが、‘`m`’または‘`c`’のフォントは固定幅フォントです。特定のフォントの外見を見るには、以下のように`xfd`コマンドを使います:

    xfd -fn 6x13

これはフォント‘`6x13`’の全体を表示します。

Emacsを実行しているときは、特定の種類のテキスト([Faces](#Faces)を参照してください)や、特定のフレーム([Frame Parameters](#Frame-Parameters)を参照してください)のフォントをセットすることもできます。

スピードバーフレーム
--------------------

speedbar
attached frame (of speedbar)
スピードバー(speedbar)は、簡単に他のフレームを操作したり処理するための、特別なフレームです。スピードバーが存在するとき、それは常にアタッチされたフレーム(attached frame)と呼ばれる、特定のフレームに対応しています。すべてのスピードバー操作は、そのフレームにたいして処理されます。

`M-x
speedbar`とタイプすると、スピードバーを作成して、カレントフレームに関連付けます。スピードバーを解除するには、再度`M-x
speedbar`とタイプするか、スピードバーを選択して`q`とタイプします(他のEmacsフレームを削除するのと同じ方法で、スピードバーフレームを削除することもできます)。スピードバーを他のフレームに関連付けたいときは、一旦解除してから、そのフレームで`M-x
speedbar`を呼び出します。

スピードバーは、さまざまなモードを処理できます。デフォルトモードはFile Display(ファイル表示)モードで、これはアタッチされたフレームの、選択されたウィンドウのカレントディレクトリーのファイルを、1行に1ファイルずつ表示します。ディレクトリー以外をクリックすると、アタッチされたフレームの、選択されたウィンドウでそのファイルをvisitし、ディレクトリーをクリックすると、スピードバーでそのディレクトリーを表示します([Mouse References](#Mouse-References)を参照してください)。各行には‘`[+]`’や‘`<+>`’が記されたボックスがあり、それをクリックすると、そのアイテムの内容を展開します。ディレクトリーを展開すると、ディレクトリーの内容を、ディレクトリー自身の行の下に加えてスピードバー表示します。通常のファイルを展開すると、ファイルの中のtagリストをスピードバー表示に加えます。tag名をクリックして、アタッチされたフレームの選択されたウィンドウで、tagにジャンプできます。ファイルまたはディレクトリーが展開されているときは、‘`[+]`’が‘`[-]`’に変化します。ボックスを再度クリックすると、アイテムを収納して、内容を隠すことができます。

キーボードを使ってスピードバーを操作することもできます。スピードバーでポイントのある行でRETをタイプするのは、そのアイテムをクリックするのと等しく、SPCはアイテムを展開または収納します。`U`は、カレントディレクトリーの親ディレクトリーを表示します。カレント行のファイルをコピー、削除、リネーム&lt;するには、`C`、`D`、`R`をタイプします。新しいディレクトリーを作成するには、`M`をタイプします。

スピードバーのモードで、他に一般的な目的に使われるのはBuffer Display(バッファー表示)モードです。このモードでは、スピードバーはEmacsバッファーのリストを表示します。このモードに切り替えるにはスピードバーで`b`をタイプします。File Displayモードに戻るには、`f`をタイプします。スピードバーのウィンドウのどこかを`mouse-3`でクリック(またはモードラインを`mouse-1`でクリック)して、ポップアップメニューの‘`Displays`’を選択しても、表示モードを変更することができます。

Rmailモード、Info、GUDを含むいくつかのメジャーモードは、スピードバーに選択可能な便利なアイテムを配する、特別な方法をもっています。たとえばRmailモードでは、スピードバーはRmailファイルのリストを表示し、カレントメッセージを他のRmailファイルに移動する場合は、それの‘`<M>`’ボックスをクリックします。

スピードバーの使い方とプログラミングに関する詳細は、section “Speedbar” in Speedbar Manualを参照してください。

複数ディスプレー
----------------

multiple displays
1つのEmacsが、1つ以上のXディスプレーと通信できます。最初、Emacsは環境変数DISPLAY、または‘`--display`’オプション([Initial Options](#Initial-Options)を参照してください)で指定された、ただ1つのディスプレーに表示されます。他のディスプレーに接続するには、コマンド`make-frame-on-display`を使います:

make-frame-on-display
`M-x make-frame-on-display RET display RET`  
ディスプレーdisplayに新しいフレームを作成します。

1つのXサーバーは、1つ以上のスクリーンを処理できます。1つのサーバーに属する2つのスクリーンでフレームを開いた場合、Emacsはそれらが1つのキーボードを共有するのを知っているので、これらのスクリーンから到着するすべてのコマンドを1つの入力ストリームとして扱います。

異なるXサーバーでフレームを開いた場合、Emacsは各サーバーごとに別な入力ストリームを作成します。各サーバーは、それぞれ選択されたフレームをもちます。特定のXサーバーで入力したコマンドは、そのサーバーの選択されたフレームに適用されます。

フレームパラメーター
--------------------

default-frame-alist
変数`default-frame-alist`の中の、フレームパラメーター(frame parameters)のデフォルトリストを指定することにより、すべてのフレームのデフォルトの外見と振る舞いを制御することができます。この値はエントリーのリストで、各エントリーにはパラメーター名と、そのパラメーターの値を指定します。これらのエントリーはEmacsが新しいフレームを作るとき(初期フレームを含む)に効果を及ぼします。

frame size, specifying default
たとえば以下のファイルをinitファイル([Init File](#Init-File)を参照してください)に追加することにより、デフォルトのフレーム幅が90列、デフォルトのフレーム高さが40行、デフォルトフォントに‘`Monospace-10`’を指定します。

    (add-to-list 'default-frame-alist '(width  . 90))
    (add-to-list 'default-frame-alist '(height . 40))
    (add-to-list 'default-frame-alist '(font . "Monospace-10"))

フレームパラメーターのリストと、その効果については、section “Frame Parameters” in The Emacs Lisp Reference Manualを参照してください.

initial-frame-alist
変数`initial-frame-alist`をカスタマイズすることにより、初期フレームだけに適用されるフレームパラメーターのリストを指定することもできます。

EmacsがX ツールキットを使ってコンパイルされている場合、カラーとフォントを指定するフレームパラメーターは、メニューとメニューバーには影響を及ぼしません。なぜなら、それらはEmacsが直接描画しているのではなく、ツールキットにより描画されているからです。

フレームの外観と振る舞いも、Xリソースを通じてカスタマイズできます([X Resources](#X-Resources)を参照)。これらはinitファイル内で指定された初期フレームのパラメーターをオーバーライドします。

セッションの保存とリストアのためにdesktopライブラリーを使用している場合は、desktopファイルに記録されたフレームが、これらのパラメーターとともにリストアされることに注意してください。これらのフレームがリストアされるときは、initファイル内で`default-frame-alist`および`initial-frame-alist`で指定されているフレームパラメーターよりも、記録されたパラメーターが優先されます。これを避ける方法については、[Saving Emacs Sessions](#Saving-Emacs-Sessions)を参照してください。

スクロールバー
--------------

Scroll Bar mode
mode, Scroll Bar
Vertical Scroll Bar
グラフィカルなディスプレーでは、Emacsウィンドの横に垂直スクロールバー(vertical scroll bar)があります。スクロールバーのupボタンまたはdownボタンを`mouse-1`でクリックすると、ウィンドウを1行ずつスクロールします(しかし、これらのボタンがないようにスクロールバーをカスタマイズできるツールキットもある)。スクロールバー内部のボックスの上または下を`mouse-1`でクリックすると、`M-v`または`C-v`と同様に、ほぼウィンドウ全体の高さ分スクロールします([Moving Point](#Moving-Point)を参照) (これも、いくつかのツールキットでは動作が異なるかもしれない)。スクロールバー内部のボックスをドラッグすると、連続してスクロールします。

EmacsがXウィンドウシステム上でXツールキットサポートなしでコンパイルされている場合、スクロールバーは違った振る舞いをします。スクロールバーの任意の箇所を`mouse-1`でクリックすると`C-v`のように前方にスクロールし、`mouse-3`でクリックすると`M-v`のように後方にスクロールします。スクロールバーで`mouse-2`をクリックすると、スクロールバー内部のボックスを上下にドラッグできます。

scroll-bar-mode
toggle-scroll-bar
垂直スクロールバーの使用を切り替えるには、`M-x
scroll-bar-mode`とタイプします。このコマンドは、まだ作成されていないフレームも含めて、すべてのフレームに適用されます。選択されたフレームの垂直スクロールバーだけ切り替えたい場合は、コマンド`M-x
toggle-scroll-bar`を使用してください。

scroll-bar-mode
起動時に垂直スクロールバーの使用を制御するには、変数`scroll-bar-mode`をカスタマイズします。この変数の値は、`right`(ウィンドウの右にスクロールバーを配します)、`left`(ウィンドウの左にスクロールバーを配します)、`nil`(垂直スクロールバーを無効にします)のどれかです。EmacsがXウィンドウシステム上でGTK+サポートつきでコンパイルされている、またはMS-Windows、macOSの場合、デフォルトでは右にスクロールバーを配します。EmacsがXウィンドウシステム上でGTK+サポートなしでコンパイルされている場合、(古いXアプリケーションの慣例にしたがって)スクロールバーを左に配します。

scroll-bar-width
width of the vertical scroll bar
Xリソース‘`verticalScrollBars`’を使って、スクロールバーの有効または無効にすることができます([Resources](#Resources)を参照してください)。スクロールバーの幅を制御するにはフレームパラメーター`scroll-bar-width`を変更してください(section “Frame Parameters” in The Emacs Lisp Reference Manualを参照してください)。

scroll-bar-adjust-thumb-portion
overscrolling
(GTK+またはMotifとともに)X上でEmacsを使っている場合、変数`scroll-bar-adjust-thumb-portion`をカスタマイズして、スクロールバーのオーバースクロール(overscrolling: たとえばバッファーの最後が表示されていてもさらに下にスクロールします)を制御できます。変数の値が非`nil`の場合、バッファーの最後が表示されていてもスクロールバーを下にドラッグできます。`nil`の場合、バッファーの最後が表示されたとき、内部のボックスはスクロールバーの最下になります。バッファー全体が表示されているときは、オーバースクロールできません。

scroll-bar
face
スクロールバーの視覚的な外見は、`scroll-bar`フェイスにより制御されます。

vertical border
グラフィカルなフレームでは、垂直スクロールバーは暗に横並びのウィンドウを区別する役目を担っています。垂直スクロールバーが無効なとき、Emacsはデフォルトでは幅1ピクセルの垂直ボーダー(vertical border)によりそのようなウィンドウを区別します。このボーダーは右側のウィンドウの最初の1ピクセルの列を占め、したがってそこに表示されていたグリフの左端ピクセルの上に上書きされることになるでしょう。これらのピクセルに重要な情報が含まれる場合は、window dividerを有効にしてそれらを可視にできます([Window Dividers](#Window-Dividers)を参照)。垂直ボーダーの見栄えを複製するには、フレームの`right-divider-width`パラメーターを1にセットして、`window-divider`フェイスを`vertical-border`のフェイスから継承してください(section “Window Dividers” in The Emacs Lisp Reference Manualを参照)。

Horizontal Scroll Bar
Horizontal Scroll Bar mode
ツールキットサポート付きのグラフィカルなディスプレーでは、Emacsは各ウィンドウの最下に水平スクロールバー(horizontal scroll bar)も提供します。スクロールバーのleftボタンまたはrightボタンを`mouse-1`でクリックすると、ウィンドウを1列ずつ水平にスクロールします(これらのボタンを表示しないようスクロールバーをカスタマイズできるツールキットがあることに注意)。スクロールバーの内部ボックスの左または右下を`mouse-1`でクリックすると、ウィンドウは4列スクロールします。スクロールバー内部のボックスをドラッグすると、連続してスクロールします。

このような水平スクロールにより、そのウィンドウのポイント位置が、右側または左側の見えない場所になるかもしれないことに注意してください。文字をタイプしてテキストを挿入したり、キーボードコマンドでポイントを移動することにより通常、ポイントは視界に戻るでしょう。

horizontal-scroll-bar-mode
水平スクロールバーの使用を切り替えるには、`M-x
horizontal-scroll-bar-mode`とタイプします。このコマンドは、まだ作成されていないフレームも含めて、すべてのフレームに適用されます。選択されたフレームの水平スクロールバーだけ切り替えたい場合は、コマンド`M-x
toggle-horizontal-scroll-bar`を使用してください。

horizontal-scroll-bar-mode
起動時に水平スクロールバーの使用を制御するには、変数`horizontal-scroll-bar-mode`をカスタマイズしてください。

scroll-bar-height
height of the horizontal scroll bar
Xリソース‘`horizontalScrollBars`’を使って、水平スクロールバーを有効または無効にすることができます([Resources](#Resources)を参照してください)。スクロールバーの高さを制御するには、フレームパラメーター`scroll-bar-height`を変更してください(section “Frame Parameters” in The Emacs Lisp Reference Manualを参照してください)。

ウィンドウdivider
-----------------

Window Divider mode
mode, Window Divider
グラフィカルなディスプレーでは、ウィンドウの外観を分割するために、window dividersを使用することができます。window dividersはマウスでドラッグできるバーなので、隣接したウィンドウを簡単にリサイズできます。

window-divider-mode
window dividersの表示を切り替えるには、コマンド`M-x window-divider-mode`を使用します。

window-divider-default-places
dividersをどこに表示するかカスタマイズするには、オプション`window-divider-default-places`を使用します。変数の値には`bottom-only` (dividersをウィンドウの下だけに表示します)、`right-only` (dividersをウィンドウの右だけに表示します)、または`t` (下と右の両方に表示します)を指定します。

window-divider-default-bottom-width
window-divider-default-right-width
このモードにより表示されるwindow dividersの幅を調整するには、オプション`window-divider-default-bottom-width`および`window-divider-default-right-width`をカスタマイズします。

ウィンドウの列の最初の1ピクセル(window dividerが無効な場合は横並びのウィンドウを区別する垂直ボーダーに使用されます)を可視とするwindow dividerは、垂直スクロールバーが無効のときにも有用です([Scroll Bars](#Scroll-Bars)を参照)。

window dividersについての詳細は、section “Window Dividers” in The Emacs Lisp Reference Manualを参照してください。

ドラッグアンドドロップ
----------------------

drag and drop
ほとんどのグラフィカルなデスクトップ環境で、Emacsはドラッグアンドドロップ(drag and drop)操作にたいする、基本的なサポートを提供します。たとえばEmacsのフレームにテキストをドロップすると、ドロップされた箇所にテキストを挿入し、ファイルをドロップすると、Emacsフレームはそのファイルをvisitします。特別なケースとしては、Diredバッファーにファイルをドロップすることにより、バッファーに表示されているディレクトリーにファイルを移動またはコピーします(アプリケーションの慣例に基づきます)。

dnd-open-file-other-window
ファイルをドロップすると、通常はドロップされたウィンドウでファイルをvisitします。そのような場合に、新しいウィンドウでファイルをvisitしたいときは、変数`dnd-open-file-other-window`をカスタマイズします。

現在のところ、XDNDおよびMotif drag and drop protocolsと、古いKDE 1.x protocolがサポートされています。

mouse-drag-and-drop-region
Emacsはオプションで、テキストのリージョンを他のバッファーの他の部分へドラッグする操作もサポートします。これを有効にするには、変数`mouse-drag-and-drop-region`を非`nil`値にカスタマイズしてください。通常そのテキストは、ドロップ先が元のリージョンと同じなら移動(カットアンドペースト)され、他のバッファーならそのリージョンがコピーされます。この変数の値が‘`shift`’、‘`control`’、‘`alt`’のような修飾キー名の場合、その修飾キーを押しながらテキストをドロップすると、ドロップ先がドラッグ元と同じバッファーでも、テキストはカットされずにコピーされます。

mouse-drag-and-drop-region-cut-when-buffers-differ
mouse-drag-and-drop-region-show-tooltip
mouse-drag-and-drop-region-show-cursor
ドラッグ元とドロップ先が異なるバッファーのときにもテキストをカットするためには、オプション`mouse-drag-and-drop-region-cut-when-buffers-differ`を非`nil`値にセットします。デフォルトでは、グラフィカルなディスプレイの選択されたテキストはツールチップ内に表示され、ドラッグ中にはマウスカーソルとともにポイントが移動します。このような動作を抑止するには、オプション`mouse-drag-and-drop-region-show-tooltip`、および/または`mouse-drag-and-drop-region-show-cursor`に`nil`をセットしてください。

メニューバー
------------

Menu Bar mode
mode, Menu Bar
menu-bar-mode
menu-bar-mode
`M-x
menu-bar-mode`で、メニューバーの使用を切り替えることができます。引数を指定しないと、このコマンドはグローバルマイナーモードのMenu Barを切り替えます。引数を指定した場合、引数が正ならMenu Barモードをオンにして、負ならオフにします。起動時にメニューバーの使用を制御するには、変数`menu-bar-mode`をカスタマイズしてください。

C-mouse-3 (when menu bar is disabled)
熟練したユーザーは、テキストのために更なる行を得るために、メニューをオフにしている場合がしばしばあります(特にテキスト端末時)。メニューバーがオフでも、ポップアップメニューをサポートするディスプレーなら、`C-mouse-3`でメニュー内容を含むポップアップメニューを表示できます。[Menu Mouse Clicks](#Menu-Mouse-Clicks)を参照してください。

メニューバーのコマンドを呼び出す方法については、[Menu Bar](#Menu-Bar)を参照してください。メニューバーのメニューの視覚的な外見をカスタマイズする方法は、[X Resources](#X-Resources)を参照してください。

ツールバー
----------

Tool Bar mode
mode, Tool Bar
icons, toolbar
グラフィカルなディスプレーでは、Emacsはフレームのトップ、メニューバーの直下にツールバー(tool bar)を配します。これはマウスでクリックすることにより、さまざまなコマンドを呼び出すことができるアイコンが1列に並んだものです。

(デフォルトの)グローバルツールバーは、一般的なコマンドを含みます。自身のツールバーを定義するメジャーモードもいくつか存在します。バッファーがそれらのメジャーモードの場合、モードのツールバーにより、グローバルツールバーが置き換えられます。

tool-bar-mode
tool-bar-mode
ツールバーの使用を切り替えるには、`M-x
tool-bar-mode`とタイプします。このコマンドは、まだ作成されていないフレームを含むすべてのフレームに適用されます。起動時にツールバーの使用を制御するには、変数`tool-bar-mode`をカスタマイズします。

tool-bar-style
Tool Bar style
EmacsがGTK+サポートつきでコンパイルされている場合、ツールバーアイテムには、イメージ、テキストラベル、またはそれら両方を含むことができます。デフォルトではEmacsはGnomeデスクトップの、ツールバースタイルセッティングにしたがいます。もし何も定義されていない場合、ツールバーのアイテムにはイメージだけが表示されます。特定のツールバースタイルを強要するには、変数`tool-bar-style`をカスタマイズしてください。

Tool Bar position
フレームパラメーター`tool-bar-position`で、GTK+ツールバーのためのツールバーの配置を制御することもできます。section “Frame Parameters” in The Emacs Lisp Reference Manualを参照してください。

NSビルドはツールバーをウィンドウ装飾と判断するため、ウィンドウが装飾されていないときはツールバーを表示しません。section “Frame Parameters” in The Emacs Lisp Reference Manualを参照してください。macOSでは、フレームがフルスクリーンのときツールバーは表示されませんが、スクリーン上端にマウスポインターを移動することにより表示することができます。

ダイアログボックスの使用
------------------------

dialog boxes
use-dialog-box
ダイアログボックスとは、yes-or-noの質問(はい／いいえで応える問いかけ)をしたり、他の何か特別な質問を問いかけるための、特別な種類のメニューです。コマンドを呼び出すためにマウスを使い、それがユーザーへの質問を要するような操作の場合、多くのEmacsコマンドはyes-or-noを問うために、ダイアログボックスを使います。

ダイアログボックスの使用を無効にするには、変数`use-dialog-box`を`nil`に変更します。この場合、Emacsはエコーエリアとキーボード入力を使ってyes-or-noプロンプトを処理します。この変数はファイル選択ウィンドウの使用も制御します(しかしこれらはすべてのプラットフォームでサポートされているわけではありません)。

use-file-dialog
file selection dialog, how to disable
ファイル選択ウィンドウはファイル名を問うための、特別な種類のダイアログボックスです。変数`use-file-dialog`をカスタマイズすれば、他の種類のダイアログボックスを使用して、ファイル選択ウィンドウを使用しないようにできます。変数`use-dialog-box`ですべてのダイアログボックスを使用しないようにしている場合、この変数は効果がありません。

x-gtk-show-hidden-files
x-gtk-file-dialog-help-text
hidden files, in GTK+ file chooser
help text, in GTK+ file chooser
EmacsがGTK+サポートつきでコンパイルされている場合、EmacsはGTK+のファイル選択ダイアログを使います。Emacsは非表示のファイル(名前がドットで始まるファイル)の表示の有効・無効を切り替えるボタンを、ダイアログボックスに追加します。この切り替えをデフォルトで有効にしたい場合、変数`x-gtk-show-hidden-files`を`t`に変更します。さらにEmacsは、GTK+ファイル選択ダイアログにヘルプテキストを追加します。このヘルプテキストを無効にするには、変数`x-gtk-file-dialog-help-text`を`nil`に変更してください。

ツールチップ
------------

tooltips
ツールチップは、小さい特別なフレームに、マウスのカレント位置に関するテキスト情報を表示します。ツールチップはウィンドウの重要なテキストの上や、ツールバーのボタンやメニューアイテムのような、Emacsフレームの他の部分の上でマウスを停止させたときにアクティブになります。

tooltip-mode
ツールチップの使用は、コマンド`M-x
tooltip-mode`で切り替えることができます。Tooltipモードが無効な場合、ヘルプテキストは、かわりにエコーエリアに表示されます。ツールチップの使用を起動時に制御するには、変数`tooltip-mode`をカスタマイズしてください。

以下の変数はツールチップ表示にたいするカスタマイズオプションを提供します:

tooltip-delay`tooltip-delay`  
この変数は、最初のツールチップを表示する前に、Emacsがwaitする長さを指定します。値は秒です。

tooltip-short-delay`tooltip-short-delay`  
この変数は、すでに最初のツールチップが表示されているとき、異なるアイテムにたいする後続のツールチップを表示する前に、Emacsがwaitする長さを指定します。値は秒です。

tooltip-hide-delay`tooltip-hide-delay`  
マウスが静止しているとき、ツールチップを隠すまでの秒数です。

tooltip-x-offset`tooltip-x-offset`; tooltip-y-offset`tooltip-y-offset`  
マウスポインター位置から、ツールチップの左上隅までのXオフセットとYオフセットを、ピクセルで指定します。`tooltip-frame-parameters`が、`left`および`top`パラメーターをインクルードするためにカスタマイズされている場合、これらは無視されることに注意してください。オフセットには、ツールチップがマウスのクリックと干渉するような、マウスポインターのホットスポットを覆い隠さない値を指定するべきです。

tooltip-frame-parameters`tooltip-frame-parameters`  
ツールチップの表示のために、フレームパラメーターが使用されます。section “Frame Parameters” in The Emacs Lisp Reference Manual、およびsection “Tooltips” in The Emacs Lisp Reference Manualを参照してください。

ツールチップの表示にたいする追加のカスタマイズオプションについては、`M-x customize-group RET tooltip
RET`を使用してください。

x-gtk-use-system-tooltips
EmacsがGTK+サポートつきでビルドされている場合、ツールチップはGTK+を通じて、GTK+のツールチップのデフォルトの外見を使います。これを無効にするには、変数`x-gtk-use-system-tooltips`を`nil`に変更します。これを行うか、EmacsがGTK+サポートなしでビルドされた場合は、ツールチップテキストのほとんどの属性は`tooltip`フェイスとXリソース([X Resources](#X-Resources)を参照してください)により指定されます。

GUDツールチップは、プログラムをGUDでデバッグしているときに変数の値を表示する、特別なツールチップです。[Debugger Operation](#Debugger-Operation)を参照してください。

マウスの回避
------------

avoiding mouse in the way of your typing
mouse avoidance
グラフィカルな端末では、マウスポインターがEmacsフレームのテキストを隠してしまうことがありえます。この問題を避けるために、Emacsは2つの方法を提供します。

1番目の方法は、ユーザーが自己挿入文字をタイプしたとき、Emacsがマウスポインターを非表示にして、マウスポインターを動かしたときに、ポインターがEmacsフレームの内側にあるときは、再びポインターを表示する方法です。この機能を無効にするには、変数`make-pointer-invisible`を`nil`にセットしてください。[Display Custom](#Display-Custom)を参照してください。

mouse-avoidance-mode
2番目の方法はMouse Avoidance(マウス回避)モードを使って、マウスポインターをポイントから遠ざける方法です。Mouse Avoidanceモードを使うには、変数`mouse-avoidance-mode`をカスタマイズします。この変数にさまざまな値をセットすることにより、マウスを遠ざけるいくつかの方法を選択できます。

`banish`  
キーが押されたらポインターをフレームの隅に移動します。ポインターをどこに遠ざけるかは、変数`mouse-avoidance-banish-position`でカスタマイズできます。

`exile`  
カーソルがポインターに近づきすぎたときだけポインターを遠ざけて、カーソルが離れたらポインターを元に戻します。

`jump`  
カーソルがポインターに近づきすぎたら、ランダムな方向と距離にポインターを移動します。

`animate`  
`jump`と同様ですが、移動モーションをアニメ化します。

`cat-and-mouse`  
`animate`と同じです。

`proteus`  
`animate`と同様ですが、マウスポインターの外見も変更します。

mouse-avoidance-mode
コマンド`M-x mouse-avoidance-mode`を使って、このモードを有効にすることもできます。Mouse Avoidanceモードがマウスを移動したときは、常にそのフレームを前に表示します。

非ウィンドウ端末
----------------

text terminal
テキスト端末では、Emacsは1度に1つのEmacsフレームしか表示できません。それでも複数のEmacsフレームを作成して、それらを切り替えることができます。これらの端末でフレームを切り替えるのは、異なるウィンドウの設定を切り替えるのによく似ています。

`C-x 5 2`を使うと新しいフレームを作成してそれに切り替えます。`C-x 5
o`を使うと既存のフレームを巡回します。`C-x 5 0`を使うと、カレントフレームを削除します。

各フレームには区別するための番号があります。端末が1度に1つのフレームしか表示できない場合、選択されたフレームの番号nが、モードラインの先頭に近い位置に、‘`Fn`’という形式で表示されます。

set-frame-name
select-frame-by-name
‘`Fn`’は、フレームの実際の初期名称です。フレームにもっと意味のある名前を与えて、その名前でフレームを選択できます。コマンド`M-x
set-frame-name RET name
RET`を使うと、選択されたフレームに新しい名前を指定し、`M-x select-frame-by-name RET
name
RET`を使うとその名前に一致するフレームを選択します。指定した名前は、そのフレームが選択されたときに、モードラインに表示されます。

テキスト端末でのマウスの使用
----------------------------

mouse support
terminal emulators, mouse support
端末ウィンドウでのマウスクリックをサポートするテキスト端末がいくつかあります。

xterm
`xterm`と互換性のある端末エミュレーターでは、`M-x
xterm-mouse-mode`を使って、Emacsに簡単なマウスの使用 — 基本的には修飾なしのシングルクリックだけがサポートされます — を制御させることができます。より新しいバージョンの`xterm`は、マウストラッキングもサポートします。そのようなクリックにたいする通常の`xterm`のマウス機能は、マウスボタンを押すときにSHIFTキーを押すことにより、利用できます。Xterm Mouseモードはグローバルマイナーモードです([Minor Modes](#Minor-Modes)を参照してください)。コマンドを繰り返すと、このモードを再びオフにします。

gpm-mouse-mode
GNU/Linuxのコンソールでは、`M-x
gpm-mouse-mode`を使ってマウスサポートを有効にできます。これが機能するためにはgpmサーバーがインストールされていて、システムで実行されていなければなりません。このモードが有効な場合、EmacsとGPMを使用する他のプログラムとの間で、マウスによるテキスト転送ができないことに注意してください。これはGPMとLinux kernelによる制限です。

MS-DOSでのマウスサポートに関する情報は、[MS-DOS Mouse](#MS_002dDOS-Mouse)を参照してください 。

国際化文字セットのサポート
==========================

international scripts
multibyte characters
encoding of characters
Han
Hindi
Hangul
Emacsは、広範囲な国際化文字セット(international character sets)をサポートします。それらには、ラテンアルファベットの変種であるEuropeanとVietnamese、同様にArabic scripts、(Bengali、Hindi、Thaiのような言語にたいする)Brahmic scripts 、Cyrillic、Ethiopic、Georgian、Greek、(ChineseとJapaneseにたいする)Han、(Koreanにたいする)Hangul、Hebrew、IPAが含まれます。Emacsは他の国際化されたソフトウェアー(ワープロやメーラー)などで使われる、それらの文字にたいするさまざまなエンコーディングもサポートします。

Emacsは関連するアクティビティーのすべてをサポートすることにより、国際化文字セットの編集を可能にします:

-   非ASCII文字のファイルをvisitしたり、非ASCIIのテキストを保存したり、非ASCIIのテキストを、EmacsとEmacsが呼び出すプログラム(コンパイラー、スペルチェッカー、メーラーなど)に引き渡すことができます。言語環境のセッティングとは、コーディングシステムのセッティングと、その他の言語に特有な文化のためのオプションを処理することです。かわりに各コマンドにエンコードあるいはデコードする方法を指定できます。[Text Coding](#Text-Coding)を参照してください.

-   さまざまなスクリプトでエンコードされた、非ASCII文字を表示することができます。これはグラフィカルなディスプレー上で適切なフォントを使うこと([Defining Fontsets](#Defining-Fontsets)を参照してください)、そしてテキスト表示のために特別なコードを送信すること([Terminal Coding](#Terminal-Coding)を参照してください)により機能します。正しく表示できない文字があるときは、[Undisplayable Characters](#Undisplayable-Characters)を参照してください。これには考えられる原因と、解決方法が記述されています。

-   本来、右から左に記述されるスクリプトの文字は、表示のために再配置されます([Bidirectional Editing](#Bidirectional-Editing)を参照)。これらのスクリプトにはArabic、Hebrew、Syriac、Thaana、それ以外にもいくつか存在します。

-   非ASCII文字を挿入したり検索することができます。これを行うために、言語にあったインプットメソッド(IM: input method。[Select Input Method](#Select-Input-Method)を参照してください)を指定するか、言語環境を選択したときにセットアップされた、デフォルトのインプットメソッドを使うことができます。キーボードが非ASCII文字を生成できる場合、適切なキーボードコーディングシステムを選択できます。Emacsはそれらの文字を受け入れることができるでしょう。Latin-1文字は、`C-x
    8`プレフィクスを使って入力することもできます。[Unibyte Mode](#Unibyte-Mode)を参照してください.

    Xウィンドウシステムでは、Emacsがキーボード入力を正しく解釈するために、localeに適切な値をセットする必要があります。[locales](#Language-Environments)を参照してください。

このチャプターの残りの部分では、これらの問題について詳細を説明します。

国際化文字セットのイントロダクション
------------------------------------

国際化文字セットとスクリプトのユーザーは、ファイルを保存するために、多少の差はありますが、標準化された多くのコーディングシステムを確立しています。これらのコーディングシステムは通常はマルチバイト(multibyte)で、これは1つの非ASCII文字を表すのに、2つ以上のバイトシーケンスを対応させることを意味します。

Unicode
Emacsは、内部的にはUnicode標準のスーパーセットである、マルチバイト文字エンコーディングを使用します。この内部的なエンコーディングは、ほとんどすべての既知のスクリプトを、1つのバッファーまたは文字列に混成することを可能にします。Emacsはファイルを読み書きしたり、サブプロセスとデータをやりとりするとき、このマルチバイト文字エンコーディングと、他のさまざまなコーディングシステムをコード変換します。

C-h h
view-hello-file
undisplayable characters
‘
?
’ in display
コマンド`C-h h` (`view-hello-file`)は、ファイル`etc/HELLO`を表示します。これは、多くの異なる言語で、“hello”をどのように記述するかを、さまざまな文字で例示するファイルです。もしもある文字が端末で表示できないときは、それらの文字は‘`?`’か、中抜きのボックスで表示されます。

これらの文字セットを使う国のキーボードでも、一般的にはすべての文字に対応するキーはもっていません。キーボードがサポートしない文字は、`C-x 8
RET` (`insert-char`)を使って挿入することができます。[Inserting Text](#Inserting-Text)を参照してください。一般的な文字のいくつかは略記が利用できます。たとえば`C-x 8 [`とタイプ(Electric Quoteモードでは、通常は単に`` ` ``とタイプ)することにより、left single quotation mark `‘`を挿入できます。Emacsはさまざまなインプットメソッド(IM: input methods)をサポートします。これはあるスクリプトの文字をタイプするのを簡単にするもので、通常1つのスクリプトまたは言語に1つです。[Input Methods](#Input-Methods)を参照してください。

C-x RET
プレフィクスキー`C-x
RET`は、マルチバイト文字、コーディングシステム、インプットメソッドに属するコマンドにたいして使用されます。

C-x =, and international characters
what-cursor-position, and international characters
コマンド`C-x =` (`what-cursor-position`)は、ポイント位置にある文字の情報を表示します。文字の位置に加えて、[Position Info](#Position-Info)で説明したように、このコマンドはその文字がどのようにエンコードされているかを表示します。たとえば、このコマンドは文字‘`c`’に大して、以下のような行をエコーエリアに表示します:

    Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

‘`Char:`’の後ろの4つの値は、ポイント位置の文字を説明するためのもので、1つ目はその文字自身、その後ろに文字コードを10進(decimal)、8進(octal)、16進(hex)で表示します。非ASCIIのマルチバイト文字の場合、バッファーのコーディングシステムでその文字を安全に1バイトでエンコードできる場合は、‘`file`’とそのバッファーのコーディングシステムで表した文字コードの16進表記が続きます。その文字のエンコーディングが1バイトより長い場合、Emacsは‘`file
...`’と表示します。

eight-bit character set
raw bytes
Emacsがrawバイト(raw bytes)に遭遇する場合がまれにあります。rawバイトとは、既知の非ASCII文字エンコーディングとしてEmacsが解釈できない、値128(8進0200)から255(8進0377)の範囲の単一バイトのことです。そのようなrawバイトは、特別な文字セット`eight-bit`に属すものとして扱われます。Emacsはそれらをエスケープされた8進コードで表示します(これはカスタマイズ可能。[Display Custom](#Display-Custom)を参照されたい)。この場合、`C-x
=`は‘`file`’のかわりに‘`raw-byte`’を示します。加えて、`C-x
=`はそれらがあたかもEmacsが範囲`#x0080..#x00FF`のユニコード文字から区別するためにマップする範囲`#x3FFF80..#x3FFFFF`にあるかのようにrawバイトの文字コードを表示します。

character set of character at point
font of character at point
text properties at point
face at point
プレフィクス引数を指定した(`C-u C-x =`)では、その文字の詳細な情報をウィンドウに表示します:

-   文字セット名(character set name)と、文字セットでその文字が識別されるコード。ASCII文字の場合、`ascii`文字セットに属すると識別されます。

-   その文字のスクリプト(script)、構文(syntax)、カテゴリー(categories)。

-   現在のインプットメソッドで(もしその文字をサポートしていれば)、その文字を入力するためにタイプするキー。

-   その文字のエンコード。バッファー内部のエンコードと、ファイルに保存したときの外部のエンコードの両方。

-   グラフィカルなディスプレーでEmacsを実行しているときはフォント名と、その文字にたいするグリフコード(glyph code)。Emacsをテキスト端末で実行している場合、端末に送るコード。

-   その文字のテキストプロパティー(section “Text Properties” in the Emacs Lisp Reference Manualを参照してください)。これにはその文字を表示するのに使われるデフォルト以外のフェイスと、それを含むオーバーレイ(overlays)が含まれます(section “Overlays” in the same manualを参照してください)。

以下は例です(マニュアルに収まるように折り返している行もあります):

                 position: 1 of 1 (0%), column: 0
                character: ê (displayed as ê) (codepoint 234, #o352, #xea)
        preferred charset: unicode (Unicode (ISO10646))
    code point in charset: 0xEA
                   script: latin
                   syntax: w        which means: word
                 category: .:Base, L:Left-to-right (strong), c:Chinese,
                           j:Japanese, l:Latin, v:Viet
                 to input: type "C-x 8 RET ea" or
                           "C-x 8 RET LATIN SMALL LETTER E WITH CIRCUMFLEX"
              buffer code: #xC3 #xAA
                file code: #xC3 #xAA (encoded by coding system utf-8-unix)
                  display: by this font (glyph code)
        xft:-PfEd-DejaVu Sans Mono-normal-normal-
            normal-*-15-*-*-*-m-0-iso10646-1 (#xAC)

    Character code properties: customize what to show
      name: LATIN SMALL LETTER E WITH CIRCUMFLEX
      old-name: LATIN SMALL LETTER E CIRCUMFLEX
      general-category: Ll (Letter, Lowercase)
      decomposition: (101 770) ('e' '^')

言語環境
--------

language environments
サポートされているすべての文字セットは、マルチバイト文字が利用可能なときは、Emacsバッファーの中でサポートされます。その文字を表示するために、特定の言語を選択する必要はありません。しかしさまざまなデフォルト値をセットするために、言語環境(language environment)を選択することは重要です。大まかに言うと、言語環境とは、言語の選択というよりも、好ましいスクリプト選択の提示です。

言語環境は、テキストを読み込むとき、それを認識するコーディングシステムを制御します([Recognize Coding](#Recognize-Coding)を参照してください)。これはファイル、到着メール、その他のEmacsで読む任意のテキストに適用されます。これは新しくファイルを作成するときに使う、デフォルトのコーディングシステムも指定します。それぞれの言語環境は、デフォルトのインプットメソッドも指定します。

set-language-environment
current-language-environment
言語環境を選択するには、`current-language-environment`をカスタマイズするか、コマンド`M-x
set-language-environment`を使います。このコマンドを使うとき、どのバッファーがカレントかで違いは生じません。なぜなら、その効果はEmacsセッションにグローバルで適用されるからです。サポートされている言語環境の一覧は、変数`language-info-alist`を参照してください。コマンド`C-h
L lang-env RET` (`describe-language-environment`)を使うと、言語環境lang-envの、より詳細な情報が参照できます。サポートされる言語環境には、以下が含まれます:

> ASCII (language environment)
> Arabic
> ASCII、Arabic、 Belarusian Bengali Belarusian、Bengali、 Brazilian Portuguese Bulgarian Brazilian Portuguese、Bulgarian、 Burmese Cham Burmese、Cham、 Chinese Chinese-BIG5、Chinese-CNS、Chinese-EUC-TW、Chinese-GB、Chinese-GB18030、Chinese-GBK、 Croatian Cyrillic Croatian、Cyrillic-ALT、Cyrillic-ISO、Cyrillic-KOI8、 Czech Devanagari Czech、Devanagari、 Dutch English Dutch、English、 Esperanto Ethiopic Esperanto、Ethiopic、 French Georgian French、Georgian、 German Greek Gujarati German、Greek、Gujarati、 Hebrew IPA Hebrew、IPA、 Italian Italian、 Japanese Kannada Japanese、Kannada、 Khmer Korean Lao Khmer、Korean、Lao、 Latin Latin-1、Latin-2、Latin-3、Latin-4、Latin-5、Latin-6、Latin-7、Latin-8、Latin-9、 Latvian Lithuanian Latvian、Lithuanian、 Malayalam Oriya Malayalam、Oriya、 Persian Polish Persian、Polish、 Punjabi Romanian Punjabi、Romanian、 Russian Sinhala Russian、Sinhala、 Slovak Slovenian Spanish Slovak、Slovenian、Spanish、 Swedish TaiViet Swedish、TaiViet、 Tajik Tamil Tajik、Tamil、 Telugu Thai Telugu、Thai、 Tibetan Turkish Tibetan、Turkish、 UTF-8 Ukrainian UTF-8、Ukrainian、 Vietnamese Welsh Vietnamese、Welsh、 Windows-1255 Windows-1255

グラフィカルなディスプレーでは、使用されている言語環境で使われているスクリプトを表示するために、適切なフォントをもっている必要があります。フォントのセットアップについては、[Fontsets](#Fontsets)を参照してください。

set-locale-environment
locale-language-names
locale-charset-language-names
locales
環境変数LC\_ALL、LC\_CTYPE、LANGをセットすることにより、使用する文字セットのlocaleを指定するオペレーティングシステムがいくつかあります(もしこれらの１つ以上がセットされている場合、特に1番目のものが空でない場合、それは正にこの目的のためにlocaleを指定しています)。起動の間、Emacsは文字セットのlocale名を、システムのlocaleエイリアステーブルから探して、その正規化された名前(canonical name)を、変数`locale-charset-language-names`および`locale-language-names`(前者は後者をオーバーライドします)のエントリーにたいしてマッチし、マッチが見つかったら対応する言語環境を選択します。これはディスプレーテーブルと端末のコーディングシステム、localeコーディングシステム、localeに必要な好ましいコーディングシステム — そして最後に重要なのは — Emacsがキーボードから送られた非ASCII文字をデコードする方法を調整します。

Emacs実行中に、(`M-x
setenv`を使って)環境変数LC\_ALL、LC\_CTYPE、LANGを変更した場合、新しいlocaleにたいする言語環境を再調整するために、後で`set-locale-environment`コマンドを呼び出したいと思うかもしれません。

locale-preferred-coding-systems
`set-locale-environment`関数は通常、システムメッセージをデコードするために、言語環境により確立された、優先されるコーディングシステムを使用します。しかしlocaleが変数`locale-preferred-coding-systems`のエントリーにマッチした場合、Emacsはかわりに対応するコーディングシステムを使用します。たとえばlocaleの‘`ja_JP.PCK`’が、`locale-preferred-coding-systems`の`japanese-shift-jis`にマッチした場合、Emacsは通常なら`japanese-iso-8bit`が使われるような場合でも、エンコーディングにそのコーディングシステムを使用します。

initファイルで明示的にコマンド`set-language-environment`を使うか、`current-language-environment`をカスタマイズすることにより、起動時に選択された言語環境をオーバーライドできます。

C-h L
describe-language-environment
特定の言語環境lang-envの効果に関する情報を表示するには、コマンド`C-h L lang-env
RET` (`describe-language-environment`)を使います。これはこの言語環境に有効な言語、文字セットのリスト、コーディングシステム、インプットメソッドを表示します。これはこの言語環境で使われるスクリプトを例示する、サンプルテキストも表示します。lang-envに空の入力を与えると、このコマンドは選択されている言語環境を説明します。

set-language-environment-hook
ノーマルフック`set-language-environment-hook`により、任意の言語環境をカスタマイズできます。コマンド`set-language-environment`は、新しい言語環境をセットアップした後に、このフックを実行します。フック関数は変数`current-language-environment`をチェックすることにより、特定の言語環境をテストできます。このフックはキーボード入力にたいするコーディングシステムや端末出力、デフォルトのインプットメソッドなど、特定の言語環境にたいして非デフォルトのセッティングが必要な場所に設定します

exit-language-environment-hook
新しい言語環境のセットアップを開始する前に、`set-language-environment`はまずフック`exit-language-environment-hook`を実行します。このフックは`set-language-environment-hook`によるカスタマイズを取り消すのに便利です。たとえば、特定の言語環境にたいして`set-language-environment-hook`を使って特別なキーバインドをセットアップした場合は、`exit-language-environment-hook`で通常のキーバインドに復元するべきです。

インプットメソッド
------------------

input methods
インプットメソッド(IM: input method)は、対話的入力のために具体的にデザインされた、一種の文字変換です。Emacsでは、各言語はそれ自身のインプットメソッドをもっています。同じ文字を使う複数の言語で、1つのインプットメソッドを共有できます。複数のインプットメソッドをサポートする言語もあります。

一番簡単な種類のインプットメソッドは、ASCII文字を他のアルファベットにマッピングすることにより機能します。これによりASCIIのかわりに他のアルファベットを使うことが可能になります。GreekとRussianのインプットメソッドはこの方式で機能します。

より強力なテクニックがコンポジション(composition: 複合)です。これは文字のシーケンスを1つの文字に変換します。Europeanのインプットメソッドの多くが、アクセント文字を後(または前)に続けた文字シーケンスから、1つの非ASCII文字を生成するためにコンポジションを使います。たとえば、インプットメソッドのいくつかは、`o
^`のシーケンスを1つのアクセントつき文字に変換します。これらのインプットメソッドは、それら自身では特別なコマンドをもちません。これらすべてが行うのは、文字シーケンスを複合して、プリント文字にすることです。

音節記号(syllabic scripts)のためのインプットメソッドは通常、マッピングと、それに続けてコンポジションを使います。ThaiとKoreanのためのインプットメソッドは、この方式で機能します。最初に複数の文字が、特定の音や口調のためのシンボルにマッピングされます。次にこれらシンボルのシーケンスから音節全体を作り、それを1つの音節記号にマッピングします。

ChineseとJapaneseには、さらに複雑な方式が必要です。Chineseのインプットメソッドでは、最初にChineseの単語の音声スペルを入力するか(特にインプットメソッド`chinese-py`)、文字の一部をシーケンスとして入力します(インプットメソッド`chinese-4corner`、`chinese-sw`など)。通常1つの入力シーケンスは、多くのChinese文字に対応します。`C-f`、`C-b`、`C-n`、`C-p`(または矢印キー)、またはこの状況では特別な意味をもつ数字を指定することにより、意図するものを選択します。

文字の候補は、概念的には複数の行にアレンジされ、各行は10個の候補をもちます。通常Emacsは1度に1行をエコーエリアに表示します。行頭に`(i/j)`が表示され、これはトータルj行中、i番目の行かを示します。`C-n`または`C-p`をタイプすると、次または前の行を表示します。

`C-f`または`C-b`をタイプすると、カレント行の候補の間を前方または後方に移動します。これを行うとき、Emacsはカレント候補を特別な色でハイライトします。`C-SPC`とタイプすると、カレント候補を選択して、それを入力に使用します。各行の候補には番号も付けられています。この番号は各候補の前に表示されます。番号をタイプすると、カレント行の番号に関連付けられた候補を選択し、それを入力に使用します。

これらChineseのインプットメソッドでは、TABはすべての文字候補をバッファーに表示します。候補の1つを`mouse-2`でクリックすることにより選択します。`C-f`、`C-b`、`C-n`、`C-p`、および数字キーは通常どおり機能しますが、それらはエコーエリアではなく、文字候補を表示したバッファーをハイライトします。

Japaneseのインプットメソッドでは、最初に音声スペルを使って単語全体を入力します。つぎに単語がバッファーに入った後で、より大きな辞書を使ってEmacsがそれを1つ以上の文字に変換します。1つの音声スペルは、いくつかのJapaneseの単語に対応します。これらの1つを選択するには、`C-n`または`C-p`を使って候補を巡回します。

インプットメソッドをオフにして、入力した文字シーケンスが複合されないようにするのが便利なときがあります。たとえばインプットメソッド`latin-1-postfix`では、シーケンス`o
^`は、アクセントつきの‘`o`’に複合されます。これらの文字を個別に入力したいときはどうすればよいでしょう?

1つは、アクセントを2度タイプする方法です。これは文字とアクセントを個別に入力するための特別な機能です。たとえば`o ^
^`により、2つの文字‘`o^`’が得られます。他の方法としては`o`の後に別の文字 — 複合されない何か別の文字 — を入力してすぐにそれを削除する方法です。たとえば`o o DEL
^`とタイプすることにより、‘`o`’と‘`^`’を個別に得ることができます。もう1つは、より一般的ですがタイプが容易とは言えない方法で、2つの文字が欠号されるのを防ぐために、文字の間で`C-\\ 
C-\\`を使用する方法です。これは、コマンド`C-\\`(`toggle-input-method`)を2回使用しています。 [Select Input Method](#Select-Input-Method)を参照してください。

incremental search, input method interference
`C-\ 
C-\`は、インクリメンタル検索の中で使うのが特に便利です。なぜならこれは複合される文字が入力されるのを待つのを止めて、それまでに入力した文字で検索を開始するからです。

現在のインプットメソッドを使って、ポイント位置の後ろの文字を入力する方法を探すには、`C-u C-x
=`をタイプします。[Position Info](#Position-Info)を参照してください。

input-method-verbose-flag
input-method-highlight-flag
変数`input-method-highlight-flag`および`input-method-verbose-flag`は、インプットメソッドで何が起きているかを告げる方法を制御します。`input-method-highlight-flag`が非`nil`の場合、部分的な入力シーケンスがバッファーでハイライトされます(この機能を無効にしているインプットメソッドもあります)。`input-method-verbose-flag`が非`nil`の場合、次にタイプできる文字の一覧をエコーエリア(ただしミニバッファーにいるときは除く)に表示します。

quail-activate-hook
quail-translation-keymap
フック変数`quail-activate-hook`に関数で変更を行うことにより、入力メソッドが機能する方法を変更できます。[Hooks](#Hooks)を参照してください。たとえば、関数`quail-translation-keymap`によりリターンされるキーマップ内のキーバインディングを、`define-key`を使用して、定義することによりその入力メソッドのいくつかのキーを再定義できます。[Init Rebinding](#Init-Rebinding)を参照してください。

キーボードにない文字をタイプする他の方法は、`C-x 8 RET` (`insert-char`)を使って、Unicode名またはコードポイント(code-point)にもとづいて1つの文字を挿入する方法です。[Inserting Text](#Inserting-Text)を参照してください。

インプットメソッドの選択
------------------------

`C-\`  
選択されたインプットメソッドを有効または無効にします(`toggle-input-method`)。

`C-x RET C-\ method RET`  
カレントバッファーにたいして、新しいインプットメソッドを選択します(`set-input-method`)。

`C-h I method RET`; `C-h C-\ method RET`  
describe-input-method

C-h I

C-h C-\\

インプットメソッドmethodの説明を表示します(`describe-input-method`)。デフォルトでは、(もしあれば)カレントのインプットメソッドを説明します。これは特定のインプットメソッドの使い方に関する、すべての詳細説明を表示します。

`M-x list-input-methods`  
サポートされている、すべてのインプットメソッドのリストを表示します。

set-input-method
current-input-method
C-x RET C-\\
カレントバッファーにたいするインプットメソッドを選択するには、`C-x RET C-\` (`set-input-method`)を使います。このコマンドはミニバッファーからインプットメソッドの名前を読み取ります。この名前は通常、それが使われることを意図した言語環境で開始されます。変数`current-input-method`は選択されたインプットメソッドを記録します。

toggle-input-method
C-\\
インプットメソッドは非ASCII文字を表すために、さまざまなASCII文字のシーケンスを使います。インプットメソッドを一時的にオフにできると便利なときもあります。そのようなときは`C-\` (`toggle-input-method`)をタイプします。インプットメソッドを再度有効にするには、もう1度`C-\`をタイプします。

`C-\`をタイプしたときに、まだインプットメソッドが選択されていない場合、インプットメソッドを指定するように求めます。これはインプットメソッドを指定する`C-x
RET C-\`を使ったときと同じ効果です。

`C-u
C-\`のようにプレフィクス引数を指定した場合、`toggle-input-method`は常にインプットメソッドを尋ねます。このときデフォルトとして提案されるのは、もっとも最近選択されたインプットメソッドです。

default-input-method
言語環境の選択により、さまざまなバッファーで使用するデフォルトのインプットメソッドが指定されます。デフォルトのインプットメソッドがある場合、`C-\`とタイプしてカレントバッファーでそれを選択できます。変数`default-input-method`はデフォルトのインプットメソッドを指定します(`nil`は、それが存在しないことを意味します)。

複数の異なるインプットメソッドをサポートする言語環境では、`set-language-environment`で選択されるデフォルトとは違うインプットメソッドを使いたいときもあるでしょう。`set-language-environment-hook`を使って、特定の言語環境にたいして異なるデフォルトのインプットメソッドを使うようEmacsに指示できます([set-language-environment-hook](#Language-Environments)を参照してください)。たとえば:

    (defun my-chinese-setup ()
      "Set up my private Chinese environment."
      (if (equal current-language-environment "Chinese-GB")
          (setq default-input-method "chinese-tonepy")))
    (add-hook 'set-language-environment-hook 'my-chinese-setup)

これは言語環境をChinese-GB languageに選択したときは、常にデフォルトのインプットメソッドを`chinese-tonepy`にセットします。

特定のインプットメソッドを自動的にアクティブにするようEmacsに指示できます。たとえば:

    (add-hook 'text-mode-hook
      (lambda () (set-input-method "german-prefix")))

これはTextモードで自動的にインプットメソッド`german-prefix`をアクティブにします。

quail-set-keyboard-layout
英文字スクリプトのためのいくつかのインプットメソッドは、それらのスクリプトで一般的に使用されているさまざまなキーボードエミュレートするために、(実質的には)他のアルファベットに再マッピングすることにより機能します。この再マッピングがどのように正しく行われるかは、実際のキーボードレイアウトに依存します。キーボードがどのレイアウトなのかを指定するには、コマンド`M-x
quail-set-keyboard-layout`を使います。

quail-show-key
コマンド`M-x
quail-show-key`を使って、ポイントの後ろにある文字を入力するために、選択されたキーボードレイアウトの、どのキー(またはキーシーケンス)をタイプすればよいのか表示できます。コマンド`C-u
C-x =`もこの情報と、それに加えてその文字に関する他の情報を表示します。

list-input-methods
`M-x
list-input-methods`は、サポートされているすべてのインプットメソッドを一覧します。この一覧は各インプットメソッドの情報と、モードラインに表示される文字列を表示します。

コーディングシステム
--------------------

coding systems
さまざまな言語のユーザーは、多少の差はあれ、それらを表示するための標準のコーディングシステムを確立しています。Emacsはこれらのコーディングシステムを、内部的に使用しません。データを読み込むときは、さまざまなコーディングシステムからEmacs独自のコーディングシステムに変換し、データを書き込むときには、内部コーディングシステムから他のコーディングシステムに変換します。ファイルの読み書き、端末とのやりとり、サブプロセスとのデータ交換において、変換が可能です。

Emacsは各コーディングシステムに名前を割り当てます。ほとんどのコーディングシステムは、1つの言語で使用され、コーディングシステムの名前は、言語の名前で始まります。複数の言語で使用されるコーディングシステムもあります。これらのコーディングシステムの名前は、通常‘`iso`’で始まります。`no-conversion`、`raw-text`、`emacs-internal`のような特別なコーディングシステムもあります。

international files from DOS/Windows systems
まとめてコードページ(codepages)として知られる、特別なクラスのコーディングシステムは、MS-WindowsおよびMS-DOSのソフトウェアーによりエンコードされたテキストをサポートするためにデザインされています。これらのコーディングシステムの名前は`cpnnnn`という形式で、nnnnは3桁から4桁のコードページ番号です。これらのコーディングもほかのコーディングシステムと同様に使うことができます。たとえばコードページ850でエンコードされたファイルをvisitするには、`C-x
RET c cp850 RET C-x C-f filename RET`とタイプします。

非ASCII文字のさまざまな表現の変換に加えて、コーディングシステムは行末変換(end-of-line conversion)も行います。Emacsは、ファイル内の行の区切り方として、3つの異なる変換を扱います。つまり、改行(Unix)、復帰改行(DOS)、復帰(Mac)です。

`C-h C coding RET`  
コーディングシステムcodingの説明を表示します(`describe-coding-system`)。

`C-h C RET`  
カレントで使用しているコーディングシステムcodingの説明を表示します(`describe-coding-system`)。

`M-x list-coding-systems`  
サポートされているすべてのコーディングシステムのリストを表示します。

C-h C
describe-coding-system
コマンド`C-h C` (`describe-coding-system`)は、特定のコーディングシステムについて、それらのコーディングシステムで規定されている、行末変換も含めた情報を表示します。引数にコーディングシステム名を指定できます。引数が空のときには、さまざまな目的のために選択されている、現在のコーディングシステムの、カレントバッファにたいするものとデフォルトの両方について表示するとともに、コーディングシステムを認識するための優先順位表を表示します([Recognize Coding](#Recognize-Coding)を参照してください)。

list-coding-systems
サポートされているすべてのコーディングシステムのリストを表示するには、`M-x
list-coding-systems`とタイプします。表示されるリストは、モードラインに表示される文字も含めて、各コーディングシステムの情報を提供します。

end-of-line conversion
line endings
MS-DOS end-of-line conversion
Macintosh end-of-line conversion
リストに表示される各コーディングシステム — ただし何の変換も行わない`no-conversion`は除く — は、プリントする文字をどのように変換するか、しないかを指定しますが、改行変換については、各ファイル内容にもどづいて決定するので選択をしません。たとえばファイルが行区切りに改行復帰文字を使っているように見えるときは、DOSの改行変換を使います。

リストされた各コーディングシステムは、改行変換を厳密に指定する3つの変種があります。

`…-unix`  
何の改行変換も行いません。ファイルは行区切りに改行文字を使っていると仮定します(これは通常Unix、GNUシステム、macOSで使われている慣習です)。

`…-dos`  
ファイルが行区切りに改行復帰文字を使っていると仮定し、適切な変換を行います(これは通常Microsoftシステムで使われている慣習です[8])。

`…-mac`  
ファイルが行区切りに復帰文字を使っていると仮定し、適切な変換を行います(これはクラシックなMac OSで使われていた慣習です)。

これらのコーディングシステムの変種は、それらが完全に予測可能なため、簡略化のために`list-coding-systems`の表示からは省略されています。たとえばコーディングシステム`iso-latin-1`は`iso-latin-1-unix`、`iso-latin-1-dos`、`iso-latin-1-mac`という変種をもちます。

undecided
, coding system
コーディングシステム`unix`、`dos`、`mac`は、それぞれ`undecided-unix`、`undecided-dos`、`undecided-mac`の別名です。これらのコーディングシステムは改行変換だけを指定し、文字コード変換はテキスト字体から推論されるよう残します

raw-text
, coding system
コーディングシステム`raw-text`は、主にASCIIテキストのファイルに適していますが、ファイルには、非ASCII文字の符号を意味しない127を越えるバイト値が含まれるかもしれません。`raw-text`では、 Emacsはそれらのバイト値を変更せずにコピーし、カレントバッファーの`enable-multibyte-characters`を`nil`にセットして、それらは適切に解釈されるます。`raw-text`は、出会ったデータに基づく通常の方法で行末変換を処理し、使用する行末変換を指定する変種も3つもちます。

no-conversion
, coding system
対照的に、コーディングシステム`no-conversion`は、いかなる文字コード変換 — 非ASCIIバイト値や行末にたいしても — を行いません。これは、バイナリーファイル、tarファイル、 そのまま処理する必要があるその他のファイルを読み書きするのに便利です。これも`enable-multibyte-characters`を`nil`にセットします。

いかなる種類の変換もしないでファイルを編集するもっとも簡単な方法は、`M-x
find-file-literally`コマンドを使うことです。このコマンドは、`no-conversion`を使い、ファイルを見る前にファイルの内容を変換するかもしれない、Emacsのその他の機能を抑制します。[Visiting](#Visiting)を参照してください。

emacs-internal
, coding system
コーディングシステム`emacs-internal`(または`utf-8-emacs`)は、Emacs内部エンコーディングのままで格納された、非ASCII文字を含むファイルであることを意味します。これは出会ったデータに基づいて行末変換を処理し、行末変換の種類を指定する通常の3つの変種を持ちます。

コーディングシステムの認識
--------------------------

Emacsはテキストを読み込むとき、どのコーディングシステムが使われているか認識しようと試みます。これはファイルの読み込み、サブプロセスからの出力、X選択からのテキストなど、さまざまです。Emacsは大抵の場合 — 自分の好みを1度指定しておけば、自動的に正しいコーディングシステムを選択できます。

データにどのバイトシーケンスが出現するかにより、認識あるいは識別されるコーディングシステムもいくつかあります。しかし識別される可能性さえないコーディングシステムもあります。たとえばLatin-1とLatin-2を識別する方法はありません。これらは同じバイト値を異なる意味で使用します。

Emacsはこのようなシチュエーションを、コーディングシステムの優先リストにより処理します。Emacsがファイルを読み込むときは常に、それに使用するコーディングシステムを指定しなければ、Emacsはデータを各コーディングシステムに照らしてチェックし、それを優先順位の上から順に、データに適合するコーディングシステムが見つかるまで続けます。そして、そのコーディングシステムで、ファイル内容が表示できると仮定して変換を行います。

コーディングシステムの優先リストは、選択されている言語環境に依存します([Language Environments](#Language-Environments)を参照してください)。たとえばFrenchを使うのなら、おそらくEmacsにはLatin-2よりLatin-1を選んでほしいでしょう。Czechを使うなら、おそらくLatin-2のほうがよいでしょう。これが言語環境を指定する理由の1つです。

prefer-coding-system
しかし、コマンド`M-x
prefer-coding-system`を使って、優先リストの詳細を変更できます。このコマンドはミニバッファーからコーディングシステムの名前を読み取り、それを優先リストの先頭に追加して、他のすべてのものより優先するようにします。このコマンドを数回使うと、使用するごとに優先リストの先頭に1つの要素が追加されます。

`iso-8859-1-dos`のような、行末変換を指定したコーディングシステムを使うと、`iso-8859-1`を優先して認識を試み、その際DOSの行末変換を使うことをEmacsに指示することになります。

file-coding-system-alist
ファイルにたいして使用するコーディングシステムをファイル名が示していることがあります。変数`file-coding-system-alist`は、この対応関係を指定します。このリストに要素を追加する特別な関数は、`modify-coding-system-alist`です。たとえば、すべての‘`.txt`’の読み書きに、コーディングシステム`chinese-iso-8bit`を使用したいなら、つぎのLisp式を実行します:

    (modify-coding-system-alist 'file "\\.txt\\'" 'chinese-iso-8bit)

1つ目の引数は`file`、2番目の引数はこれを適用するファイルを決定する正規表現、3番目の引数は、これらのファイルに対して使用するコーディングシステムです。

inhibit-eol-conversion
DOS-style end-of-line display
Emacsはファイルの内容にもとづいて、使用する行末変換の種類を認識します。復帰のみ、あるいは復帰改行のシーケンスだけであれば、対応する行末変換を選択します。変数`inhibit-eol-conversion`を非`nil`にセットすることにより、行末変換の自動的な使用を抑止できます。これを行うとDOSスタイルのファイルは、バッファー内に可視の‘`^M`’という文字を表示します。モードラインの左端に目立たないように表示される改行タイプ指示‘`(DOS)`’より、こちらのほうを好む人もいます。

inhibit-iso-escape-detection
escape sequences in files
デフォルトでは、コーディングシステムの自動検知はエスケープシーケンスを検出します。文字シーケンスがエスケープ文字で開始されていて、そのシーケンスが有効なISO-2022であれば、それはEmacsにファイルをデコードするエンコーディングに、ISO-2022を使うことを告げています。

しかし、ファイルの中のエスケープシーケンスを、そのまま読み取りたい場合もあるでしょう。そのような場合、変数`inhibit-iso-escape-detection`を非`nil`にセットします。これにより、コード検知はエスケープシーケンスを無視するようになり、ISO-2022エンコーディングは使用されません。この結果として、すべてのエスケープシーケンスがバッファー内で可視になります。

変数`inhibit-iso-escape-detection`のデフォルト値は`nil`です。わたしたちは特別な操作を除いて、これを変更しないことを推奨します。なぜなら、EmacsディストリビューションのEmacs Lispソースファイルのいくつかは、コーディングシステム`iso-2022-7bit`でエンコードされた非ASCII文字を含んでおり、エスケープシーケンス検知を抑止しているときにこれらのファイルをvisitすると、正しくデコードされないからです。

auto-coding-alist
auto-coding-regexp-alist
変数`auto-coding-alist`および`auto-coding-regexp-alist`は、それぞれファイル名に含まれる特定パターン、およびファイルに含まれる特定パターンによりコーディングシステムを指定する一番強い方法です。これらの変数は、ファイル自身に含まれる‘`-*-coding:-*-`’タグさえオーバーライドします。たとえば、Emacsはtarおよびアーカイブファイルに、`auto-coding-alist`を使います。これはアーカイブのメンバーファイルに‘`-*-coding:-*-`’が含まれている場合、Emacsが混乱してそれをファイル全体に適用するのを防ぎます。

auto-coding-functions
コーディングシステムを指定する他の方法は、変数`auto-coding-functions`を使う方法です。たとえばビルトインの1つ`auto-coding-functions`は、XMLファイルにたいするエンコーディングを検知します。前の2つと異なり、この変数は‘`-*-coding:-*-`’タグをオーバーライドしません.

ファイルのコーディングシステムの指定
------------------------------------

Emacsがファイルのエンコーディングを正しく認識しなかった場合、`C-x RET r` (`revert-buffer-with-coding-system`)で、正しいコーディングシステムでファイルを再読み込みできます。このコマンドは、使用するコーディングシステムの入力を求めます。ファイルのデコードに実際に使われているコーディングシステムを見るには、モードラインの左端の近くのコーディングシステムのニーモニック文字を見るか、`C-h
C` (`describe-coding-system`)をタイプします。

coding
特定のファイルのコーディングシステムを指定するのに、そのファイル自身の最初に‘`-*-…-*-`’構成を指定するか、ファイルの最後にローカル変数リスト([File Variables](#File-Variables)を参照してください)を使用できます。これは`coding`という名前の“変数”に、値を定義することにより行われます。Emacsは実際には変数`coding`をもっていません。かわりに変数をセットして、特定のファイルにたいしてコーディングシステムを指定するのにこれを使います。たとえば‘`-*-mode:
C; coding: latin-1;
-*-`’は、Latin-1コーディングシステム、同様にCモードを指定することを指示します。ファイルの中でコーディングを明示的に指定した場合、これは`file-coding-system-alist`をオーバーライドします。

出力のためのコーディングシステムの選択
--------------------------------------

buffer-file-coding-system
Emacsがバッファーにたいして1度コーディングシステムを選択すると、そのコーディングシステムは、`buffer-file-coding-system`に記録されます。これにより`save-buffer`や`write-region`などの、バッファーからファイルに書き込む際のデフォルトに、それを使用するようになります。`set-buffer-file-coding-system`を使って、バッファーのコーディングシステムとは異なるコーディングシステムで、ファイルに書き込むよう指定できます([Text Coding](#Text-Coding)を参照してください)。

Emacsがサポートする任意の文字を、任意のEmacsバッファーに挿入できますが、ほとんどのコーディングシステムは、それらの文字のサブセットしか処理することができません。したがって挿入した文字は、そのバッファーを保存するのに使われるコーディングシステムではエンコードできないかもしれません。たとえば、`iso-8859-2`でエンコードされたPolishのファイルをvisitして、それにRussianの単語を追加することは可能です。このバッファーを保存するとき、Emacsは`buffer-file-coding-system`の現在の値を使用できません。なぜなら追加された文字が、そのコーディングシステムではエンコードできないからです。

これが発生した場合、Emacsは(`M-x prefer-coding-system`または`M-x
set-language-environment`によりセットされた)もっとも適したコーディングシステムを試します。そのコーディングシステムがバッファーのすべての文字をエンコードできたら、Emacsはそれを使って、その値を`buffer-file-coding-system`に格納します。そうでなければEmacsはバッファー内容をエンコードするのに適したコーディングシステムのリストを表示して、それらのコーディングシステムを1つ選ぶよう求めます。

メールメッセージに適さない文字を入力した場合、Emacsの振る舞いは若干異なります。この場合、追加でMIMEメッセージに推奨されたもっとも適したコーディングシステムかをチェックします。もしそうでなければ、この事実を知らせ、他のコーディングシステムの入力を求めます。これにより、メール受信者のメールソフトがデコードするのが困難なエンコードで、無意識にメッセージを送るようなことがなくなります(入力をもとめられたときに、適さないコーディングシステムを選ぶ、という選択肢もまだ残っています)。

sendmail-coding-system
メールメッセージを送信するとき、Emacsはメッセージテキストのエンコーディングに使うコーディングシステムを決定する、4つの異なる方法をもっています。最初にバッファー自身の`buffer-file-coding-system`が非`nil`なら、それを使います。次に`sendmail-coding-system`が非`nil`なら、それを使います。3番目は`default-sendmail-coding-system`の値を使います。上述した値のすべてが`nil`の場合、Emacsは、新たなファイルに使用されるデフォルトコーディングシステム(選択された言語環境により制御される、`buffer-file-coding-system`の値)を使用して送信メールをエンコードします。

ファイルのテキストにたいするコーディングシステムの指定
------------------------------------------------------

Emacsがファイル内容にたいして、自動的に正しいコーディングシステムを選択しない場合、コーディングシステムを指定するために、以下のコマンドを使用できます。

`C-x RET f coding RET`  
カレントバッファーのファイルを、コーディングシステムcodingを使って保存または再visitします(`set-buffer-file-coding-system`)。

`C-x RET c coding RET`  
直後に続くコマンドのコーディングシステムにcodingを指定します(`universal-coding-system-argument`).

`C-x RET r coding RET`  
コーディングシステムcodingを使って、現在のファイルを再visitします(`revert-buffer-with-coding-system`)。

`M-x recode-region RET right RET wrong RET`  
コーディングシステムwrongを使ってデコードされたリージョンを、かわりにコーディングシステムrightを使ってデコードします。

C-x RET f
set-buffer-file-coding-system
コマンド`C-x RET f` (`set-buffer-file-coding-system`)は、カレントバッファーのファイルのコーディングシステムをセットします(たとえばファイルを保存またはリバートするときに使うコーディングシステム)。これはミニバッファーを使ってコーディングシステムを指定します。モードラインのコーディングシステムインディケーターを`mouse-3`でクリックしても、このコマンドを呼び出すことができます。

バッファーのすべての文字を処理できないコーディングシステムを指定した場合、Emacsは問題となる文字について警告します。そしてそのバッファーを保存するときのコーディングシステムの選択を求めます。

specify end-of-line conversion
このコマンドを、カレントバッファーのエンコーディングの際の改行変換の指示に使うこともできます([end-of-line conversion](#Coding-Systems)を参照してください)。たとえば`C-x RET f dos
RET`は、カレントバッファーを、DOSスタイル(行末が改行復帰文字)で保存します。

C-x RET c
universal-coding-system-argument
ファイルにたいしてコーディングシステムを指定する他の方法は、ファイルをvisitするときに指定する方法です。最初にコマンド`C-x
RET c` (`universal-coding-system-argument`)を使います。このコマンドはミニバッファーを使ってコーディングシステムを読み取ります。ミニバッファーを抜けた後、*その直後に続くコマンド*に、指定したコーディングシステムが使用されます。

たとえば直後に続くコマンドが`C-x
C-f`の場合、そのコーディングシステムを使ってファイルを読み込みます(そして後で保存するときのために、そのコーディングシステムを記録します)。直後に続くコマンドが`C-x
C-w`の場合、そのコーディングシステムを使ってファイルを書き込みます。`C-x RET
f`のかわりに、この方法で保存するときのコーディングシステムを指定した場合、バッファーにそのコーディングシステムが処理できない文字が含まれていても警告はされません。

`C-x i`や`C-x C-v`、同様に`C-x C-f`の別ウィンドウ版`C-x RET
c`など、その他のファイルコマンドも指定されたコーディングシステムに影響されます。そして`M-x shell` ([Shell](#Shell)を参照してください)を含む、サブプロセスを開始するコマンドも影響を受けます。直後に続くコマンドがコーディングシステムを使用しない場合、`C-x
RET c`は何の影響も与えません。

変換をせずにファイルをvisitする簡単な方法は、`M-x
find-file-literally`コマンドです。[Visiting](#Visiting)を参照してください。

変数`buffer-file-coding-system`のデフォルト値は、新しいファイルを作成するときに選択されるコーディングシステムを指定します。これは新しいファイルを作成するときや、バッファーを作成してそれをファイルに保存するときに適用されます。言語環境の選択は、この変数を言語環境にたいして適した、デフォルトのコーディングシステムにセットします。

C-x RET r
revert-buffer-with-coding-system
間違ったコーディングシステムでファイルをvisitしたときは、`C-x RET r` (`revert-buffer-with-coding-system`)でこれを正すことができます。これは指定したコーディングシステムを使って、現在のファイルを再visitします。

recode-region
テキストの一部が、すでに間違ったコーディングシステムでバッファーに挿入されてしまった場合、`M-x
recode-region`を使ってデコードしなおすことができます。これは正しいコーディングシステムと、実際に使われた間違ったコーディングシステムの入力を求め、変換を行います。最初にリージョンを間違ったコーディングシステムでエンコードして、その後で正しいコーディングシステムでデコードします。

プロセス間通信にたいするコーディングシステム
--------------------------------------------

このセクションでは、他のプロセスと通信するときに使うコーディングシステムを指定する方法を説明します。

`C-x RET x coding RET`  
選択したテキストを、他のグラフィカルなアプリケーションと送受信するために、コーディングシステムcodingを使用します(`set-selection-coding-system`)。

`C-x RET X coding RET`  
次回に選択するテキストを、他のグラフィカルなアプリケーションと送受信するために、コーディングシステムcodingを使用します(`set-next-selection-coding-system`)。

`C-x RET p input-coding RET output-coding RET`  
カレントバッファーでのサブプロセスの入出力に、コーディングシステムinput-codingとoutput-codingを使用します(`set-buffer-process-coding-system`)。

C-x RET x
C-x RET X
set-selection-coding-system
set-next-selection-coding-system
コマンド`C-x RET x` (`set-selection-coding-system`)は、選択したテキストを他のウィンドウアプリケーションに送信するとき、および他のアプリケーションで選択されたテキストを受信するときのコーディングシステムを指定します。このコマンドは、このコマンドを再度使って設定をオーバーライドするまで、以降のすべての選択に適用されます。コマンド`C-x
RET X` (`set-next-selection-coding-system`)は、Emacsで次に選択されるテキスト、または次に読み取られるテキストのためのコーディングシステムを指定します。

x-select-request-type
変数`x-select-request-type`は、Xウィンドウシステムからのリクエストにより、他のアプリケーションで選択されたテキストを受信する際のデータタイプを指定します。値が`nil`(デフォルト)の場合、Emacsは`UTF8_STRING`、`COMPOUND_TEXT`の順に試み、さらにさまざまな経験則を用いて、2つの結果からより適したものを選択します。どちらも成功しなかったとき、Emacsは`STRING`にフォールバックします。`x-select-request-type`の値が、`COMPOUND_TEXT`、`UTF8_STRING`、`STRING`、`TEXT`のうちのどれかであった場合、Emacsはリクエストされたタイプだけを使用します。値がこれらのシンボルのリストだった場合、Emacsはリストのリクエストタイプを順に試行し、どれかが成功するか、すべてを試みるまで続けます。

C-x RET p
set-buffer-process-coding-system
コマンド`C-x RET p` (`set-buffer-process-coding-system`)は、サブプロセスの入出力のコーディングシステムを指定します。このコマンドはカレントバッファーに適用されます。サブプロセスは通常、それぞれ自身のバッファーをもっています。したがってサブプロセスに対応するバッファーでこのコマンドを実行することにより、特定のサブプロセスとの送受信に使用するコーディングシステムを指定できます。

サブプロセスを開始するコマンドの直前に`C-x RET c` (`universal-coding-system-argument`)を使うことにより、そのプロセスとの通信で使用するコーディングシステムを指定することもできます。[Text Coding](#Text-Coding)を参照してください。

デフォルトでは、プロセス通信の入出力は現在の言語環境に依存します。

locale-coding-system
decoding non-
ASCII
keyboard input on X
変数`locale-coding-system`は、システムのエラーメッセージや、`format-time-string`のフォーマットやタイムスタンプなどの、システム文字列のエンコードおよびデコードで使用するコーディングシステムを指定します。このコーディングシステムは、Xウィンドウシステムでの非ASCIIキーボードによる入力のデコード、およびバッチモードのときに標準出力とエラーストリームに送るテキストのエンコードにも使用されます。通常は環境変数LC\_ALL、LC\_CTYPE、LANGのうちの1つで指定される、背景にあるシステムのテキスト表現(text representation)と互換性のあるコーディングシステムを選択するべきです(上記の順番で最初の環境変数の値が空でない場合、それはテキスト表現を決定します)。

ファイル名にたいするコーディングシステム
----------------------------------------

`C-x RET F coding RET`  
ファイル名のエンコードおよびデコードに、コーディングシステムcodingを使用します(`set-file-name-coding-system`)。

set-file-name-coding-system
C-x RET F
file names with non-
ASCII
characters
コマンド`C-x RET F` (`set-file-name-coding-system`)は、ファイルの*名前*に使用するコーディングシステムを指定します。ファイルの*内容*の読み込みと書き込みには影響がありません。

file-name-coding-system
実際にこのコマンドが行うのは、変数`file-name-coding-system`に値をセットすることだけです。変数にコーディングシステムの名前(Lispシンボルか文字列)をセットすると、Emacsはすべてのファイル操作において、ファイル名のエンコードにそのコーディングシステムを使用します。これによりファイル名に非ASCII文字 — または少なくとも指定されたコーディングシステムではエンコードできる非ASCII文字 — を使うことが可能になります。

`file-name-coding-system`が`nil`の場合、Emacsは言語環境により選択され、変数`default-file-name-coding-system`に格納される、デフォルトのコーディングシステムを使用します。デフォルトの言語環境では、ファイル名の非ASCII文字は特別にエンコードはされません。これらはEmacsの内部表現を使って、ファイルシステム上に表示されます。

file-name encoding, MS-Windows
w32-unicode-filenames
Emacsが、MS-WindowsのNTファミリーの子孫(Windows 2000、XP、および以降すべてのバージョン)にあたるバージョンで実行されている場合、`file-name-coding-system`の値は大部分が無視されます。これはEmacsがデフォルトでUnicodeファイル名を直接渡せるAPIを使用するからです。一方、Windows 9Xでは、ファイル名は変数`file-name-coding-system`を使ってエンコードされており、この変数にはカレントのシステムロケールにたいして適切なコードページ([codepage](#Coding-Systems)を参照してください)がセットされている必要があります。変数`w32-unicode-filenames`の値は、Emacsがファイル名を引数とするOS関数を呼び出すUnicode APIを使うかどうかを制御します。この変数はスタートアップコードにより、Windows 9Xでは`nil`、新しいバージョンのMS-Windowsでは`t`にセットされます。

**警告:**Emacsセッションの途中で`file-name-coding-system`(または言語環境)を変更した場合、すでにvisitしているファイルの名前が、古いコーディングシステムを使えばエンコードできるが、新しいコーディングシステムではエンコードされない(または違ってエンコードされる)という問題が発生します。このようなバッファーをvisitしたファイル名で保存を試みると、間違ったファイル名で保存するか、エラーが発生します。このような問題が発生したときは`C-x
C-w`を使って、そのバッファーにたいして新しいファイル名を指定してください。

recode-file-name
ファイル名をエンコードするとき間違いが発生した場合、コマンド`M-x
recode-file-name`を使って、ファイル名のコーディングシステムを変更します。このコマンドは古いコーディングシステムでの既存のファイル名と、変換したいコーディングシステムの入力を求めます。

端末入出力にたいするコーディングシステム
----------------------------------------

`C-x RET t coding RET`  
端末の出力に、コーディングシステムcodingを使用します(`set-terminal-coding-system`)。

`C-x RET k coding RET`  
キーボード入力に、コーディングシステムcodingを使用します(`set-keyboard-coding-system`)。

C-x RET t
set-terminal-coding-system
コマンド`C-x RET t` (`set-terminal-coding-system`)は、端末出力のためのコーディングシステムを指定します。端末出力の文字コードを指定した場合、端末へのすべての文字出力は、指定したコーディングシステムに変換されます。

この機能は、特定の言語または文字セットをサポートするようビルドされた、特定の文字端末で有用です — たとえばEuropean端末は、ISO Latin文字セットの1つをサポートします。マルチバイトテキストを使う場合は、端末のコーディングシステムを指定する必要があります。これにより、Emacsは端末が実際にどの文字を処理できるのか知ることができます。

デフォルトでは、Emacsが端末タイプまたはlocale指定により、正しいコーディングシステムを推論できない場合、端末への出力は変換されません。

C-x RET k
set-keyboard-coding-system
keyboard-coding-system
コマンド`C-x RET k` (`set-keyboard-coding-system`)、または変数`keyboard-coding-system`は、キーボード入力のためのコーディングシステムを指定します。キーボード入力の文字コード変換は、非ASCIIのグラフィック文字を送信するキーをもつ端末で有用です — たとえば、いくつかの端末はISO Latin-1、またはそれのサブセットのためにデザインされています。

デフォルトでは、キーボード入力はシステムのlocale設定にもとづいて変換されます。端末がlocaleにより暗に指定されるエンコードを実際にはサポートしない場合(たとえば、`M-i`をタイプしたときに非ASCII文字が挿入されるのに気づいたとき)、エンコーディングをオフにするために`keyboard-coding-system`を`nil`にセットする必要があるでしょう。これは、

    (set-keyboard-coding-system nil)

をinitファイルに記述することにより、行うことができます。

キーボード入力にたいするコーディングシステムを使用した変換と、インプットメソッドの使用は似通った点があります。これらは両方ともキーボード入力シーケンスを1つの文字に変換します。しかし、インプットメソッドは人間により対話的に使用されることが便利なようにデザインされており、通常はASCIIのプリント文字のシーケンスが、変換されたシーケンスになります。通常、コーディングシステムは非グラフィック文字のシーケンスを変換します。

フォントセット
--------------

fontsets
フォントは通常、1つのアルファベットまたはスクリプトの形状を定義します。したがってEmacsがサポートするスクリプトの全範囲を表示するには、多くのフォントのコレクションが要求されます。Emacsではこのようなコレクションのことをフォントセット(fontset)と呼びます。フォントセットはフォント仕様のリストとして定義され、それぞれが文字コードのある範囲を処理し、指定されたフォントでカバーしない文字にたいしては他のフォントセットにフォールバックします。

fonts for various scripts
Intlfonts package, installation
それぞれのフォントセットは、フォントと同様に名前をもちます。しかしフォントはシステムに格納されていて、利用可能なフォント名はシステムで定義されていますが、フォントセットはEmacs自身で定義されます。1度フォントセットを定義したら、1つのフォントを使える場所ならどこでも、フォントセットを名前で指定して使用することができます。もちろんEmacsのフォントセットに使用できるのは、システムがサポートするフォントだけです。もしある文字がスクリーン上で空のボックスや16進コードで表示される場合、それは使用しているフォントセットがその文字にたいするフォントをもっていないことを意味します。このような場合や、文字は表示されるが、それが意図したものとは異なる場合、多分追加のフォントをインストールする必要があるでしょう。オペレーティングシステムにはインストールできるオプションのフォントがあるはずです。またはサポートされたスクリプトのほとんどのフォントを含むGNU Intlfontsパッケージをインストールすることもできます。[9]

Emacsは3つのフォントセットを自動的に作成します。それはスタンダードフォントセット(standard fontset)、スタートアップフォントセット(startup fontset)、デフォルトフォントセット(default fontset)の3つです。デフォルトフォントセットは、さまざまな非ASCII文字のフォントをもち、他の2つのフォントセットのデフォルトのフォールバック先です(デフォルトフォントをセットしたときは、デフォルトフォントセットではなくデフォルトフォント)。しかしこれはフォントのファミリー名を指定しないので、これを直接使うと、結果は少しランダムに思えるかもしれません。Emacsを‘`-fn`’オプションで実行することにより、特定のフォントセットを使用するように指示できます。たとえば、

    emacs -fn fontset-standard

‘`Font`’でフォントセットを指定することもできます([X Resources](#X-Resources)を参照してください)。

使用するフォントセットが何も指定されていない場合、EmacsはASCIIフォントを使用し、そのフォントがカバーしない文字にたいするフォールバックに‘`fontset-default`’を使用します。名前とは裏腹にスタンダードフォントセットは、明示的に要求されたときだけ使用されます。

describe-fontset
特定のフォントセットの情報を表示するためには、`M-x
describe-fontset`コマンドを使用します。これこのコマンドはフォントセットの名前(デフォルトはカレントフレームで使用されているフォントセット)を尋ねて、文字のすべての部分範囲(subrange)と、フォントセット内でそれらに割り当てられたフォントを表示します。

フォントセットは、すべての文字コードにたいしてフォントを指定する必要はありません。フォントセットが特定の文字にたいしてフォントを指定していない、または指定したフォントがシステムに存在しない場合、フォントセットは文字を正しく表示できません。この場合、その文字は16進コード、細いスペース、または空のボックスがかわりに表示されます(詳細は、[glyphless characters](#Text-Display)を参照してください)。

フォントセットの定義
--------------------

standard-fontset-spec
w32-standard-fontset-spec
ns-standard-fontset-spec
standard fontset
XでEmacsを実行している場合、Emacsは`standard-fontset-spec`の値により、スタンダードフォントセットを作成します。このフォントセットの名前は、

    -*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard

または単に短く‘`fontset-standard`’です。

GNUstep、およびmacOSではスタンダードフォントセットは、`ns-standard-fontset-spec`の値を使って作成され、MS Windowsでは`w32-standard-fontset-spec`の値を使って作成されます。

スタンダードフォントセットのボールド、イタリック、ボールドイタリックなどの変種も自動的に作成されます。これらの変種の名前には‘`medium`’のかわりに‘`bold`’、または‘`r`’のかわりに‘`i`’、またはその両方が使われます。

startup fontset
Emacsは‘`Font`’リソース、または‘`-fn`’引数で指定した任意のデフォルトASCIIフォント、またはEmacsが起動時に見つけたデフォルトフォントにもとづいて、フォントセットを自動的に作成します。これがスタートアップフォントセット(startup fontset)で、名前は`fontset-startup`です。Emacsはcharset\_registryフィールドを‘`fontset`’、charset\_encodingフィールドを‘`startup`’で置き換えてフォントセットを生成して、その置き換えた文字列をフォントセットの指定に用います。

たとえば以下の形式でEmacsを起動した場合、

    emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"

Emacsは以下のフォントセットを生成して、それをXウィンドウの初期フレームに使用します:

    -*-courier-medium-r-normal-*-14-140-*-*-*-*-fontset-startup

スタートアップフォントセットは、そのフォントでサポートされているすべての文字にたいして指定したフォントか、異なるregistryまたはencodingのフォントを使用し、それ以外の文字は‘`fontset-default`’にフォールバックして表示するでしょう。

Xリソースの‘`Emacs.Font`’では、フォントセット名を実際のフォント名のように指定できます。しかし‘`Emacs*Font`’のようなワイルドカードを使ったリソースにフォントセット名を指定しないように注意してください — ワイルドカードを使った指定は、メニューのようなフォントセットを処理できないものも含めて、 他のさまざまな目的にも適用されます。[X Resources](#X-Resources)を参照してください。

‘`Fontset-n`’という名前のXリソースを使って、追加のフォントセットを指定できます。ここでnは0から始まる整数です。リソースの値はつぎのような形式です:

    fontpattern, [charset:font]…

ここでfontpatternは、最後の2つのフィールドを除いて、標準のXフォント名の形式です(前のfontset-startupの例を参照)。最後の2つのフィールドは、‘`fontset-alias`’の形式をもつべきです。

すべてのフォントセットには2つの名前、長い名前と短い名前があります。長い名前はfontpatternです。短い名前は‘`fontset-alias`’で、これは長い名前の最後の2つのフィールドです(たとえば、スタートアップ時に自動的に作成されるフォントセットは‘`fontset-startup`’)。どちらの名前でもフォントセットを参照できます。

‘`charset:font`’という構成は、ある文字セットにたいして、(このフォントセットでは)どのフォントを使用するかを指定します。ここでcharsetは、文字セットの名前で、fontはその文字セットに使用するフォントです。1つのフォントセットの定義の中で、この構成を何度でも使用できます。

他の文字セットにたいしては、Emacsはfontpatternにもとづいて選択します。これは文字セットを記述する値で‘`fontset-alias`’を置き換えます。ASCII文字フォントにたいしては、‘`fontset-alias`’を‘`ISO8859-1`’で置き換えます。

これに加えて、複数の連続するフィールドがワイルドカードの場合、Emacsはそれらを1つのワイルドカードにまとめます。これは、オートスケールされたフォントの使用を避けるためです。大きいフォントをスケーリングしたフォントは編集に適しておらず、小さいフォントをスケーリングしたフォントも同様です。なぜならEmacsがそうするように、もともと小さなフォントを使うほうがよいからです。

したがって、fontpatternが以下の場合、

    -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

ASCII文字にたいするフォント指定は、以下のようになるでしょう:

    -*-fixed-medium-r-normal-*-24-*-ISO8859-1

そしてChinese GB2312文字にたいするフォント指定は、以下のようになるでしょう:

    -*-fixed-medium-r-normal-*-24-*-gb2312*-*

上記のフォント指定に一致するChineseフォントがないかもしれません。ほとんどのXディストリビューションには、familyフィールドが‘`song
ti`’か‘`fangsong
ti`’のChineseフォントだけが含まれています。そのような場合、‘`Fontset-n`’をつぎのように指定します:

    Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
            chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

そうするとChinese GB2312の文字を除くフォント指定では、familyフィールドが‘`fixed`’となり、Chinese GB2312の文字に対するフォント指定では、familyフィールドが‘`*`’となります。

create-fontset-from-fontset-spec
フォントセットのリソース値を処理してフォントセットを作る関数は、`create-fontset-from-fontset-spec`と呼ばれます。フォントセットを作るために、この関数を明示的に呼ぶこともできます。

フォントの命名についての詳細は、[Fonts](#Fonts)を参照してください。

フォントセットの修正
--------------------

fontsets, modifying
set-fontset-font
常にフォントセットをスクラッチから作成する必要はありません。軽微な変更だけが必要なときは、既存のフォントセットを修正するのが簡単な方法でしょう。‘`fontset-default`’の修正は、それをフォールバックに使用する他のフォントセットにも影響するので、特定のスクリプトのためにEmacsが選択するフォントに関する問題を解決する、効果的な方法になり得ます。

フォントセットは関数`set-fontset-font`を使って、文字、文字セット、スクリプトフォントを修正する文字範囲、使用されるフォントの指定を修正することができます。以下は例です:

    ;; Use Liberation Mono for latin-3 charset.
    (set-fontset-font "fontset-default" 'iso-8859-3
                      "Liberation Mono")

    ;; Prefer a big5 font for han characters.
    (set-fontset-font "fontset-default"
                      'han (font-spec :registry "big5")
                      nil 'prepend)

    ;; Use DejaVu Sans Mono as a fallback in fontset-startup
    ;; before resorting to fontset-default.
    (set-fontset-font "fontset-startup" nil "DejaVu Sans Mono"
                      nil 'append)

    ;; Use MyPrivateFont for the Unicode private use area.
    (set-fontset-font "fontset-default"  '(#xe000 . #xf8ff)
                      "MyPrivateFont")

ignore font
fonts, how to ignore
face-ignored-fonts
システムにインストールされているフォントが壊れていたり、使用されている文字にたいして好ましくない結果を生成するフォントがあるかもしれません。そのような場合、文字を表示するのに必要となる適切なフォントの検索に、それらのフォントを完全に無視するように、Emacsに指示したいと思うかもしれません。`face-ignored-fonts`の値(リスト変数です)に、不適切なフォントを追加することによりこれを行なうことができます。以下は、そのような設定を`~/.emacs`に記述する例です:

    (add-to-list 'face-ignored-fonts "Some Bad Font")

表示できない文字
----------------

あなたの端末では表示できない非ASCII文字が、いくつか存在するかもしれません。ほとんどのテキスト端末は、1つの文字セットだけをサポートします(Emacsに何を使うか指示するには、変数`default-terminal-coding-system`を使用します。[Terminal Coding](#Terminal-Coding)を参照してください)。そのコーディングシステムではエンコードできない文字は、デフォルトでは‘`?`’と表示されます。

グラフィカルなディスプレーでは、より広範囲の文字を表示できますが、それらすべてのフォントがインストールされていないかもしれません。フォントがない文字は、中空のボックスで表示されます。

Latin-1文字を使用するとき、端末がLatin-1を表示できない場合、かわりにニーモニックASCIIシーケンスを表示できます。たとえばo-umlautのかわりに‘`"o`’が表示されます。これを行うには`iso-ascii`をロードします。

latin1-display
端末がLatin-1を表示できる場合、Latin-1と等しい文字とASCIIニーモニックを混交して、他のEuropean文字セットを表示できます。これは変数`latin1-display`をカスタマイズすることにより有効になります。ニーモニックASCIIシーケンスは、ほとんどがインプットメソッドのプレフィクスに対応します。

Unibyte編集モード
-----------------

European character sets
accented characters
ISO Latin character sets
Unibyte operation
ISO 8859 Latin-n文字セットは、さまざまなEuropean言語で必要とされるアクセント文字と区切り文字を扱うために、8進の0240から0377(10進の160から250)の範囲の文字コードを定義しています。Emacsはこの範囲のバイトを、たとえunibyteバッファー(たとえばマルチバイト文字を無効にしている場合)でも、それらを文字としてではなく、rawバイトとみなします。しかし、それでもEmacsはこれらの文字コードを、あたかも*1つ*も1バイト文字セットに属するかのように1度に扱うことができます。これらのコードの*どれ*を使うかを指定するには、`M-x
set-language-environment`を呼び出して、‘`Latin-n`’のような適切な言語環境を指定します。section “Disabling Multibyte Characters” in GNU Emacs Lisp Reference Manualを参照してください。

unibyte-display-via-language-environment
端末や使っているフォントがこれらの文字をサポートしている場合、Emacsは160から255の文字を読み取り可能な文字として表示できます。これは自動的に行われます。グラフィカルなディスプレーでは、Emacsはフォントセットを通じて1バイト文字として表示できます。これは現在の言語環境で、それらに対応するマルチバイト文字を表示することにより行われます。これを行うには、変数`unibyte-display-via-language-environment`に非`nil`値を設定します。このセッティングは、これらのバイトを表示する方法だけに影響しますが、Emacsがそれらを文字としてではなくrawバイトとして扱うという基礎事実は変わらないことに注意して下さい。

iso-ascii
library
端末でLatin-1文字セットを表示できない場合、Emacsはこれらの文字をその文字が少なくとも何であるかを明確に理解できるような、ASCIIシーケンスとして表示できます。これを行うには、ライブラリー`iso-ascii`をロードします。他のLatin-n文字セットに対しても似たようなライブラリを実装できますが、これは まだ行われていません。

standard-display-8bit
8-bit display
通常、非ISO 8859文字セット(10進文字の128から159のコードも含む)は、8進でエスケープ表示されます。ライブラリー`disp-table`の関数`standard-display-8bit`を使うことにより、非標準の拡張バージョンのISO 8859文字セットに変更できます。

1バイトの非ASCII文字を入力する2つの方法があります:

-   8-bit input
    選択した言語環境のインプットメソッドを使用することができます。[Input Methods](#Input-Methods)を参照してください。unibyteバッファーでインプットメソッドを使用した場合、入力した非ASCII文字は、ユニバイトに変換されます。

-   キーボードが、非ASCII文字を表現する(10進の)128以上の文字コードを生成できるならば、それらの文字コードを直接タイプすることができます。

    グラフィカルなディスプレーでは、これらのキーを使うのに特別なことをする必要はありません。それらは単純に機能するでしょう。テキスト端末では、コマンド`M-x
    set-keyboard-coding-system`を使うか、変数`keyboard-coding-system`をカスタマイズして、キーボードが使用するコーディングシステムを指定します([Terminal Coding](#Terminal-Coding)を参照してください)。この機能を有効にすることにより、おそらくMeta文字を入力するためにESCを使う必要が生じるでしょう。しかし、コンソール端末、または`xterm`のような端末エミュレータでは、MetaをESCにアレンジすることが可能です。また8ビット文字を直接キーボードから入力したり、ComposeキーやAltGrキーを使うこともできます。[User Input](#User-Input)を参照してください。

-   iso-transl
    library
    compose character
    dead character
    非ASCIIのLatin-1、および、数は多くありませんが他のプリント文字入力の合成文字(compose-character)プレフィックスとして`C-x
    8`を使用できます。`C-x
    8`は、(ミニバッファーや他のバッファーでの)挿入、検索、キーシーケンスが許される他のコンテキストなどで使用できます。

    ライブラリー`iso-transl`をロードすることにより`C-x
    8`は機能します。1度ライブラリーをロードすると、Alt修飾キーがある場合は、`C-x
    8`と同じ目的で使用できます。後続の文字を修飾するには、アクセント文字と一緒にAltを使用します。さらにLatin-1の専用アクセント文字キー(dead accent characters)があると、1度`iso-transl`をロードした後は、それらのキーも後続の文字を合成するように定義されます。

    `C-x 8 C-h`を使用すると、利用可能なすべての`C-x 8`翻訳をリストします。

文字セット
----------

charsets
Emacsでは“文字セット(character set)”を縮めて、charsetと呼びます。Emacsは、ほとんどの有名なcharsets(`ascii`、`iso-8859-1`、`cp1250`、`big5`、`unicode`など)に加えて、Emacs自身のcharsets(`emacs`、`unicode-bmp`、`eight-bit`など)をサポートします。すべてのサポートされた文字は、1つ以上のcharsetsに属します。

Emacsは通常、charsetsにたいして正しいことを行う(does the right thing)ので、あなたはそれらを心配する必要はありません。しかし、charsetsの背景の詳細を知ることが助けになる場合もあります。

1つの例はフォント選択です([Fonts](#Fonts)を参照してください)。それぞれの言語環境([Language Environments](#Language-Environments)を参照してください)は、さまざまな文字にたいする優先リスト(priority list)を定義します。フォントを検索するとき、Emacsは最初に一番優先度の高いcharsetsを表示できるものを探すことを試みます。たとえばJapanese言語環境では、charsets `japanese-jisx0208`は一番高い優先度をもっているので、Emacsは`registry`プロパティーが‘`JISX0208.1983-0`’のフォントの使用を試みます。

list-charset-chars
characters in a certain charset
describe-character-set
charsetsに関する情報を得るのに使うことができるコマンドが2つあります。コマンド`M-x
list-charset-chars`はcharset名の入力を求め、その文字セットのすべての文字を表示します。コマンド`M-x
describe-character-set`はcharset名の入力を求め、Emacsでの内部表現も含めたそのcharsetに関する情報を表示します。

list-character-sets
`M-x
list-character-sets`は、すべてのサポートされたcharsetsを表示します。このリストはcharsetsの名前と、各charsetを識別する追加の情報を与えます。詳細については、[Information Processing Society of Japan/Information Technology Standards Commission of Japan (IPSJ/ITSCJ)](https://www.itscj.ipsj.or.jp/itscj_english/)により保守されている、[ISO International Register of Coded Character Sets to be Used with Escape Sequences (ISO-IR)](https://www.itscj.ipsj.or.jp/itscj_english/iso-ir/ISO-IR.pdf)を参照してください。このリストでは、charsetsは2つのカテゴリーに分かれています。通常のcharsets(normal charsets)が最初にリストされ、その後に追加のcharsets(supplementary charsets)が続きます。追加のcharsetは他のcharsetを定義するのに(サブセットの親として)使用されるか、古いバージョンのEmacsとの互換性のために提供されます。

バッファーの文字がどのcharsetに属するか探すには、ポイントをその文字の前において、`C-u C-x
=`をタイプします([International Chars](#International-Chars)を参照してください)。

双方向の編集
------------

bidirectional editing
right-to-left text
EmacsはArabicやFarsi、Hebrewのような、テキストを水平方向の右から左に記述するスクリプトで書かれたテキストの編集をサポートします。しかし数字やそれらのスクリプトに埋め込まれたLatinテキストは、左から右に表示されます。Latin文書の中に少量のArabicやHebrewのテキスト部分が含まれている場合も、稀ではありません(例: プログラムソース内のコメントや文字列)。これらの理由により、これらのスクリプトを使うテキストは、実際には双方向(bidirectional)、つまりそれらはleft-to-right(左から右)の文字とright-to-left(右から左)文字の混交されたものになります。

このセクションでは、双方向テキストを編集するためにEmacsが提供する機能とオプションを説明します。

logical order
visual order
Emacsはright-to-leftおよび双方向テキストを、いわゆるlogical順(またはreading順)で格納します。バッファーまたは文字列の最初の文字の位置は、次に読む文字の前になります。双方向テキストをvisual順に再配置するには、表示時間が発生します。結果として文字の位置は、それらが表示される位置にたいして単調に増加しなくなります。Emacsは表示のための双方向テキストの再配置を、[Unicode Standard Annex \#9](http://unicode.org/reports/tr9/)で説明されているUBA(Unicode Bidirectional Algorithm)で実装しています。right-to-leftパラグラフ中に長い英文テキストが出現するような、基本となるパラグラフと継続行が逆方向のときに表示する方法だけが、UBAと異なります。

bidi-display-reordering
バッファーローカルな変数`bidi-display-reordering`は、表示用にバッファーのテキストを再配置するかどうかを制御します。この変数の値が非`nil`の場合、Emacsは右から左の方向に表示される文字を再配置します。デフォルト値は`t`です。

base direction of paragraphs
paragraph, base direction
bidi-paragraph-start-re
bidi-paragraph-separate-re
双方向テキストの各パラグラフは、それ自身のbase direction(基本方向)をもっており、それはright-to-leftまたはleft-to-rightです。left-to-rightのパラグラフはスクリーンの左端から開始し、右端に到達すると切り詰め、または継続されます。対照的にright-to-leftのパラグラフのテキストは右端から開始し、左端で継続、または切り詰められて表示されます。デフォルトでは、パラグラフの境界は空行(たとえば行全体が空白文字からなる行)です。これを変更するために、2つの変数`bidi-paragraph-start-re`と`bidi-paragraph-separate-re`をカスタマイズできます。これらの値には正規表現(文字列)を指定します。たとえば単一の改行を新たなパラグラフの開始とする場合は、両方の変数に`\"^\"`をセットします。これら2つの変数はバッファーローカルです([Locals](#Locals)を参照)。

bidi-paragraph-direction
Emacsは、パラグラフを開始するテキストにもとづいて、各パラグラフの基本方向を動的に決定します。しかし、バッファーのパラグラフにたいして特定の基本方向を強制する必要もあるでしょう。変数`bidi-paragraph-direction`が非`nil`の場合、これは基本方向の動的な決定を無効にして、バッファーのすべてのパラグラフの方向を、このバッファーローカルな値で指定された方向に強制します。値には`right-to-left`と`left-to-right`が指定できます。これ以外の値は`nil`と解釈されます。

LRM
RLM
かわりにパラグラフの先頭に特別な文字を挿入することにより、パラグラフの基本方向を制御できます。特別な文字`RIGHT-TO-LEFT
MARK`またはRLMは、以降に続くパラグラフをright-to-left方向に強制します。その効果は`LEFT-TO-RIGHT
MARK`またはLRMによりleft-to-right方向に再強制されるまで続きます(`C-x 8
RET`を使ってこれらの文字を挿入できます)。GUIセッションではLRM文字およびRLM文字は、極端に細いスペースで表示されます。テキスト端末では、それらはスペースで表示されます。

文字は表示用に再配置されるので、logical順で処理を行うEmacsコマンドやバッファーの拡大は、普通とは異なる効果を生みます。たとえばコマンド`C-f`および`C-b`はポイントをlogical順で移動するので、再配置された双方向テキストではポイントがジャンプすることがあります。同様に隣接する文字位置の範囲をカバーするハイライトされたリージョンは、リージョンが再配置されたテキストにかかる場合には不連続に見える場合があります。これは双方向テキストをサポートする他のプログラムの振る舞いとしては普通であり、似通っています。

RIGHT, and bidirectional text
LEFT, and bidirectional text
right-char, and bidirectional text
left-char, and bidirectional text
LEFTや`C-RIGHT`のように、矢印キーにバインドされたカーソル移動コマンドは、カレントパラグラフの基本方向にしたがいます。left-to-rightパラグラフでは、修飾キーの有無に関わらず、RIGHTにバインドされるコマンドは、バッファーテキスト内を*前方(forward)*に移動しますが、right-to-leftパラグラフではかわりに*後方(backward)*に移動することになります。これは、right-to-leftパラグラフのバッファー位置は、ディスプレイ上を左に移動することにより大部分は増加するという事実を反映しています。

パラグラフ外に移動した際、先行または後続するパラグラフの基本方向が、移動する前のパラグラフの方向と異なる場合は、矢印キーのもつ意味は変化するでしょう。これが発生したときは、新たな基本方向に合わせて矢印キーを押下する必要があります。

visual-order-cursor-movement
cursor, visual-order motion
デフォルトでは、LEFTおよびRIGHTはlogical方向に移動しますが、`visual-order-cursor-movement`が非`nil`の場合、これらのコマンドはそれぞれスクリーン位置を左または右に、必要ならスクリーン行の次行または前行へと移動します。これは周辺の双方向コンテキストに依存して、多くのバッファー位置が移動される可能性を秘めることに注意してください。

メジャーモードとマイナーモード
==============================

Emacsには多くの編集用モード(editing modes)が含まれており、これは基本的な振る舞いを、編集に便利な方法に変更します。これらの編集用モードはメジャーモード(major modes)とマイナーモード(minor modes)に分けられます。

メジャーモードは、Cソースファイル([Programs](#Programs)を参照してください)などの特定のファイルタイプや、shellバッファー([Shell](#Shell)を参照してください)などの、特別なタイプの非ファイルバッファーにたいして作業するための特別な機能を提供します。メジャーモードは互いに排他であり、各バッファーは常に1つのメジャーモードをもちます。

マイナーモードはオンとオフを切り替えることができるオプションの機能で、ファイルやバッファーのタイプに特定する必要はありません。たとえばAuto Fillモードは、単語の間にタイプしたSPCで行を区切るマイナーモードです([Auto Fill](#Auto-Fill)を参照してください)。マイナーモードは互いに独立していて、選択されたメジャーモードからも独立しています。

メジャーモード
--------------

major modes
mode, major
TAB (and major modes)
DEL (and major modes)
C-j (and major modes)
すべてのバッファーはメジャーモードをもっており、そのバッファーがカレントである間の編集の動作を決定します。モードラインには通常カレントのメジャーモード名がカッコ内に表示されます([Mode Line](#Mode-Line)を参照してください)。

もっとも特殊化されていないメジャーモードは、Fundamental(基本)モードと呼ばれます。このモードには、モード独自の再定義や変数設定がないので、各Emacsコマンドはもっとも一般的な振る舞いをし、各ユーザーオプションはデフォルトの状態になっています。

Lispや英文テキストのように、Emacsが認識できる特定のタイプのテキスト編集には、LispモードやTextモードのような、より特殊化されたメジャーモードを通常は使用します。ほとんどのメジャーモードは3つのグループに分けられます。最初のグループはプレインまたはマークアップされた通常テキストのためのモードを含みます。これにはTextモード、HTMLモード、SGMLモード、TEXモードやOutlineモードなどが含まれます。2番目のグループはプログラミング言語特有のモードです。これらは、Lispモード(いくつかの変種を有する)、Cモード、Fortranモードなどが含まれます。3番目のグループはファイルに直接関連付けられていないメジャーモードが含まれます。これらはEmacsが特別の目的のために作るバッファーで使用されるものです。例としては、Diredが作成するバッファーのためのDiredモード([Dired](#Dired)を参照)、`C-x
m`で作成されるバッファーのためのMessageモード([Sending Mail](#Sending-Mail)を参照)、下位のシェルプロセスとの通信用のバッファーのためのShellモード([Interactive Shell](#Interactive-Shell)を参照)などが含まれます。

通常、メジャーモードは最初にファイルをvisitしたとき、またはバッファーを作成したときに、Emacsにより自動的にセットされます。`M-x`コマンドを使うことにより、新しいメジャーモードを明示的に選択することができます。モードの名前に`-mode`を追加することにより、モードを選択するコマンド名を得ることができます(たとえば、Lispモードを選択する場合は`M-x
lisp-mode`)。すべてのバッファーは厳密に1つのメジャーモードをもつので、メジャーモードを“オフ”にする方法はなく、かわりに他のメジャーモードに切り替えなければなりません。

major-mode
バッファーローカルな変数`major-mode`の値は、メジャーモードコマンドと同じ名前のシンボル(たとえば`lisp-mode`)です。この変数は自動的にセットされます。あなた自身が変更するべきではありません。

`major-mode`のデフォルト値は、メジャーモードが指定されていないファイルを使うときや、`C-x
b`で作成した新しいバッファーのメジャーモードを決定します。通常、デフォルト値はFundamentalモードを指定する、シンボル`fundamental-mode`です。Customizationインターフェースを通じて、このデフォルト値を変更できます([Easy Customization](#Easy-Customization)を参照してください)。initファイルに以下のような行を追加しても変更できます([Init File](#Init-File)を参照してください):

    (setq-default major-mode 'text-mode)

`major-mode`のデフォルト値が`nil`の場合、メジャーモードは前のカレントバッファーから引き継がれます。

特殊化されたメジャーモードは、特定のキーにたいして、そのモードにより適した何かを行うよう、意味づけが変更される場合があります。たとえばプログラミングに関連するモードでは、TABには、カレント行をその言語のルールにしたがってインデントする機能がバインドされます([Indentation](#Indentation)を参照してください)。一般的に変更されるキーはTAB、DEL、`C-j`です。多くのモードがモード自身の特別なコマンドを定義しており、それらは通常、プレフィクスキーが`C-c`であるようなキーシーケンスにバインドされます。メジャーモードはユーザーオプションと変数も変更できます。たとえばプログラミングに間するモードは通常、変数`comment-start`にバッファーローカルな値をセットします。これはソースコードのコメントがどのように区切られるかを決定します([Comments](#Comments)を参照してください)。

カレントメジャーモードのキーバインディング一覧も含めたドキュメントを閲覧するには、`C-h m` (`describe-mode`)とタイプします。[Misc Help](#Misc-Help)を参照してください。

mode hook
prog-mode-hook
Fundamentalモード以外のすべてのメジャーモードは、モードフック(mode hook)を定義します。これはバッファーでそのモードが有効になるたびに実行される、カスタマイズ可能なLisp関数のリストです。フックに間する詳細は、[Hooks](#Hooks)を参照してください。各モードフックはメジャーモード名の後に名前がつけられます。たとえばFortranモードのモードフックは、`fortran-mode-hook`です。さらに、すべてのテキストベースのメジャーモードは、`text-mode-hook`を実行し、多くの、プログラミング言語のモード(Emacsとともに配布されるものを含む) は、その言語モード自身のモードフックの前に、`prog-mode-hook`を実行します[10] 。フック関数は変数`major-mode`の値を調べて、どのモードに入ろうとしているか調べることができます。

モードフックは、一般的にマイナーモードを有効にするために使用されます([Minor Modes](#Minor-Modes)を参照してください)。たとえば以下の行をinitファイルに記述すると、すべてのテキストベースのメジャーモードでFlyspellマイナーモード([Spelling](#Spelling)を参照してください)を、Emacs LispモードでEldocマイナーモード([Lisp Doc](#Lisp-Doc)を参照してください)を有効にすることができます:

    (add-hook 'text-mode-hook 'flyspell-mode)
    (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)

マイナーモード
--------------

minor modes
mode, minor
マイナーモードは明確な方法でEmacsの動作を変更する、オプションの編集用モードです。メジャーモードとは異なり、いつでも任意の数のマイナーモードを有効にできます。いくつかのマイナーモードはバッファーローカル(buffer-local)で、特定のバッファーにたいしてオン(有効)にして、他のバッファーではオフ(無効)に切り替えることができます。それ以外のマイナーモードはグローバル(global)で、それが有効な間はEmacsセッションのすべてのバッファーで行う、すべての操作に影響します。ほとんどのマイナーモードはデフォルトで無効ですが、デフォルトで有効なものもいくつかあります。

ほとんどのバッファーローカルなマイナーモードは、モードラインのメジャーモード標識のすぐ後ろに有効であることを示します。たとえばモードラインに‘`Fill`’と表示されているとき、それはAuto Fillモードが有効であることを意味します。[Mode Line](#Mode-Line)を参照してください。

mode commands for minor modes
メジャーモードと同様に、各マイナーモードはモードコマンド(mode command)に関連付けられていて、それはモード名の後ろに‘`-mode`’を付けた名前です。たとえばAuto Fillモードのモードコマンドは`auto-fill-mode`です。しかしメジャーモードのコマンドは、単純にそのモードを有効にするだけですが、マイナーモードのモードコマンドは、モードを有効または無効にすることができます。

-   `M-x`を通じて、またはバインドしたキー([Key Bindings](#Key-Bindings)を参照してください)をタイプすることにより、モードコマンドをプレフィクスキーなしで直接呼び出すと、それはマイナーモードを切り替え(toggles)ます。つまり、マイナーモードがオフのときはオンに、オンのときはオフに切り替えます。

-   プレフィクス引数を指定してモードコマンドを呼び出すと、引数が0または負のときは無条件にマイナーモードをオフにし、それ以外のときは無条件にオンに切り替えます。

-   Lispからモードコマンドが呼び出された場合、引数が省略されているか`nil`のとき、マイナーモードは無条件にオンになります。これはメジャーモードのモードフックからマイナーモードをオンに切り替えるのを簡単にします([Major Modes](#Major-Modes)を参照してください)。非`nil`の引数は、上で説明したインタラクティブなプレフィクス引数と同様に処理されます。

ほとんどのマイナーモードは、モードコマンドと同じ名前のモード変数(mode variable)をもっています。変数の値が非`nil`のときはモードが有効で、`nil`なら無効です。一般的に、Lispから直接モード変数を変更して、モードを有効または無効にするべきではありません。かわりにモードコマンドを使うべきです。しかしCustomizeインターフェース([Easy Customization](#Easy-Customization)を参照してください)を通じてのノード変数のセットは、Customizeが自動的にモードコマンドを実行するので、常に正しくモードを有効または無効にします。

以下にいくつかのバッファーローカルなマイナーモードのリストを示します:

-   Abbrevモードは、事前に定義された省略形(abbreviation)の定義にもとづいて、テキストを自動的に展開します。[Abbrevs](#Abbrevs)を参照してください。

-   Auto Fillモードは、行が長くなりすぎるのを防ぐため、タイプされた文字にしたがって改行を挿入します。[Filling](#Filling)を参照してください。

-   Auto Saveモードはバッファー内容を定期的に保存して、クラッシュした場合等に失われる作業量を減らします。[Auto Save](#Auto-Save)を参照してください。

-   Electric Quoteモードは、クォーテーションマークを自動的に変換します。たとえば、`` `like
    this' ``とタイプするとこれは、`‘like
    this’`のように再クォートされます。どうのような種類のテキストを処理するかを制御できます。また特定のバッファーにたいしてこれを完全に無効にできます。[Quotation Marks](#Quotation-Marks)を参照してください。

-   Enrichedモードは、書式つきのテキストの編集と保存を可能にします。[Enriched Text](#Enriched-Text)を参照してください。

-   Flyspellモードは、自動的に間違ったスペルの単語をハイライトします。[Spelling](#Spelling)を参照してください。

-   Font-Lockモードは、プログラム内で見つかった特定のテキスト単位を自動的にハイライトします。このモードはデフォルトでグローバルに有効になっていますが、個別のバッファーで無効にすることができます。[Faces](#Faces)を参照してください。

-   Display Line Numbersモードは`display-line-numbers`の便利なラッパーであり、`display-line-numbers-type`の値を使用してセッティングします。[Display Custom](#Display-Custom)を参照してください。

-   Outline minorモードは、Outlineモードと呼ばれるメジャーモードと同様な機能を提供します。[Outline Mode](#Outline-Mode)を参照してください。

-   Overwrite mode
    mode, Overwrite
    overwrite-mode
    INSERT
    Overwriteモードは、通常のプリント文字の挿入により、後の文字をずらすかわりに、既存のテキストを置き換えます。たとえば、ポイントが‘`FOOBAR`’の‘`B`’の前にある場合、`G`をタイプすると通常は‘`FOOGBAR`’となりますが、Overwriteモードでは‘`FOOGAR`’になります。Overwriteモードでは、コマンド`C-q`は次の文字が何であれ、たとえそれが数字であってもその文字を挿入します — これにより既存のテキストを置き換える代わりに文字を挿入する方法が与えられます。モードコマンド`overwrite-mode`は、Insertキーにバインドされています。

-   binary-overwrite-mode
    Binary Overwriteモードは、バイナリーファイルを編集するための、Overwriteモードの変種です。このモードは改行とタブを他の文字と同じように扱うので、他の文字を上書きしたり、他の文字で上書きさせたりすることができます。Binary Overwriteモードでは`C-q`の後の数字は、通常どおり8進文字コードを指定します。

-   Visual Lineモードは、 単語単位の折り返し(word wrapping)を処理します。これにより長い行は単語境界で折り返されます。[Visual Line Mode](#Visual-Line-Mode)を参照してください。

以下に便利なグローバルマイナーモードをいくつか示します:

-   Column Numberモードは、現在の列番号をモードラインに表示します。[Mode Line](#Mode-Line)を参照してください。

-   Delete Selectionモードでは、リージョンがアクティブの場合、最初にリージョンのテキストを削除してからテキストを挿入します。[Using Region](#Using-Region)を参照してください。

-   Icompleteモードは、ミニバッファーで補完がアクティブのとき、利用可能な候補を表示します。[Icomplete](#Icomplete)を参照してください。

-   Line Numberモードは、現在の行番号をモードラインに表示します。このモードはデフォルトで有効です。[Mode Line](#Mode-Line)を参照してください。

-   Menu Barモードは、各フレームにメニューバーを表示します。このモードはデフォルトで有効です。[Menu Bars](#Menu-Bars)を参照してください。

-   Scroll Barモードは、各ウィンドウにスクロールバーを表示します。このモードはデフォルトで有効ですが、スクロールバーが表示されるのはグラフィカルな端末だけです。[Scroll Bars](#Scroll-Bars)を参照してください。

-   Tool Barモードは、各フレームにツールバーを表示します。このモードはデフォルトで有効ですが、ツールバーが表示されるのはグラフィカルな端末だけです。[Tool Bars](#Tool-Bars)を参照してください。

-   Transient Markモードはリージョンをハイライトして、マークがアクティブなときはEmacsの多くのコマンドがリージョンにたいして操作を行うようになります。このモードはデフォルトで有効です。[Mark](#Mark)を参照してください。

ファイルのモードを選択する
--------------------------

choosing a major mode
choosing a minor mode
auto-mode-alist
ファイルをvisitしたとき、Emacsは自動的にメジャーモードを選択します。これは通常、ファイル名にもとづいて選択されます—たとえば名前が‘`.c`’で終わるファイルは通常、Cモードで編集されます — が、ファイル内の特別なテキストにもとづいてメジャーモードが選択されるときもあります。この特別なテキストは、バッファーローカルなマイナーモードを有効にするためにも使用されます。

以下は、これの正確な手順です:

最初にEmacsは、ファイルにファイルローカル(file-local)なモード変数が含まれているかチェックします。[File Variables](#File-Variables)を参照してください。メジャーモードを指定するファイルローカル変数が存在する場合、Emacsは他の条件をすべて無視してそのメジャーモードを使用します。ファイルローカル変数を使用してメジャーモードを指定する方法はいくつかあります。一番単純なのは、空行でない最初の行に、そのモードの名前と、モード名の前後に‘`-*-`’を記述する方法です。他のテキストがその行にあっても問題はありません。たとえば、

    ; -*-Lisp-*-

これはEmacsにLispモードを使用するよう指示します。Lispがこの行をコメントとして扱うように、セミコロンがどのように使われているか注意してください。以下のように書くこともできます

    ; -*- mode: Lisp;-*-

ファイルローカル変数を使用して、バッファーローカルなマイナーモードを指定することもできます。これは`eval`指定を使用して行います。たとえば、空行でない最初の行に以下を記述すると、これはバッファーをLispモードにして、Auto-Fillモードを有効にします。

    ; -*- mode: Lisp; eval: (auto-fill-mode 1); -*-

しかし、ほとんどのマイナーモードはユーザー個人の好みが表れるものなので、この方法でマイナーモードを有効にするのは、通常は不適切です。特定のファイルタイプにたいしてマイナーモードを個人的に使用したい場合は、メジャーモードフックを通じてマイナーモードを有効にするのが、より良い方法です。

interpreter-mode-alist
2番目に、メジャーモードを指定するファイル変数が存在しない場合、Emacsは最初の行が‘`#!`’で開始されていないかチェックします。もし該当したら、それはそのファイルがファイルの最初の行に記述された名前のインタープリターを実行する(ファイルの残りはインタープリターへの入力として使用されます)ことにより機能する、実行可能なシェルコマンドであることを示します。したがってEmacsはインタープリター名を使って、モードの選択を試みます。たとえば、‘`#!/usr/bin/perl`’で始まるファイルは、Perlモードで開かれます。変数`interpreter-mode-alist`は、インタープリター名とメジャーモードの対応を指定します。

最初の行が‘`#!`’で開始されている場合、最初の行で‘`-*-`’の機能は通常は使用できません。なぜならインタープリターを実行するときにシステムが混乱するからです。そのため、Emacsはそのようなファイルにたいしては、1行目と同じように2行目の‘`-*-`’を探します。これはマジック文字列‘`'\"`’で開始されるman pageで、troffプリプロセッサーのリストを指定することと同じです。

magic-mode-alist
3番目に、Emacsは変数`magic-mode-alist`にもとづいて、バッファーの先頭のテキストを調べて、メジャーモードの決定を試みます。デフォルトではこの変数は`nil`(空のリスト)なので、Emacsはこのステップをスキップしますが、initファイルでこれをカスタマイズできます([Init File](#Init-File)を参照してください)。変数の値には、以下の形式のリスト要素を指定します

    (regexp . mode-function)

ここでregexpは正規表現([Regexps](#Regexps)を参照してください)で、mode-functionはメジャーモード関数です。ファイルの先頭のテキストがregexpにマッチした場合、Emacsはmode-functionで指定したメジャーモードを選択します。

`magic-mode-alist`の要素は、以下の形式でも指定できます

    (match-function . mode-function)

ここでmatch-functionは、バッファーの先頭で呼び出されるLisp関数です。この関数が非`nil`を返した場合、Emacsはメジャーモードをmode-functionにセットします。

4番目に —Emacsが適正なメジャーモードをまだ見つけていない場合 — 今度はファイル名を調べます。ファイル名とメジャーモードの対応付けは、変数`auto-mode-alist`で制御されます。この変数の値は、各要素が以下の形式のリストです。

    (regexp . mode-function)

または以下の形式です

    (regexp mode-function flag)

たとえば、通常見られるようなリストの要素は、`("\\.c\\'"
.
c-mode)`のような形式で、これは名前が`.c`で終わるファイルにたいして、Cモードを選択する役目を負っています(正規表現で‘`.`’がもつ特別な意味を打ち消すために、文字列に‘`\`’を含めなければなりません。これはLisp構文では‘`\\`’と記述する必要があります)。要素が`(regexp
mode-function
flag)`の形式をもち、flagが非`nil`の場合、Emacsはmode-functionを呼び出した後、Emacsはregexpとマッチした接尾辞を捨てて、ほかのマッチを検索します。

auto-mode-case-fold
GNU/Linuxおよび、ファイル名の大文字小文字を区別する他のシステムでは、Emacsは`auto-mode-alist`の検索で大文字小文字を区別します。この検索が失敗すると、2回目は大文字小文字を区別せずにalistを再検索します。2回目の検索を行わないようにするには、変数`auto-mode-case-fold`を`nil`に変更します。Microsoft Windowsのような、ファイル名の大文字小文字を区別しないシステムでは、Emacsは大文字小文字を区別しないで`auto-mode-alist`を検索します。

magic-fallback-mode-alist
最後に、Emacsが*まだ*使用するメジャーモードを見つけられない場合、Emacsはバッファーの先頭のテキストと、変数`magic-fallback-mode-alist`を比較します。この変数は上述した`magic-mode-alist`と同じように機能しますが、`auto-mode-alist`の*後*に調べられるという点が異なります。デフォルトでは`magic-fallback-mode-alist`にはイメージファイル、HTML/XML/SGMLファイル、PostScriptファイル、およびUnixスタイルのConfファイルをチェックする形式が含まれています。

normal-mode
バッファーのメジャーモードを変更したとき、`M-x
normal-mode`とタイプすると、Emacsが自動的に選択するメジャーモードに戻ることができます。この関数は`find-file`がメジャーモードを選択するために呼び出す関数と同じです。この関数は、(もしあれば)ファイルの‘`-*-`’ 行およびローカル変数リストも処理します。[File Variables](#File-Variables)を参照してください。

change-major-mode-with-file-name
コマンド`C-x
C-w`および`set-visited-file-name`は、新しいファイル名が何らかのモードに関係がある場合は、新しいメジャーコードに変更します(そのバッファーがファイルをvisitしていない場合、`C-x
C-s`も同じことを行います)。しかしバッファーの内容がメジャーモードを指定していて、ある種の特別なメジャーモードはモードの変更を許しません。このモード変更機能をオフにするには、`change-major-mode-with-file-name`を`nil`にセットして下さい。

インデント
==========

indentation
tabs
columns (indentation)
whitespace character
インデント(Indentation)とは、空白文字(スペースやタブ文字)を行のテキストの先頭に挿入したり調整することを指します。このチャプターでは、インデントコマンドと、Textモードやそれに関連するモード、同様にプログラミング言語のモードでの一般的なオプションを記します。プログラミング用のモードでのインデントに関する追加のドキュメントは、[Program Indent](#Program-Indent)を参照してください。

indent-for-tab-command
TAB (indentation)
インデントを行うもっとも簡単な方法は、TABキーです。ほとんどのメジャーモードでは、これによりコマンド`indent-for-tab-command`が実行されます(Cおよびそれに関連するモードでは、TABは同じように振る舞うコマンド`c-indent-line-or-region`を実行する。[C Indent](#C-Indent)を参照されたい)。

TAB  
空白文字を挿入、またはモードに適した方法でカレント行をインデントします(`indent-for-tab-command`)。リージョンがアクティブのときは、リージョンのすべての行をインデントします。

TABの正確な動作は、メジャーモードに依存します。Textモードおよびそれに関連するモードでは、TABは通常、空白とタブ文字を組み合わせたものを挿入して、ポイントを次のタブストップに進めます。このために、先行する行の最初の空白以外の文字の位置は、追加のタブストップとして扱われるので、TABを使って先行する行にポイントを揃えることができます。リージョンがアクティブ([Using Region](#Using-Region)を参照してください)な場合、TABは特別な動作をします。これはリージョンの各行をインデントするので、各行の最初の空白以外の文字は、先行する行に揃えられます。

プログラミング関連のモードでは、TABはコードのカレント行にたいして、前の行のコードの意味を理解してインデントします。リージョンがアクティブな場合、リージョンのすべての行はこの方法でインデントされます。ポイントが最初にカレント行のインデント領域にあった場合、その行の最初の空白以外の文字に再配置されます。

単にタブ文字をバッファーに挿入したいときは、`C-q TAB`とタイプします([Inserting Text](#Inserting-Text)を参照してください)。

インデントコマンド
------------------

`TAB` (`indent-for-tab-command`)コマンドとは別に、Emacsは他の方法でインデントを処理する、さまざまなコマンドを提供します。

`C-M-o`  
C-M-o

split-line

カレント行をポイント位置で分割します(`split-line`)。その行のポイントの後にあるテキストは新しい行となり、ポイントがあった位置と同じ列にインデントされます。このコマンドは、最初にポイントを複数のスペースまたはタブを飛び越えて移動させます。その後、ポイントは挿入された行の前に配されます。

M-m

back-to-indentation

`M-m`  
カレント行の最初の空白以外の文字に移動(前方または後方)します(`back-to-indentation`)。その行に空白文字しかない場合は、その行の行末に移動します。

`M-i`  
M-i

tab-to-tab-stop

ポイント位置の空白文字を次のタブストップまでインデントします(`tab-to-tab-stop`)。[Tab Stops](#Tab-Stops)を参照してください。

indent-relative

`M-x indent-relative`  
ポイントが前の行(実際には最後の空行以外の行)の、最初の空白以外の文字に揃うように、ポイント位置に空白文字を挿入します。ポイントがすでにその位置より右にある場合は、かわりに`tab-to-tab-stop`を実行します — ただし数引数を指定した場合は何もしません。

`M-^`  
M-^

delete-indentation

前の行とカレント行をマージします(`delete-indentation`)。このコマンドはカレント行の前にある任意のインデントと、行の境界を1つのスペースで置き換えて、2つの行を明解に結合(join)します。

特別なケースとして、結合された文字が連続する開きカッコまたは閉じカッコの場合、または他の改行が続く場合、1つのスペースは省略されます(Lispコードにたいして有用)。

fillプレフィクスが存在して、それが改行の後ろにあった場合、`M-^`はfillプレフィクスを削除します。[Fill Prefix](#Fill-Prefix)を参照してください。

`C-M-\`  
C-M-\\

indent-region

リージョンのすべての行にたいして、各行の先頭で`TAB`をタイプしたかのようにインデントします(`indent-region`)。

数引数が与えられた場合、その列番号までリージョンのすべての行をインデントします。

`C-x TAB`  
C-x TAB

indent-rigidly

remove indentation

このコマンドは、リージョン内で開始されるすべての行のインデントを変更するのに使用されます。インデントの変更は、影響を受ける行を厳格な(rigid)単位として移動することにより行われます。

引数を指定しないで呼び出されたとき、このコマンドは影響を受ける行のインデントを対話的に調整するために、transientモードをアクティブにします。transientモードがアクティブの間は、`LEFT`または`RIGHT`により、スペース1文字単位で左または右にインデントします。`S-LEFT`または`S-RIGHT`とタイプすることにより、タブストップ単位で左または右にインデントすることもできます。他のキーをタイプするとtransientモードは無効になり、通常の編集を再開します。

プレフィクス引数nを指定して呼び出すと、このコマンドは行をn個のスペースでインデントします(transientモードは有効になりません)。nに値を与えると後方にインデントするので、リージョン内の行のすべてのインデントを除去したいときは、以下のように充分に大きい負の引数を与えます。

    C-u -999 C-x TAB

タブストップ
------------

tab stops
tab-stop-list
Emacsは、特定の列番号がタブストップになるよう定義しています。これらはTextモードおよびそれに関連するモードで、TABおよび`M-i`のようなコマンドにより、空白文字が挿入されるときのストップポイントとして使用されます。変数`tab-stop-list`は、これらの位置を制御します。デフォルト値は`nil`で、これはタブストップが8列ごとという意味です。値には、タブストップの列番号を、0基準の列番号のリスト(昇順)で指定することもできます。Emacsは最後の要素と、その1つ前の要素の差分を繰り返すことにより、リストを無限に拡張します。

edit-tab-stops
C-c C-c (Edit Tab Stops)
変数`tab-stop-list`を直接カスタマイズするかわりに、コマンド`M-x
edit-tab-stops`を通じて、タブストップを視認しながらセットする便利な方法があります。このコマンドは、以下のようなタブストップの説明を含んだバッファーに切り替えます。

            :       :       :       :       :       :
    0         1         2         3         4
    0123456789012345678901234567890123456789012345678
    To install changes, type C-c C-c

最初の行は各タブストップ位置にコロンを示します。その後の2行はコロンが示す位置を表示します。`tab-stop-list`の値が`nil`(デフォルト)の場合、最初はコロンが表示されません。

異なるタブストップを置きたい列に、コロンを配して指定するために、このバッファーを編集できます。このバッファーはOverwriteモードを使用します([Minor Modes](#Minor-Modes)を参照してください)。Emacsは、最後に明示した2つのストップの差分を繰り返すことにより、タブストップのリストを無限に拡張することを思い出してください。編集が終わったら、新しいタブストップを有効にするために、`C-c
C-c`とタイプします。通常、新しいタブストップのセッティングは、すべてのバッファーに適用されます。しかし`M-x
edit-tab-stops`を呼び出したバッファーにたいして、ローカルな変数`tab-stop-list`を作成していた場合([Locals](#Locals)を参照してください)、新しいタブストップのセッティングは、そのバッファーだけに適用されます。将来のEmacsセッションのためにタブストップのセッティングを保存するには、Customizeインターフェースを使用して`tab-stop-list`の値を保存します([Easy Customization](#Easy-Customization)を参照してください)。

このセクションで議論したタブストップは、バッファーでタブ文字が表示される方法には影響しないことに注意してください。タブ文字は常に次のタブストップ表示(display tab stop)まで拡張される、空のスペースとして表示されます。[Text Display](#Text-Display)を参照してください。

タブ vs. スペース
-----------------

インデントコマンドは通常、最小になるような一連のタブ文字とスペースを挿入(または削除)することにより、望む列に行を揃えます。タブ文字は次のタブストップ表示(display tab stop)まで伸長された、空のスペースとして表示されます。デフォルトでは、`tab-width`列ごと(デフォルトは8)に、1つのタブストップ表示があります。[Text Display](#Text-Display)を参照してください。

indent-tabs-mode
もし望むなら、すべてのインデントをスペースだけで行うこともできます。これを要求するには、バッファーローカルな変数`indent-tabs-mode`を`nil`にセットします。バッファーローカルな変数についての情報は、[Locals](#Locals)を参照してください。しかし`C-q
TAB`は、`indent-tabs-mode`の値とは無関係に、常にタブ文字を挿入することに注意してください。

`indent-tabs-mode`を`nil`にセットする1つの理由は、すべてのエディターがタブ文字を同じ方法で表示するわけではないという理由です。Emacsユーザーも同様で、彼らはカスタマイズされた`tab-width`により、異なる値をもつかもしれません。スペースだけを使うことにより、ファイルが常に同じように見えることを保証できます。Emacsでどのように見えるかだけに関心がある場合、この問題に取り組む他の方法は、ファイルローカルな変数`tab-width`をセットする方法です([File Variables](#File-Variables)を参照してください)。

tabify
untabify
空白以外の文字の列を常に保ちながら、スペースをタブに、またはその逆の変換を行うコマンドも存在します。`M-x
tabify`は、リージョンの連続するスペースをスキャンして、インデントを変更せずに、少なくとも2文字の連続するスペースをタブに変換します。`M-x
untabify`は、リージョンのすべてのタブを適正な数のスペースに変更します。

インデントの便利な機能
----------------------

tab-always-indent
変数`tab-always-indent`は、TAB (`indent-for-tab-command`)コマンドの動作を微調整します。デフォルト値は`t`で、これは[Indentation](#Indentation)で説明した動作を与えます。値をシンボル`complete`に変更すると、TABは最初にカレント行のインデントを試みます、すでにその行がインデントされている場合、このコマンドはポイント位置のテキストの補完を試みます([Symbol Completion](#Symbol-Completion)を参照してください)。値が`nil`の場合、TABはポイントが行の左端かインデント位置にあるときだけインデントを行い、それ以外はタブ文字を挿入します。

Electric Indent mode
mode, Electric Indent
electric-indent-mode
Electric Indentモードはグローバルなマイナーモードで、これはRETをタイプしたあと自動的にインデントを行います。このモードはデフォルトで有効です。このマイナーモードを切り替えるには、`M-x
electric-indent-mode`とタイプします。1つのバッファーにたいしてモードを切り替えるには、`M-x
electric-indent-local-mode`を使用してください。

人間の言語のためのコマンド
==========================

text
manipulating text
このチャプターではテキスト(text) — 人間の言語(対照的なものとしてコンピューターのプログラム言語があります)における、文字シーケンスという意味 — にたいして動作する、Emacsコマンドを説明します。これらコマンドは、人間の言語の構文および文体の規則に配慮した方法で動作します。単語、センテンス(文)、パラグラフ(段落)、大文字に関する規則があります。フィル(filling) — パラグラフの行をおおよそ同じ長さに再配置するという意味 — を行うコマンドもあります。これらのコマンドは主にテキストの編集を意図しており、プログラムの編集にも便利なときがあります。

Emacsには、人間言語のテキストを編集するためのメジャーモードがいくつかあります。ファイルが普通のテキストを含む場合は、Textモードを使います。これはEmacsを、テキストの構文規則にたいして少しカスタマイズしたものです。Outlineモードは。アウトライン構造でテキストを操作する特別なコマンドを提供します。[Outline Mode](#Outline-Mode)を参照してください。

Orgモードは、Outlineモードを拡張してEmacsを本格的なオーガナイザーに変えます。これによりTODOリストを管理したり、ノートを保存して、それを多くのフォーマットで公開することができます。 Emacsと共に配布されるOrgのInfoマニュアルを参照してください。

EmacsにはTEXやLATEX ([TeX Mode](#TeX-Mode)を参照してください)、HTMLやSGML ([HTML Mode](#HTML-Mode)を参照してください)、XML (Emacsと共に配布されるnXLMモードのマニュアルを参照してください)、 GroffやNroff ([Nroff Mode](#Nroff-Mode)を参照してください)のような、コマンドが埋め込まれたテキストのための、他のメジャーモードがあります。

ASCII art
テキスト文字で作られたAA(ASCII art)のピクチャーを編集する必要がある場合は、そのような絵を編集するための特別なメジャーモードのPictureモードを使用します [Picture Mode](#Picture-Mode)を参照してください。

単語
----

words
Meta commands and words
Emacsは、単語単位で移動するコマンドをいくつか定義しています:

`M-f`  
1単語前方に移動します(`forward-word`)。

`M-b`  
1単語後方に移動します(`backward-word`)。

`M-d`  
単語の最後までkillします(`kill-word`)。

`M-DEL`  
単語の先頭までkillします(`backward-kill-word`)。

`M-@`  
次の単語の最後にマークをセットします(`mark-word`)。

`M-t`  
2つの単語を入れ替える、または他の単語を飛び越えて単語をドラッグします(`transpose-words`)。

これらのキーは文字単位のコマンド`C-f`、`C-b`、`C-d`、DEL、`C-t`に類似していることに注目してください。`M-@`は`C-@`(これは`C-SPC`の別名です)が由来です。

M-f
M-b
forward-word
backward-word
コマンド`M-f` (`forward-word`)および`M-b` (`backward-word`)は、単語単位で前方または後方に移動します。これらのMetaベースのキーシーケンスは、1文字単位で移動するキーシーケンス`C-f`および`C-b`に類似しています。類似点は数引数にも拡張されます。これらは繰り返し回数を指定します。`M-f`に負の引数を与えると後方に移動し、`M-b`に負の引数を与えると前方に移動します。前方への移動は単語の最後の文字の直後で停止し、後方への移動は、最初の文字の直前で停止します。

M-d
kill-word
`M-d` (`kill-word`)は、ポイントの後ろの単語をkillします。正確に言うと、ポイントから、`M-f`で移動する位置までのすべてをkillします。したがってポイントが単語の途中にある場合、`M-d`はポイントの後だけをkillします。ポイントと次の単語の間に区切り文字がある場合、それは単語と一緒にkillされます（次の単語だけをkillして、その前にある区切り文字はkillしたくないときは、`M-f`で最後まで移動して、`M-DEL`で単語を後方にkillします)。`M-d`は`M-f`と同様の引数を取ります。

backward-kill-word
M-DEL
`M-DEL` (`backward-kill-word`)は、ポイントの前の単語をkillします。これはポイントから、`M-b`で移動する位置までのすべてをkillします。たとえばポイントが‘`FOO,
BAR`’のスペースの後ろにある場合、これは‘`FOO,
`’をkillします。‘`FOO`’だけをkillして、カンマとスペースは残したい場合は、`M-DEL`のかわりに`M-b
M-d`を使用します。

`M-t` (`transpose-words`)は、ポイントの前またはポイントを含む単語を、次の単語と交換します。単語間の区切り文字は移動されません。たとえば‘`FOO,
BAR`’は、‘`BAR FOO,`’ではなく、‘`BAR,
FOO`’に入れ替えられます。入れ替えについては、[Transpose](#Transpose)を参照してください。

M-@
リージョンにたいして操作を行う際、単語単位で操作したいときは、コマンド`M-@` (`mark-word`)を使用します。このコマンドは`M-f`で移動する位置にマークをセットします。このコマンドにつての詳しい詳細は、[Marking Objects](#Marking-Objects)を参照してください。

単語にたいするコマンドが理解する単語境界は、構文テーブル(syntax table)で制御されます。単語の区切り文字に、(たとえば)任意の文字を使うことができます。section “Syntax Tables” in The Emacs Lisp Reference Manualを参照してください。

以上に加えて、リージョンまたはバッファーに含まれる単語数のカウントとリポートを行う`M-=` (`count-words-region`)および`M-x count-words`コマンドについては、[Position Info](#Position-Info)を参照してください。

センテンス
----------

sentences
manipulating sentences
センテンス(文)とパラグラフ(段落)を操作するEmacsコマンドは、単語を処理するコマンドと同様、ほとんどがMetaキーに割り当てられています。

`M-a`  
センテンスの先頭に、後方へ移動します(`backward-sentence`)。

`M-e`  
センテンスの最後に、前方へ移動します(`forward-sentence`)。

`M-k`  
センテンスの最後まで、前方にkillします(`kill-sentence`)。

`C-x DEL`  
センテンスの最初まで、後方にkillします(`backward-kill-sentence`)。

M-a
M-e
backward-sentence
forward-sentence
コマンド`M-a` (`backward-sentence`)および`M-e` (`forward-sentence`)は、センテンスの先頭または最後に移動します。これらのコマンドのバインディングは、行の先頭と最後に移動する`C-a`と`C-e`に似せて選ばれました。似ていない点は、`M-a`または`M-e`を繰り返すと、センテンス単位で連続して移動することです。

センテンスにたいして後方に移動すると、ポイントはセンテンスの最初の文字の直前に移動します。前方に移動したときは、センテンスを終了させる区切り文字の直後に移動します。どちらもセンテンスの境界にある空白文字にポイントを移動することはありません。

M-k
kill-sentence
`C-a`と`C-e`がkillコマンド`C-k`をもつように、`M-a`と`M-e`にも対応するkillコマンドがあります。`M-k` (`kill-sentence`)は、ポイントからセンテンスの最後までをkillします。正の数引数nを指定すると、次のnセンテンスをkillします。負の数引数−nを指定すると、後方にn番目のセンテンスの先頭までをkillします。

C-x DEL
backward-kill-sentence
`C-x DEL` (`backward-kill-sentence`)は、センテンスの先頭までを後方にkillします。

センテンスのコマンドは、センテンスの最後に2つのスペースを置くというAmericanのタイピストの慣習に、ユーザーが従うと仮定します。つまりセンテンスの最後は‘`.`’、‘`?`’、‘`!`’の後ろに改行または2つのスペースがあると仮定し、その間に任意の個数の‘`)`’、‘`]`’、‘`'`’、‘`"`’が許されます。パラグラフの先頭および最後は、センテンスの先頭および最後でもあります。この慣習にしたがうことにより、Emacsのセンテンスにたいするコマンドがセンテンスの最後のピリオドと、省略形を示すピリオドを区別できるので便利になります。

sentence-end-double-space
センテンスの間を1つのスペースにしたい場合は、`sentence-end-double-space`を`nil`にセットすることにより、センテンスのコマンドが1つのスペースで止まるようになります。しかし、これにはセンテンスの終わりのピリオドと、省略形を示すピリオドを区別できなくなるという欠点があります。したがって便利で信頼できる編集のために、2つのスペースの慣習にしたがうことを推奨します。変数`sentence-end-double-space`はフィルにも影響します([Fill Commands](#Fill-Commands)を参照してください)。

sentence-end
変数`sentence-end`は、センテンスの終了を認識する方法を制御します。非`nil`の場合、その値は正規表現にすべきで、それはセンテンスの最後の数文字(センテンスの後ろのスペースも含む)とのマッチに使用されます。値が`nil`(デフォルト)の場合、Emacsは`sentence-end-double-space`の値のような、変数条件に照らしてセンテンスの最後を計算します。

sentence-end-without-period
Thaiのようないくつかの言語は、センテンスの最後を示すのにピリオドを使用しません。そのような場合は変数`sentence-end-without-period`に`t`をセットします。

パラグラフ
----------

paragraphs
manipulating paragraphs
パラグラフ(段落)を操作するEmacsコマンドもMetaキーに割り当てられています。

`M-{`  
前のパラグラフの先頭に、後方へ移動します(`backward-paragraph`)。

`M-}`  
次のパラグラフの最後に、前方へ移動します(`forward-paragraph`)。

`M-h`  
そのパラグラフ、または次のパラグラフの周囲にポイントとマークを配します(`mark-paragraph`)。

M-{
M-}
backward-paragraph
forward-paragraph
`M-{` (`backward-paragraph`)は、カレントのパラグラフ、または前のパラグラフの先頭に移動します(呼び出し時にポイントがある場所に依存する。パラグラフの定義は以下を参照)。同様に、`M-}` (`forward-paragraph`)は、カレントのパラグラフ、または次のパラグラフの最後に移動します。パラグラフの前に空行がある場合、`M-{`はその空行に移動します。

M-h
mark-paragraph
パラグラフにたいして操作をしたい場合、`M-h` (`mark-paragraph`)とタイプすることにより、パラグラフの周囲にリージョンがセットされます。たとえば`M-h
C-w`は、パラグラフの周囲またはポイントの後ろをkillします。`M-h`は、ポイント位置のパラグラフの先頭にポイントを、最後にマークを配します。ポイントがパラグラフの間(連続する空行の中、または境界)にある場合、`M-h`はポイントの後ろに続くパラグラフの周囲にリージョンをセットします。パラグラフの最初の行の前に空行がある場合、その空行はリージョンに含まれます。 リージョンがすでにアクティブの場合、このコマンドはポイントを変更せずにマークをセットします。連続する`M-h`は、マークをパラグラフ単位で先にセットします。

パラグラフの定義はメジャーモードに依存します。Fundamentalモード、同様にTextモードとそれに関連するモードでは、パラグラフと、その隣接するパラグラフを分けるのは１行以上の空行 — 空の行、スペースとタブだけからなる行、およびそれらに改ページ文字がついた行 — です。プログラミング言語に関するモードでは、通常パラグラフは同じような方法で定義されるので、パラグラフがないプログラムなどにたいしても、パラグラフのコマンドを使うことができます。

Textモードでは、インデントされた行自体では、パラグラフの区切りには*ならない*ことに注意してください。インデントされた行をパラグラフの分割に使用したい場合は、かわりにParagraph-Indent Textモードを使用します。[Text Mode](#Text-Mode)を参照してください。

フィルプレフィクスをセットしている場合、フィルプレフィクスで始まっていないすべての行は、パラグラフの区切りとなります。[Filling](#Filling)を参照してください。

paragraph-start
paragraph-separate
パラグラフ境界の正確な定義は、変数`paragraph-separate`および`paragraph-start`により制御されます。`paragraph-start`の値には、パラグラフを開始または分割する行にマッチする正規表現を指定します。`paragraph-separate`の値には、パラグラフの一部とならないような、パラグラフを分割する行にマッチする正規表現を指定します。新しいパラグラフを開始するパラグラフに含まれる行は、`paragraph-start`にはマッチしますが、`paragraph-separate`にはマッチしません。たとえばFundamentalモードでは、`paragraph-start`は`"\f\\|[
\t]*$"`、`paragraph-separate`は`"[ \t\f]*$"`です。

`paragraph-start`と`paragraph-separate`はテキストの左マージンにマッチしますが、行頭である必要はないので、パラグラフ関数がマージンのセッティングに応じてテキストリージョン内で同じように確実に機能させるために、これらのregexpに‘`^`’を使用するべきでないことに注意してください。

ページ
------

pages
formfeed character
改ページ文字(formfeed character: ASCIIコード12で、‘`control-L`’とも表示されます)でページに分割されているものがあり、Emacsではそれらがエスケープシーケンス‘`^L`’で表示されます([Text Display](#Text-Display)を参照してください)。伝統的には、そのようなテキストファイルのハードコピーを印刷する場合、各改ページ文字で改ページされます。ほとんどのEmacsコマンドは、この文字をほかの文字と同様に扱うので、`C-q
C-l`で挿入して、DELで削除などができます。それに加えて、Emacsはページ単位の移動や操作を行うコマンドを提供します。

`M-x what-page`  
ポイント位置のページ番号と、ページ内での行番号を表示します。

`C-x [`  
前のページ境界にポイントを移動します(`backward-page`)。

`C-x ]`  
次のページ境界にポイントを移動します(`forward-page`)。

`C-x C-p`  
現在のページ(または他のページ)の周囲に、ポイントとマークを配します(`mark-page`)。

`C-x l`  
現在のページの行数を数えます(`count-lines-page`)。

what-page
`M-x what-page`は、ファイルの先頭から数えたページ数と、そのページの行数をエコーエリアに表示します。

C-x \[
C-x \]
forward-page
backward-page
`C-x [` (`backward-page`)コマンドは、前のページ区切りの直後にポイントを移動します。ポイントがすでにページ区切りの直後にある場合は、そのページ区切りをスキップして、その前のページ区切りに移動します。数引数は繰り返し回数を指定します。`C-x
]` (`forward-page`)コマンドは、次のページ区切りに前方に移動します。

C-x C-p
mark-page
`C-x C-p` (`mark-page`)コマンドは、ポイントを現在のページの先頭(ページの先頭に隣接するページ区切りの後ろ)、マークをページの最後(ページの最後に隣接するページ区切りの後ろ)に配します。

`C-x C-p C-w`は、ページを他の場所に移動するためにkillする便利な方法です。`C-x [`または`C-x
]`で他のページへ移動して、そこにkillされたページをyankすれば、すべてのページは再び適切に区切られます。`C-x
C-p`のリージョンに後続のページ区切りだけが含まれるのは、これが期待したよう確実に機能させるためです。

`C-x
C-p`に数引数を指定すると、現在のページから数えて何ページ目に移動するかを指定します。0は現在のページ、1は次のページ、−1は前のページを意味します。

C-x l
count-lines-page
`C-x l` (`count-lines-page`)コマンドは、ページをどこで2つに分割するかの良い指標になります。これは現在のページの全行数と、カレント行の前にある行数と、後ろにある行数を以下のように表示します。

    Page has 96 (72+25) lines

合計が1少ないのに注意してください。これはポイントが行の先頭にない場合は正しくなります。

page-delimiter
変数`page-delimiter`は、ページがどこで始まるかを制御します。この値にはページを分割する行の先頭にマッチする正規表現を指定します([Regexps](#Regexps)を参照してください)。この変数の値は通常`"^\f"`で、これは行の先頭の改ページ文字にマッチします。

クォーテーションマーク
----------------------

Quotation marks
Electric Quote mode
mode, Electric Quote
curly quotes
curved quotes
guillemets
electric-quote-mode
テキストをクォートするための一般的な方法の1つは、typewriter convention(タイプライター方式)です。これは`'like
this'`のようなstraight apostrophesによるクォートや、`"like
this"`のようなダブルクォートを使用します。別の一般的な方法としてはcurved quote convention(曲クォート方式)があります。これは‘`like this`’や‘\``like
thi`”のように、左右のシングルクォーテーションマークやダブルクォーテーションマークを使用します。[11]テキストファイルにおいては、typewriter quotesはシンプルで可搬性があり、curved quotesはあいまいさが少なく見栄えもよくなります。

electric-quote-chars
Electric Quoteモードにより、curved quotesをタイプするのが簡単になります。オプションでタイプした文字`` ` ``を‘、`'`を’、``` `` ```を“、`''`を”に変換します。このデフォルトのクォートリストは、変数`electric-quote-chars`をカスタマイズして変更できます。値には左シングルクォート、右シングルクォート、左ダブルクォート、右ダブルクォートに対応する、4つの文字からなるリストを指定します。デフォルト値は`'(?‘
?’ ?“ ?”)`です。

electric-quote-paragraph
electric-quote-comment
electric-quote-string
Electric Quoteモードは、このモードをどこでアクティブにするかを制御する変数を通じて、カスタマイズできます。`electric-quote-paragraph`が非`nil`の場合、テキストパラグラフ内でアクティブになります。`electric-quote-comment`が非`nil`の場合、プログラミング言語のコメント内でアクティブになります。`electric-quote-string`が非`nil`の場合、プログラミング言語の文字列定数内でアクティブになります。デフォルトでは、`electric-quote-string`が`nil`で、それ以外の変数が`t`です。

Electric Quoteモードはデフォルトで無効になっています。これを単一のバッファーで切り替えるには`M-x
electric-quote-local-mode`、グローバルに切り替えるには`M-x
electric-quote-mode`とタイプします。1回だけこれを抑制したいときは、`` ` ``や`'`のかわりに、`` C-q
` ``と`C-q '`を使用します。Electric Quoteモードが無効または非アクティブのときにcurved quoteを挿入する場合、『`‘`』は`C-x 8 [`、『`’`』は`C-x 8 ]`、『`“`』は`C-x 8
{`、『`”`』は`C-x 8 }`とタイプします。[Inserting Text](#Inserting-Text)を参照してください。`electric-quote-chars`の値は、これらのキーバインドには影響を与えないことに注意してください。これらの値は`electric-quote-mode`のキーバインドではなく、`global-map`のバインドのためのものです。

テキストのフィル
----------------

filling text
テキストをフィル(fill)するとは、指定した幅に収まるように行を分割することを意味します。Emacsはフィルを2つの方法で行います。Auto Fillモードでは、自己挿入文字によるテキストの挿入で、自動的にフィルされます。テキストを編集するときに使用できる、明示的なフィルコマンドもあります。

### Auto Fillモード

Auto Fill mode
mode, Auto Fill
Auto Fillモードは、行が長くなりすぎたとき、スペースの箇所で行を自動的に分割する、バッファーローカルなマイナーモード([Minor Modes](#Minor-Modes)を参照)です。

`M-x auto-fill-mode`  
Auto Fillモードを有効または無効にします。

`SPC`; `RET`  
Auto Fillモード中は、適切なときに行を分割します。

auto-fill-mode
モードコマンド`M-x auto-fill-mode`は、カレントバッファーのAuto Fillモードを切り替えます。他のマイナーモードと同様、正の数引数はAuto Fillモードを有効にし、負の引数は無効にします。特定のメジャーモードでAuto Fillモードを自動的に有効にするには、モードフックに`auto-fill-mode`を追加します([Major Modes](#Major-Modes)を参照してください)。Auto Fillモードが有効なときは、モードラインにモード指標の‘`Fill`’が表示されます([Mode Line](#Mode-Line)を参照してください)。

Auto Fillモードは、行が望ましい幅より長くなったとき、空白の位置で自動的に行を分割します。行の分割は、SPCかRETをタイプしたときだけ発生します。行の分割をさせずにスペースまたは改行を挿入したいときは、`C-q
SPC`または`C-q C-j`とタイプします。`C-o`も行の分割を発生させずに改行を挿入します。

Auto Fillモードが行を分割するときは、適応型フィルプレフィクス(adaptive fill prefix)にしたがうよう試みます。フィルプレフィクスがカレントパラグラフの最初の１行目、および/または2行目で推論できる場合、そのフィルプレフィクスは新しい行に挿入されます([Adaptive Fill](#Adaptive-Fill)を参照してください)。そうでない場合、新しい行はその行でTABをタイプしたかのようにインデントされます([Indentation](#Indentation)を参照してください)。プログラミング言語に関するモードでは、行がコメントの途中で改行された場合、新しいコメント区切りが適切に挿入されてコメントが分割されます。

Auto Fillモードはパラグラフ全体を再フィルしません。これは行の分割はしますが、行のマージはしません。したがって、パラグラフの途中を編集しているときは、適切にフィルされていないパラグラフがあり得ます。これをフィルするには、フィルコマンドを明示的に呼び出してください ([Fill Commands](#Fill-Commands)を参照してください)。

### 明示的なフィルコマンド

`M-q`  
カレントパラグラフをフィルします(`fill-paragraph`)。

`C-x f`  
フィルの列幅をセットします(`set-fill-column`)。

`M-x fill-region`  
リージョンの各パラグラフをフィルします(`fill-region`)。

`M-x fill-region-as-paragraph`  
リージョンを1つのパラグラフとしてフィルします。

`M-o M-s`  
行を中央に揃えます。

M-q
fill-paragraph
コマンド`M-q` (`fill-paragraph`)は、カレントのパラグラフをフィルします。このコマンドは特定の最大列幅に適合するような方法で、パラグラフの改行を再配分して、パラグラフの余分なスペースやタブ文字を削除します。

fill-region
`M-q`は通常、ポイントがあるパラグラフに作用しますが、ポイントがパラグラフの間にあるときは、ポイントの後ろのパラグラフに作用します。リージョンがアクティブの場合、かわりにリージョンのテキストに作用します。`M-x
fill-region`を呼び出して、リージョンのテキストを明確にフィルすることもできます。

fill-region-as-paragraph
`M-q`および`fill-region`は、パラグラフの境界を探すために、通常のEmacsの条件式を使用します。より細かく制御するには、ポイントとマークの間にあるすべてを1つのパラグラフとして再フィルする、`M-x
fill-region-as-paragraph`を使用することができます。このコマンドはリージョンの空行を削除するので、分割されたテキストブロックは、1つのブロックに結合されます。

justification
`M-q`に数引数を指定した場合、これはテキストのフィルと同時に割付(justify)も指示します。これは行の右端が正確にフィル列になるように、余分なスペースが挿入されることを意味します。余分なスペースを削除するには、引数を指定せずに`M-q`を使用します(`fill-region`と同じ)。

fill-column
C-x f
set-fill-column
フィルのための行の最大幅は、バッファーローカルな変数`fill-column`により指定されます。デフォルト値は70です([Locals](#Locals)を参照してください)。カレントバッファーの`fill-column`をセットする一番簡単な方法は、コマンド`C-x
f` (`set-fill-column`)を使用する方法です。数引数を指定すると、それを新しいフィル列として使用します。`C-u`だけを指定すると、このコマンドは現在のポイントの水平位置を`fill-column`にセットします。

M-o M-s (Text mode)
centering
center-line
コマンド`M-o M-s` (`center-line`)は、現在のフィル列でカレント行を中央に揃えます。数引数nを指定すると、nを中央に揃えた後、ポイントを先に移動します。このバインディングはTextモードのためのもので、利用可能なのはTextモードとそれに関連するモードだけです([Text Mode](#Text-Mode)を参照してください)。

デフォルトでは、Emacsは2つのスペースまたは改行が後にあるピリオドを、センテンスの終わりと判断します。後に1つのスペースしかないピリオドは、センテンスの終わりではなく、省略形を示します。それに合わせて、フィルコマンドも後に1つのスペースしかないピリオドでは、行を分割しません。変数`sentence-end-double-space`を`nil`にセットした場合、フィルコマンドは後に1つのスペースしかないピリオドでも行を分割するようになり、各ピリオドの後に1つのスペースを配すようになります。他の効果とこの方法の欠点については、[Sentences](#Sentences)を参照してください。

colon-double-space
変数`colon-double-space`が非`nil`の場合、フィルコマンドはコロンの後に2つのスペースを配します。

fill-nobreak-predicate
行分割を許さない場所の条件を追加で指定するには、アブノーマルフック変数`fill-nobreak-predicate`をカスタマイズします([Hooks](#Hooks)を参照してください)。このフックの各関数は、Emacsが行を分割すべきと判断する位置で、引数なしで呼び出されます。関数が非`nil`値を返した場合、Emacsはその位置で行を分割しません。このフックに指定できる関数には、`fill-single-word-nobreak-p`(センテンスの最初の単語の後ろ、および最後の単語の前では分割しません)、`fill-single-char-nobreak-p`(1文字の単語の後ろでは分割しません)、`fill-french-nobreak-p`(‘`(`’の後ろ、および‘`)`’、‘`:`’、‘`?`’の前では分割しません)が含まれます。

### フィルプレフィクス

fill prefix
フィルプレフィクス(fill prefix)機能により、フィルされるパラグラフの各行が、特別な文字列(インデントされたパラグラフの行頭につける複数のスペースなど)で開始されるようになります。フィルプレフィクスを明示的に指定することができます。明示的に指定しない場合、Emacsは自動的にそれを推測することを試みます([Adaptive Fill](#Adaptive-Fill)を参照してください)。

`C-x .`  
フィルプレフィクスをセットします(`set-fill-prefix`)。

`M-q`  
現在のフィルプレフィクスで、パラグラフをフィルします(`fill-paragraph`)。

`M-x fill-individual-paragraphs`  
リージョンをフィルします。インデントの変化は、新しいパラグラフの開始と判断されます。

`M-x fill-nonuniform-paragraphs`  
リージョンをフィルします。パラグラフを分割する行だけを、新しいパラグラフの開始と判断します。

C-x .
set-fill-prefix
カレントバッファーのフィルプレフィクスを指定するには、使用したいフィルプレフィクスで開始される行に移動して、プレフィクスの最後にポイントを配し、`C-x
.` (`set-fill-prefix`)とタイプします(`C-x`の後にピリオドです)。フィルプレフィクスをオフに切り替えるには、ポイントを行の先頭に移動して`C-x
.`とタイプして、空のフィルプレフィクスを指定します。

フィルプレフィクスの効果がある間、フィルコマンドはフィルを行う前にパラグラフの各行のフィルプレフィクスを削除して、フィルを行った後で各行にフィルプレフィクスを挿入します(パラグラフの最初の行は変更されずに残ります。これは他の行と異なるように意図されていることがよくあるからです)。Auto Fillモードは、新しい行を作成するときにフィルプレフィクスの自動的な挿入も行います([Auto Fill](#Auto-Fill)を参照してください)。`C-o`コマンドは、行の先頭で使用したときは、新しい行を作成してフィルプレフィクスを挿入します。コマンド`M-^`は逆に、削除する改行の後ろにフィルプレフィクスがあれば、プレフィクスを削除します。

たとえば`fill-column`が50で、フィルプレフィクスが‘`;;
`’の場合、以下のテキストにたいして`M-q`を行うと、

    ;; This is an
    ;; example of a paragraph
    ;; inside a Lisp-style comment.

結果は以下のようになります:

    ;; This is an example of a paragraph
    ;; inside a Lisp-style comment.

`M-q`およびパラグラフのコマンドは、フィルプレフィクスで開始されない行を、パラグラフの開始と判断します。これは、最初の行を除く各行がインデントされている形式のパラグラフにたいして、良い結果を与えます。空行、またはプレフィクスが削除されたインデントされた行も、パラグラフを分割または開始します。これは各行にコメント区切りがある、複数パラグラフにわたるコメントを記述するときに望ましいものです。

fill-individual-paragraphs
`M-x
fill-individual-paragraphs`を使用して、各パラグラフに自動的にフィルプレフィクスをセットできます。このコマンドはリージョンをパラグラフに分割して、インデントの変化を新しいパラグラフの開始として扱い、それらのパラグラフをフィルします。したがって1つのパラグラフのすべての行は、同じ量のインデントをもちます。このインデントは、そのパラグラフにたいするフィルプレフィクスの役目を果たします。

fill-nonuniform-paragraphs
`M-x
fill-nonuniform-paragraphs`も同様なコマンドですが、別の方法でリージョンをパラグラフに分割します。このコマンドは、(`paragraph-separate`で定義される)パラグラフ開始行だけを、新しいパラグラフの開始と判断します。これは1つのパラグラフの各行は異なる量のインデントをもつことを想定しており、パラグラフの中で最小のインデント量をフィルプレフィクスに使用します。このコマンドは最初の行のインデントが、パラグラフの他の行より少なくても多くても、良い結果をもたらします。

fill-prefix
フィルプレフィクスは、変数`fill-prefix`に保存されます。変数の値は文字列で、フィルプレフィクスがないときは`nil`です。これはバッファーごとの変数です。変数の変更はカレントバッファーだけに影響しますが、変更できるデフォルト値も存在します。[Locals](#Locals)を参照してください。

テキストプロパティー`indentation`は、パラグラフのインデント量を制御する別の方法を提供します。[Enriched Indentation](#Enriched-Indentation)を参照してください。

### 適応型フィル

adaptive filling
フィルコマンドは、特定なケースでは自動的に適切なフィルプレフィクスを推測できます。空白文字または特定の区切り文字が行の先頭にあり、それがパラグラフの全行に適用されている場合です。

パラグラフに2行以上の行がある場合は、2行目からフィルプレフィクスが取得されますが、それは1行目にもそれが存在する場合だけです。

パラグラフに1行しかない場合、フィルコマンドは、その行からフィルプレフィクスを取得する*かも*しれません。この決定は複雑です。なぜならそのような場合に妥当な、3つの選択肢があるからです。

-   最初の行のプレフィクスを、パラグラフのすべての行に適用します。

-   後続の行を空白文字でインデントします。これにより最初の行のプレフィクスの下にテキストが並びますが、実際には最初の行からプレフィクスをコピーしません。

-   2行目以降の行に特別なことは行いません。

これら3つの書式スタイルは一般的に使用されているものです。そのためフィルコマンドは、そのメジャーモードに出現するプレフィクスにもとづいて、望ましいスタイルを決定しようと試みます。判断基準は以下のとおりです。

adaptive-fill-first-line-regexp
最初の行で見つかったプレフィクスが`adaptive-fill-first-line-regexp`にマッチするか、それがコメント開始シーケンス(メジャーモードに依存します)の場合、見つかったプレフィクスをパラグラフのフィルに使用しますが、それは後続の行でそれらがパラグラフの開始として振る舞わない場合に限られます。

上記以外の場合、見つかったプレフィクスは同じ量のスペースに変換され、それらのスペースは残りの行のフィルプレフィクスとして使用されますが、それは後続の行でそれらがパラグラフの開始として振る舞わない場合に限られます。

Textモード、および空行またはページ区切りだけがパラグラフを分割するモードでは、適応型フィルにより選択されるプレフィクスは、パラグラフの開始として振る舞わないので、常にフィルに使用できます。

adaptive-fill-mode
adaptive-fill-regexp
変数`adaptive-fill-regexp`は、どのような行開始がフィルプレフィクスの役目を果たすかを決定します。行がこの正規表現にマッチする文字で開始されるとき、プレフィクスとして使用されます。変数`adaptive-fill-mode`を`nil`にセットした場合、フィルプレフィクスは自動的に選択されません。

adaptive-fill-function
変数`adaptive-fill-function`に関数をセットすることにより、より複雑な方法で自動的にフィルプレフィクスを選択する方法を指定できます。この関数は行の左端の直後のポイントで呼び出され、その行にもとづいた適切なフィルプレフィクスを返すべきです。この関数が`nil`を返した場合、`adaptive-fill-regexp`がフィルプレフィクスを見つける機会を与えられます。

大文字小文字変換コマンド
------------------------

case conversion
Emacsには、1つの単語または任意の範囲のテキストを、大文字または小文字に変換するコマンドがあります。

`M-l`  
後続の単語を小文字に変換します(`downcase-word`)。

`M-u`  
後続の単語を大文字に変換します(`upcase-word`)。

`M-c`  
後続の単語の先頭の文字を大文字に変換します(`capitalize-word`)。

`C-x C-l`  
リージョンを小文字に変換します(`downcase-region`)。

`C-x C-u`  
リージョンを大文字に変換します(`upcase-region`)。

M-l
M-u
M-c
words, case conversion
converting text to upper or lower case
capitalizing words
downcase-word
upcase-word
capitalize-word
`M-l` (`downcase-word`)は、ポイントの後ろの単語を小文字に変換して、その先にポイントを移動します。したがって、`M-l`を繰り返すと、単語を連続して変換します。`M-c` (`capitalize-word`)は、単語の最初の文字を大文字にして残りを小文字にしますが、`M-u` (`upcase-word`)はすべての文字を大文字に変換します。これらのコマンドはすべて、引数を与えると複数の単語を変換します。これらのコマンドはすべてが大文字の大きなテキストを、これらが混成されたものに変換するとき、特に有用です、なぜなら適切に`M-l`、`M-u`、`M-c`を使い分けて単語を変換しながら移動できるからです(変換が不要なときは`M-f`を使ってその単語をスキップします)。

負の引数を与えると。ポイントの前の指定した数の単語にたいして、大文字小文字の変換を適用しますが、ポイントは移動しません。これは大文字小文字を間違えてタイプしたとき有用です。大文字小文字の変換コマンドを実行した後、そのまま編集を続けられるからです。

単語の途中で単語の大文字小文字を変換するコマンドが与えられた場合、ポイントの後ろに続く単語の一部だけに変換が適用されます(これは`M-d` (`kill-word`)と互換性があります)。負の引数の場合は、ポイントの前にある単語の一部が変換されます。

C-x C-l
C-x C-u
downcase-region
upcase-region
他の大文字小文字の変換コマンドは`C-x C-u` (`upcase-region`)と`C-x C-l` (`downcase-region`)で、これらはポイントとマークの間にあるすべてのテキストを大文字または小文字に変換します。ポイントとマークは移動しません。

リージョンにたいする大文字小文字の変換コマンド`upcase-region`および`downcase-region`は、通常では無効になっています。これは、これらを使おうと試みたとき、確認を求められることを意味します。確認にたいして同意するとコマンドが有効になり、それ以降は確認を求められなくなることを意味します。[Disabling](#Disabling)を参照してください。

Textモード
----------

Text mode
mode, Text
text-mode
Textモードは、人間の言語のテキストファイルを編集するためのメジャーモードです。`.txt`という拡張子で終わる名前のファイルは、通常はTextモードで開かれます。明示的にTextモードに切り替えるには、`M-x
text-mode`とタイプしてください。

Textモードでは、改行とページ区切りだけがパラグラフを分割します。結果として、パラグラフはインデントすることができ、適応型フィルはパラグラフをフィルするときに、どのインデントが使用されているか決定します。[Adaptive Fill](#Adaptive-Fill)を参照してください。

TAB (Text mode)
TextモードではTAB (`indent-for-tab-command`)コマンドは通常、カレント行をインデントするかわりに、次のタブストップまで空白文字を挿入します。詳細については、[Indentation](#Indentation)を参照してください。

Textモードは、明示的にそれらを呼び出した場合をのぞき、コメントに間する機能をオフに切り替えます。これは構文テーブル(syntax table)を変更するので、アポストロフィーは単語の一部と判断されます(たとえば‘`don't`’は1つの単語と判断されます))。しかし単語がアポストロフィーで開始される場合、それは先頭の文字を大文字にするためのプレフィクスとして扱われます(たとえば`M-c`により、‘`'hello'`’は‘`'Hello'`’に変換されます)。

Paragraph-Indent Text mode
mode, Paragraph-Indent Text
paragraph-indent-text-mode
paragraph-indent-minor-mode
パラグラフの最初の行をインデントしている場合は、TextモードではなくParagraph-Indent Textモード(`M-x
paragraph-indent-text-mode`)を使用するべきでしょう。このモーででは、パラグラフの間に空行を入れる必要はありません。最初の行のインデントだけでパラグラフの開始を判断するのに充分だからです。しかしパラグラフのすべての行がインデントされている場合は、サポートされません。メジャーモードを変更したくないとき(たとえばメール作成時など)は、`M-x
paragraph-indent-minor-mode`を使って、等価なマイナーモードを有効にしてください。

M-TAB (Text mode)
Textモードでは、`M-TAB`が`ispell-complete-word`にバインドされます。このコマンドはバッファーのポイントの前にある単語を、スペル辞書を使用して補完します。[Spelling](#Spelling)を参照してください。ウィンドウマネージャーが`M-TAB`をウィンドウの切り替えに定義している場合は、かわりに`ESC
TAB`または`C-M-i`とタイプすることができます。

text-mode-hook
Textモードに入ると、モードフック`text-mode-hook`が実行されます([Major Modes](#Major-Modes)を参照してください)。

以下のセクションでは、Textモードから派生したいくつかのメジャーモードを説明します。派生したモードは、上記で説明したTextモードのほとんどの機能を継承します。とくに、Textモードから派生したモードは、それら自身のモードフックの前に、`text-mode-hook`を実行します。

Outlineモード
-------------

Outline mode
mode, Outline
invisible lines
outline-mode
outline-minor-mode
outline-minor-mode-prefix
outline-mode-hook
OutlineモードはTextモードから派生したメジャーモードで、アウトライン(outline: 概略、概要、要綱)を編集するために特化したモードです。このモードはアウトライン構造のエントリー間を操作したり、バッファーの一部を一時的に非表示にするコマンドを提供するので、アウトライン構造をより簡単に閲覧することができるでしょう。`M-x
outline-mode`とタイプすることにより、Outlineモードに切り替わります。Outlineモードに入ることにより、フック`text-mode-hook`、およびそれに続けてフック`outline-mode-hook`が実行されます([Hooks](#Hooks)を参照してください)。

Outlineモードで行を非表示にするコマンド([Outline Visibility](#Outline-Visibility)を参照してください)を使用した場合、それらの行は画面に表示されなくなります。非表示行の前にある表示された行の後ろには省略記号(3つのピリオド)が表示され、そこに隠れたテキストがあることを示します。連続する複数の行を非表示にした場合も、省略記号は1つだけです。

`C-n`や`C-p`のような、複数の行にたいして操作を行う編集コマンドは、非表示の行のテキストを、その前にある表示された行の一部として扱います。表示された行の最後にある省略記号をkillすると、省略記号に対応する後続のすべての非表示テキストを実際にkillします。

Outline minorモードは、メジャーモードであるOutlineモードと同じコマンドを提供する、バッファーローカルなマイナーモードで、他のメジャーモードと合わせて使うことができます。`M-x
outline-minor-mode`とタイプして、カレントバッファーにたいしてOutline minorモードを切り替えることができます。ファイルローカル変数のセッティングを使用して、特定のファイルにたいして有効にすることもできます([File Variables](#File-Variables)を参照してください)。

C-c @ (Outline minor mode)
メジャーモードのOutlineモードは、`C-c`プレフィクスで特別なキーバインディングを提供します。Outline minorモードは、`C-c
@`プレフィクスで同様なバインディングを提供します。これは他のメジャーモードの特別なコマンドとの競合を減らすためです(変数`outline-minor-mode-prefix`は、使用するプレフィクスを制御します)。

### アウトラインのフォーマット

heading lines (Outline mode)
body lines (Outline mode)
Outlineモードは、バッファーの行には2つのタイプがあると仮定します。それはヘッダー行(heading lines)とボディー行(body lines)です。ヘッダー行はアウトラインのトピックを表します。ヘッダー行は1つ以上のアスタリスク文字(‘`*`’)で開始されます。アスタリスクの数はアウトライン構造でのヘッダーの深さを決定します。したがって1つの‘`*`’がついたトピックは、メジャーなトピックになります。このヘッダーと、次の‘`*`’が1つのヘッダーの間にある、‘`*`’が2つのヘッダー行は、そのヘッダーのサブトピックです。ヘッダー行ではないすべての行はボディー行です。ボディー行は、それの前にあるヘッダー行に属します。以下は例です:

    * Food
    This is the body,
    which says something about the topic of food.

    ** Delicious Food
    This is the body of the second-level header.

    ** Distasteful Food
    This could have
    a body too, with
    several lines.

    *** Dormitory Food

    * Shelter
    Another first-level topic with its header line.

ヘッダー行とそれに属するすべてのボディー行を合わせて、エントリー(entry)と呼びます。ヘッダー行と、その配下にあるすべてのヘッダー行、それらすべてのボディー行を、サブツリー(subtree)と呼びます。

outline-regexp
ヘッダー行と判別する条件は、変数`outline-regexp`をセットすることによりカスタマイズできます(これを行う推奨された方法は、メジャーモードの関数を使うか、ファイルローカル変数を使う方法です)。行の開始がこのregexpにマッチする行は、ヘッダー行と判断されます。(行の左端ではなく)行の途中でのマッチは勘定に入りません。

テキストにたいするマッチの長さは、ヘッダーのレベルを決定します。長いマッチは、より深くネストされたレベルとなります。‘`@chapter`’、‘`@section`’、‘`@subsection`’というコマンドが、ドキュメントをチャプター、セクション、サブセクションに分割するようなテキストフォーマッターがある場合(訳注: texinfo形式のこと)、`outline-regexp`に‘`"@chap\\|@\\(sub\\)*section"`’をセットすることにより、それらの行をヘッダー行と判断させることができます。ここでトリックに注意してください。2つの単語‘`chapter`’と‘`section`’は同じ長さです。しかしregexp‘`chap`’だけにマッチするように定義することによって、チャプターのヘッダーにマッチするテキストの長さを短くすることができるので、Outlineモードはセクションがチャプターの配下であることを知ることができます。これは‘`@chap`’で始まるコマンドが他にない場合に限り機能します。

outline-level
変数`outline-level`をセットすることにより、ヘッダー行のレベルを計算するためのルールを明示できに指定できます。`outline-level`の値には、引数をとらないカレントヘッダーのレベルを返す関数を指定します。この変数をセットする推奨された方法は、メジャーモードのコマンドを使うか、ファイルローカル変数を使用する方法です。

### アウトライン移動コマンド

Outlineモードはヘッダー行を後方または前方に移動する、特別な移動コマンドを提供します。

`C-c C-n`  
outline-next-visible-heading

C-c C-n (Outline mode)

ポイントを次の可視なヘッダー行に移動します(`outline-next-visible-heading`)。

`C-c C-p`  
outline-previous-visible-heading

C-c C-p (Outline mode)

ポイントを前の可視なヘッダー行に移動します(`outline-previous-visible-heading`)。

`C-c C-f`  
outline-forward-same-level

C-c C-f (Outline mode)

ポイントを同じレベルの、次の可視なヘッダー行に移動します(`outline-forward-same-level`)。

`C-c C-b`  
outline-backward-same-level

C-c C-b (Outline mode)

ポイントを同じレベルの、前の可視なヘッダー行に移動します(`outline-backward-same-level`)。

`C-c C-u`  
outline-up-heading

C-c C-u (Outline mode)

ポイントを、より低い(より包括的な)レベルの可視のヘッダー行に移動します(`outline-up-heading`)。

上記のコマンドはすべて、繰り返し回数として数引数を受け取ります。たとえば、`C-c
C-f`に引数を与えると、その数だけ前方の可視なヘッダー行と同じレベルに移動し、`C-c
C-u`に引数を与えると、ネストされたレベルをその数のレベル抜け出して移動します。

### アウトライン表示コマンド

Outlineモードには、アウトライン構造にもとづいてバッファーの一部を一時的に非表示にしたり可視にするコマンドが、いくつかあります。これらのコマンドはアンドゥ可能ではありません。コマンドの効果は単純にアンドゥメカニズムに記録される訳ではありませんが、それらを実行した直後に限りアンドゥできます([Undo](#Undo)を参照してください)。

これらのコマンドは、カレントのヘッダー行に作用します。ポイントがヘッダー行にある場合、それがカレントのヘッダー行です。ポイントがボディー行にある場合、カレントヘッダー行は一番近くの前にあるヘッダー行です。

`C-c C-c`  
カレントヘッダー行のボディーを非表示にします(`outline-hide-entry`)。

`C-c C-e`  
カレントヘッダー行のボディーを可視にします(`outline-show-entry`)。

`C-c C-d`  
カレントヘッダー行の配下のすべて(ヘッダー行自身は含まれません)を非表示にします(`outline-hide-subtree`)。

`C-c C-s`  
カレントヘッダー行の配下のすべて(ボディー、サブヘッダーおよびそのボディーを含む)を可視にします(`outline-show-subtree`)。

`C-c C-l`  
カレントヘッダー行のボディーと、すべてのサブヘッダーを非表示にします(`outline-hide-leaves`)。

`C-c C-k`  
カレントヘッダー行のサブヘッダーをすべてのレベルで可視にします(`outline-show-branches`)。

`C-c C-i`  
カレントヘッダー行の一番近いサブヘッダー(1レベル下)を可視にします(`outline-show-children`)。

`C-c C-t`  
バッファーのすべてのボディー行を非表示にします(`outline-hide-body`)。

`C-c C-a`  
バッファーのすべての行を可視にします(`outline-show-all`)。

`C-c C-q`  
上位nレベルのヘッダー行を除き、すべてを非表示にします(`outline-hide-sublevels`)。

`C-c C-o`  
ポイントのあるヘッダー行またはボディー行と、そこから最上位までのレベルにあるヘッダーを除き、すべてを非表示にします(`outline-hide-other`)。

outline-hide-entry
outline-show-entry
C-c C-c (Outline mode)
C-c C-e (Outline mode)
これらのコマンドのうち、カレントヘッダー行に直接続くボディー行を非表示にする`C-c C-c` (`outline-hide-entry`)と、それらを可視にする`C-c C-e` (`outline-show-entry`)が一番簡単なコマンドです。サブヘッダーとそれらのボディーは影響を受けません。

outline-hide-subtree
outline-show-subtree
C-c C-s (Outline mode)
C-c C-d (Outline mode)
subtree (Outline mode)
コマンド`C-c C-d` (`outline-hide-subtree`)および`C-c C-s` (`outline-show-subtree`)は、より強力です。これらはカレントヘッダー行のサブツリー — つまりカレントヘッダー行のボディーと、すべての直接または間接のサブヘッダーとそのボディー — に適用されます。

outline-hide-leaves
outline-show-branches
outline-show-children
C-c C-l (Outline mode)
C-c C-k (Outline mode)
C-c C-i (Outline mode)
コマンド`C-c C-l` (`outline-hide-leaves`)は、カレントヘッダー行のボディーと、サブツリーのボディーをすべて非表示にします(サブヘッダー自身は表示されます)。コマンド`C-c
C-k` (`outline-show-branches`)は、(たとえば`C-c
C-d`)などで)前に非表示にされたサブヘッダーを可視にします。コマンド`C-c C-i` (`outline-show-children`)はこれの穏やかなバージョンで、直接的なサブヘッダー(たとえば1レベル下のサブヘッダー)を可視にします。

outline-hide-other
C-c C-o (Outline mode)
コマンド`C-c C-o` (`outline-hide-other`)は、ポイントのあるエントリーと、その祖先(アウトライン構造上でそこから最上位レベルに至るまでのヘッダー)、およびトップレベルのヘッダーを除き、すべてを非表示にします。このコマンドは、そのバッファーの最初のヘッダーの前のボディー行も表示します。

outline-hide-body
outline-show-all
C-c C-t (Outline mode)
C-c C-a (Outline mode)
hide-sublevels
C-c C-q (Outline mode)
残りのコマンドは、バッファー全体に作用するコマンドです。`C-c C-t` (`outline-hide-body`)はすべてのボディー行を非表示にするので、アウトライン構造だけを見ることができます(特別な例外として、ファイルの最初にあるヘッダー行より前の行は、技術的に言うとボディー行ですが、これらは非表示になりません)。`C-c
C-a` (`outline-show-all`)はすべての行を可視にします。`C-c C-q` (`outline-hide-sublevels`)は、カレントのヘッダー行(ポイントがヘッダー行にないときのデフォルトは1行目)の位置、またはその上にある最上位のヘッダーを除き、すべてを非表示にします。数引数nを指定すると、上位nレベルのヘッダー行を除き、すべてを非表示にします。この場合、上位nレベルと、最初のヘッダーの前のボディー行が表示されることに注意してください。

reveal-mode
search-invisible
インクリメンタル検索が、Outlineモードにより非表示にされたテキストを検索したとき、検索された部分のバッファーは可視になります。その位置で検索を抜けると、テキストは可視のまま残ります。アクティブなインクリメンタル検索が、非表示のテキストにマッチするかを切り替えるには、`M-s
i`とタイプします。将来の検索にたいしてデフォルトを変更するには、オプション`search-invisible`をカスタマイズします(このオプションは`query-replace`、および関連する機能が非表示のテキストを扱う方法に影響を与えます。[Query Replace](#Query-Replace)を参照してください)。バッファーローカルなマイナーモードRevealモード(`M-x
reveal-mode`)を使用して、操作にしたがって自動的にテキストを可視にもできます。

### 複数ビューによるアウトラインの閲覧

multiple views of outline
views of an outline
outline with multiple views
indirect buffers and outlines
1つのアウトラインを同時に2つのビューで、別のウィンドウで表示することができます。これを行うには、`M-x
make-indirect-buffer`を使ってインダイレクトバッファーを作らなければなりません。このコマンドの最初の引数は既存のアウトラインバッファーの名前で、2番目の引数は新しくインダイレクトバッファーとして使用する名前です。[Indirect Buffers](#Indirect-Buffers)を参照してください。

1度インダイレクトバッファーが作成されると、`C-x 4
b`や他のEmacsコマンドで、通常のやり方でウィンドウにそれを表示できます。テキストの一部を可視にしたり非表示にするOutlineモードのコマンドは、それぞれのバッファーで独立したエントリーを操作し、それぞれのバッファーは独自のビューをもつことができます。同じアウトラインにたいして2つ以上のビューが欲しいときは、追加でインダイレクトバッファーを作成します。

### 折り畳み編集

folding editing
Foldoutパッケージは、OutlineモードおよびOutline minorモードを、フォールディング(folding: 折り畳み)コマンドで拡張します。フォールディングのアイデアは、アウトラインのネストされた部分にたいして、それに関連する部分と、より高いレベルが非表示のときに、それにズームインするというものです。

すべてのテキストと、レベル1より下のレベルが非表示になっているOutlineモードのバッファーを考えてください。それらのヘッダーの下に何が隠れているか見るには、`C-c
C-e` (`M-x outline-show-entry`)でボディーを可視にするか、`C-c
C-i`でその子ヘッダー(レベル2)を可視にすることができます。

C-c C-z
foldout-zoom-subtree
Foldoutでは、`C-c C-z` (`M-x
foldout-zoom-subtree`)を使います。これはそのヘッダーのボディーと、その子サブヘッダーを可視にして、バッファーをナローイングするので、レベル1にヘッダーとボディー、それにレベル2のヘッダーだけが可視になります。そのうちの1つのレベル2ヘッダーの下を見るには、カーソル位置をそのヘッダーに移動して、もう一度`C-c
C-z`を使用します。これにより、そのレベル2ヘッダーのボディーと、レベル3の子サブヘッダーが可視になり、バッファーが再びナローイングされます。連続して好きなだけサブヘッダーをズームインすることができます。モードラインの文字列には、今どの深さにいるのかが表示されます。

ヘッダーにズームインしているときに、それらの子サブヘッダーを見るには`C-u C-c
C-z`のように数引数を指定します。何レベル下の子かを指定することもできます(`M-x
outline-show-children`に相当します)。たとえば`M-2 C-c
C-z`は2レベルの子サブヘッダーを可視にします。ボディーを指定するには`M-- C-c
C-z`のように負の引数を指定します。`C-c C-s` (`M-x
outline-show-subtree`)のようにサブツリー全体を展開するには、`M-0 C-c
C-z`のように引数に0を指定します。

ズームインしている時でも、Outlineモードの表示および非表示の関数は、Foldoutに干渉せずに使用できます。バッファーがナローイングされているので、グローバルな編集操作は、ズームインされたヘッダーのテキストだけに影響します、これは特定のチャプターやセクションに変更を限定するのに便利です。

C-c C-x
foldout-exit-fold
フォールドのズームを取り消す(抜ける)には、`C-c C-x` (`M-x
foldout-exit-fold`)を使用します。これは最上位レベルのヘッダーの配下のすべてのテキストと、サブヘッダーを非表示にして、バッファーの以前のビューに戻ります。数引数はフォールドを何レベル抜けるかを指定します。0を指定するとすべてのフォールドを抜けます。

テキストとサブヘッダーを非表示にせずに、フォールドのナローイングを取り消すには、負の引数を指定します。たとえば、`M--2 C-c
C-x`は2つのフォールドを抜け出し、テキストとサブヘッダーは表示されたままにします。

Foldoutモードはフォールドへの出入りと、非表示のテキストを表示するためのマウスコマンドも提供します:

`C-M-mouse-1`でヘッダーをクリックするとズームインします。  
-   シングルクリック: ボディーを可視にします。

-   ダブルクリック: サブヘッダーを可視にします。

-   トリプルクリック: ボディーとサブヘッダーを可視にします。

-   4連クリック: サブツリー全体を可視にします。

`C-M-mouse-2`でヘッダーをクリックしたときは可視になります  
-   シングルクリック: ボディーを可視にします。

-   ダブルクリック: サブヘッダーを可視にします。

-   トリプルクリック: ボディーとサブヘッダーを可視にします。

-   4連クリック: サブツリー全体を可視にします。

`C-M-mouse-3`でヘッダーをクリックすると、ヘッダーの配下のテキストを非表示にするか、フォールドを抜けます  
-   シングルクリック: サブツリーを非表示にします。

-   ダブルクリック: フォールドを抜けてテキストを非表示にします。

-   トリプルクリック: テキストを非表示にせずにフォールドを抜けます

-   4連クリック: すべてのフォールドを抜けてテキストを非表示にします。

foldout-mouse-modifiers
`foldout-mouse-modifiers`をセットすることにより、(`Ctrl-Meta-`のかわりに)他の修飾キーを指定できます。すでに`foldout.el`ライブラリーがロードされている場合、これが効果をもつために再ロードしなければなりません。

Foldoutパッケージを使用するには、`M-x load-library RET foldout
RET`とタイプするか、initファイルに以下の行を記述して自動的にこれを行うことができます。

    (with-eval-after-load "outline"
      (require 'foldout))

Orgモード
---------

organizer
planner
Org mode
mode, Org
org-mode
Orgモードは、Emacsをオーガナイザーおよび／またはオーサリングツールとして使用するための、Outlineモードの変種です。名前が拡張子`.org`で終わるファイルは、Orgモードで開かれます([Choosing Modes](#Choosing-Modes)を参照してください)。明示的にOrgモードに切り替えるには、`M-x org-mode`とタイプしてください。

Orgモードでは、Outlineモードのように、各エントリーは1つ以上の‘`*`’文字で始まるヘッダー行をもちます。[Outline Format](#Outline-Format)を参照してください。それに加えて、‘`#`’文字で始まる行は、コメントとして扱われます。

TAB (Org Mode)
org-cycle
Orgモードは、簡単にアウトライン構造を眺めたり操作するためのコマンドを提供します。それらのコマンドのうち、一番簡単なのはTAB (`org-cycle`)です。ヘッダー行でこのコマンドを呼び出すと、サブツリーを — (i)ヘッダー行だけを表示 (ii)ヘッダー行と、(あれば)直接の子ヘッダー行だけを表示 (iii)サブツリー全体を表示 — の3つの異なる視点で巡回します。ボディー行にたいして呼び出された場合、TABにグローバルにバインドされたコマンドが実行されます。

S-TAB (Org Mode)
org-shifttab
Orgモードのバッファーの任意の場所で、`S-TAB` (`org-shifttab`)とタイプすることにより、アウトライン構造全体を — (i) 最上位ㇾベルのヘッダー行だけを表示 (ii)ボディー行を除いたすべてのヘッダー行を表示 (iii) すべてを表示 — の3つの異なる視点で巡回します。

M-UP (Org Mode)
M-DOWN (Org Mode)
M-LEFT (Org Mode)
M-RIGHT (Org Mode)
org-metaup
org-metadown
org-metaleft
org-metaright
ヘッダー行で`M-<UP>` (`org-metaup`)または`M-<DOWN>` (`org-metadown`)とタイプすることにより、ボディー行と(あれば)サブツリーを含むバッファー内のエントリー全体を、上または下に移動できます。同様に`M-<LEFT>` (`org-metaleft`)および`M-<RIGHT>` (`org-metaright`)で、ヘッダー行を昇格または降格できます。ボディー行で呼び出された場合は、それらのキーにグローバルにバインドされたコマンドが実行されます。

以下のサブセクションでは、オーガナイザーやオーサリングシステムとしてOrgモードを使用するための基本的な操作方法を解説します。詳細については、section “Introduction” in The Org Manualを参照してください。

### オーガナイザーとしてのOrg

TODO item
Org agenda
C-c C-t (Org Mode)
org-todo
org-todo-keywords
エントリー内のどこかで`C-c C-t` (`org-todo`)とタイプすることにより、そのOrgエントリーをTODOアイテムとして、タグ付けすることができます。これはヘッダー行にキーワード‘`TODO`’を追加します。もう一度`C-c
C-t`をタイプするとキーワードは‘`DONE`’に切り替わり、さらに`C-c
C-t`とタイプするとキーワード全体を除去します。`C-c
C-t`で使用されるキーワードは、変数`org-todo-keywords`を通じてカスタマイズすることができます。

C-c C-s (Org Mode)
C-c C-d (Org Mode)
org-schedule
org-deadline
エントリーをTODOとして作成する他に、エントリー内で`C-c C-s` (`org-schedule`)とタイプすることにより、日付を割り当てることができます。これはEmacs Calender([Calendar/Diary](#Calendar_002fDiary)を参照してください)をポップアップして日付の入力を求め、選択された日付と一緒に、ヘッダー行の下にタグ‘`SCHEDULED`’を追加します。コマンド`C-c
C-d` (`org-deadline`)も、タグ`DEADLINE`を使う以外は同じ効果をもちます。

C-c \[ (Org Mode)
org-agenda-file-to-front
org-agenda-files
1度Orgファイルに計画されたTODOアイテムをもつと、`C-c [` (`org-agenda-file-to-front`)とタイプすることにより、アジェンダファイル(agenda files)のリストにそのファイルを追加できます。Orgモードは、たとえばあなたの生活のさまざまな側面をオーガナイズするために、複数のアジェンダファイルを簡単に保守できるようにデザインされています。アジェンダファイルのリストは、変数`org-agenda-files`に格納されています。

org-agenda
アジェンダファイルのアイテムを閲覧するには、`M-x
org-agenda`とタイプします。このコマンドは何を見たいのか、入力を求めます(今週に行なうすべての事項のリストか、特定のキーワードにマッチするTODOアイテムのリストか、など)。 詳細は、section “Agenda views” in The Org Manualを参照してください。

### オーサリングシステムとしてのOrg

Org exporting
org-export
C-c C-e (Org mode)
Orgノートを見映えよくフォーマットしたり、エクスポートして公表したいと思うかもしれません。カレントバッファーをエクスポートするには、Orgバッファーのどこかで`C-c
C-e` (`org-export`)とタイプします。このコマンドはエクスポートするフォーマットの入力を求めます。現在サポートされているフォーマットは、HTML、LATEX、Texinfo、OpenDocument(`.odt`)、iCalendar、Markdown、man-page、PDFです。PDFのようないくつかのフォーマットは、システムに特定のツールがインストールされている必要があります。

org-publish-project-alist
1度に複数のファイルを特定のディレクトリー(ローカルまたはネットワーク越し)にエクスポートするには、変数`org-publish-project-alist`にプロジェクトのリストを定義しなければなりません。詳細はOrgのドキュメントを参照してください。

Orgはエクスポートされたドキュメントのテキストのフォーマットに適用する、シンプルなマークアップの仕組みをサポートします:

    - This text is /emphasized/
    - This text is *in bold*
    - This text is _underlined_
    - This text uses =a teletype font=

    #+begin_quote
    ``This is a quote.''
    #+end_quote

    #+begin_example
    This is an example.
    #+end_example

詳細は、section “Exporting” in The Org Manual、およびsection “Publishing” in The Org Manualを参照してください。

TEXモード
---------

TEX mode
LATEX mode
SliTEX mode
DocTEX mode
mode, TEX
mode, LATEX
mode, SliTEX
mode, DocTEX
tex-mode
plain-tex-mode
latex-mode
slitex-mode
doctex-mode
bibtex-mode
TEXはDonald Knuthにより記述された強力なテキストフォーマッターで、GNU Emacsと同様、フリーなソフトウェアーです。TEXフォーマットにはいくつかの変種があります。LATEXはTEXのための簡略化された入力フォーマットです。DocTEXはLATEXソースが記述された特別なファイルフォーマットであり、ソースとドキュメントが合成されています。SliTEXは、時代遅れの特別なLATEX形式です。[12]

tex-default-mode
Emacsは、それらの変種用にTEXのメジャーモードを提供します。それはPlain TEXモード、LATEXモード、DocTEXモード、SliTEXモードです。Emacsはバッファーの内容を調べて、適切なモードを選択します(通常これはTEX様式のファイルをvisitしたときに自動的に呼び出される`tex-mode`コマンドにより行われる。[Choosing Modes](#Choosing-Modes)を参照されたい)。ファイル内容がこれを決定するのに不十分な場合、Emacsは`tex-default-mode`に指定されたモードを選択します。デフォルト値は`latex-mode`です。Emacsが間違った選択をしたときは、コマンド`M-x
plain-tex-mode`、`M-x latex-mode`、`M-x
slitex-mode`、`doctex-mode`を使用して、正しいTEXモードの変種を選択できます。

以下のセクションでは、TEXモードとその変種の機能について記述しています。TEXに関連したモードは他にもいくつかありますが、このマニュアルには記述されていません。

-   BibTEXモードはBibTEXファイルのためのメジャーモードで、これは一般的にはLATEX文書の図書目録リファレンスを維持するのに使用されます。詳細については、コマンド`bibtex-mode`のドキュメント文字列を参照してください。

-   RefTEXパッケージは、図書目録リファレンスを管理するLATEXモードとして使用されるマイナーモードを提供します。 詳細については、Emacsとともに配布されているRefTEXのInfoマニュアルを参照してください。

-   AUCTEXパッケージは、TEXおよびそれに関連するフォーマットを編集するための。より先進的な機能を提供します。これにはEmacsバッファーでTEXをプレビューする機能も含まれます。BibTEXモードやRefTEXパッケージとは異なり、AUCTEXはデフォルトではEmacsとともには配布されません。これはPackageメニュー([Packages](#Packages)を参照してください)を通じてダウンロードできます。インストールされた後に、 パッケージに含まれるAUCTEXマニュアルを参照してください。

### TEX編集コマンド

`"`  
コンテキストに応じて‘``` `` ```’、‘`"`’、‘`''`’のどれかを挿入します(`tex-insert-quote`)。

`C-j`  
パラグラフの区切り(2つの改行)を挿入して、前のパラグラフのバランスの取れていない大カッコ(braces)やドル記号をチェックします(`tex-terminate-paragraph`)。

`M-x tex-validate-region`  
リージョン内のパラグラフの、バランスのとれていない大カッコやドル記号をチェックします。

`C-c {`  
‘`{}`’を挿入して、ポイントをその間に配します(`tex-insert-braces`)。

`C-c }`  
対応が取れていない、次の閉じ大カッコの後ろに、前方に移動します(`up-list`)。

tex-insert-quote
" (TEX mode)
TEXでは文字‘`"`’は通常使用されません。かわりに‘``` `` ```’で始まり‘`''`’で終わる引用が使用されます。したがってTEXモードは`"`キーを`tex-insert-quote`コマンドにバインドしています。これは空白文字または開き大カッコの後ろに‘``` `` ```’、バックスラッシュの後に‘`"`’、それ以外の文字の場合は‘`''`’を挿入します。

特別な例外として、ポイントの前のテキストが‘``` `` ```’か‘`''`’のときに`"`をタイプすると、Emacsは前のテキストを1つの`"`で置き換えます。したがって、必要がある時は`""`とタイプして‘`"`’を挿入できます(`C-q
"`を使用してこの文字を挿入することもできます)。

TEXモードでは、‘`$`’は特別な構文コードを持っていて、それはTEXの数式モードの区切りを理解しようと試みます。数式モードを抜けるために‘`$`’を入力した場合、数式モードに入るための対応する‘`$`’の位置が1秒間表示されます。これは閉じ大カッコが挿入されたとき、それに対応する開き大カッコが表示されるのと同じき機能です。しかし‘`$`’が数式モードに入るためなのか、それとも抜けるためなのかを指示する方法はありません。したがって、もし対応するものがある場合、実際にはそれが関係なくても、前の‘`$`’の位置が表示されます。

tex-insert-braces
C-c { (TEX mode)
up-list
C-c } (TEX mode)
TEXは大カッコを、対応が取れていなければならない区切りとして使用します。これを1つずつ挿入するより、つねに大カッコの対応が取られている方を好むユーザーもいます。`C-c
{` (`tex-insert-braces`)を使うと、対になった大カッコを挿入します。これはポイントを2つの大カッコの間に配すので、中のテキストを挿入することができます。その後でコマンド`C-c
}` (`up-list`)を使用すると、前方の閉じ大カッコの先に移動します。あるテキストをマークした後に`C-c
{`を呼び出すこともでき、その場合このコマンドはマークされたテキストを大カッコで括ります。

tex-validate-region
tex-terminate-paragraph
C-j (TEX mode)
対応の取れていない大カッコをチェックするコマンドが2つあります。`C-j` (`tex-terminate-paragraph`)は、ポイントの前のパラグラフをチェックして、新しいパラグラフを開始するための2つの改行を挿入します。対応が取れていないものが見つかった場合、エコーエリアにメッセージを出力します。`M-x
tex-validate-region`はリージョンを、パラグラフごとにチェックします。エラーは`*Occur*`バッファーにリストされます。そのバッファーでは、特定のミスマッチをvisitする`C-c
C-c`などの、通常のOccurモードのコマンドを使用できます([Other Repeating Search](#Other-Repeating-Search)を参照してください)。

TEXのEmacsコマンドは大カッコだけではなく、角カッコ(square brackets)やカッコ(parentheses)などもカウントすることに注意してください。これはTEX構文をチェックする目的としては、厳密に正しいとは言えません。しかしカッコと角カッコはテキストの中で、同じような対応の取れた区切りとして使用され、さまざまな移動コマンドや、対応する区切りの表示が、それらにたいして機能するのは便利なのです。

### LATEX編集コマンド

LATEXモードは、plain TEXには適用できない特別な機能をいくつか提供します:

`C-c C-o`  
LATEXブロックのための‘`\begin`’と‘`\end`’を挿入して、ポイントをそれらの間の行に配します(`tex-latex-block`)。

`C-c C-e`  
まだ閉じていない一番内側のLATEXブロックを閉じます(`tex-close-latex-block`)。

tex-latex-block
C-c C-o (LATEX mode)
LATEX入力では、テキストをブロック化するのに‘`\begin`’と‘`\end`’のタグが使用されます。ブロックを挿入するには`C-c
C-o` (`tex-latex-block`)とタイプします。これはブロックタイプの入力を求め、適切な対応する‘`\begin`’と‘`\end`’を挿入し、その2行の間に空行を残してポイントをそこに移動します。

latex-block-names
`C-c
C-o`にたいしてブロックタイプを入力するとき、通常の補完コマンドを使用できます([Completion](#Completion)を参照してください)。デフォルトの補完リストには、標準的なLATEXのブロックタイプが含まれています。補完にブロックタイプを追加したい場合は、リスト変数`latex-block-names`をカスタマイズしてください。

tex-close-latex-block
C-c C-e (LATEX mode)
latex-electric-env-pair-mode
LATEX入力では、‘`\begin`’と‘`\end`’のタグは対応が取れていなければなりません。`C-c C-e` (`tex-close-latex-block`)により、対応が取れていない最後の‘`\begin`’に対応する‘`\end`’を挿入することができます。これは対応する‘`\begin`’に調和するように‘`\end`’をインデントし、ポイントが行の先頭にあるときは‘`\end`’タグの後ろに改行を挿入します。マイナーモード`latex-electric-env-pair-mode`は、‘`\end`’か‘`\begin`’の一方をタイプしたとき、自動的に対応する‘`\end`’または‘`\begin`’を挿入します。

### TEX印刷コマンド

バッファーの全内容、または一部(たとえば大きなドキュメントの1つのチャプター)にたいして、TEXをEmacsのサブプロセスとして呼び出すことができます。

`C-c C-b`  
カレントバッファー全体にたいしてTEXを呼び出します(`tex-buffer`)。

`C-c C-r`  
バッファーのヘッダーとともに、カレントリージョンにたいしてTEXを呼び出します(`tex-region`)。

`C-c C-f`  
カレントファイルにたいしてTEXを呼び出します(`tex-file`)。

`C-c C-v`  
最後の`C-c C-b`、`C-c C-r`、`C-c
C-f`コマンドの出力をプレビューします(`tex-view`)。

`C-c C-p`  
最後の`C-c C-b`、`C-c C-r`、`C-c C-f`コマンドの出力を印刷します(`tex-print`)。

`C-c TAB`  
カレントファイルにたいしてBibTEXを呼び出します(`tex-bibtex-file`)。

`C-c C-l`  
TEX出力を表示するウィンドウを再センタリングして、最後の行が見えるようにします(`tex-recenter-output-buffer`)。

`C-c C-k`  
TEXサブプロセスをkillします(`tex-kill-job`)。

`C-c C-c`  
カレントバッファー全体にたいして、他のコンパイルコマンドを呼び出します(`tex-compile`)。

tex-buffer
C-c C-b (TEX mode)
tex-view
C-c C-v (TEX mode)
tex-print
C-c C-p (TEX mode)
カレントバッファーをTEXに渡すには、`C-c C-b` (`tex-buffer`)とタイプします。フォーマットされた出力は、通常`.dvi`という一時ファイルに出力されます。その後で`C-c
C-v` (`tex-view`)とタイプして、`xdvi`のような外部プログラムを起動して、出力ファイルを閲覧することができます。`C-c
C-p` (`tex-print`)とタイプして出力ファイルのハードコピーを印刷することもできます。

TEXINPUTS
environment variable
tex-directory
デフォルトでは`C-c
C-b`は、カレントディレクトリーでTEXを実行します。TEXの出力もこのディレクトリーに作成されます。TEXを違うディレクトリーで実行するには、変数`tex-directory`を望むディレクトリー名に変更します。環境変数TEXINPUTSに相対名が含まれていたり、ファイルに含まれる‘`\input`’コマンドが相対ファイル名の場合、`tex-directory`を`"."`に*しないと*、望ましくない結果となるでしょう。そうでない場合は、`"/tmp"`などの他のディレクトリーを指定しても安全です。

tex-run-command
latex-run-command
tex-dvi-view-command
tex-dvi-print-command
tex-print-file-extension
そのバッファーにたいするTEXの変種は、`C-c C-b`で実際に実行されるシェルコマンドを決定します。Plain TEXモードでは、これは変数`tex-run-command`で指定され、デフォルトは`"tex"`です。LATEXモードでは、これは`latex-run-command`で指定され、デフォルトは`"latex"`です。`.dvi`を閲覧するために`C-c
C-v`で実行されるシェルコマンドは、TEXの種類に関係なく、変数`tex-dvi-view-command`で決定されます。出力を印刷するために`C-c
C-p`で実行されるシェルコマンドは、変数`tex-dvi-print-command`で決定されます。TEXでコンパイルされたファイルを閲覧および印刷するために要求されるファイル拡張子は、変数`tex-print-file-extension`でセットできます。たとえば、この変数に`.pdf`をセットして、それに合わせて`tex-dvi-view-command`と`tex-dvi-print-command`を変更できます。

Emacsは出力ファイル名に通常、前のパラグラフで説明したシェルコマンド文字列を自動的に追加します。たとえば`tex-dvi-view-command`が`"xdvi"`のとき、`C-c
C-v`は`xdvi
output-file-name`を実行します。しかし、ファイル名がコマンドに埋め込まれている必要があるケース、たとえばあるコマンドの引数にファイル名を与えて、そのコマンドの出力をパイプで他のコマンドに渡さなければいけない場合があります。コマンド文字列の‘`*`’で、ファイル名をどこに置くか指定することができます。以下は例です

    (setq tex-dvi-print-command "dvips -f * | lpr")

tex-kill-job
C-c C-k (TEX mode)
tex-recenter-output-buffer
C-c C-l (TEX mode)
エラーメッセージを含むTEXからの端末出力は、`*tex-shell*`という名前のバッファーに表示されます。TEXでエラーが発生した場合、このバッファーに切り替えて、適切な入力を与えることができます(これはShellモードで機能します。[Interactive Shell](#Interactive-Shell)を参照してください)。このバッファーに切り替えなくても、これをスクロールできるので、`C-c
C-l`とタイプして最後の行を表示することができます。

これ以上の出力が有用でないと判断した時は、`C-c C-k` (`tex-kill-job`)とタイプしてTEXプロセスをkillします。`C-c C-b`および`C-c
C-r`の使用するときも、TEXがまだ実行中の時はkillします。

tex-region
C-c C-r (TEX mode)
`C-c C-r` (`tex-region`)とタイプして、任意のリージョンをTEXに渡すことができます。しかし、これはトリッキーです。なぜならほとんどのTEX入力ファイルは、先頭にパラメーターをセットしたりマクロを定義するコマンドを含んでいるからです。この問題を解決するために、`C-c
C-r`では、必須のマクロを含むファイル部分を指定することができます。指定したリージョンの前にそれを含めて、TEXの入力の一部とします。ファイルの必須と指定された部分をヘッダーと呼びます。

header (TEX mode)
Plain TEXモードでヘッダーの境界を示すには、ファイルに2つの特別な文字列を挿入します。これはヘッダーの前に‘`%**start
of header`’、ヘッダーの後ろに‘`%**end of
header`’を記述します。これらの文字列は1行に全体を記述しなければなりませんが、文字列の前または後ろに他のテキストがあっても構いません。この2つの文字列を含む行はヘッダーの中に含まれます。‘`%**start
of header`’がバッファーの先頭100行にない場合、`C-c C-r`はヘッダーがないとみなします。

LATEXモードでは、ヘッダーは‘`\documentclass`’または‘`\documentstyle`’で始まり、‘`\begin{document}`’で終わります。いかなる場合でもLATEXがこれらを要求するので、ヘッダーを識別するのに特別なことをする必要はありません。

tex-file
C-c C-f (TEX mode)
コマンド(`tex-buffer`)および(`tex-region`)は、すべてを一時ディレクトリーで処理します。そしてTEXでクロスリファレンスのために必要となる補助的なファイルは利用不可です。一般的にこれらのコマンドは、すべてのクロスリファレンスが正しい必要がある最終コピーのために実行するのには適していません。

クロスリファレンスのための補助的なファイルを使いたいときは、`C-c C-f` (`tex-file`)を使用します。これはカレントバッファーのファイルにたいして、そのファイルのディレクトリーでTEXを実行します。TEXを実行する前に、変更されたバッファーを保存するか確認が求められます。一般的には、クロスリファレンスを正しく取得するために、2回(`tex-file`)を使用する必要があります。

tex-start-options
変数`tex-start-options`の値は、TEXを実行するためのオプションを指定します。

tex-start-commands
変数`tex-start-commands`の値は、TEXを開始するTEXコマンドを指定します。デフォルト値はTEXをノンストップモードで実行します。対話的にTEXを実行するときは、変数に`""`をセットします。

tex-main-file
大きなサイズのTEXドキュメントは複数のファイル — 1つはメインファイルで、他はサブファイル — に分割されているときがあります。サブファイルにたいしてTEXを実行しても通常は動作しません。メインファイルにたいして実行する必要があるのです。サブファイルを編集するのに`tex-file`を使えるようにするには、変数`tex-main-file`にメインファイルの名前をセットします。その後は`tex-file`はそのファイルにたいしてTEXを実行します。

`tex-main-file`を使用する一番簡単な方法は、各サブファイルのローカル変数リストにそれを指定する方法です。[File Variables](#File-Variables)を参照してください。

tex-bibtex-file
C-c TAB (TEX mode)
tex-bibtex-command
LATEXファイルにたいしては、BibTEXを使用してカレントバッファーのファイルのための補助的なファイルを処理できます。BibTEXはデータベースの図書目録の引用(bibliographic citations)を探して、図書目録のセクション(bibliography section)のための引用文献(cited references)を準備します。コマンド`C-c TAB` (`tex-bibtex-file`)は、カレントバッファーのファイルにたいする‘`.bbl`’ファイルを生成するためにシェルコマンド(`tex-bibtex-command`)を実行します。一般的に、‘`.aux`’ファイルを生成するために一度`C-c
C-f` (`tex-file`)を行う必要があります。その後`C-c TAB` (`tex-bibtex-file`)を行ってから、さらなるクロスリファレンスを正しく取得するために`C-c C-f` (`tex-file`)を2回行います。

tex-compile
C-c C-c (TEX mode)
カレントのTEXバッファーで、他のコンパイルプログラムを呼び出すには、`C-c C-c` (`tex-compile`)をタイプします。このコマンドは`pdflatex`、`yap`、`xdvi`、`dvips`を含む、多くの一般的なプログラムに渡す引数を知っています。標準の補完キーを使用して望ましいコンパイルプログラムを選択できます([Completion](#Completion)を参照してください)。

### TEXモード、その

tex-shell-hook
tex-mode-hook
doctex-mode-hook
latex-mode-hook
slitex-mode-hook
plain-tex-mode-hook
TEXモードの変種に入ると、フック`text-mode-hook`および`tex-mode-hook`を実行します。その後、`plain-tex-mode-hook`、`doctex-mode-hook`、`latex-mode-hook`、`slitex-mode-hook`のうち、適切なものを実行します。TEXシェルを開始すると、フック`tex-shell-hook`を実行します。[Hooks](#Hooks)を参照してください。

iso-iso2tex
iso-tex2iso
iso-iso2gtex
iso-gtex2iso
Latin-1 TEX encoding
TEX encoding
コマンド`M-x iso-iso2tex`、`M-x iso-tex2iso`、`M-x
iso-iso2gtex`、`M-x
iso-gtex2iso`はLatin-1でエンコードされたファイルと、TEXでエンコードされた等価なファイルの変換に使用できます。

SGMLモードとHTMLモード
----------------------

SGML mode
HTML mode
mode, SGML
mode, HTML
sgml-mode
html-mode
SGMLおよびHTMLのためのメジャーモードは、インデントのサポートとタグを操作するコマンドを提供します。

HTMLは2つのモードから構成されます — 1つ目は`html-mode`と呼ばれる基本的なモードで、これは若干カスタマイズされたSGMLモードの変種です。もう１つはデフォルトでHTMLファイルに使用されるもので`mhtml-mode`モードと呼ばれ、`<script>`要素で囲まれたJavascript、および`<style>`要素内に埋め込まれたCSSを正しく処理することを意図しています。

`C-c C-n`  
C-c C-n (SGML mode)

sgml-name-char

対話的に特殊文字を指定して、その文字に対応するSGMLの‘`&`’コマンドを挿入します(`sgml-name-char`)。

`C-c C-t`  
C-c C-t (SGML mode)

sgml-tag

対話的にタグとタグの属性を指定します(`sgml-tag`)。このコマンドはタグ名と属性値を尋ね、開始タグと終了タグの両方を挿入し、ポイントをその間に置きます。

プレフィクス引数nを指定すると、このコマンドはバッファーのポイントの後ろにあるn個の単語の周囲にタグを配します。リージョンがアクティブなときは、タグをリージョンの周辺に配します(Transient Markモードがオフのときは、引数に−1を与えることにより、これを行います)。

`C-c C-a`  
C-c C-a (SGML mode)

sgml-attributes

対話的にカレントタグの属性値を挿入します(`sgml-attributes`)。

`C-c C-f`  
C-c C-f (SGML mode)

sgml-skip-tag-forward

対応の取れたタグのグループ(開始タグと対応する終了タグまでの範囲)をスキップします(`sgml-skip-tag-forward`)。数引数は繰り返し回数として振る舞います。

`C-c C-b`  
C-c C-b (SGML mode)

sgml-skip-tag-backward

対応の取れたタグのグループ(開始タグと対応する終了タグまでの範囲)を後方にスキップします(`sgml-skip-tag-backward`)。数引数は繰り返し回数として振る舞います。

`C-c C-d`  
C-c C-d (SGML mode)

sgml-delete-tag

ポイント位置またはポイントの後ろのタグを削除し、それに対応するタグも削除します(`sgml-delete-tag`)。ポイントの後のタグが開始タグの場合は、終了タグも削除します。終了タグの場合は、開始タグも削除します。

`C-c ? tag RET`  
C-c ? (SGML mode)

sgml-tag-help

タグtagの意味の説明を表示します(`sgml-tag-help`)。引数tagが空のときは、ポイント位置のタグを説明します。

`C-c /`  
C-c / (SGML mode)

sgml-close-tag

一番内側の終了されていないタグの終了タグを挿入します(`sgml-close-tag`)。タグまたはコメントの中で呼び出されたときは、終了タグを挿入するかわりにそれを終了させます。

`C-c 8`  
C-c 8 (SGML mode)

sgml-name-8bit-mode

挿入したLatin-1文字を、その文字自身ではなく、その文字を表すSGMLコマンドを挿入するマイナーモードを切り替えます(`sgml-name-8bit-mode`)。

`C-c C-v`  
C-c C-v (SGML mode)

sgml-validate

カレントバッファーをSGMLとして評価するシェルコマンド(要指定)を実行します(`sgml-validate`)。(HTMLモードでは、このキーシーケンスは違うコマンドを実行する。)

`C-c TAB`  
C-c TAB (SGML mode)

sgml-tags-invisible

バッファーの既存のタグの可視・不可視を切り替えます。これは簡単なプレビューとして使用できます(`sgml-tags-invisible`)。

nXML mode
mode, nXML
mode, XML
nxml-mode
XML schema
XMLドキュメントを編集するためのメジャーモードはnXMLモードと呼ばれます。このモードは多くの既存のXMLスキーマを認識することができ、`M-TAB`を通じてXMLエレメントの補完、同様にエラーをハイライトするオンザフライ(on-the-fly)なXMLの妥当性検証を提供します。既存のバッファーでnXMLモードを有効にするには、`M-x
nxml-mode`とタイプするか、`M-x
xml-mode`とタイプしても同じです。Emacsは`.xml`という拡張子をもつファイルにたいしてnXMLモードを使用します。`.xhtml`という拡張子をもつXHTMLファイルにたいしては、デフォルトでEmacsはHTMLモードを使用します。変数`auto-mode-alist`をカスタマイズすることによりnXMLモードを使用させることができます([Choosing Modes](#Choosing-Modes)を参照してください)。 nXMLモードについては、Emacsとともに配布されているInfoマニュアルで説明されています。

sgml-xml-mode
XMLはSGMLの厳格なサブセットなので、XMLを編集するのに、それほど強力ではないSGMLモードの使用を選択することもできます。既存のバッファーでSGMLモードを有効にするには、`M-x
sgml-mode`とタイプします。SGMLを有効にするとき、EmacsはバッファーがXMLかどうかを検証します。もしXMLの場合、変数`sgml-xml-mode`に非`nil`値をセットします。これにより上述したSGMLモードのタグ挿入コマンドは、常に明示的に終了タグを挿入するようになります。

Nroffモード
-----------

nroff
nroff-mode
nroff-mode-hook
NroffモードはTextモードから派生した、nroffファイル(たとえばUnixのman)の編集に特化したメジャーモードです。`M-x
nroff-mode`とタイプすることによりこのモードにはいります。Nroffモードに入ることにより、フック`text-mode-hook`、その後で`nroff-mode-hook`が実行されます([Hooks](#Hooks)を参照してください)。

Nroffモードでは、nroffコマンド行はパラグラフの区切りとして扱われ、ページは‘`.bp`’で区切られ、コメントはバックスラッシュとダブルクォートで始まります。これは以下のコマンドも定義します:

nroff-forward-text-line
nroff-backward-text-line
nroff-count-text-lines
M-n (Nroff mode)
M-p (Nroff mode)
M-? (Nroff mode)
`M-n`  
nroffコマンドではない次の行の先頭に移動します(`nroff-forward-text-line`)。引数は繰り返し回数です。

`M-p`  
`M-n`と同様ですが上に移動します(`nroff-backward-text-line`)。

`M-?`  
エコーエリアにリージョンの、(nroffコマンドではない)テキストの行数を表示します(`nroff-count-text-lines`)。

nroff-electric-mode
Electric Nroffモードはバッファーローカルなマイナーモードで、Nroffモードとともに使うことができます。このマイナーモードを切り替えるには、`M-x
nroff-electric-mode`とタイプします([Minor Modes](#Minor-Modes)を参照してください)。このモードがオンのとき、グループ化を行う種類のnroffコマンドを含む行をRETをタイプして終端すると、グループ化を閉じるnroffコマンドが自動的に後続の行に挿入されます。

NroffモードとともにOutline minorモード([Outline Mode](#Outline-Mode)を参照してください)を使用する場合、ヘッダー行は‘`.H`’の後に数字(ヘッダーレベル)が続く形式の行です。

Enrichedテキスト
----------------

Enriched mode
mode, Enriched
enriched text
WYSIWYG
word processing
text/enriched MIME format
Enriched(多くの刺激を含む、豊かにした)は、フォーマットされたテキストファイルをWYSIWYG(What You See Is What You Get)な方法で編集するためのマイナーモードです。Enrichedモードが有効な場合、フォントやカラーなどのさまざまなフォーマットプロパティーを、バッファーのテキストに適用できます。バッファーを保存するときは、それらのプロパティーはテキストとともに、MIME形式‘`text/enriched`’のファイルフォーマットを使用して保存されます。

Enrichedモードは通常、Textモードとともに使用されます([Text Mode](#Text-Mode)を参照してください)。これは多くのメジャーモード(構文のハイライトのためにFont Lockモードを使用するほとんどのプログラミング言語関連のモードを含む)で使用される、Font Lockモードとの互換性は*ありません*。Enrichedモードとは異なり、Font Lockモードはカレントバッファーの内容にもとづいて、テキストのプロパティーを自動的に割り当てます。これらのプロパティーはディスクには保存されません。

Emacsの`data-directory`のファイル`enriched.txt`は、Enrichedモードの機能例として役に立ちます。

### Enrichedモード

Enrichedモードは、バッファーローカルなマイナーモードです([Minor Modes](#Minor-Modes)を参照してください)。‘`text/enriched`’フォーマットで保存されたファイルをvisitすると、Emacsは自動的にEnrichedモードを有効にし、ファイル内のフォーマット情報をバッファーのテキストに適用します。Enrichedモードが有効なときにバッファーを保存すると、ファイルはフォーマット情報を含む‘`text/enriched`’フォーマットで保存されます。

enriched-mode
フォーマットされたテキストで新しいファイルを作成するには、存在しないファイルをvisitして`M-x
enriched-mode`とタイプします。このコマンドは実際にEnrichedモードを切り替えます。プレフィクス引数を指定した場合、引数が正のときはEnrichedモードを有効にし、それ以外はEnrichedモードを無効にします。Enrichedモードを無効にすると、Emacsは‘`text/enriched`’フォーマットでバッファーを保存しなくなります。バッファーに追加されたフォーマットプロパティーはバッファーに残りますが、ディスクには保存されません。

enriched-translations
Enrichedモードは、すべてのEmacsのテキストプロパティーを保存しません。変数`enriched-translations`に指定されたものだけを保存します。これにはフォント、カラー、インデント、行端揃えのプロパティーが含まれます。

format-decode-buffer
ファイルをvisitしたとき、ファイルが‘`text/enriched`’フォーマットだとEmacsが認識できなかった場合は、`M-x
format-decode-buffer`とタイプします。このコマンドはファイルフォーマットの入力を求め、そのフォーマットでファイルを再読み込みします。‘`text/enriched`’フォーマットを指定することにより、自動的にEnrichedモードが有効になります。

‘`text/enriched`’ファイルをraw形式(フォーマットされたテキストではなく、マークアップタグを伴う通常テキスト)として閲覧するには、`M-x
find-file-literally`を使用します([Visiting](#Visiting)を参照してください)。

Emacsが‘`text/enriched`’のようなファイルフォーマットを認識・変換する方法については、section “Format Conversion” in the Emacs Lisp Reference Manualを参照してください。テキストプロパティーについての詳細は、section “Text Properties” in the Emacs Lisp Reference Manualを参照してください。

### ハード改行とソフト改行

hard newline
soft newline
newlines, hard and soft
use-hard-newlines
Enrichedモードでは、Emacsは2つの異なる改行、ハード改行とソフト改行を区別します。`M-x
use-hard-newlines`とタイプすることにより、他のバッファーにたいしてこの機能を有効または無効にできます。

ハード改行は、パラグラフを分割したりテキストがフィルされる方法に関らず行区切りが必要な場所で使用され、ソフト改行はフィルで使用されます。RET (`newline`)および`C-o` (`open-line`)コマンドはハード改行を挿入します。Auto Fill([Auto Fill](#Auto-Fill)を参照してください)を含むフィルコマンドは、ソフト改行だけを挿入し、削除もソフト改行だけでハード改行は削除せずに残します。

したがってEnrichedモードで編集するときは、フィルされたパラグラフの途中で行を分けるのにRETや`C-o`を使うべきではありません。かわりにAuto Fillモード、または明示的なフィルコマンド([Fill Commands](#Fill-Commands)を参照してください)を使用します。テーブルやリストのように、行区切りを常に残したい場所でRETや`C-o`を使用します。そのような行では、行端揃えスタイル(justification style)も`unfilled`にしたいと思うかもしれません([Enriched Justification](#Enriched-Justification)を参照してください)。

### フォーマット情報の編集

プロパティーを変更する一番簡単な方法は、‘`Text Properties`’メニューです。このメニューは、メニューバー([Menu Bar](#Menu-Bar)を参照してください)の‘`Edit`’メニュー、または`C-mouse-2`([Menu Mouse Clicks](#Menu-Mouse-Clicks)を参照してください)で取得することができます。‘`Text
Properties`’メニューのコマンドのいくつかを、以下にリストします(`M-x`)で呼び出すこともできます):

`Remove Face Properties`  
リージョンからフェイスプロパティーを削除します(`facemenu-remove-face-props`)。

facemenu-remove-all

`Remove Text Properties`  
リージョンからフェイスプロパティーを含む、すべてのテキストプロパティーを削除します(`facemenu-remove-all`)。

describe-text-properties

text properties of characters

overlays at character position

widgets at buffer position

buttons at buffer position

`Describe Properties`  
ポイントの後ろにある文字の、すべてのテキストプロパティーと他の情報をリストします(`describe-text-properties`)。

`Display Faces`  
定義されたフェイスのリストを表示します(`list-faces-display`)。[Faces](#Faces)を参照してください。

`Display Colors`  
定義されたカラーのリストを表示します(`list-colors-display`)。[Colors](#Colors)を参照してください。

他のメニューエントリーについては、以下のセクションで説明します。

### Enrichedテキストのフェイス

以下のコマンドは、フェイスを追加または削除するのに使用することができます([Faces](#Faces)を参照してください)。マークがアクティブのときは、リージョンのテキストに適用され、マークが非アクティブのときは、次の自己挿入文字に適用されます。プレフィクス引数を指定すると、これらのコマンドはリージョンがアクティブな場合でも、次の自己挿入文字に適用されます。

`M-o d`  
すべての`face`プロパティーを削除します(`facemenu-set-default`)。

M-o b (Enriched mode)

facemenu-set-bold

`M-o b`  
`bold`(太字)フェイスを適用します(`facemenu-set-bold`)。

M-o i (Enriched mode)

facemenu-set-italic

`M-o i`  
`italic`(斜体)フェイスを適用します(`facemenu-set-italic`)。

M-o l (Enriched mode)

facemenu-set-bold-italic

`M-o l`  
`bold-italic`(太字斜体)フェイスを適用します(`facemenu-set-bold-italic`)。

M-o u (Enriched mode)

facemenu-set-underline

`M-o u`  
`underline`(下線)フェイスを適用します(`facemenu-set-underline`)。

M-o o (Enriched mode)

facemenu-set-face

`M-o o face RET`  
フェイスfaceを適用します(`facemenu-set-face`)。

facemenu-set-foreground

`M-x facemenu-set-foreground`  
カラーの入力を求め(see [Colors](#Colors))、それをフォアグラウドカラーに適用します。

facemenu-set-background

`M-x facemenu-set-background`  
カラーの入力を求め、それをバックグラウンドカラーに適用します。

これらのコマンドは、Text Propertiesメニューからも利用可能です。

自己挿入文字は通常、フェイスプロパティー(および他のほとんどのテキストプロパティー)を、そのバッファーの前の文字から継承します。次の自己挿入文字にたいして上記のコマンドを指定した場合、その文字は前の文字からフェイスプロパティーは継承しませんが、他のテキストプロパティーは継承します。

Enrichedモードは、他の追加のフェイス`excerpt`および`fixed`を定義します。これらはtext/enrichedファイルフォーマットで使われるコードに対応します。`excerpt`フェイスは引用のために使用されることを意図されており、デフォルトでは`italic`と同じように表示されます。`fixed`フェイスは固定幅テキストを指定し、デフォルトでは`bold`と同じように表示されます。

### Enrichedテキストのインデント

Enrichedモードでは、パラグラフまたはパラグラフの一部の、右余白または左余白に異なる量のインデントを指定できます。これらの余白は`M-q` ([Filling](#Filling)を参照してください)のようなフィルコマンドにも影響します。

IndentationサブメニューのTextプロパティーは、インデントを指定するコマンドを提供します:

`Indent More`  
リージョンを4列ずつインデントします(`increase-left-margin`)。Enrichedモードでは、このコマンドは`C-x
TAB`でも利用可能です。数引数を指定した場合、何列を余白に追加するかを指定します(負の引数は余白を何列縮めるかを指定します)。

`Indent Less`  
リージョンから4列のインデントを削除します。

`Indent Right More`  
右端から4列インデントすることにより、テキストを狭くします。

`Indent Right Less`  
右端からのインデントを4列削除します。

standard-indent
変数`standard-indent`は、これらのコマンドがインデントを追加または減少させる列数を指定します。デフォルトは4です。Enrichedにたいするデフォルトの右余白は、通常のように`fill-column`により制御されます。

C-c \[ (Enriched mode)
C-c \] (Enriched mode)
set-left-margin
set-right-margin
`C-c [` (`set-left-margin`)または`C-c ]` (`set-right-margin`)とタイプしても、左余白または右余白をセットできます。数引数で余白の幅を指定できます。指定しない場合、これらのコマンドはミニバッファーを通じて値の入力を求めます。

それに加えてフィルプレフィクスがある場合は、指定されたパラグラフのインデントに使用されます。`C-x
.`は、フィルプレフィクスにたいして指定された、新しい値の中の空白文字は含めません。フィルコマンドは各行のインデントの後ろにフィルプレフィクスを探します。[Fill Prefix](#Fill-Prefix)を参照してください。

### Enrichedテキストの位置調整

justification style
Enrichedモードでは、以下のコマンドを使って、フィルのためにさまざまな行端揃えスタイル(justification styles)を指定できます。これらのコマンドは。ポイントを含むパラグラフ、またはリージョンがアクティブの場合は、リージョンと重なるすべてのパラグラフに適用されます。

`M-j l`  
行を左余白に揃えます(`set-justification-left`)。

M-j r (Enriched mode)

set-justification-right

`M-j r`  
行を右余白に揃えます(`set-justification-right`)。

M-j b (Enriched mode)

set-justification-full

`M-j b`  
行の途中にスペースを挿入することにより、行を両端の余白に揃えます(`set-justification-full`)。

M-j c (Enriched mode)

M-S (Enriched mode)

set-justification-center

`M-j c`; `M-S`  
両端の余白の間で行を中央に揃えます(`set-justification-center`)。

M-j u (Enriched mode)

set-justification-none

`M-j u`  
フィルを完全にオフに切り替えます(`set-justification-none`)。このセッティングにより、フィルコマンドはテキストに何も行わなくなります。それでも左余白はインデントすることができます。

default-justification
Text PropertiesメニューのJustificationサブメニューを使用して、行端揃えスタイルを指定することもできます。デフォルトの行端揃えスタイルはバッファーごとの変数`default-justification`により指定されます。この変数の値はシンボル`left`、`right`、`full`、`center`、または`none`のうちの1つです。シンボルの意味は上述したコマンドに対応します。

### その他のテキストプロパティーのセッティング

Text PropertiesメニューのSpecial Propertiesサブメニューには、3つのテキストプロパティー — `read-only`(テキストの変更を不可にします)、`invisible`(テキストを非表示にします)、`intangible`(テキスト内でのポイントの移動を不可にします) — を、追加または削除するエントリーがあります。‘`Remove
Special`’メニューアイテムは、リージョン内のテキストにたいする、これらの特別なプロパティーを削除します。

プロパティー`invisible`および`intangible`は保存されません。

enriched-allow-eval-in-display-props
security, when displaying enriched text
Enrichedモードは`display`プロパティ(section “Display Property” in the Emacs Lisp Reference Manualを参照)の保存とリストアもサポートします。このプロパティはスクリーン上でテキストがどのように表示されるかに影響を与え、バッファーのテキスト以外のソース由来のイメージや文字列も表示することができます。`display`プロパティはディスプレイにたいするプロパティ処理の一部として、任意のLispフォームの実行もサポートします。したがって、表示時しか知ることができないコンディションにディスプレイを動的に合わせる能力を提供します。任意のLisp実行は、そのenrichedテキストのソースがEmacs、あるいはシステム外からのもの(たとえば受信した電子メールの添付ファイル)である場合は、Emacsに攻撃の可能性を開くので、Enrichedモードではそのような実行はデフォルトで無効になっています。変数`enriched-allow-eval-in-display-props`を非`nil`値にカスタマイズすることにより、これを有効にすることができます。

テキストベーステーブルの編集
----------------------------

table mode
text-based tables
`table`パッケージは、テキストベースのテーブルを簡単に編集するコマンドを提供します。以下は、そのようなテーブルがどのように見えるかの例です:

    +-----------------+--------------------------------+-----------------+
    |     Command     |          Description           |   Key Binding   |
    +-----------------+--------------------------------+-----------------+
    |  forward-char   |Move point right N characters   |       C-f       |
    |                 |(left if N is negative).        |                 |
    |                 |                                |                 |
    +-----------------+--------------------------------+-----------------+
    |  backward-char  |Move point left N characters    |       C-b       |
    |                 |(right if N is negative).       |                 |
    |                 |                                |                 |
    +-----------------+--------------------------------+-----------------+

このようなテキストがテーブルだとEmacsが認識した場合([Table Recognition](#Table-Recognition)を参照してください)、テーブルのセル内容を編集すると、内容が大きくなってセルに収まらなくなったときは、テーブルのセルを自動的にサイズ変更します。以下のセクションで説明されている、テーブルのレイアウトを操作したり編集するコマンドを使用することができます。

table-fixed-width-mode
`M-x table-fixed-width-mode`とタイプすることにより、自動的なテーブルのサイズ変更を切り替えることができます。

### テキストベーステーブルとは?

cells, for text-based tables
テーブル(table)は矩形のテキスト領域からなり、それらはセル(cells)に分割されます。セルは少なくとも1文字分の幅と高さをもち、それにボーダーラインは含まれません。セルは複数のセルに分割できますが、それらは重なることはできません。

セルのボーダーラインは、以下の変数で指定された3つの特別な文字で描画されます:

`table-cell-vertical-char`  
垂直ラインに使用される文字です。デフォルトは‘`|`’です。

table-cell-horizontal-chars

`table-cell-horizontal-chars`  
水平ラインに使用される文字です。デフォルトは‘`"-="`’です。

table-cell-intersection-char

`table-cell-intersection-char`  
水平ラインと垂直ラインの交点に使用される文字です。デフォルトは‘`+`’です。

以下は*無効*なテーブルの例です:

       +-----+       +--+    +-++--+
       |     |       |  |    | ||  |
       |     |       |  |    | ||  |
       +--+  |    +--+--+    +-++--+
       |  |  |    |  |  |    +-++--+
       |  |  |    |  |  |    | ||  |
       +--+--+    +--+--+    +-++--+
          a          b          c

左から順に説明します:

1.  重なったセル、または非矩形のセルは許されません。

2.  ボーダーは矩形でなければなりません。

3.  セルは最小でも1文字分の幅と高さがなければなりません。

### テーブルの作成

create a text-based table
table creation
table-insert
テキストベースのテーブルをスクラッチから作成するには、`M-x
table-insert`とタイプします。このコマンドはテーブルの列数、テーブルの行数、セルの幅と高さの入力を求めます。セルの幅とセルの高さに、セルのボーダーは含まれません。これらは1つの整数で指定するか(これは各セルの幅と高さが同じになることを意味します)、スペースまたはカンマで区切られた整数のシーケンス(これはテーブルの左から右の列、上から下の行の個別のセルにたいして幅と高さを指定します)です。その後、指定されたテーブルはポイント位置に挿入されます。

`M-x
table-insert`で挿入されたテーブルは、Emacsにそれをテキストベースのテーブルとして特別に扱うように指示する、特別なテキストプロパティーを含みます。そのバッファーをファイルに保存して、後で再びvisitすると、それらのプロパティーは失われ、Emacsにとってテーブルは普通のテキストとして判断されます。これをテーブルに変換する方法については、次のセクションを参照してください。

### テーブルの認識

table recognition
table-recognize
table-unrecognize
バッファーに既存のテーブルがあり、そのテーブルから`M-x
table-insert`で適用された特別なテキストプロパティーが失われているとき、それはテーブルとして特別に扱われなくなります。これにテキストプロパティーを適用するには、`M-x
table-recognize`とタイプします。このコマンドはカレントバッファーをスキャンして、有効なテーブルセルを認識して、適切なテキストプロパティーを適用します。反対に、`M-x
table-unrecognize`とタイプすることにより、特別なテキストプロパティーを削除して、テーブルをプレーンテキストに変換して、カレントバッファーのすべてのテーブルを認識しなくなります。

以下のコマンドを使って、選択的にテーブルを認識したり認識させなくすることもできます:

`M-x table-recognize-region`  
カレントリージョンのテーブルを認識します。

table-unrecognize-region

`M-x table-unrecognize-region`  
カレントリージョンのテーブルを認識しなくします。

table-recognize-table

`M-x table-recognize-table`  
ポイント位置のテーブルを認識してアクティブにします。

table-unrecognize-table

`M-x table-unrecognize-table`  
ポイント位置のテーブルを非アクティブにします。

table-recognize-cell

`M-x table-recognize-cell`  
ポイント位置のセルを認識してアクティブにします。

table-unrecognize-cell

`M-x table-unrecognize-cell`  
ポイント位置のセルを非アクティブにします。

テーブルを認識する他の方法については、[Table Conversion](#Table-Conversion)を参照してください。

### テーブルセルにたいするコマンド

table-forward-cell
table-backward-cell
コマンド`M-x table-forward-cell`および`M-x
table-backward-cell`は、ポイントをカレントセルから隣接するセルに移動します。その順番は巡回的です。ポイントがテーブルの最後のセルにあるとき、`M-x
table-forward-cell`はポイントを最初のセルに移動します。同様に、ポイントが最初のセルにあるとき、`M-x
table-backward-cell`はポイントを最後のセルに移動します。

table-span-cell
`M-x table-span-cell`は方向 — 右、左、上、下 — の入力を求め、カレントセルをその方向の隣接するセルにマージします。マージした結果が不正なセルのレイアウトになる場合、このコマンドはエラーをシグナルします。

table-split-cell
table-split-cell-vertically
table-split-cell-horizontally
text-based tables, splitting cells
splitting table cells
`M-x
table-split-cell`は、ミニバッファーを使って分割する方向の入力を求め、カレントセルを垂直(vertically)または水平(horizontally)に分割します。特定の方向に分割するには、`M-x
table-split-cell-vertically`と`M-x
table-split-cell-horizontally`を使います。垂直に分割する場合、古いセルの内容は自動的に2つの新しいセルに分割されます。水平に分割する場合、セルが空でない場合は、セル内容をどのように分割するか入力を求めます。オプションは‘`split`’(内容をポイント位置で分割)、‘`left`’(すべての内容を左のセルへ)、‘`right`’(すべての内容を右のセルへ)です。

以下のコマンドは、セルを拡大または縮小します。デフォルトでは、1行または1列ずつサイズ変更します。数引数が与えられた場合、それはサイズ変更を何行または何列単位で行うかを指定します。

`M-x table-heighten-cell`  
カレントセルを垂直方向に拡大します。

table-shorten-cell

`M-x table-shorten-cell`  
カレントセルを垂直方向に縮小します。

table-widen-cell

`M-x table-widen-cell`  
カレントセルを水平方向に拡大します。

table-narrow-cell

`M-x table-narrow-cell`  
カレントセルを水平方向に縮小します。

### セルの位置調整

justification in text-based tables
コマンド`M-x
table-justify`は、テキストベーステーブルの1つ以上のセルにたいして、位置調整(justification)を行います。位置調整は、セルのテキストがセルの外枠にたいして、どのように位置合わせされるかを決定します。テーブルの各セルは個別に位置調整できます。

table-justify
`M-x
table-justify`は、最初に何の位置調整をするかの入力を求めます。オプションは‘`cell`’(カレントセルのみ)、‘`column`’(テーブルのカレント列のすべてのセル)、‘`row`’ (テーブルのカレント行のすべてのセル)です。その後、コマンドは位置調整のスタイルの入力を求めます。オプションは`left`、`center`、`right`、`top`、`middle`、`bottom`、または`none`(垂直方向の位置調整を行わないことを意味します)です。

水平および垂直方向の位置調整スタイルは独立して指定され、2つのタイプは同時に適用できます。たとえば`M-x
table-justify`を2回呼び出して、1回目は位置調整に`right`を指定して、2回目は位置調整に`bottom`を指定することにより、セルの内容を右下に位置調整することができます。

table-detect-cell-alignment
位置調整スタイルは、テキストプロパティーとしてバッファーに格納され、バッファーをkillするかEmacsを終了すると失われます。`M-x
table-recognize`([Table Recognition](#Table-Recognition)を参照してください)のようなテーブルの認識コマンドは、セルの内容を確認して各セルの位置調整スタイルの決定と再適用を試みます。この機能を無効にするには、変数`table-detect-cell-alignment`を`nil`に変更してください。

### テーブルの行と列

inserting rows and columns in text-based tables
table-insert-row
`M-x
table-insert-row`は、テーブルのカレント行の前にセル行を挿入します。カレント行とポイントは、新しい行の下になります。テーブル最下にある最後の行の後ろに行を挿入するには、ポイントをテーブルの最下線の直下にポイントを移動して、このコマンドを呼び出します。数引数を指定することにより2つ以上の行を挿入できます。

table-insert-column
同様に、`M-x
table-insert-column`は、テーブルのカレント列の左にセル列を挿入します。右端の最右列の右に列を挿入するには、ポイントを最右線の右(テーブルの外)に移動して、このコマンドを呼び出します。数引数は挿入する列の数を指定します。

deleting rows and column in text-based tables
`M-x table-delete-column`は、ポイントがあるセルの列を削除します。同様に、`M-x
table-delete-row`は、ポイントがあるセルの行を削除します。どちらのコマンドも数引数により削除する列または行の数を指定します。

### プレーンテキストとテーブルの変換

text to table
table to text
table-capture
コマンド`M-x table-capture`は、プレーンテキストをリージョンにキャプチャーして、それをテーブルに変換します。`M-x
table-recognize`([Table Recognition](#Table-Recognition)を参照してください)とは異なり、元のテキストはテーブルの体裁をとる必要はありません。テーブル的な論理構造もつことだけが必要です。

たとえば以下の数字があったとして、これらは3つの行と、カンマで水平方向に分割されます:

    1, 2, 3, 4
    5, 6, 7, 8
    , 9, 10

このテキストにたいして`M-x table-capture`を呼び出すと、以下のテーブルが生成されます:

    +-----+-----+-----+-----+
    |1    |2    |3    |4    |
    +-----+-----+-----+-----+
    |5    |6    |7    |8    |
    +-----+-----+-----+-----+
    |     |9    |10   |     |
    +-----+-----+-----+-----+

table-release
`M-x table-release`は逆のことを行います。これはテーブルを元のプレーンテキストに戻し、セルのボーダーを削除します。

この2つのコマンドの1つの用途としては、テキストをレイアウトで編集することです。以下の3つのパラグラフを見てください:

    table-capture is a powerful command.
    Here are some things it can do:

    Parse Cell Items   Using row and column delimiter regexps,
                       it parses the specified text area and
                       extracts cell items into a table.

上記のテキストを含むリージョンに`table-capture`を適用して、列と行を区切るregexpsに空文字列を指定すると、以下のような1つのセルからなるテーブルが作成されます。

    +----------------------------------------------------------+
    |table-capture is a powerful command.                      |
    |Here are some things it can do:                           |
    |                                                          |
    |Parse Cell Items   Using row and column delimiter regexps,|
    |                   it parses the specified text area and  |
    |                   extracts cell items into a table.      |
    +----------------------------------------------------------+

その後でセル分割コマンド([Cell Commands](#Cell-Commands)を参照してください)を使って、各パラグラフが1つのセルを占めるようにテーブルを分割できます。

    +----------------------------------------------------------+
    |table-capture is a powerful command.                      |
    |Here are some things it can do:                           |
    +-----------------+----------------------------------------+
    |Parse Cell Items | Using row and column delimiter regexps,|
    |                 | it parses the specified text area and  |
    |                 | extracts cell items into a table.      |
    +-----------------+----------------------------------------+

これで各セルは他のセルのレイアウトに影響を与えることなく、独立して編集することができるようになりました。終了したら`M-x
table-release`を呼び出して、テーブルをプレーンテキストに戻します。

### テーブル、その他

table dimensions
table-query-dimension
コマンド`table-query-dimension`は、テーブルのレイアウトとポイント位置のテーブルセルをレポートします。以下は出力の例です:

    Cell: (21w, 6h), Table: (67w, 16h), Dim: (2c, 3r), Total Cells: 5

これはカレントセルの幅が21文字、高さが6行で、テーブルの幅が67文字、高さが16行で、2列3行で5つのセルがあることを示します。

table-insert-sequence
`M-x
table-insert-sequence`は、テキスト文字列のシーケンスを、テーブルのセルを横断して、適切に各セルに挿入します。これは、そのシーケンスの基本文字列(base string)を尋ねて、その基本文字列を数値的(基本文字列が数字で終わる場合)、またはASCII順で“増加”させてシーケンスを生成します。基本文字列に加え、このコマンドはシーケンス内の要素数、増分、セル間隔、各セル内のテキストの行端揃えの入力を求めます。

table for HTML and LaTeX
table-generate-source
`M-x
table-generate-source`は、特定のマークアップ言語にフォーマットされたテーブルを生成します。このコマンドは言語(これは`html`、`latex`、`cals`のどれか1つでなければなりません)と、結果を出力するバッファー、テーブルの表題を尋ね、生成されたテーブルを指定したバッファーに出力します。デフォルトの出力バッファーは`table.lang`で、langは指定された言語です。

2列編集
-------

two-column editing
splitting columns
columns, splitting
2C-two-column(2列)モードは、横に並んだテキストの列を、簡単に編集できるようにします。これは横に並んだ2つのウィンドウを使って、それぞれのウィンドウは自身のバッファーを表示します。2Cモードに入るには3つの方法があります。

`F2 2`または`C-x 6 2`  
F2 2

C-x 6 2

2C-two-columns

カレントバッファーを左に、カレントバッファーの名前にもとづいた名前のバッファーを右にして、2Cモードに入ります。右側のバッファーがまだ存在しない場合、そのバッファーは空で開始されます。カレントバッファーの内容は変更されません。

このコマンドは、カレントバッファーが空か1列だけしか含まなくて、それに別の列を追加したいときに適しています。

`F2 s`または`C-x 6 s`  
F2 s

C-x 6 s

2C-split

2列のテキストを含むカレントバッファーを2つのバッファーに分割して、それを横に並べて表示します(`2C-split`)。カレントバッファーは左側のバッファーになりますが、右側の列のテキストは、右側のバッファーに移動します。カレント列は分割ポイントを指定します。分割はカレント行からバッファーの最後まで続きます。

このコマンドはすでに2列になったテキストを含むバッファーがあり、一時的にそれを列に分割したいときに適しています。

`F2 b buffer RET`; `C-x 6 b buffer RET`  
F2 b

C-x 6 b

2C-associate-buffer

カレントバッファーを左側のバッファー、バッファーbufferを右側のバッファーにして2Cモードに入ります(`2C-associate-buffer`)。

`F2 s`または`C-x 6
s`は、列の区切りを探します。区切りは各行に出現する2列の間にある文字列です。区切りの幅は、`F2
s`への数引数で指定することができます。これはポイントの前の指定した文字数文を区切り文字とします。デフォルトでは幅が1なので、ポイントの前の文字が列区切りになります。

行が適切な位置で分割された場合、`F2
s`は区切りの後ろのテキストを右側のバッファーに移動して、区切りを削除します。適切な位置に列区切りをもたない行は、分割されずに残ります。分割されない行は左側のバッファーに残り、右側のバッファーの対応する行は空になります(これは2Cモードで2列にまたがる行を書くときの方法で、そのような行は左側のバッファーに記述して、右側のバッファーは空の行にします)。

F2 RET
C-x 6 RET
2C-newline
コマンド`F2 RET`または`C-x 6 RET` (`2C-newline`)は、2つのバッファーの対応する位置にそれぞれ改行を挿入します。これは2列のテキストを分割されたバッファーで編集するときに、新しい行を追加する一番簡単な方法です。

F2 1
C-x 6 1
2C-merge
望みどおりに両方のバッファーを編集し終えたら、`F2 1`または`C-x 6 1` (`2C-merge`)で、それらをマージします。これは右側のバッファーからテキストを、もう一方のバッファーの2列目にコピーします。2列編集に戻るには、`F2
s`を使用します。

F2 d
C-x 6 d
2C-dissociate
`F2 d`または`C-x 6 d`は、バッファーをそのままにして、2つのバッファーを分割します。`F2
d`とタイプしたとき、カレントではないバッファーが空の場合、`F2 d`によりそのバッファーはkillされます。

プログラムの編集
================

Lisp editing
C editing
program editing
このチャプターでは、プログラムの編集を容易にするEmacsの機能を説明します。これらの機能で行えるいくつかは、以下のようなものです:

-   トップレベルの定義の検索や移動([Defuns](#Defuns)を参照してください)。

-   言語の通常のインデント規則の適用([Program Indent](#Program-Indent)を参照してください)。

-   カッコの対応をとります([Parentheses](#Parentheses)を参照してください)。

-   コメントの挿入、kill、位置揃え([Comments](#Comments)を参照してください)。

-   プログラム構文のハイライト([Font Lock](#Font-Lock)を参照してください)。

プログラミング言語のためのメジャーモード
----------------------------------------

modes for programming languages
Emacsには、プログラミング言語のために特化した、多くのメジャーモード([Major Modes](#Major-Modes)を参照してください)があります。プログラミング言語に関連したモードは通常、式の構文、インデントの慣習的ルール、言語の構文をハイライトする方法、関数定義の開始と終了を検索する方法を指定します。プログラムをコンパイルしたり、デバッグするための機能をもつ場合もあります。各言語にたいするメジャーモード名は、言語名により名づけられます。たとえばCプログラミング言語にたいするメジャーモードは、`c-mode`です。

Perl mode
Icon mode
Makefile mode
Tcl mode
CPerl mode
DSSSL mode
Octave mode
Metafont mode
Modula2 mode
Prolog mode
Python mode
Ruby mode
Simula mode
Verilog mode
VHDL mode
M4 mode
Shell-script mode
OPascal mode
PostScript mode
Conf mode
DNS mode
Javascript mode
Awk mode
EmacsにはLisp、Scheme、SchemeベースのDSSSL expression言語、Ada、ASM、AWK、C、C++、Fortran、Icon、IDL(CORBA)、IDLWAVE、Java、Javascript、M4、Makefile、Metafont(フォント作成のためのTEXの仲間)、Modula2、Object Pascal、Objective-C、Octave、Pascal、Perl、Pike、PostScript、Prolog、Python、Ruby、Simula、SQL、Tcl、Verilog、VHDLなどのプログラミング言語のためのモードがあります。Perlのための代替モードはCPerlモードと呼ばれます。一般的なGNUおよびUnixシェルのスクリプティング言語、MS-DOS/MS-Windowsの‘`BAT`’ファイル、makefiles、DNS masterファイル、一連のさまざまな設定ファイルのためのモードも利用可能です。

理想的には、Emacsは編集したいと望むすべてのプログラミング言語のためのメジャーモードをもつべきです。しかし、もしあなたのお気に入りの言語のためのモードがない場合、それはEmacsとともに配布されないパッケージで実装されているかもしれません([Packages](#Packages)を参照してください)。または、あたたが貢献することもできます。

DEL (programming modes)
backward-delete-char-untabify
ほとんどのプログラミング言語では、インデントはプログラム構造を示すために行ごとに異なります。したがって、ほとんどのプログラミング言語のモードでは、`TAB`とタイプすることにより、カレント行のインデントが更新されます([Program Indent](#Program-Indent)を参照してください)。さらに`DEL`は通常、タブをあたかも等価な数のスペースであるかのように扱って、後方に削除する`backward-delete-char-untabify`にバインドされているので、空白文字がスペースなのかタブなのか気にせずに、インデントを1列ずつ削除できます。

mode hook, and major modes
c-mode-hook
lisp-mode-hook
emacs-lisp-mode-hook
lisp-interaction-mode-hook
scheme-mode-hook
プログラミング言語のモードに入ることにより、フック変数`prog-mode-hook`に指定されたカスタムLisp関数と、その後でモード自身のモードフックが実行されます([Major Modes](#Major-Modes)を参照してください)。たとえばCモードに入ることにより、`prog-mode-hook`と`c-mode-hook`が実行されます。フックについての情報は、[Hooks](#Hooks)を参照してください。

Adaモード(section “Ada Mode” in Ada Modeを参照してください)、C/C++/Objective C/Java/Corba IDL/Pike/AWKモード(section “CC Mode” in CC Modeを参照してください)、Octaveモード、VHDLモード、IDLWAVEモード(section “IDLWAVE” in IDLWAVE User Manualを参照してください)のマニュアルが利用可能です。

トップレベルの定義、またはdefun
-------------------------------

Emacsでは関数などの、バッファーのトップレベルの主要な定義は、defunと呼ばれます。この名前はLispが由来ですが、Emacsではすべての言語に使用します。

### 左端の慣習

open-parenthesis in leftmost column
( in leftmost column
プログラミング言語のモードの多くは、デフォルトでは左端で見つかった開始区切りは、トップレベル定義、またはdefunの開始とみなします。したがって、**そのような意味をもたない場合、開始区切りを左端に配してはいけません**。たとえば、それがトップレベルのリストの開始でない場合は、Lispファイルの左端に開きカッコを記述しないでください。

この慣習に従わない場合、コードの構文を解析するために、バッファーの先頭から再スキャンが必要ですが、慣習に従うことにより、多くのEmacs操作をスピードアップできます。

この慣習にしたがわない場合、defunにより動作するコマンドを明示的に使用する場合にトラブルが起こるだけではありません。これを使用する他の機能もトラブルを起こすでしょう。これにはインデントコマンド([Program Indent](#Program-Indent)を参照してください)と、Font Lockモード([Font Lock](#Font-Lock)を参照してください)が含まれます。

同様な問題ケースのほとんどは、文字列リテラルで開始区切りを行の先頭に記述したい場合です。このトラブルを避けるには、開始区切りの前にエスケープ文字(CおよびEmacs Lispでは‘`\`’、その他のLisp方言のいくつかは‘`/`’)を配します。これは文字列の内容には影響を与えませんが、その開始区切りがdefunの開始となるのを防ぎます。以下は例です:

      (insert "Foo:
    \(bar)
    ")

この慣習を破ったことに気づくには、Font Lockモードが助けになります。Font Lockモードは混乱して、(クォートする必要がある)開始区切りを赤の太字でハイライトするからです。

open-paren-in-column-0-is-defun-start
この慣習をオーバーライドする必要がある場合、変数`open-paren-in-column-0-is-defun-start`をセッティングすることにより、これを行うことができます。このユーザーオプションが`t`(デフォルト)にセットされている場合、列0の開きカッコまたは大カッコ(braces)は常にdefunの開始となります。`nil`の場合、defunは最外レベルのカッコまたは大カッコを検索することにより発見されます。

通常は、このオプションをデフォルト値の`t`にしておくべきです。バッファーの列0にdefunの開始でないカッコまたは大カッコが含まれていて、これらのカッコまたは大カッコを削除するのが何らかの理由で現実的でない場合、このオプションを`nil`にするのが役に立つかもしれません。しかしこれは大きなバッファーのスクロールや、表示の速度を著しく低下させるかもしれないことを知っておいてください。さらに、正しく機能させるために、バッファー全体を通じてカッコまたは大カッコが、正しく対応が取れていなければなりません。

### defunの移動

defuns
これらのコマンドはトップレベルの主要な定義、またはdefunsにもとづいてポイントを移動したり、リージョンをセットアップします。

`C-M-a`  
カレントまたは直前のdefunの先頭に移動します(`beginning-of-defun`)。

`C-M-e`  
カレントまたは直後のdefunの最後に移動します(`end-of-defun`)。

`C-M-h`  
カレントまたは後続のdefun全体の周囲にリージョンを設定します(`mark-defun`)。

move to beginning or end of function
function, move to beginning or end
C-M-a
C-M-e
C-M-h
beginning-of-defun
end-of-defun
mark-defun
カレントのdefunの先頭または最後に移動するコマンドは、`C-M-a` (`beginning-of-defun`)と`C-M-e` (`end-of-defun`)です。これらのコマンドの1つを繰り返すか、正の数引数を使用すると、繰り返しごとに動作方向の次のdefunに移動します。

`C-M-a`で負の引数−nを指定すると、次のdefunの開始へとn回移動します。これは`C-M-e`に引数nを与えたときに移動する位置と、正確に同じではありません。defunの終わりは通常、後続のdefunの開始と同じ位置ではないからです(空白文字、コメント、もしかしたら宣言がこれらのdefunを分割するからです)。同様に`C-M-e`に負の引数を与えると、defunの最後に後方に移動しますが、これは`C-M-a`に正の引数を与えた場合とは完全に異なる位置になります。

C-M-h (C mode)
c-mark-function
カレントのdefunを操作するには、`C-M-h` (`mark-defun`)を使用します。これはカレントのdefunの最後にマークをセットし、先頭にポイントを配します。[Marking Objects](#Marking-Objects)を参照してください。これは、そのdefunをkillしてファイルの他の場所に移動するための、一番簡単な準備方法です。defunの直前(間に空行を挟まない)にコメントがある場合は、そのコメントもマークされます。ポイントがdefunの間にある場合は、後続のdefunを使用します。マークがすでにアクティブのときにこのコマンドを使用すると、リージョンの最後が、複数のdefunを含むように拡張されます。プレフィクス引数を指定した場合は、その数のdefunをマークするか、適切な数のdefunになるようリージョンを拡張します。負のプレフィクス引数の場合は、反対方向のdefunをマークするとともに、以降の`mark-defun`使用での選択方向も変更します。

Cモードでは、`mark-defun`とほとんど同じな`c-mark-function`を実行します。違いは、それが引数定義、関数名、リターンデータ型を含むことで、これによりC関数全体にリージョンが設定されます。これは標準のキーバインディングをメジャーモードが調整する方法の例です。これにより特定の言語によりふさわしい方法で標準的な作業を行うのです。この目的のために、他のメジャーモードは、これらのキーバインディングすべてを置き換えているかもしれません。

### Imenuとは

index of buffer definitions
buffer definitions index
Imenu機能は、ファイル内の主要な定義を、名前で検索する方法を提供します。これはチャプター、セクションなどを扱う、テキストフォーマッターのためのメジャーモードでも有用です(複数ファイルを扱う、より強力な機能については、[Xref](#Xref)を参照してください)。

imenu
`M-x
imenu`とタイプすると、これはミニバッファーを使用して定義の名前を読み取り、ポイントをその定義に移動します。名前の指定に補完を使用できます。このコマンドは常に有効な名前の全体のリストを表示します。

imenu-add-menubar-index
かわりに、コマンド`imenu`をマウスクリックにバインドできます。そうすると定義名を選択するために、マウスメニューが表示されます。`imenu-add-menubar-index`を呼び出して、バッファーのインデックスをメニューバーに追加することもできます。特定のメジャーモードのすべてのバッファーにたいして、このメニューバーアイテムを有効にしたい場合、モードフックに`imenu-add-menubar-index`を追加して、これを行うことができます。しかし、それを行うことにより、そのモードでファイルをvisitするたびに、Emacsがそのバッファーのすべての定義を検索する間、待つ必要があります。

imenu-auto-rescan
バッファーの内容を変更する際、定義の追加や削除をした場合は、メニューの‘`*Rescan*`’アイテムを呼び出すことにより、新しい内容にもとづいてバッファーのインデックスを更新することができます。`imenu-auto-rescan`を非`nil`値にセットした場合、再スキャンは自動的に発生します。テキストを少量変更しただけの場合、再スキャンは必要ありません。

imenu-auto-rescan-maxout
`imenu-auto-rescan`は、バイト数が`imenu-auto-rescan-maxout`より大きいバッファーでは無効にされるでしょう。

imenu-sort-function
変数`imenu-sort-function`をセットして、メニューがソートされる方法をカスタマイズすることができます。デフォルトでは、名前はバッファーで出現する順にソートされています。アルファベット順にソートしたいときは、値にシンボル`imenu--sort-by-name`を使用します。Lispコードを記述することにより、独自の比較関数を定義することもできます。

ImenuはWhich Functionモードに情報を提供します ([Which Function](#Which-Function)を参照してください)。 Speedbarもこれを使用します([Speedbar](#Speedbar)を参照してください)。

### Which Functionモード

current function name in mode line
Which Function(どの関数)モードは、グローバルなマイナーモード([Minor Modes](#Minor-Modes)を参照してください)で、これはカレントの関数名をモードラインに表示して、バッファーの移動にしたがってそれを更新します。

which-function-mode
which-func-modes
Which Functionモードを有効または無効にするには、コマンド`M-x which-function-mode`を使用します。Which Functionモードは、グローバルなマイナーモードです。デフォルトでは、それをサポートする方法を知っている、すべてのメジャーモード(たとえばImenuをサポートするすべてのメジャーモード)に影響を与えます。変数`which-func-modes`の値を`t`(これは利用可能なすべてのメジャーモードをサポートすることを意味します)から、特定のメジャーモードのリストに変更することにより、これを制限することができます。

プログラムのインデント
----------------------

indentation for programs
プログラムを正しくインデントされた状態に保つには、何か変更したらEmacsを使って再インデントするのが一番よい方法です。Emacsには1行、指定した数の行、1つのカッコでグループ化されたすべての行をインデントするコマンドがあります。

インデントに間する全般的な情報は、[Indentation](#Indentation)を参照してください。このセクションでは、プログラミング言語のモードに特有のインデント機能について説明します。

pretty-printer
Emacsは`pp`パッケージで、Lispのプリティープリンター(pretty-printer)も提供します。これはLispオブジェクトを、見栄えのよいインデントで再フォーマットします。section “pp” in The Emacs Lisp Reference Manualを参照してください。

### プログラムの基本的なインデントコマンド

`TAB`  
カレント行のインデントを調整します(`indent-for-tab-command`)。

`RET`  
改行を挿入して、次の行のインデントを調整します(`newline`)。

TAB (programming modes)
indent-line-function
基本的なインデントコマンドは`TAB` (`indent-for-tab-command`)で、これは[Indentation](#Indentation)で説明されています。プログラミング言語のモードでは、`TAB`は前の行のインデントと構文的な内容にもとづき、カレント行をインデントします。リージョンがアクティブのとき、`TAB`はカレント行だけでなく、リージョン内の各行をインデントします。

[Inserting Text](#Inserting-Text)で説明されているコマンド`RET` (`newline`)は、`C-j`の後に`TAB`を続けるのと同じです。これは改行を挿入してから、その行のインデントを調整します。

カッコによるグループ化により開始される行でインデントする場合、通常Emacsはグループ内の前の行の開始、または、カッコの後ろのテキストの下に、行の開始を合わせます。(たとえば美的観点により)これらの行に手動で非標準的なインデントを与えた場合は、その下の行もそれにしたがいます。

プログラミング言語のモードのほとんどは、左端の開きカッコ、開き大カッコ(open-brace)、その他の開始区切りを関数の開始とみなします。編集しているコードがこの前提に違反する場合は — それらの区切りが文字列やコメントの中にある場合でも — インデントが正しく機能するために、`open-paren-in-column-0-is-defun-start`に`nil`をセットしなければなりません。[Left Margin Paren](#Left-Margin-Paren)を参照してください

### 複数行のインデント

複数行のコードを、1度に再インデントしたいときがあるかもしれません。これを行う1つの方法は、マークを使う方法です。マークがアクティブでリージョンが空でないとき、`TAB`はリージョン内の各行をインデントします。一方、コマンド`C-M-\` (`indent-region`)は、マークがアクティブか否かにかかわらず、リージョン内の各行をインデントします([Indentation Commands](#Indentation-Commands)を参照してください)。

それらに加えて、Emacsはコードの大きな断片をインデントするために、以下のコマンドを提供します:

`C-M-q`  
カッコでグループ化された、すべての行を再インデントします。

`C-u TAB`  
カッコでグループ化されたすべてを横にシフトして、最初の行が正しくインデントされるようにします。

`M-x indent-code-rigidly`  
リージョン内のすべての行を横にシフトしますが、コメントや文字列内で開始される行は変更しません。

C-M-q
indent-pp-sexp
1つのカッコでグループ化されたものを再インデントするには、ポイントをグループ化の前に配して、`C-M-q`とタイプします。これはグループ化されたものの全体的なインデント(たとえばグループ化が開始される行のインデント)は変更せずに、相対的なインデントを変更します。`C-M-q`で実行される関数は、Lispモードでは`indent-pp-sexp`、Cモードでは`c-indent-exp`、のようにメジャーモードに依存します。全体的なインデントも同様に訂正したい場合は、最初に`TAB`をタイプします。

C-u TAB
グループ内の相対的なインデントは好ましいが、それの最初の行のインデントが好ましくない場合は、その最初の行にポイントを移動して`C-u
TAB`とタイプします。Lisp、C、他のいくつかのメジャーモードでは、数引数を指定した`TAB`は通常どおりカレント行をインデントしてから、カレント行で始まる、カッコでグループ化されたすべての行を同じ量で再インデントします。このコマンドは巧妙なので、文字列内で開始される行は変更しません。CモードのときはCプリプロセッサー行は変更しませんが、それらにアタッチされた継続行は再インデントします。

indent-code-rigidly
コマンド`M-x
indent-code-rigidly`は、`indent-rigidly`が行うように([Indentation Commands](#Indentation-Commands)を参照してください)、リージョン内のすべての行を厳格(rigidly)にシフトします。このコマンドはリージョンが文字列内で開始される場合を除き、文字列内で開始される行のインデントは変更しません。プレフィクス引数は、インデントする列数です。

### Lispのインデントのカスタマイズ

customizing Lisp indentation
Lisp式のインデントパターンは、式により呼ばれる関数によって決定することができます。それぞれのLisp関数のために、事前定義された複数のインデントパターンの中から選択するか、Lispプログラムで独自のものを定義できます。

標準的なインデントのパターンは以下のとおりです。最初の引数が式の開始行にある場合、式の2行目は最初の引数の下にインデントされます。そうでない場合、2行目は関数名の下にインデントされ、後続の行はネストの深さが同じなら前の行の下にインデントされます。

lisp-indent-offset
変数`lisp-indent-offset`が非`nil`の場合、これは式の2行目の通常のインデントパターンをオーバーライドするので、常にこれを含むリストより`lisp-indent-offset`列余計にインデントされます。

lisp-body-indent
特定の関数は、標準のパターンをオーバーライドします。名前が`def`で始まる関数は、式の開始の開きカッコより`lisp-body-indent`列多く2行目をインデントすることにより、2行目をbodyの開始として扱います。

lisp-indent-function
property
関数名の`lisp-indent-function`プロパティーにより、個々の関数の標準パターンを、さまざまな方法でオーバーライドできます。これは通常`declare`構成を使用することにより、マクロ定義のために行われます。section “Defining Macros” in The Emacs Lisp Reference Manualを参照してください。

### Cのインデントのためのコマンド

Cおよび関連するモードのインデントのために、特別な機能があります。

`C-c C-q`  
C-c C-q (C mode)

c-indent-defun

カレントのトップレベル関数を再インデント、または型定義を統合します(`c-indent-defun`)。

`C-M-q`  
C-M-q (C mode)

c-indent-exp

ポイントの後ろの、対応が取れた式の中の各行を再インデントします(`c-indent-exp`)。プレフィクス引数は、無効な構文についての警告メッセージを抑制します。

`TAB`  
c-indent-command

カレント行の再インデントおよび／またはタブ文字を挿入する場合もあります(`c-indent-command`)。

c-tab-always-indent

`c-tab-always-indent`が`t`の場合、このコマンドは常にカレント行をインデントし、他には何もしません。これがデフォルトです。

この変数が`nil`の場合、このコマンドはポイントが左端か、その行のインデント位置にある場合だけ、カレント行を再インデントします。そうでない場合、このコマンドはタブ(`indent-tabs-mode`が`nil`の場合は等価な数のスペース)を挿入します。

(`nil`でも`t`でもない)他の値の場合、常にその行をインデントし、コメントか文字列の中の場合は、タブも挿入します。

カレントバッファー全体を再インデントするには、`C-x h
C-M-\`とタイプします。これは最初にバッファー全体をリージョンとして選択し、それからリージョンを再インデントします。

カレントブロックを再インデントするには、`C-M-u
C-M-q`を使用します。これはブロックの前に移動してから、ブロックのすべてを再インデントします。

### Cのインデントのカスタマイズ

style (for indentation)
Cモードおよび関連するモードは、インデントをカスタマイズするために柔軟なメカニズムを使用します。Cモードはソース行を2ステップでインデントします。最初のステップは、行の内容とコンテキストに応じて行の構文を分類します。次のステップで、構文コンストラクトで選択されたスタイルにより、関連付けられたインデントのオフセットを決定して、これをアンカーとなる命令文(anchor statement)のインデントに加えます。

`C-c . style RET`  
事前に定義されたスタイルstyleを選択します(`c-set-style`)。

スタイルとは、Cモードおよび関連するモードで使用できるカスタマイズ用の名前つきコレクションです。完全な説明は、section “Styles” in The CC Mode Manualを参照してください。Emacsには、`gnu`、`k&r`、`bsd`、`stroustrup`、`linux`、`python`、`java`、`whitesmith`、`ellemtel`、`awk`を含む、事前に定義されたスタイルがいくつか付属します。これらのスタイルのうちいくつかは、主に1つの言語を意図したものですが、他のスタイルはこれらのモードをサポートする任意の言語で使用できます。スタイルがどのように見えるかは、何らかのコードにたいしてスタイルを選択して、(たとえば関数定義の最初で`C-M-q`とタイプして)再インデントしてみることです。

C-c . (C mode)
c-set-style
カレントバッファーのスタイルを選択するには、コマンド`C-c
.`を使用します。引数として、スタイル名を指定します(大文字小文字に意味はありません)。このコマンドはカレントバッファーだけに影響し、将来のインデントコマンドの呼び出しだけに影響します。そのバッファーにすでにあるコードの再インデントはしません。バッファー全体を新しいスタイルで再インデントするには、`C-x
h C-M-\`とタイプしてください。

c-default-style
変数`c-default-style`をセットして、さまざまなメジャーモードにたいしてデフォルトのスタイルを指定できます。この値は、スタイル名(文字列)、または各要素が1つのメジャーモードと、それに使用するインデントスタイルを指定するalistです。たとえば、

    (setq c-default-style
          '((java-mode . "java")
            (awk-mode . "awk")
            (other . "gnu")))

これはJavaモード、AWKモードにたいして明示的に選択して、その他のC-likeなモードにたいしては、デフォルトの‘`gnu`’スタイルを指定します。この変数はC-likeなメジャーモードを選択したときに効果を表します。したがってJavaモードにたいして新しいデフォルトスタイルを指定するには、既存のJavaモードのバッファーで、`M-x
java-mode`とタイプすることにより効果が表れます。

`gnu`スタイルは、CにたいするGNUプロジェクトで推奨されるフォーマットを指定します。これがデフォルトで、私たちが使用を推奨するスタイルです。

既存のスタイルのオーバーライドや、独自のスタイルを定義する方法など、Cおよび関連するモードにたいするインデントのカスタマイズに間する情報は、section “Indentation Engine Basics” in the CC Mode Manual、およびsection “Customizing Indentation” in the CC Mode Manualを参照してください。

c-guess
c-guess-install
スタイルを指定するかわりに、サンプルコードのバッファーで`M-x
c-guess`とタイプすることにより、Emacsにスタイルを推測させることができます。その後、`M-x
c-guess-install`として、推測されたスタイルを他のバッファーに適用できます。詳細については、section “Guessing the Style” in the CC Mode Manualを参照してください。

カッコに付随する編集のためのコマンド
------------------------------------

check-parens
unbalanced parentheses and quotes
このセクションでは、プログラム内のカッコ構造を活用したり、それらを対応が取れた状態に保つためのコマンドと機能について説明します。

これらの機能を語るとき、用語“カッコ(parenthesis)”には、大カッコ(braces)、角カッコ(brackets)、またはマッチするペアとして定義される区切りも含まれます。メジャーモードはどの区切りに意味があるかを、構文テーブル(syntax table)を通じて制御します(section “Syntax Tables” in The Emacs Lisp Reference Manualを参照してください)。Lispでは丸カッコ(parentheses)だけが考慮され、Cではこれらのコマンドは大カッコや角カッコにも適用されます。

`M-x
check-parens`を使用して、バッファー内の対応の取れていないカッコと、対応が取れていない文字列のクォートを検索することができます。

### 対応が取れたカッコの式

sexp
expression
balanced expression
プログラミング言語のモードはそれぞれ、対応が取れた式(balanced expression)にたいする、独自の定義をもちます。対応が取れた式は通常、個別のシンボル、数字、文字列定数、同様にマッチする区切りで囲まれたコードの断片を含みます。以下のコマンドは対応が取れた式にたいするものです(Emacsでは、内部的にそのような式はsexpとして参照されます[13])。

`C-M-f`  
対応が取れた式を、前方に飛び越して移動します(`forward-sexp`)。

`C-M-b`  
対応が取れた式を、後方に飛び越して移動します(`backward-sexp`)。

`C-M-k`  
対応が取れた式を、前方にkillします(`kill-sexp`)。

`C-M-t`  
式を入れ替えます(`transpose-sexps`)。

`C-M-@`; `C-M-SPC`  
後続の式の後ろに、マークを配します(`mark-sexp`)。

C-M-f
C-M-b
forward-sexp
backward-sexp
対応が取れた式を前方に飛び越して移動するには、`C-M-f` (`forward-sexp`)を使用します。ポイントの後ろの最初の文字が開始区切り(たとえばCでは‘`(`’、‘`[`’、‘`{`’)の場合、このコマンドはそれにマッチする終了区切りまで移動します。文字がシンボル、文字列、数字で始まる場合、このコマンドはそれらを飛び越して移動します。

コマンド`C-M-b` (`backward-sexp`)は対応が取れた式を後方 — `C-M-f`と同様ですが逆向き — に飛び越して移動します。式の前にプレフィクス文字がある場合(Lispではシングルクォート、バッククォート、カンマ)、このコマンドはそれらも同様に飛び越して後方に移動します。

`C-M-f`および`C-M-b`に数引数を与えると、指定した回数繰り返し操作をします。負の引数を与えると、反対の方向に移動します。ほとんどのモードでは、これらの2つのコマンドはコメントをあたかも空白文字のように通過します。これら`C-M-f`および`C-M-b`のキーは、文字単位で移動する`C-f`および`C-b`([Moving Point](#Moving-Point)を参照してください)、単語単位に移動する`M-f`および`M-b`([Words](#Words)を参照してください)に類似していることに注意してください。

killing expressions
C-M-k
kill-sexp
対応が取れた式全体をkillするには、`C-M-k` (`kill-sexp`)とタイプします。これは`C-M-f`が飛び越すテキストをkillします。

transposition of expressions
C-M-t
transpose-sexps
`C-M-t` (`transpose-sexps`)は、前にある対応の取れた式と、次の対応の取れた式の位置をスイッチします。このコマンドは、文字を入れ替える`C-t`コマンド([Transpose](#Transpose)を参照してください)と類似しています。`C-M-t`への引数は繰り返し回数を意味し、前の式を、何個か先の式に移動します。負の引数は前にある対応が取れた式を後方に、それらの式の前に移動します。引数0は何もしないのではなく、ポイントの位置で終わる対応が取れた式、またはポイントの後ろの式と、マークの後ろの式を入れ替えます。

C-M-SPC
リージョンにたいして動作するコマンドで対応が取れた式を操作するには、`C-M-SPC` (`mark-sexp`)とタイプします。これは`C-M-f`が移動する位置にマークをセットします。マークがアクティブの間、このコマンドを連続で呼び出すとマークが1つの式ごとにシフトしてリージョンが拡張します。正または負の引数はマークを前方または後方に指定した数の式分のマークを移動します。エイリアス`C-M-@`は、`C-M-SPC`と等価です。これに関連したコマンドは、[Marking Objects](#Marking-Objects)を参照してください。

Cのように挿入オペレーター(infix operators)を使用する言語では、与えられた位置で複数の可能な解釈があるので、すべての対応が取れた式を認識するのは不可能です。たとえば‘`foo
+
bar`’は1つのCの式ですが、Cモードはこれを1つの式とは扱いません。かわりに‘`foo`’を1つの式、‘`bar`’をもう1つの式、そしてそれらの間にある‘`+`’を句読点として認識します。しかしカッコがあればCモードは‘`(foo
+ bar)`’を1つの式として認識します。

### カッコ構造の移動

parenthetical groupings
parentheses, moving across
matching parenthesis and braces, moving to
braces, moving across
list commands
以下のコマンドはカッコ(または、あなたが使用している言語で、そのような区切りとして使用される文字)で区切られてグループ化されたものを移動するコマンドです。これらのコマンドは、カッコを含んでいたとしても文字列とコメントを無視し、エスケープ文字でクォートされたカッコも無視します。これらのコマンドは主にプログラムの編集を意図していますが、カッコを含む任意のテキストの編集にも有用です。これらは内部的には“リストコマンド”として参照されます。なぜならLispではこれらのグループはリストだからです。

これらのコマンドは、開始ポイントが文字列やコメントの中でないと仮定します。これらのコマンドを文字列やコメントの中から呼び出したとき、結果は信頼できません。

`C-M-n`  
カッコでグループ化されたグループを飛び越えて、前方に移動します(`forward-list`)。

`C-M-p`  
カッコでグループ化されたグループを飛び越えて、後方に移動します(`backward-list`)。

`C-M-u`  
カッコによる構造を上に移動します(`backward-up-list`)。

`C-M-d`  
カッコによる構造を下に移動します(`down-list`)。

C-M-n
C-M-p
forward-list
backward-list
リスト(list)コマンドの`C-M-n` (`forward-list`)と、`C-M-p` (`backward-list`)は、グループ化されたカッコを前方または後方に、1つ(またはn個)飛び越えて移動します。

C-M-u
backward-up-list
`C-M-n`と`C-M-p`は、カッコによる構造において同じレベルに留まろうと試みます。1レベル(またはnレベル)*上*に移動するには、`C-M-u` (`backward-up-list`)を使用します。`C-M-u`は対応が取れていない、前にある開始区切りへ、後方に移動します。正の引数は繰り返し回数を意味します。負の引数は移動の方向を逆転するので、このコマンドは1レベル以上を上に、前方に移動します。

C-M-d
down-list
カッコによる構造を*下*に移動するには、`C-M-d` (`down-list`)を使用します。Lispモードでは‘`(`’は開始区切りなので、これは‘`(`’を検索するのとほとんど同じです。引数は何レベルしたに移動するかを指定します。

### マッチするカッコ

matching parentheses
parentheses, displaying matches
Emacsにはカッコのマッチング(parenthesis matching)機能がいくつかあります。これにより、どのカッコ(または他の区切り)がどのようにマッチするか簡単に見ることができます。

終了文字となる自己挿入文字をタイプすると、Emacsはそれがスクリーン上にあれば、マッチする開始区切りの位置を簡単に示します。スクリーン上にない場合、Emacsは開始区切りの近くにあるテキストをエコーエリアに表示します。どちらの方法でも、どのグループを終了したのか見分けることができます。開始区切りと終了区切りがマッチしない — ‘`[x)`’のような場合、エコーエリアに警告メッセージが表示されます。

blink-matching-paren
blink-matching-paren-distance
blink-matching-delay
3つの変数が、マッチするカッコの表示を制御します:

-   `blink-matching-paren`は、この機能をオンまたはオフに切り替えます。`nil`は無効にしますが、デフォルトの`t`は有効にします。`jump`にセットすると、マッチする開始区切りに数瞬カーソルを移動して指示します。`jump-offscreen`にセットすると、開始区切りが画面上にない場合でもカーソルをジャンプさせます。

-   `blink-matching-delay`は、マッチする開始区切りを何秒表示するかを指定します。これには整数または浮動小数点数を指定します。デフォルトは1です。

-   `blink-matching-paren-distance`には、マッチする開始区切りを後方に何文字検索するかを指定します。この文字数内にマッチが見つからない場合、Emacsは検索を中止して、何も表示しません。デフォルトは102400です。

Show Paren mode
highlighting matching parentheses
show-paren-mode
グローバルなマイナーモードのShow Parenモードは、より強力な自動的なマッチングの類を提供します。これは開始区切りの前、または終了区切りの後ろにポイントを移動すると、開始区切りと終了区切り、間にあるテキスト(オプション)をハイライトします。Show Parenモードに切り替えるには、`M-x show-paren-mode`とタイプします。これをカスタマイズするには、`M-x
customize-group RET
paren-showing`とタイプします。このモードの処理を制御するカスタマイズ可能なオプションには、以下が含まれます:

-   show-paren-highlight-openparen
    `show-paren-highlight-openparen`は、ポイントが開きカッコの直前にあるとき(つまり、その位置にカーソルがにあるとき)、そのカッコをハイライトするかどうかを制御します。デフォルトは非`nil` (ハイライトする)です。

-   show-paren-style
    `show-paren-style`は、2つのカッコだけをハイライトするか、それともカッコの間のスペースもハイライトされるかを制御します。有効なオプションは、`parenthesis` (マッチするカッコをハイライト)、`expression` (カッコで括られた式全体をハイライト)、`mixed` (カッコが表示されているときはマッチするカッコ、カッコが表示されていないときは式をハイライト)です。

-   show-paren-when-point-inside-paren
    `show-paren-when-point-inside-paren`が非`nil`の場合は、ポイントがカッコの内側にあるときもハイライトされます。

-   show-paren-when-point-in-periphery
    `show-paren-when-point-in-periphery`が非`nil`の場合は、行の先頭が空白文字で開始されていて、ポイントがその空白文字範囲の中にあり、その行の非空白文字の最初または最後がカッコの場合は、そのカッコもハイライトします。同様に、行の末尾が空白文字で終端されていて、ポイントがその空白文字範囲の中にあり、その行の非空白文字の最後がカッコの場合は、そのカッコもハイライトします。

Electric Pair mode
inserting matching parentheses
electric-pair-mode
グローバルなマイナーモードのElectric Pairモードは、マッチするカッコ(parentheses)、大カッコ(braces)、角カッコ(brackets)、...などの 区切りを簡単に挿入する方法を提供します。開始区切りを挿入すると、マッチする終了区切りが自動的に挿入され、2つの区切りの間にポイントが置かれます。反対に終了区切りを既存の区切りの先に挿入した場合、何の挿入もされず、その位置は単にスキップされます。リージョンがアクティブ([Mark](#Mark)を参照)の場合、区切りの挿入はそのリージョンを操作します。リージョン内の文字はマッチする区切りのペアー内に括られ、ポイントはタイプした区切りの後に置かれます。

以下の変数は、Electric Pairモードの追加機能を制御するのに使用できます:

-   electric-pair-preserve-balance
    `electric-pair-preserve-balance` — 非`nil`の場合、デフォルトのペアリングロジックは、開始区切りと終了区切りの数のバランスになります。

-   electric-pair-delete-adjacent-pairs
    `electric-pair-delete-adjacent-pairs` — 非`nil`の場合、隣接する区切りの間でのバックスペースにより、終了区切りも自動的に削除します。

-   electric-pair-open-newline-between-pairs
    `electric-pair-open-newline-between-pairs` — 非`nil`の場合、2つの隣接するペアの間での改行の挿入は、ポイントの後ろに自動的に追加の改行をオープンします。

-   electric-pair-skip-whitespace
    `electric-pair-skip-whitespace` — 非`nil`の場合、終了区切りのスキップを決定する前に、マイナーモードが空白文字を前方にスキップするようにします。

Electric Pairモードに切り替えるには、`M-x
electric-pair-mode`とタイプします。1つのバッファーにたいしてこのモードを切り替えるには、`M-x
electric-pair-local-mode`を使用してください。

コメントの操作
--------------

comments
コメントは、プログラミングにおいて重要なパートなので、Emacsはコメントの編集や挿入を行う特別なコマンドを提供します。Flyspell Progモードによる、コメントのスペルチェックも行うことができます([Spelling](#Spelling)を参照してください)。

異なる種類のコメントのインデントにたいして、特別なルールをもつメジャーモードがいくつかあります。たとえばLispコードでは、2つのセミコロンで始まるコメントは、それらの行がコードであるかのようにインデントされ、3つのセミコロンで始まるコメントは左端に揃えてインデントされ、しばしば区分けの目的で使用されます。Emacsはこれらの慣習を理解します。たとえば、コメント行で`TAB`をタイプすると、そのコメントを適切な位置にインデントします。

    ;; This function is just an example.
    ;;; Here either two or three semicolons are appropriate.
    (defun foo (x)
    ;;;  And now, the first part of the function:
      ;; The following line adds one.
      (1+ x))           ; This line adds one.

### コメントコマンド

indentation for comments
alignment for comments
以下のコマンドは、コメントにたいして処理を行います:

`M-;`  
カレント行にコメントを挿入、または位置揃えします。リージョンがアクティブのときは、かわりにリージョンをコメント化、または非コメント化します(`comment-dwim`)。

`C-x C-;`  
カレント行をコメント、または非コメントにします(`comment-line`)。リージョンがアクティブの場合は、かわりにリージョンをコメント、または非コメントにします。

`C-u M-;`  
カレント行のコメントをkillします(`comment-kill`)。

`C-x ;`  
コメント列をセットします(`comment-set-column`)。

`C-M-j`; `M-j`  
`RET`の後にコメントを挿入して位置揃えします(`comment-indent-new-line`)。[Multi-Line Comments](#Multi_002dLine-Comments)を参照してください。

`M-x comment-region`; `C-c C-c` (C-likeなモードの場合)  
リージョンのすべての行にたいして、コメント区切りを追加します。

M-;
comment-dwim
コメントを挿入または位置揃えするコマンドは、`M-;` (`comment-dwim`)です。単語“dwim”は、“Do What I Mean(私が言ったとおりにしてください)”の頭文字をとったものです。このコマンドは、コメントに関係する多くの異なる作業に使用できます。それは、このコマンドをどこで使うかという、状況に依存することを示します。

リージョンがアクティブ([Mark](#Mark)を参照してください)の場合、`M-;`はリージョンのコメント区切りの追加と削除のどちらかを行います。リージョンの各行がすでにコメントの場合、それらのコメント区切りを削除することにより、それらの行を非コメント化します。そうでない場合は、リージョンのテキストにコメント区切りを追加します。

リージョンがアクティブのときに`M-;`に数引数を与えると、それは追加または削除するコメント区切りの数を指定します。正の引数nはn個の区切りを追加し、負の引数-nはn個の区切りを削除します。

リージョンが非アクティブで、カレント行にコメントがない場合、`M-;`はカレント行に新しいコメントを追加します。ブランク行(たとえば空または空白文字しか含まない)の場合、`TAB`をタイプしたときにインデントされるのと同じ位置に、コメントがインデントされます([Basic Indent](#Basic-Indent)を参照)。非ブランク行の場合、コメントはその行の最後の非空白文字の後ろに配されます。Emacsは、可能なら変数`comment-column`と`comment-fill-column` ([Options for Comments](#Options-for-Comments)を参照)で指定された列の間にコメントを配そうと試みます。それ以外では、Emacsは別の適切な位置、通常、非コメントのテキストと少なくとも1つのスペースを空けてコメントを配します。どちらの場合も、Emacsはコメントの開始区切りの後にポイントを配すので、すぐにコメントのタイプを開始できます。

既存のコメントの位置揃えにも`M-;`を使用できます。行がすでにコメント開始文字列を含む場合、`M-;`は慣習的な位置にそれを位置揃えして、ポイントをコメント開始区切りの後ろに移動します。例外として、列0で始まるコメントは移動されません。既存のコメントがすでに正しく位置揃えされているときでも、`M-;`はコメントテキストの開始に直接移動するので有用です。

comment-line
C-x C-;
`C-x C-;` (`comment-line`)は、行そのものをコメント化または非コメント化します。リージョンがアクティブ([Mark](#Mark)を参照してください)の場合は、リージョン内の行をコメント化または非コメント化します。リージョンが非アクティブの場合、このコマンドはポイントがある行をコメント化または非コメント化します。正のプレフィクス引数nを与えた場合、カレント行から数えてn行を処理します。nが負の場合、先行するn行に作用します。負の引数を与えてこのコマンドを呼び出した後は、それに続けて正の引数を指定して連続して呼び出した場合、あたかも負の引数が与えられたかのように、先行する行を処理します。

comment-kill
C-u M-;
`C-u M-;` (`comment-dwim`にプレフィクス引数を指定)は、カレント行の任意のコメントを、それの前の空白文字と一緒にkillします。コメントはkillリングに保存されるので、他の行の行末に移動して`C-y`で挿入して、`M-;`でコメントの位置揃えをすることができます。`M-x
comment-kill`とタイプしても`C-u
M-;`と同じ効果を得ることができます(`comment-dwim`はプレフィクス引数を与えられたとき、実際にサブルーチンとして`comment-kill`を呼び出します)。

C-c C-c (C mode)
comment-region
uncomment-region
コマンド`M-x
comment-region`は、アクティブなリージョンにたいして`M-;`を呼び出すのと等価ですが、このコマンドはマークが非アクティブのときでも、常にリージョンにたいして動作します。Cモードおよび関連するモードでは、このコマンドは`C-c
C-c`にバインドされています。コマンド`M-x
uncomment-region`は、リージョンの各行を非コメント化します。数引数は、削除するコメント区切りの数を指定します(負の引数は、追加するコメント区切りの数を指定します)。

C-likeなモードにたいしては、変数`c-indent-comment-alist`および`c-indent-comments-syntactically-p`をセットすることにより、`M-;`の正確な効果を設定できます。たとえば閉じ大カッコで終わる行では、`M-;`は`comment-column`ではなく、大カッコの後ろにスペースを1つ空けてコメントを配します。完全な詳細は、section “Comment Commands” in The CC Mode Manualを参照してください。

### 複数行のコメント

C-M-j
M-j
blank lines in programs
comment-indent-new-line
comment-multi-line
コメントをタイプするとき、それを次の行に継続したくなったときは、`M-j`または`C-M-j` (`comment-indent-new-line`)とタイプします。これはカレント行を行ブレークして、コメントを継続するために必要なコメント区切りとインデントを挿入します。

コメントの終了区切りをもつ言語(たとえばCの‘`*/`’)では、`M-j`の正確な振る舞いは、変数`comment-multi-line`の値に依存します。変数の値が`nil`の場合、このコマンドは古い行のコメントを終了させて、新しい行で新しいコメントを開始します。そうでない場合、カレントのコメント区切りの中で新しい行を開きます。

Auto Fillモードがオンの場合、コメントをタイプしているときにフィル列に達すると、明示的に`M-j`を呼び出したときと同じ方法で、コメントが継続されます。

既存の行をコメントにするには、リージョンがアクティブのときは`M-;`、または`M-x comment-region`を使用します。 as described in the preceding section.

複数行ブロックのコメントの行の開始で‘`/`’をタイプすると、コメントを終了するようにCモードを設定できます。これを行なうには、クリーンアップ(clean-up)で、`comment-close-slash`を有効にします。section “Clean-ups” in The CC Mode Manualを参照してください。

### コメントを制御するオプション

comment-column
comment-fill-column
C-x ;
comment-set-column
[Comment Commands](#Comment-Commands)で示したように、`M-j`コマンドが行にコメントを追加するとき、バッファーローカルな変数`comment-column`と`comment-fill-column`(`nil`の場合は`fill-column`の値。[Fill Commands](#Fill-Commands)を参照されたい)の間にコメントを配そうと試みます。このバッファーローカルな変数のデフォルト値、またはローカルな値は、通常の方法でセットできます([Locals](#Locals)を参照)。かわりに`C-x
;` (`comment-set-column`)とタイプすることにより、カレントバッファーの`comment-column`の値を、現在コメントがある列にセットすることができます。`C-u
C-x
;`は、コメント列をそのバッファーのポイントの前にある最後のコメントにセットします。その後で`M-;`を行うことにより、カレント行のコメントを前のコメントに揃えることができます。

comment-start-skip
コメントコマンドは、変数`comment-start-skip`の値である正規表現にもとづいて、コメントを認識します。この正規表現がヌル文字列にマッチしないように気をつけてください。単語という言葉の厳格な意味から考えると、これはコメント開始区切りより長い文字列にマッチするかもしれません。たとえばCモードでの変数の値は`"\\(//+\\|/\\*+\\)\\s
*"`で、これは‘`/*`’自身と、その後ろの余分なアスタリスクやスペースにマッチし、C++スタイルのコメントも許容します(文字列に‘`\`’を含む場合、Lisp構文では‘`\\`’と記述する必要があることに注意してください。これは最初のアスタリスクにたいして、正規表現においてアスタリスクがもつ特別な意味を打ち消すために必要です)。

comment-start
comment-end
コメントコマンドが新しいコメントを作るとき、これは`comment-start`の値をコメント開始区切りとして挿入します。これはポイントの後ろに、コメント終了区切りとして`comment-end`の値も挿入します。たとえばLispモードでは`comment-start`が‘`";"`’で、`comment-end`が`""`(空文字列)です。Cモードでは`comment-start`が`"/*
"`で、`comment-end`が`" */"`です。

comment-padding
変数`comment-padding`は、コメントコマンドが、コメント区切りとコメントテキストの間を区切る文字列を指定します。デフォルトでは‘`"
"`’、つまり1つのスペースが指定されます。かわりに数字を指定すると、これは指定した数のスペースになり、`nil`の場合、スペースは挿入されません。

変数`comment-multi-line`は、`M-j`とAuto Fillモードがコメントをどのように複数行に継続するかを制御します。[Multi-Line Comments](#Multi_002dLine-Comments)を参照してください。

comment-indent-function
変数`comment-indent-function`は、新しく挿入されたコメント、または既存のコメントの位置揃え位置を計算するために呼び出される関数を指定します。これはメジャーモードごとに異なります。関数は引数なしで呼び出されますが、新しいコメントが挿入されるときはコメント開始位置のポイント、または行末のポイントで呼び出されます。この関数はコメントが開始されるべき列を返す必要があります。たとえばLispモードでは、デフォルト関数の決定は、既存のコメントがいくつのコメント文字で始まるかにもとづきます。

さらにEmacsは、コメントを付近の行と揃えるようとも試みます。これをオーバーライドするには、インデントの許容できる範囲を示す、(もしかしたら等しい)2つの整数から成るコンスを関数がしても構いません。

ドキュメントの照会
------------------

Emacsは、関数やプログラムで使おうと計画している変数およびコマンドを、ドキュメントから探すのに使用できる機能をいくつか提供します。

### Infoドキュメントの照会

info-lookup-file
Infoドキュメントをもつ言語に適用されるメジャーモードでは、プログラムで使用されるシンボルにたいして`C-h S` (`info-lookup-symbol`)を使用することにより、Infoドキュメントを閲覧できます。シンボルはミニバッファーで指定します。デフォルトはバッファーのポイント位置にあるシンボルです。たとえばCモードでは、シンボルをC Library Manualから探します。このコマンドは適切なInfoファイルのマニュアルがインストールされているときだけ機能します。

Emacsは、どのドキュメントのどこからシンボルを探すか — つまり、どのInfoファイルを探すのか、そしてどのインデックスを検索するか — をメジャーモードにもとづき決定します。`M-x info-lookup-file`を使用して、ドキュメントのファイル名を指定することもできます。

`C-h S`をサポートしないメジャーモードでこれを使用すると、これはsymbol help modeを指定するよう求めます。ここでは`c-mode`コマンドのように、`C-h S`をサポートするメジャーモードを選択します。

### man-pageの照会

man page
Unixでは、オンラインドキュメントのメインフォームはmanual pageまたはman pageです。GNUオペレーティングシステムではmanを、Infoでブラウズできる、より組織化されたマニュアルで置き換えることを目指しています。このプロセスは終了していないので、manを読むことはまだ有用です。

man
オペレーティングシステムのコマンド、ライブラリー関数、システムコールにたいするman pageを、`M-x
man`コマンドで読むことができます。このコマンドは補完つき([Completion](#Completion)を参照してください)でトピック(topic)の入力を求め、対応するman pageをフォーマットするために、`man`コマンドを実行します。そのシステムが許すなら、このコマンドは`man`を非同期で実行するので、ページがフォーマットされる間、編集を続けることができます。フォーマットされた結果は`*Man
topic*`という名前のバッファーに表示されます。このバッファーは、Manモードという特別なメジャーモードを使用します。これはスクロールや他のman pageにジャンプする機能をもちます。詳細についてはManモードのバッファーで、`C-h m`をタイプしてください。

sections of manual pages
それぞれのman pageは、1つ以上のセクション(sections)に属します。セクションの名前は数字または数字と文字です。同じ名前のman pageが、複数のセクションに存在することもあります。特定のセクションのman pageを読むには、`M-x
man`がトピックの入力を求める際、‘`topic(section)`’または‘`section
topic`’とタイプします。たとえばCのライブラリー関数`chmod`はセクション2ですが、同じ名前のシェルコマンドのman pageはセクション1です。前者を閲覧するには、`M-x man RET chmod(2)
RET`とタイプしてください。

Man-switches
M-n (Man mode)
M-p (Man mode)
セクションを指定しないと、`M-x man`は通常、最初に見つかったman pageだけを表示します。`man`に、コマンドラインオプション‘`-a`’を指定できるシステムもいくつかあります。これは指定したトピックにたいするすべてのman pageを表示するよう指定します。これを使用するには、変数`Man-switches`の値を‘`"-a"`’に変更します。そうするとManモードのバッファーで、`M-n`と`M-p`で異なるセクションのman pagfeを切り替えることができます。モードラインには、利用可能なman pageの数が表示されます。

woman
manual pages, on MS-DOS/MS-Windows
man pageを読む他の方法として、`M-x woman`コマンドがあります。`M-x man`とは異なり、これはman pageをフォーマットするために外部のプログラムを実行しないので、MS-Windowsのような、`man`プログラムが利用できないかもしれないシステムでも機能します。このコマンドは、表示するman pageの入力を求め、それを`*WoMan section topic`という名前のバッファーに表示します。

`M-x woman`は、コマンドを最初に呼び出したとき、man pageの補完リストを計算します。数引数を指定すると、このリストを再計算します。これはman pageを追加・削除したとき有用です。

man pageの名前を入力して、`M-x woman`が複数のセクションで同じ名前のman pageを見つけた場合、これはウィンドウをポップアップして利用可能な候補を示し、それらから1つを選択するよう求めます。

`M-x woman`はモダンなman-pagesの最新機能をまだサポートしていないので、システムで利用可能なら`M-x
man`の使用をわたしたちが推奨していることに注意してください。

`M-x woman`のセットアップと使用についての情報は、 Emacsとともに配布されているWoMan Infoマニュアルを参照してください。

### Emacs Lispドキュメントの照会

Emacs Lispコードを編集するとき、コマンド`C-h f` (`describe-function`)および`C-h
v` (`describe-variable`)で、使用したい関数または変数のビルトインドキュメントを閲覧できます。[Name Help](#Name-Help)を参照してください。

Eldoc mode
eldoc-mode
global-eldoc-mode
Eldocモードは、Lispドキュメントを検索するのに助けとなる、バッファーローカルなマイナーモードです。これが有効な場合、ポイントがLisp関数または変数にあるときは、有用な情報がエコーエリアに表示されます。関数の場合は引数リスト、変数の場合は変数のドキュメントストリングの最初の行が表示されます。Eldocモードに切り替えるには、`M-x
eldoc-mode`とタイプします。Global Eldocモードもあり、これはデフォルトでオンであり、バッファーにたいするメジャーモードがEmacs LispモードやLisp Interactionモードである、‘`*scratch*`’のようなバッファーに影響します(`M-x
global-eldoc-mode`でグローバルでオフに切り替えられます)。

Hideshowマイナーモード
----------------------

Hideshow mode
mode, Hideshow
hs-minor-mode
Hideshowモードは、バッファーローカルなマイナーモードで、ブロックと呼ばれるプログラムの一部を、選択的に表示させることができます。このマイナーモードに切り替えるには、`M-x
hs-minor-mode`とタイプします([Minor Modes](#Minor-Modes)を参照してください)。

ブロックを非表示にするためにHideshowモードを使用したとき、そのブロックはスクリーンに表示されなくなり、かわりに省略記号(3つのピリオド)に置き換えられます。何をブロックと定めるかは、メジャーモードに依存します。Cモード、および関連するモードでは、ブロックは大カッコ(braces)で区切られ、Lispモードでは丸カッコ(parentheses)で区切られます。複数行のコメントもブロックとみなされます。

Hideshowモードは以下のコマンドを提供します:

hs-hide-all
hs-hide-block
hs-show-all
hs-show-block
hs-show-region
hs-hide-level
C-c @ C-h
C-c @ C-s
C-c @ C-M-h
C-c @ C-M-s
C-c @ C-r
C-c @ C-l
S-mouse-2
`C-c @ C-h`; `C-c @ C-d`  
カレントブロックを隠します(`hs-hide-block`)。

`C-c @ C-s`  
カレントブロックを表示します(`hs-show-block`)。

`C-c @ C-c`; `C-x @ C-e`  
カレントブロックを表示、または非表示にします(`hs-toggle-hiding`)。

`S-mouse-2`  
クリックしたブロックの表示・非表示を切り替えます(`hs-mouse-toggle-hiding`)。

`C-c @ C-M-h`; `C-c @ C-t`  
トップレベルのすべてのブロックを隠します(`hs-hide-all`)。

`C-c @ C-M-s`; `C-c @ C-a`  
バッファーのすべてのブロックを表示します(`hs-show-all`)。

`C-u n C-c @ C-l`  
現在のブロックの、nレベル下のすべてのブロックを隠します(`hs-hide-level`)。

hs-hide-comments-when-hiding-all
hs-isearch-open
hs-special-modes-alist
以下の変数はHideshowモードをカスタマイズするのに使用されます:

`hs-hide-comments-when-hiding-all`  
非`nil`の場合、`C-c @ C-M-h` (`hs-hide-all`)はコメントも隠します。

`hs-isearch-open`  
この変数は、インクリメンタル検索でマッチするテキストが隠されたブロックにあるとき、それを表示すべき条件を指定します。変数の値は、`code`(コードブロックだけを表示)、`comment`(コメントだけを表示)、`t`(コードブロックとコメントの両方を表示)、`nil`(どちらも表示しない)のいずれかです。デフォルト値は`code`です。

シンボル名の補完
----------------

completion (symbol names)
補完は通常ミニバッファーで行われますが([Completion](#Completion)を参照してください)、シンボル名の補完を、普通のEmacsバッファーで行うこともできます。

M-TAB
C-M-i
プログラミング言語のモードでは、`C-M-i`または`M-TAB`とタイプすることにより、ポイントの前のシンボル名の一部にたいして補完を行うことができます。グラフィカルなディスプレーでは、`M-TAB`キーは通常、グラフィカルなウィンドウの切り替え用にウィンドウマネージャーに予約されているので、かわりに`C-M-i`または`ESC
TAB`とタイプする必要があります。

tags-based completion
completion-at-point, in programming language modes
Lisp symbol completion
completion (Lisp symbols)
ほとんどのプログラミング言語のモードでは、`C-M-i` (または`M-TAB`)は、コマンド`completion-at-point`を呼び出します。これは柔軟な方法で補完リストを生成します。Semanticモードが有効な場合は、補完にSemanticパーサーのデータを使用することを試みます([Semantic](#Semantic)を参照してください)。Semanticモードが無効、または補完の処理に失敗した場合、選択されたtagsテーブル([Tags Tables](#Tags-Tables)を参照してください)を使用して補完を試みます。Emacs Lispモードの場合、カレントのEmacsセッションで定義された関数、変数、プロパティー名を使用して補完を行います。

他の点では、バッファーでのシンボル補完はミニバッファーでの補完と同様に振る舞います。たとえば、Emacsが一意なシンボルを補完できない場合、他のウィンドウに補完候補のリストを表示します。[Completion](#Completion)を参照してください。

Textモード、および関連するモードでは、`M-TAB`はスペルチェッカーの辞書にもとづいて単語を補完します。[Spelling](#Spelling)を参照してください。

大文字小文字の混ざった単語
--------------------------

camel case
いくつかのプログラミングスタイルでは、‘`unReadableSymbol`’のような大文字小文字が混ざった(“CamelCase”の)シンボルを使います(GNUプロジェクトでは、識別子の単語の区切りに、大文字小文字の違いではなく、アンダースコアを使用することを推奨しています)。Emacsには、そのようなシンボルに簡単に対処するための、さまざまな機能があります。

Glasses mode
mode, Glasses
バッファーローカルなマイナーモードのGlassesモードは、そのようなシンボルが表示される方法を変更することにより、それらを読みやすくします。デフォルトでは、小文字とそれに続く大文字の間に余分なアンダースコアを表示します。これはバッファーのテキストを変更するわけではなく、表示の仕方だけを変更します。

Glassesモードに切り替えるには、`M-x glasses-mode`とタイプします([Minor Modes](#Minor-Modes)を参照してください)。Glassesモードが有効な場合、モードラインのマイナーモードインジケーターには‘`o^o`’が表示されます。Glassesモードに間する情報を得るには、`C-h
P glasses RET`とタイプしてください。

Subword mode
subword-mode
Subwordモードは、バッファーローカルなマイナーモードです。Subwordモードでは、Emacsの単語コマンドは、‘`StudlyCapsIdentifiers`’のような、単語の中の大文字を単語境界と認識します。Subwordモードが有効なときは、モードラインのマイナーモードインジケーターに‘`,`’が表示されます。同様なモード`superword-mode`も参照してください([Misc for Programs](#Misc-for-Programs)を参照してください)。

Semanticとは
------------

Semantic package
Semanticは、`ソースコードパーサー(source code
parsers)`にもとづく、言語認識(language-aware)による編集のためのコマンドを提供します。このセクションは、Semanticについての簡単な説明を提供します。完全な詳細については、 section “Semantic” in Semanticを参照してください。

Font Lockモード([Font Lock](#Font-Lock)を参照してください)のような、Emacsの言語認識機能(language aware features)のほとんどは、rules of thumb[14]にもとづいています。これは大抵の場合においてよい結果を得られますが、完全に正しい結果は決して得られない、ということを意味します。対照的に、Semanticで使用されるパーサーは、プログラミング言語の構文を正確に理解します。これによりSemanticは、より強力で正確な検索、操作、補完コマンドが提供できるのです。

Semantic mode
mode, Semantic
Semanticの使用を開始するには、`M-x
semantic-mode`をタイプするか、‘`Tools`’メニューの、‘`Source Code Parsers
(Semantic)`’という名前のメニューをクリックします。これはグローバルなマイナーモードのSemanticモードを有効にします。

Semanticモードが有効な場合、Emacsはファイルをvisitするたびに自動的にパースを試みます。現在のところ、SemanticはC、C++、HTML、Scheme、Java、Javascript、Make、Python、Scheme、SRecord、Texinfoを理解します。パースされたバッファーでは以下のコマンドが利用可能です:

`C-c , j`  
C-c , j

カレントファイルで定義された関数名の入力を求め、ポイントをそこに移動します(`semantic-complete-jump-local`)。

`C-c , J`  
C-c , J

Emacsがパースした任意のファイルで定義された関数名の入力を求め、ポイントをそこに移動します(`semantic-complete-jump`)。

`C-c , SPC`  
C-c , SPC

ポイント位置のシンボルにたいして可能な補完候補のリストを表示します(`semantic-complete-analyze-inline`)。これは補完候補を選択するための特別なキーバインドのセットをアクティブにします。`RET`はカレントの補完候補を選択し、`M-n`と`M-p`は可能な補完候補を巡回、`TAB`は可能なところまで補完を行ってから巡回、そして、`C-g`または他のキーは補完を中止します。

`C-c , l`  
C-c , l

ポイント位置のシンボルにたいして可能な補完候補のリストを、他のウィンドウに表示します(`semantic-analyze-possible-completions`)。

上記のコマンドに加えて、Semanticパッケージは、パーサー情報を使用する他のさまざまな方法を提供します。たとえば、Emacsがアイドルのとき、補完候補のリストを表示するために、それを使用することができます。 詳細は、section “Semantic” in Semanticを参照してください。

プログラムを編集するための他の便利な機能
----------------------------------------

プログラムを編集するためにデザインされているわけではありませんが、有用なEmacsコマンドもいくつかあります

単語、センテンス、パラグラフを操作するEmacsコマンドは、コードを編集するのに有用です。ほとんどのシンボル名は単語([Words](#Words)を参照してください)を含んでおり、文字列やコメントの中でセンテンス([Sentences](#Sentences)を参照してください)を見つけることができます。パラグラフについては、ほとんどのプログラミング言語のモードは空行をパラグラフの開始および終了に定義しています。したがって空行を注意深く使用してプログラムをクリアーにすることにより、パラグラフコマンドが機能できる、有意なテキストの集合を提供することができます。プログラミング言語のモードでAuto Fillモードが有効な場合、新しい行の作成でインデントされるようになります。

superword-mode
Superwordはバッファーローカルなマイナーモードで、編集および移動コマンドがシンボル(たとえば‘`this_is_a_symbol`’)を単語として扱うようになります。Superwordモードが有効な場合、モードラインのマイナーモードインジケーターに、 ‘`²`’ が表示されます。同様なモード`subword-mode`も参照してください([MixedCase Words](#MixedCase-Words)を参照してください)。

electric-layout-mode
Electric Layoutモード(`M-x
electric-layout-mode`)はグローバルなマイナーモードで、特定の文字をタイプしたときに自動的に改行を挿入します。たとえばJavascriptモードでは‘`{`’、‘`}`’、‘`;`’などです。

Hideshowモード([Hideshow](#Hideshow)を参照してください)は別として、プログラムの一部を選択的に表示するには、選択的な表示機能([Selective Display](#Selective-Display)を参照してください)を使う方法があります。プログラミングのモードには、Foldoutパッケージ([Foldout](#Foldout)を参照してください)とともに使用できる、Outline minorマイナーモード([Outline Mode](#Outline-Mode)を参照してください)をサポートするものもあります。

prettify-symbols-mode
Prettify Symbolsモードはバッファーローカルなマイナーモードで、特定の文字の表示をよりアトラクティブ(attractive: 見栄えのする)なバージョンに置き換えます。たとえばEmacs Lispモードでは、文字列‘`lambda`’を、ギリシャ文字のラムダ‘`λ`’に置き換えます。TEXバッファーでは‘`\alpha`’ ... ‘`\omega`’、および他の数学マクロ(math macros)を、対応するUnicode文字に置き換えます。このモードを、プログラミングとは関係のないモードで使いたいと思うかもしれません。`prettify-symbols-alist`にエントリーを追加することにより、このモードをカスタマイズできます。デフォルト値である`prettify-symbols-default-compose-p`の値が適切でない場合、`prettify-symbols-compose-predicate`をカスタマイズすることで、より入念なカスタマイズが可能です。グローバルなバージョン`global-prettify-symbols-mode`は、サポートするすべてのモードでこれを有効にします。

ポイント位置のシンボルを、元の形式で表示することもできます。これは変数`prettify-symbols-unprettify-at-point`により制御されます。非`nil`の、ポイントがシンボル位置にある限り、そのシンボルの元の形式が復元されます。

Cおよび関連するモード
---------------------

C mode
Java mode
Pike mode
IDL mode
CORBA IDL mode
Objective C mode
C++ mode
AWK mode
mode, Java
mode, C
mode, C++
mode, Objective C
mode, CORBA IDL
mode, Pike
mode, AWK
このセクションではC、C++、Objective-C、Java、CORBA IDL、Pike、AWKのためのモード(これらは“Cモードおよび関連するモード”と呼ばれます)で利用できる、特別な機能を簡単に説明します。 詳細は、Emacsとともに配布されるCC modeのInfoマニュアルを参照してください。

### Cモードの移動コマンド

このセクションでは、Cモードおよび関連するモードで、ポイントを移動するコマンドを説明します。

`C-M-a`; `C-M-e`  
c-beginning-of-defun

c-end-of-defun

カレント関数またはトップレベルの定義の、先頭または最後にポイントを移動します。スコープによる囲い(C++のclassなど)をもつ言語では、カレント関数(current function)はスコープ内の隣接する関数です。そうでない場合、それは大カッコ(braces)で囲まれることにより定義されます。[Moving by Defuns](#Moving-by-Defuns)を参照してください。

`C-c C-u`  
C-c C-u (C mode)

c-up-conditional

マークを置いたまま、ポイントを含むプリプロセッサー条件を後方に移動します。プレフィクス引数は、繰り返し回数として振る舞います。負の引数を指定すると、ポイントを含むプリプロセッサー条件の最後に、前方へポイントを移動します。

‘`#elif`’は、‘`#else`’の後に‘`#if`’を続けたのと同じなので、この関数は後方に移動するときは‘`#elif`’で止まりますが、前方に移動するときは止まりません。

`C-c C-p`  
C-c C-p (C mode)

c-backward-conditional

マークを置いたまま、プリプロセッサー条件を越えてポイントを後方に移動します。プレフィクス引数は、繰り返し回数として振る舞います。負の引数の場合は前方に移動します。

`C-c C-n`  
C-c C-n (C mode)

c-forward-conditional

マークを置いたまま、プリプロセッサー条件を越えて、ポイントを前方に移動します。プレフィクス引数は、繰り返し回数として振る舞います。負の引数の場合は後方に移動します。

`M-a`  
M-a (C mode)

c-beginning-of-statement

一番内側のCステートメントの先頭に、ポイントを移動します(`c-beginning-of-statement`)。すでにポイントがステートメントの先頭にある場合は、その前のステートメントの先頭に移動します。プレフィクス引数nを指定した場合、n − 1個前のステートメントに、後方へ移動します。

2行以上のコメントまたは文字列の場合、このコマンドはステートメントではなくセンテンス単位で移動します。

`M-e`  
M-e (C mode)

c-end-of-statement

Cステートメントまたはセンテンスの最後に、ポイントを移動します。`M-a`と同様ですが、これは逆の方向に移動します(`c-end-of-statement`)。

### エレクトリックC文字

Cモードおよび関連するモードでは、特定の文字はエレクトリック(electric) — つまり自分自身を挿入するのに加えて、カレント行を再インデントしたり、オプションで改行を挿入します。エレクトリックな文字は、`{`、`}`、`:`、`#`、`;`、`,`、`<`、`>`、`/`、`*`、`(`、`)`です。

混乱したインデントのコードを編集している場合には、エレクトリックなインデントを不便だと感じるかもしれません。CCモードになれていない場合、それはあなたを当惑させるかもしれません。エレクトリックな動作は、コマンド`C-c
C-l`で切り替えることができます。有効な場合には、モードラインのモード名の後ろに‘`/cl`’が表示されます(cが表示される場合、それはコメントスタイルがブロックスタイルかラインスタイルかに応じて‘`*`’か‘`/`’が表示される)。

`C-c C-l`  
C-c C-l (C mode)

c-toggle-electric-state

エレクトリックな動作を切り替えます(`c-toggle-electric-state`)。正のプレフィクス引数を指定した場合、、このコマンドはエレクトリックな動作を有効にし、負の引数の場合は無効にします。

エレクトリックな文字は、エレクトリックな状態に加えて、自動改行(auto-newline)の機能が有効な場合(モードラインのモード名の後ろに‘`/cla`’が表示されている状態のとき)だけ、改行を挿入します。この機能は`C-c
C-a`で、オンまたはオフに切り替えることができます。

`C-c C-a`  
C-c C-a (C mode)

c-toggle-auto-newline

自動改行機能を切り替えます(`c-toggle-auto-newline`)。このコマンドにプレフィクス引数を指定した場合、引数が正のときは自動改行機能をオン、負のときはオフに切り替えます。

CCモードのスタイルは通常、Emacsが自動改行する正確な状況を設定します。これを直接設定することもできます。section “Custom Auto-newlines” in The CC Mode Manualを参照してください。

### Cの欲張りな削除機能

hungry deletion (C Mode)
ポイント位置の空白文字のブロック全体を削除したい場合は、hungry deletion(欲張りな削除)を使うことができます。これはポイントの前後の、一連の空白文字を1回の操作で削除します。空白文字(whitespace)にはタブと改行が含まれますが、コメントとプリプロセッサーコマンドは含まれません。

`C-c C-DEL`; `C-c DEL`  
c-hungry-delete-backwards

C-c C-DEL (C Mode)

C-c DEL (C Mode)

ポイントの前の空白文字のブロック全体を削除します(`c-hungry-delete-backwards`)。

`C-c C-d`; `C-c C-Delete`; `C-c Delete`  
c-hungry-delete-forward

C-c C-d (C Mode)

C-c C-Delete (C Mode)

C-c Delete (C Mode)

ポイントの後の空白文字のブロック全体を削除します(`c-hungry-delete-forward`)。

上記のコマンドのかわりに、hungry deleteモードを有効にすることができます。この機能が有効な場合(モードラインのモード名の後に‘`/`’と‘`h`’が示されます)、1回の`DEL`で1つのスペースではなくポイントの前に続くすべての空白文字を削除し、`C-d`(`Delete`では*ありません*)でポイントの後に続くすべての空白文字を削除します。

`M-x c-toggle-hungry-state`  
c-toggle-hungry-state

hungry-delete機能を切り替えます(`c-toggle-hungry-state`)。このコマンドにプレフィクス引数を指定した場合、正の場合はhungry-delete機能をオン、負の場合はオフにします。

c-hungry-delete-key
変数`c-hungry-delete-key`は、hungry-delete機能を有効にするかを制御します。

### Cモードのその他のコマンド

`M-x c-context-line-break`  
c-context-line-break

このコマンドは、コンテキストに応じたマナーで、行ブレークの挿入と新しい行のインデントを行います。通常のコードの中では、`RET` (`newline`)の働きをしますが、Cプリプロセッサー行の中では、行ブレークに追加で‘`\`’を挿入し、コメントの中では`M-j` (`c-indent-new-comment-line`)のように動作します。

デフォルトでは、`c-context-line-break`はキーにバインドされていませんが、便利に使うためには、キーにバインドする必要があります。以下のコードは、このコマンドを`RET`にバインドします。この例ではキーマップを変更する前に、それがロードされていることを確実にするために`c-initialization-hook`を使用しています。

    (defun my-bind-clb ()
      (define-key c-mode-base-map "\C-m"
                  'c-context-line-break))
    (add-hook 'c-initialization-hook 'my-bind-clb)

`C-M-h`  
マークを関数定義の最後に配し、ポイントを先頭に配します(`c-mark-function`)。

`M-q`  
M-q (C mode)

c-fill-paragraph

CおよびC++のコメントに対応した、パラグラフのフィルを行います(`c-fill-paragraph`)。カレント行がコメントを含む、またはカレント行がコメントの場合、このコマンドはコメントのインデントとコメント区切りを保ちながら、コメントまたはポイントがあるパラグラフをフィルします。

`C-c C-e`  
macro expansion in C

expansion of C macros

c-macro-expand

C-c C-e (C mode)

リージョンのテキストにたいして、Cプリプロセッサーを実行して、すべてのマクロ呼び出しの展開を含めて、結果を表示します。リージョンの前にあるバッファーのテキストも、マクロ定義がそこにあるためにプリプロセスされますが、この部分は出力には表示されません。

マクロを使用するCコードをデバッグするとき、マクロがどのように展開されるか正確に解明するのが難しいときがあります。このコマンドにより、展開結果を見ることができるので、わざわざ解明する必要がなくなります。

`C-c C-\`  
c-backslash-region

C-c C-\\ (C mode)

リージョン内の各行末に、‘`\`’文字を挿入、または位置揃えします(`c-backslash-region`)。これはCマクロ定義を、記述または編集した後に便利です。

行がすでに(`c-backslash-region`)で終了されている場合、このコマンドはそれの前の空白文字の数を調整します。そうでない場合は、新規に‘`\`’を挿入します。しかしリージョンの最後の行は特別に扱われます。この行には‘`\`’は挿入されず、もし‘`\`’がある場合は削除します。

`M-x cpp-highlight-buffer`  
preprocessor highlighting

cpp-highlight-buffer

プリプロセッサー条件に対応するテキスト部分を、ハイライトします。このコマンドは`*CPP
Edit*`という名前の別のバッファーを表示します。これは特定の条件とその内容をどのように表示するかを選択するための、グラフィックメニューを供します。さまざまなセッティングを変更した後に、‘`[A]pply
these settings`’をクリック(またはそのバッファーで`a`をタイプ)すると、それに応じてCモードのバッファーが再ハイライトされます。

`C-c C-s`  
c-show-syntactic-information

C-c C-s (C mode)

カレントソース行の構文的な情報を表示します(`c-show-syntactic-information`)。この情報は、その行がどのようにインデントされるべきか決定するために使用されます。

`M-x cwarn-mode`; `M-x global-cwarn-mode`  
cwarn-mode

global-cwarn-mode

global-cwarn-mode

CWarn mode

suspicious constructions in C, C++

CWarnマイナーモードは、ある種の疑わしいCおよびC++の構文をハイライトします。

-   式の中での値の割り当て。

-   ‘`if`’、‘`for`’、‘`while`’(‘`do … while`’命令は除く)の直後のセミコロン。

-   参照パラメーターをともなうC++関数。

このモードを1つのバッファーにたいして有効にするにはコマンド`M-x
cwarn-mode`、すべての適合するバッファーにたいして有効にするにはコマンド`M-x
global-cwarn-mode`、または変数`global-cwarn-mode`をカスタマイズします。これが機能するためには、Font Lockモードも有効にしなければなりません。

`M-x hide-ifdef-mode`  
hide-ifdef-mode

Hide-ifdef mode

hide-ifdef-shadow

Hide-ifdefマイナーモードは、プリプロセッサーブロック‘`#if`’および‘`#ifdef`’の中の選択されたコードを隠します。変数`hide-ifdef-shadow`を`t`に変更した場合、Hide-ifdefマイナーモードははプリプロセッサーブロックを隠すかわりに、より目立たないフェイスでそれらのブロックをshadowします。詳細は、`hide-ifdef-mode`のドキュメント文字列を参照してください。

`M-x ff-find-related-file`  
related files

ff-find-related-file

ff-related-file-alist

カレントバッファーでvisitされたファイルに関連するファイルを、特別な方法で検索します。通常これはC/C++ソースファイルにたいするヘッダーファイル、またはその逆です。変数`ff-related-file-alist`は、関連するファイル名をどのように計算するかを指定します。

Asmモード
---------

Asm mode
assembler mode
Asmモードは、アセンブラーコードのファイルを編集するためのメジャーモードです。このモードは、以下の3つのコマンドを定義します:

`TAB`  
`tab-to-tab-stop`.

`C-j`  
改行を挿入してから、`tab-to-tab-stop`を使ってインデントします。

`:`  
コロンを挿入してから、コロンの前のラベルからインデントを削除します。その後、`tab-to-tab-stop`を実行します。

`;`  
コメントの挿入または位置揃えをします。

変数`asm-comment-char`はアセンブラー構文でコメントを開始する文字を指定します。

Fortranモード
-------------

Fortran mode
mode, Fortran
Fortran fixed form and free form
Fortran 77 and Fortran 90, 95, 2003, 2008
f90-mode
fortran-mode
Fortranモードは、固定形式(fixed form)(またはタブ形式(tab format))のソースコードを編集するためのモードです(通常はFortran 77)。よりモダンな自由形式(free form)のソースコードを編集するためには、F90モード(`f90-mode`)を使用します。Emacsは通常、拡張子が‘`.f`’、‘`.F`’、‘`.for`’のファイルにたいしてはFortranモードを使用し、拡張子が‘`.f90`’、‘`.f95`’、‘`.f03`’、‘`.f08`’のファイルにたいしてはF90モードを使用します。`auto-mode-alist`をカスタマイズして、拡張子を追加することができます。GNU Fortranは、これら自由形式と固定形式の両方をサポートします。このマニュアルでは主にFortranモードを記述しますが、対応するF90モードの機能については、その都度言及します。

Fortranモードは、Fortran命令文およびサブプログラムにたいする特別な移動コマンドと、Fortranのネスト規則、行番号、行継続された命令文を理解する、インデントコマンドを提供します。Fortranモードは、長い行を適正なFortranの継続行にブレークする、Auto Fillモードをサポートします。FortranモードはHideshowマイナーモード ([Hideshow](#Hideshow)を参照してください)、 、およびImenu ([Imenu](#Imenu)を参照してください)もサポートします。

Fortranのコメントは他の言語とは異なるので、コメントのための特別なコマンドも提供されています。ビルトインのabbrev(省略形)は、Fortranキーワードをタイプする手間を削減します。

`M-x
fortran-mode`を使用して、このメジャーモードに切り替えます。このコマンドはフック`fortran-mode-hook`を実行します。 [Hooks](#Hooks)を参照してください。

### 移動コマンド

defun(Fortranのサブプログラム — 関数、サブルーチン、同様にF90モードのモジュールには、コマンド`fortran-end-of-subprogram`および`fortran-beginning-of-subprogram`を使用します)を単位に移動、操作する通常コマンドに加えて、Fortranモードは命令文や他のプログラム単位に移動する、特別なコマンドを提供します。

`C-c C-n`  
次の命令文の先頭に移動します(`fortran-next-statement`/`f90-next-statement`)。

C-c C-p (Fortran mode)

fortran-previous-statement

f90-previous-statement

`C-c C-p`  
前の命令文の先頭に移動します(`fortran-previous-statement`/`f90-previous-statement`)。前の命令文が存在しない場合(たとえばバッファーの最初の命令文で呼び出された場合)、バッファーの先頭に移動します。

C-c C-e (F90 mode)

f90-next-block

`C-c C-e`  
次のコードブロックの先頭、またはカレントのコードブロックの最後に移動します(`f90-next-block`)。コードブロックとは、サブルーチン、`if`–`endif`命令文などです。これはF90モードだけのコマンドで、Fortranモードにはありません。数引数を指定すると、複数ブロックを前方に移動します。

C-c C-a (F90 mode)

f90-previous-block

`C-c C-a`  
前のブロックに、後方にポイントを移動します(`f90-previous-block`)。これは`f90-next-block`と似ていますが、後方に移動します。

C-M-n (Fortran mode)

fortran-end-of-block

f90-end-of-block

`C-M-n`  
カレントのコードブロックの最後にポイントを移動します(`fortran-end-of-block`/`f90-end-of-block`)。数引数を指定した場合、指定した数のブロックを前方に移動します。ポイントを移動する前にマークがセットされます。このコマンドのF90モードのバージョンでは、ブロックタイプと、(もしあれば)ラベルの整合性をチェックしますが、最外のブロックは不完全かもしれないのでチェックしません。

C-M-p (Fortran mode)

fortran-beginning-of-block

f90-beginning-of-block

`C-M-p`  
カレントコードブロックの先頭にポイントを移動します(`fortran-beginning-of-block`/`f90-beginning-of-block`)。これは`fortran-end-of-block`と似ていますが、後方に移動します。

コマンド`fortran-beginning-of-subprogram`および`fortran-end-of-subprogram`は、カレントサブプログラムの先頭または後方に移動します。コマンド`fortran-mark-do`および`fortran-mark-if`は、カレントの`do`ブロック、または`if`ブロックの最後にマークをセットして、ポイントをブロックの先頭に移動します。

### Fortranのインデント

固定形式(またはタブ形式)のFortranコードにたいしては、さまざまな構文エントリー(行番号、行インジケーター、継続行フラグ)が、要求される列に表示されるようにするために、特別なコマンドと機能が必要です。

#### Fortranのインデントおよびフィルコマンド

`C-M-j`  
ポイント位置でカレント行をブレークして、継続行をセットアップします(`fortran-split-line`)。

`M-^`  
その行を前の行と結合します(`fortran-join-line`)。

`C-M-q`  
ポイントのあるサブプログラムの、すべての行をインデントします(`fortran-indent-subprogram`)。

`M-q`  
コメントブロックまたは命令文をフィルします(`fortran-fill-paragraph`または`fortran-fill-statement`を使用します)。

C-M-q (Fortran mode)
fortran-indent-subprogram
キー`C-M-q`は、`fortran-indent-subprogram`を実行します、これはポイントを含むFortranサブプログラム(関数またはサブルーチン)の、すべての行を再インデントします。

C-M-j (Fortran mode)
fortran-split-line
キー`C-M-j`は、`fortran-split-line`を実行します、これはFortranの流儀にあった方法で行を分割します。非コメント行では、後半は継続行になり、それにしたがったインデントになります。コメント行の場合、両方とも別のコメント行になります。

M-^ (Fortran mode)
C-c C-d (Fortran mode)
fortran-join-line
`M-^`または`C-c
C-d`は、コマンド`fortran-join-line`を実行します。これは継続行を前の行に結合します。大雑把にいうと、`fortran-split-line`の逆です。このコマンドを呼び出すとき、ポイントは継続行になければなりません。

M-q (Fortran mode)
Fortranモードでの`M-q`は、ポイントのあるコメントブロックまたは命令文ブロックをフィルします。これは余分な命令文の継続を削除します。

#### 継続行

Fortran continuation lines
fortran-continuation-string
ほとんどのFortran77コンパイラーは、2つの方法で継続行を記述します。ある行の最初の非スペース文字が列5の場合、その行は前の行の継続行です。これを固定形式(fixed form)と呼びます。(GNU Emacsでは常に列は0から数えますが、Fortran標準では列1から数えることに注意。列をFortran様式で表示するよう、変数`column-number-indicator-zero-based`をカスタマイズできる。 [Optional Mode Line](#Optional-Mode-Line)を参照されたい) 変数`fortran-continuation-string`は、列5に配す文字を指定します。タブ文字で開始され、その後‘`0`’以外の任意の数字後に続くTAB文字も継続行です。この継続スタイルをタブ形式(tab format)と呼びます(Fortran 90では、自由形式(free form)という継続行スタイルが導入された)。

indent-tabs-mode (Fortran mode)
fortran-analyze-depth
fortran-tab-mode-default
Fortranモードは、どちらの継続行スタイルも使用できます。Fortranモードに入ったとき、バッファー内容から、自動的に適切な継続行スタイルを推論しようと試みます。これはバッファーの開始から、`fortran-analyze-depth`行(デフォルトは100)をスキャンすることにより行われます。最初の行の開始がタブ文字か、6個のスペースかで選択が決定されます。スキャンが失敗した場合(たとえば、新しいバッファーで中身が空の場合)、`fortran-tab-mode-default`の値(`nil`の場合は固定形式で、非`nil`の場合はタブ形式)が使用されます。モードラインに‘`/t`’ (`fortran-tab-mode-string`)が表示されている場合、タブ形式が選択されていることを示します。それに応じてFortranモードは`indent-tabs-mode`の値をセットします。

行のテキストがFortranの継続マーカー‘`$`’で始まるか、列5の非空白文字で始まる場合、Fortranモードはそれを継続行として扱います。継続行を`TAB`でインデントした場合、その行をカレントの継続スタイルに変換します。Fortran命令文を`C-M-j`で分割した場合、継続スタイルに応じた継続マーカーがある新しい行が作成されます。

継続スタイルのセッティングは、Fortranモードでの編集の他の側面に影響します。固定形式の場合、命令文の最小列は6になります。Fortranブロック内でそれより大きい列にインデントされる行には、空白文字としてスペース文字だけを使用しなければなりません。タブ形式では、命令文の最小列は8で、列8より前の空白文字は1つのタブ文字でなければなりません。

#### 行番号

その行の最初の非空白文字が数字の場合、Fortranのインデントはそれを行番号と判断して、列0から列4に移動します(Emacsでは列を常に0から数えるが、`column-number-indicator-zero-based`を`nil`にセットすることによりこれを変更できる。 [Optional Mode Line](#Optional-Mode-Line)を参照されたい)

fortran-line-number-indent
4桁以下の行番号は、通常1つのスペースでインデントされます。変数`fortran-line-number-indent`はこれを制御します。これは行番号がもてる最大のインデントを指定します。この変数のデフォルト値は1です。Fortranモードは、必要なら指定した最大列以下にインデントを減らして、行番号が列4を超えるのを防ごうと試みます。`fortran-line-number-indent`が5の場合、行番号は列4で終わるように右端に揃えられます。

fortran-electric-line-number
これらのルールに応じたインデントをするには、単純に行番号を挿入するだけで充分です。各桁が挿入されるたびに、インデントは再計算されます。この機能をオフに切り替えるには、変数`fortran-electric-line-number`を`nil`にセットしてください。

#### 構文的な慣習

Fortranモードは正しくインデントを行うために、あなたが、Fortranプログラム解読を単純化する特定の慣習にしたがうと仮定します：

-   ネストされた2つの‘`do`’ループは、‘`continue`’命令を共有しない。

-   ‘`if`’、‘`else`’、‘`then`’、‘`do`’、その他のFortranキーワードは、空白文字や行ブレークを含まずに記述される。

    Fortranコンパイラーは一般的に文字列定数の外の空白文字を無視しますが、Fortranモードはこれらのキーワードが隣接していない場合、それらを認識しません。‘`else
    if`’や‘`end do`’のような構成は許されますが、2つ目の単語は継続行ではなく、1つ目の単語と同じ行にあるべきです。

これらの慣習にしたがわない場合、インデントコマンドは醜いインデントをするかもしれません。しかし正しいFortranプログラムなら、慣習にしたがわずにインデントされたものでも、その意味は変わりません。

#### Fortranのインデントのための変数

fortran-do-indent
fortran-if-indent
fortran-structure-indent
fortran-continuation-indent
fortran-check-all-num…
fortran-minimum-statement-indent…
Fortranのインデントがどのように機能するかを制御する、追加の変数がいくつかあります:

`fortran-do-indent`  
‘`do`’命令の各レベルにたいする、追加のインデントです(デフォルトは3)。

`fortran-if-indent`  
‘`if`’、‘`select case`’、‘`where`’命令の各レベルにたいする、追加のインデントです(デフォルトは3)。

`fortran-structure-indent`  
‘`structure`’、‘`union`’、‘`map`’、‘`interface`’命令の各レベルにたいする、追加のインデントです(デフォルトは3)。

`fortran-continuation-indent`  
継続行の本文にたいする、追加のインデントです(デフォルトは3)。

`fortran-check-all-num-for-matching-do`  
Fortran 77では、番号つきの‘`do`’命令は、それにマッチする行番号をもつ任意の命令で終了します。この目的のためには‘`continue`’命令を使うのが一般的です(が、強制ではありません)。この変数が非`nil`値の場合、番号が付与された命令をインデントするとき、そこで終了する‘`do`’をチェックしなければなりません。‘`do`’命令を常に‘`continue`’(またはよりモダンな‘`enddo`’)で終了する場合は、この変数を`nil`(デフォルト)にセットすることにより、インデントの速度を上げることができます。

`fortran-blink-matching-if`  
この変数が`t`の場合、‘`endif`’(または‘`enddo`’)命令のインデントにより、マッチする‘`if`’(または‘`do`’)命令にカーソルが数瞬移動します。デフォルトは`nil`です。

`fortran-minimum-statement-indent-fixed`  
固定形式の継続行スタイルを使用する場合の、Fortran命令にたいする最小のインデントです。命令本体はこれより小さい値でインデントされることはありません。デフォルトは6です。

`fortran-minimum-statement-indent-tab`  
タブ形式の継続行スタイルを使用する場合の、Fortran命令にたいする最小のインデントです。命令本体はこれより小さい値でインデントされることはありません。デフォルトは8です。

以下のセクションでは、コメントのインデントを制御する変数を説明します。

### Fortranのコメント

通常のEmacsのコメントコマンドは、コード行の後にコメントを記述できると仮定します。Fortran 77では、標準のコメント構文はコメント行に行全体を要求します。したがってFortranモードは、標準のEmacsコメントコマンドを置き換え、新しい変数も定義します。

fortran-comment-line-start
Fortranモードは、‘`!`’で始まり、他のテキストの後に記述することができる、Fortran 90のコメント構文も処理できます。この構文を許すFortran 77コンパイラーは限られているので、Fortranモードは、あらかじめそれを行うように指示しない限り、そのようなコメントを挿入しません。これを行うには、変数`fortran-comment-line-start`に‘`"!"`’をセットします。通常とは異なる値を使う場合、`fortran-comment-line-start-skip`も変更する必要があるでしょう。

`M-;`  
コメントの位置揃え、または新しいコメントを挿入します(`comment-dwim`)。

`C-x ;`  
非標準の‘`!`’だけを適用します(`comment-set-column`)。

`C-c ;`  
リージョンのすべての行をコメントにします。または(引数を指定した場合は)コメントを実際のコードに戻します(`fortran-comment-region`)。

Fortranモードで実行すると、これは標準の`comment-dwim`を実行します。これは任意の種類の既存のコメントを認識して、それらのテキストの位置揃えをします。既存のコメントがない場合は、コメントの挿入・位置揃えをします。Fortranモードでのコメントの挿入および位置揃えは、他のモードとは異なります。

新しいコメントが挿入されなければならない場合、カレント行が空のときは、行全体をコメントとして挿入します。その行が空でない場合、もしそれを使うことを指示していれば、非標準の‘`!`’コメントが挿入されます。そうでない場合はカレント行の前に新しい行を挿入して、その行全体をコメントにします。

非標準の‘`!`’コメントは、他の言語のコメントと同じように位置揃えされますが、行全体のコメントは異なります。標準の行全体のコメントは、コメント区切り自体は常に列0に出現しなければなりません。位置揃えできるのは、コメントの中のテキストです。変数`fortran-comment-indent-style`に、以下の3つの値のうち1つをセットすることにより、3つのスタイルの位置揃えを選択できます。

fortran-comment-indent-style
fortran-comment-line-extra-indent
`fixed`  
テキストを固定列に位置揃えします。これは`fortran-comment-line-extra-indent`と命令文の最小のインデントとの和です。これがデフォルトです。

最小のインデントは、タブ形式の継続行スタイルの場合は`fortran-minimum-statement-indent-tab`で、固定形式スタイルの場合は`fortran-minimum-statement-indent-fixed`です。

`relative`  
そのテキストがコード行であるかのように位置揃えしますが、`fortran-comment-line-extra-indent`に指定した列のインデントが追加されます。

`nil`  
行全体のコメントを自動的に移動しません。

fortran-comment-indent-char
これらに加えて、変数`fortran-comment-indent-char`に、使用したい1文字をセットすることにより、行全体のコメントのインデントに使用する文字を指定することができます

fortran-directive-re
コンパイラーにたいする命令行や、プリプロセッサー行は、コメント行と同じ外観をもっています。しかし、`fortran-comment-indent-style`の値に関わらず、そのような行が決してインデントされないことが重要です。変数`fortran-directive-re`は、どのような行がそのような命令なのかを指定する正規表現です。これにマッチする行はインデントされず、特別な外観のフォントが適用されます。

Emacsの通常のコメントコマンド`C-x ;` (`comment-set-column`)は再定義されません。‘`!`’コメントを使用している場合、このコマンドをそれらに使用できます。そうでない場合、これはFortranモードでは役に立ちません。

C-c ; (Fortran mode)
fortran-comment-region
fortran-comment-region
コマンド`C-c ;` (`fortran-comment-region`)は、リージョンのすべての行の行頭に文字列‘`c$$$`’を挿入することにより、これらをコメントにします。数引数を指定した場合、各行の行頭から‘`c$$$`’を削除することにより、リージョンをコードに戻します。これらのコメントに使用する文字列は、変数`fortran-comment-region`をセットすることにより制御できます。これはコマンドと変数が同じ名前をもつ例であることに注意してください。同じ名前を2つの用途で使用することによる衝突はありません。なぜならLispおよびEmacsではそれが意味するものは、コンテキストにより明らかだからです。

### FortranモードでのAuto Fill

Fortranモードは、Auto Fillモードにたいする特別なサポートをもっています。これは命令文を挿入するとき、それが長くなりすぎた場合は自動的に分割するマイナーモードです。命令文の分割は、`fortran-continuation-string`を使用した継続行により行われます([ForIndent Cont](#ForIndent-Cont)を参照してください)。この分割は`SPC`、`RET`、`TAB`、およびFortranのインデントコマンドにより発生します。FortranモードでのAuto Fillの有効化は、通常の方法で行うことができます。 [Auto Fill](#Auto-Fill)を参照してください。

fortran-break-before-delimiters
Auto Fillは、その行が望ましい幅(`fill-column`の値)より長くなった場合は、スペースおよび区切り文字で行をブレークします。Auto Fillが行をブレークする(空白文字以外の)区切り文字は‘`+`’、‘`-`’、‘`/`’、‘`*`’、‘`=`’、‘`<`’、‘`>`’、‘`,`’です。`fortran-break-before-delimiters`が`nil`の場合、区切り文字の後ろで行ブレークします。そうでない場合(デフォルト)、区切り文字の前で行ブレークします。

すべてのFortranバッファーでAuto Fillを有効にするには、`fortran-mode-hook`に`auto-fill-mode`を追加します。 [Hooks](#Hooks)を参照してください。

### Fortranでの列のチェック

fortran-line-length
標準のFortran 77では、72列目以降は無視されます。ほとんどのコンパイラーはこれを変更するオプションを提供します(たとえばgfortranの‘`-ffixed-line-length-N`’)。変数`fortran-line-length`をカスタマイズすることにより、Fortranモードでの行の長さを変更できます。このポイント以降はコメントにfont-lockされます(ただし文字列内の場合は除きます。`fortran-line-length`を超える文字列は、font-lockを混乱させるでしょう)。

`C-c C-r`  
カレント行の上に、列目盛(column ruler)を一時的に表示します。

`C-c C-w`  
`fortran-line-length`列の幅になるように、カレントウィンドウを水平に分割します(`fortran-window-create-momentarily`)。これは、Fortranコンパイラーにより課せられた制限を超えないようにする助けになるでしょう。

`C-u C-c C-w`  
(`fortran-window-create`)列の幅になるように、カレントウィンドウを水平に分割します。その後は編集を続行できます。

`M-x fortran-strip-sequence-nos`  
列`fortran-line-length`以上のすべてのテキストを削除します。

C-c C-r (Fortran mode)
fortran-column-ruler
コマンド`C-c C-r` (`fortran-column-ruler`)は、カレント行の上に列目盛を一時的に表示します。列目盛は2行のテキストで、Fortranプログラムにおいて特別な意味をもつ列の位置を表示します。角カッコ(square brackets)は行番号の範囲を示し、中カッコ(curly brackets)は命令文本体の範囲を示します。列番号がその上に表示されます。

GNU Emacsで常にそうであるように、列番号は0からカウントされることに注意してください(ただしF`column-number-indicator-zero-based`oをカスタマイズして、rtranにマッチするよう列表示を変更することができる)。 [Optional Mode Line](#Optional-Mode-Line)を参照されたい) 結果として、この番号はあなたが親しんでいる番号より1小さくなるかもしれません。しかしこの行で示される位置は、Fortranの標準です。

fortran-column-ruler-fixed
fortran-column-ruler-tabs
列目盛を表示するのに使用されるテキストは、変数`indent-tabs-mode`の値に依存します。`indent-tabs-mode`が`nil`の場合、変数`fortran-column-ruler-fixed`の値が列目盛として使用されます。それ以外は、変数`fortran-column-ruler-tab`の値が表示されます。これらの値を変更することにより、表示される列目盛を変更できます。

C-c C-w (Fortran mode)
fortran-window-create-momentarily
`C-c C-w` (`fortran-window-create-momentarily`)で、一時的にカレントウィンドウを水平方向に分割して、ウィンドウの幅を`fortran-line-length`列にすることにより、長くなりすぎた行を見つけることができます。スペースをタイプすると元の幅に戻ります。

C-u C-c C-w (Fortran mode)
fortran-window-create
適切な位置でウィンドウを水平方向に分割して、編集を継続することもできます。これを行うには、`C-u C-c C-w` (`M-x
fortran-window-create`)を使用します。このウィンドウで編集することより、Fortranでの正しい長さを超える行をすぐに見つけることができます。

fortran-strip-sequence-nos
コマンド`M-x
fortran-strip-sequence-nos`は、カレントバッファーのすべての行にたいして、列`fortran-line-length`以上のテキストすべてを削除します。これは古いシーケンス番号を削除する一番簡単な方法です。

### FortranキーワードのAbbrev

Fortranモードは、一般的なキーワードや定義にたいするabbrev(abbreviation: 省略形)を提供します。あなたが定義できるabbrevと同様なものがあります。これらを使用するには、Abbrevモードをオンに切り替えなければなりません。 [Abbrevs](#Abbrevs)を参照してください。

ビルトインのabbrevは、1つの点で特異です。これらはすべてセミコロンから始まります。たとえばFortranのビルトインのabbrevである‘`;c`’は、‘`continue`’にたいする省略形です。‘`;c`’を挿入してから、スペースや改行のような区切りとなる文字を挿入すると、Abbrevモードが有効な場合、‘`;c`’は自動的に‘`continue`’に展開されます。

‘`;?`’または‘`;C-h`’とタイプすると、すべてのビルトインのFortranのabbrevのリストと、それが何を意味するかが表示されます。

プログラムのコンパイルとテスト
==============================

building programs
program building
running Lisp functions
前のチャプターでは、プログラムを変更するのに便利なEmacsコマンドについて議論しました。このチャプターでは、プログラムのコンパイルとテストに役立つコマンドを扱います。

Emacs下でのコンパイルの実行
---------------------------

inferior process
make
compilation errors
error log
Emacsは、CやFortranのような言語のためのコンパイラーを実行でき、コンパイルログをEmacsのバッファーに取り込むことができます。エラーメッセージを解析して、エラーが発生した場所を示すこともできます。

`M-x compile`  
Emacs下で非同期にコンパイラーを実行し、エラーメッセージは`*compilation*`バッファーに送られます。

`M-x recompile`; `g (Compilation mode)`  
最後に呼び出した`M-x compile`と同じコマンドで、コンパイラーを呼び出します。

`M-x kill-compilation`  
サブプロセスで実行されているコンパイルをkillします。

compile
`make`、または他のコンパイルコマンドを実行するには、`M-x
compile`とタイプします。これはミニバッファーを使用してシェルのコマンドラインを読み取り、シェルをEmacsのサブプロセス(または下位プロセス(inferior process))として、そのコマンドを実行します。出力は`*compilation*`という名前のバッファーに挿入されます。カレントバッファーのデフォルトディレクトリーが、コマンドを実行する作業ディレクトリーとして使用されます。したがって、通常はそのディレクトリーでコンパイルが行われます。

compile-command
デフォルトのコンパイルコマンドは‘`make
-k`’で、これは`make`ユーティリティーを使ってコンパイルするプログラムにたいして通常正しいコマンドです(‘`-k`’フラグは`make`に、エラー後も可能な限りコンパイルを継続するよう指示します)。section “Make” in GNU Make Manualを参照してください。前に`M-x
compile`を実行している場合、それに指定したコマンドは自動的に変数`compile-command`に格納されます。これは、次に`M-x
compile`とタイプしたときのデフォルトとなります。ファイルのファイルローカルな値で`compile-command`を指定することもできます([File Variables](#File-Variables)を参照してください)。

コンパイルを開始すると、他のウィンドウで`*compilation*`バッファーが表示されますが、そのウィンドウは選択されません。コンパイルが実行中は、`*compilation*`バッファーのメジャーモードインジケーターに‘`run`’という単語が表示され、単語‘`Compiling`’がすべてのモードラインに表示されます。コンパイル実行中、常に`*compilation*`バッファーを表示している必要はありません。表示されていなくてもコンパイルは継続します。何らかの理由によりコンパイルが終了したときは、`*compilation*`バッファーのモードラインが‘`exit`’(その後に終了コード。‘`[0]`’の場合は通常終了)、または‘`signal`’(何らかのシグナルがプロセスを終了させた場合)に変化します。

コンパイルの経過を見たいときは、バッファー`*compilation*`に切り替えて、ポイントをバッファーの最後に移動します。ポイントが最後にある場合、コンパイル出力はポイント位置に挿入されるので、ポイントは最後に留まります。そうでない場合は、バッファーの最後にコンパイル出力が追加される間も、ポイント位置は固定されたままです。

コンパイル処理中、モードラインにはその時点までのエラー、警告の数と、コンパイラーからの情報が表示されます。

compilation buffer, keeping point at end
compilation-scroll-output
変数`compilation-scroll-output`を非`nil`値に変更した場合、`*compilation*`バッファーは出力に追随して自動的にスクロールします。値が`first-error`の場合は、最初のエラーが出現した箇所でスクロールがストップし、ポイントはエラー箇所に留まります。その他の任意の非`nil`値の場合は、出力がなくなるまでスクロールが継続されます。

recompile
最後にコンパイルしたのと同じコマンドで再実行するには、`M-x recompile`とタイプします。これは最後に呼び出した`M-x
compile`からコンパイルコマンドを再利用します。これは`*compilation*`バッファーも再利用し、コンパイルもそのバッファーのデフォルトディレクトリー、つまり前にコンパイルが開始されたのと同じディレクトリーで行われます。`*compilation*`バッファーでは、このコマンドは`g`にバインドされています。

kill-compilation
compilation-always-kill
新しいコンパイルの開始は、すでに`*compilation*`で実行中のコンパイルをkillします。これは、そのバッファーが1度に1つのコンパイルしか処理できないからです。しかし実行中のコマンドを実際にkillする前に、`M-x
compile`、および`M-x
recompile`は確認を求めます。常に確認なしで自動的にコンパイルをkillするには、変数`compilation-always-kill`を`t`に変更します。コマンド`M-x
kill-compilation`で、コンパイルプロセスをkillすることもできます。

1度に2つのコンパイルを実行するには、最初に1つを開始してから(多分`rename-uniquely`を使用して。[Misc Buffer](#Misc-Buffer)を参照してください)`*compilation*`、バッファーをリネームして、それからバッファーを切り替えて他のコンパイルを開始します。これにより新しい`*compilation*`バッファーが作成されます。

compilation-environment
コンパイルコマンドに渡される環境は、変数`compilation-environment`で制御できます。この変数の値は環境変数のセッティングのリストで、各要素は文字列`"envvarname=value"`の形式です。これらの環境変数のセッティングは、通常の値をオーバーライドします。

Compilationモード
-----------------

Compilation mode
mode, Compilation
locus
`*compilation*`バッファーは、Compilationモードと呼ばれるメジャーモードを使用します。Compilationモードは、バッファーのエラーメッセージをハイパーリンクに変換します。ポイントをそこに移動してRETをタイプするか、マウスでクリック([Mouse References](#Mouse-References)を参照してください)すると、別のウィンドウでエラーメッセージのlocusをvisitします。locusとは、エラーが発生したファイルの特定の位置を意味します。

compile-goto-error
compilation-auto-jump-to-first-error
変数`compilation-auto-jump-to-first-error`を非`nil`値に変更した場合、Emacsは、`*compilation*`バッファーに表れる最初のエラーメッセージのlocusを自動的にvisitします。

Compilationモードは、以下の追加のコマンドを提供します。これらのコマンドは`*grep*`バッファーでも使用できます。このバッファーではエラーメッセージのかわりに、検索にたいするマッチにハイパーリンクが設定されます([Grep Searching](#Grep-Searching)を参照してください)。

`M-g M-n`; `M-g n`; `` C-x ` ``  
次のエラーメッセージ(またはマッチ)のlocusをvisitします(`next-error`)。

`M-g M-p`; `M-g p`  
前のエラーメッセージ(またはマッチ)のlocusをvisitします(`previous-error`)。

`M-n`  
locusをvisitせずに、ポイントを次のエラーメッセージ(またはマッチ)に移動します(`compilation-next-error`)。

`M-p`  
locusをvisitせずに、ポイントを前のエラーメッセージ(またはマッチ)に移動します(`compilation-previous-error`)。

`M-}`  
他のファイルで発生した次のエラーメッセージ(またはマッチ)にポイントを移動します(`compilation-next-file`)。

`M-{`  
他のファイルで発生した前のエラーメッセージ(またはマッチ)にポイントを移動します(`compilation-previous-file`)。

`C-c C-f`  
Next Error Followマイナーモードに切り替えます。これはcompilationバッファーでのカーソル移動にしたがって、ソースを自動的に表示するモードです。

`g`  
出力が`*compilation*`バッファー内に表示されている、最後のコマンドを再実行します。

M-g M-n
M-g n
C-x ‘
next-error
next-error-highlight
順番にエラーをvisitするには、`` C-x ` `` (`next-error`)とタイプするか、これと等価な`M-g
M-n`または`M-g
n`とタイプします。このコマンドはCompilationモードのバッファーだけでなく、任意のバッファーから呼び出すことができます。コンパイル後に最初に呼び出すときは、最初のエラーメッセージのlocusをvisitします。連続した`` C-x
` ``は、同じ方法で次のエラーをvisitします。`*compilation*`バッファーからRETまたはマウスクリックで特定のエラーをvisitした場合、`` C-x
` ``はそのエラーの次のエラーからvisitしていきます。これ以上visitするエラーメッセージがない場合、`` C-x
` ``はエラーをシグナルします。`` C-u C-x
` ``はcompilationバッファーの先頭から再開して、最初のlocusをvisitします。

`M-g M-p`または`M-g p` (`previous-error`)は、反対方向にエラーを巡回します。

コマンド`next-error`および`previous-error`は、バッファー`*compilation*`または`*grep*`にリストされたエラー(またはマッチ)だけに作用されるわけではありません。これらのコマンドは`M-x
occur` ([Other Repeating Search](#Other-Repeating-Search)を参照のようなコマンドで生成されたエラー(またはマッチ)を巡回する方法も知っています。カレントバッファーがエラーメッセージ、またはマッチを含む場合、これらのコマンドは、それらを巡回するでしょう。そうでない場合、Emacsは選択されたフレームのウィンドウの中から、エラーメッセージ(またはマッチ)を含むバッファーを探し、次に`next-error`または`previous-error`が最後にvisitしたバッファー、最後にその他のすべてのバッファーを探します。これらのコマンドが巡回するために選択されたバッファーが、カレントでウィンドウに表示されていなければ、そのバッファーが表示されるでしょう。

compilation-skip-threshold
デフォルトでは、コマンド`next-error`および`previous-error`は、重要でないメッセージはスキップします。変数`compilation-skip-threshold`が、これを制御します。デフォルト値は1で、これは警告(warning)より重要でないメッセージをスキップします。2の場合、エラー(error)より重要でないものをスキップし、0はメッセージをスキップしません。

Emacsがエラーメッセージのlocusをvisitしているとき、関連するソース行が一時的にハイライトされます。このハイライトの持続時間は、変数`next-error-highlight`により決定されます。

compilation-context-lines
`*compilation*`バッファーが左フリンジ([Fringes](#Fringes)を参照してください)のあるウィンドウで表示されている場合、locusをvisitするコマンドはカレントエラーメッセージを指す矢印をフリンジに配します。テキスト端末のように、左フリンジがないウィンドウの場合、これらのコマンドは、カレントメッセージがウィンドウの一番上にくるようにウィンドウをスクロールします。変数`compilation-context-lines`を整数値nに変更した場合、これらのコマンドは、フリンジの有無に関わらずメッセージがウィンドウの上からn行目にくるようにウィンドウをスクロールします。デフォルト値の`nil`では上述したように振る舞います。

compilation-error-regexp-alist
grep-regexp-alist
コンパイラーからのメッセージを解析するために、Compilationモードは変数`compilation-error-regexp-alist`を使用します。これはさまざまなエラーメッセージのフォーマットをリストし、それらからlocusを抽出する方法をEmacsに指示します。同じような変数`grep-regexp-alist`は、`grep`コマンド([Grep Searching](#Grep-Searching)を参照してください)の出力を解析する方法を指示します。

compilation-next-error
compilation-previous-error
compilation-next-file
compilation-previous-file
Compilationモードは、スクリーン単位でスクロールを行うために、キーSPCおよびDELも定義します。`M-n` (`compilation-next-error`)および`M-p` (`compilation-previous-error`)は、次または前のエラーメッセージに移動します。`M-{` (`compilation-next-file`)および`M-}` (`compilation-previous-file`)は、違うソースファイルの、次または前のエラーメッセージに移動します。

Next Error Follow mode
next-error-follow-minor-mode
`C-c C-f`とタイプして、Next Error Followモードに切り替えることができます。このマイナーモードでは、compilationバッファーでの通常のカーソル移動により、自動的にソースを表示するバッファーが更新されます。たとえばカーソルをエラーメッセージに移動すると、そのエラーにたいするlocusが表示されます。

Compilationモードの機能は、Compilation Minorモード呼ばれるマイナーモードでも利用可能です。これは通常のコンパイル出力のバッファーだけでなく、任意のバッファーのエラーメッセージを解析します。`M-x
compilation-minor-mode`とタイプすることにより、このマイナーモードが有効になります。たとえばRloginバッファー([Remote Host](#Remote-Host)を参照してください)では、Compilation minorモードはリモートのソースファイルに、FTPを通じて自動的にアクセスします([File Names](#File-Names)を参照してください)。

コンパイルのためのサブシェル
----------------------------

このセクションには、compilationバッファー内で、シェルやその機能を使用するための、さまざまなテクニックとアドバイスが含まれています。ローカルでのコンパイルに特有なトピックを扱うので、デフォルトディレクトリーがリモートホスト上であるようなcompilationバッファーでは、おそらくほとんどは機能しない(または無関係)でしょう。

`M-x
compile`コマンドは、コンパイルコマンドを実行するためにシェルを使いますが、オプションで非対話的なシェルを指定します。これは、シェルがプロンプトなしで開始されることを意味します。`*compilation*`バッファーで、通常のシェルプロンプトの見映えがよくない場合、それはシェルの初期化ファイルで、無条件にプロンプトをセットするという間違いを犯していることを意味します(この初期化ファイルは使用しているシェルに応じて`.bashrc`、`.profile`、`.cshrc`、`.shrc`などの名前がついています)。シェルの初期化ファイルでは、プロンプトがすでにあるときだけプロンプトをセットするべきです。これをbashで行うには、以下のようにします:

    if [ "${PS1+set}" = set ]
    then PS1=…
    fi

cshで行うには以下のようにします:

    if ($?prompt) set prompt = …

TERM, environment variable, in compilation mode
compilationのサブシェルに渡す環境変数TERMの値をカスタマイズしたい場合は、変数`comint-terminfo-terminal`の値をカスタマイズしてください([Shell Options](#Shell-Options)を参照)。

Emacsは、コンパイラープロセスが非同期なサブプロセスで実行されることを要求しません。もしこれを行う場合、メインのコンパイラープロセスが終了した後で、サブプロセスがまだ実行中のときは、Emacsはこれらをkillするか、それらの出力はEmacsには到達しません。この問題を避けるには、メインのコンパイルプロセスが、それのサブプロセスの終了までwaitするようにします。シェルスクリプトでは、以下のように‘`$!`’と‘`wait`’を使用して、これを行うことができます:

    (sleep 10; echo 2nd)& pid=$!  # サブプロセスのpidを記録
    echo first message
    wait $pid                     # サブプロセスのwait

バックグラウンドのプロセスがcompilationバッファーに何も出力せず、メインのコンパイルプロセスが終了したときに、これらがkillされるのを防ぐことだけが必要な場合は、以下で充分です:

    nohup command; sleep 1

MS-DOSオペレーティングシステムでは、非同期なサブプロセスはサポートされていないので、`M-x
compile`はコンパイルコマンドを同期実行します(たとえばEmacsで他のことを行うには、コマンドが終了するまで待たなければなりません)。[MS-DOS](#MS_002dDOS)を参照してください。

Emacs下でのGrepによる検索
-------------------------

Emacsからコンパイラーを実行して、コンパイルエラーの行をvisitできるように、`grep`を実行して見つかったマッチの行をvisitすることもできます。これは`grep`が報告するマッチを、エラーのように扱うことで機能します。出力バッファーはGrepモードを使用します。これはCompilationモードの変種です([Compilation Mode](#Compilation-Mode)を参照してください)。

`M-x grep`; `M-x lgrep`  
Emacs下で`grep`を非同期で実行し、`*grep*`という名前のバッファーにマッチした行をリストします。

`M-x grep-find`; `M-x find-grep`; `M-x rgrep`  
`find`を通じて`grep`を実行し、出力を`*grep*`バッファーに収集します。

`M-x zrgrep`  
`zgrep`を実行して、出力を`*grep*`バッファーに収集します。

`M-x kill-grep`  
実行中の`grep`サブプロセスをkillします。

grep
`grep`を実行するには、`M-x
grep`とタイプしてから、どのように`grep`を実行するかを指定するコマンドラインを入力します。これは通常、`grep`を実行するとき与える引数と同じです。`grep`スタイルのregexp(通常、シェルのスペシャル文字をクォートするためシングルクォートで囲む)の後に、ファイル名(ワイルドカードも使用できる)を続けます。`M-x
grep`にプレフィクス引数を指定した場合、バッファーのポイント位置周辺の識別子([Xref](#Xref)を参照してください)を探して、それを`grep`コマンドのデフォルトにします。

指定するコマンドは、単純に`grep`を実行するものである必要はありません。同じフォーマットで出力を生成するシェルコマンドを使用することができます。たとえば、以下のように、`grep`コマンドを連結することができます:

    grep -nH -e foo *.el | grep bar | grep toto

`grep`コマンドの出力は、`*grep*`バッファーに送られます。オリジナルのファイルの対応する行は、コンパイルエラーと同様、`` C-x
` ``、RETなどで見つけることができます。コマンドのより詳細な説明と、`*grep*`バッファー内で利用可能なキーバインディングについては、[Compilation Mode](#Compilation-Mode)を参照してください。

マッチをハイライトするために、その周囲に特別なマーカーを出力する‘`--color`’オプションを指定できるgrepプログラムもあります。この機能を使うには、`grep-highlight-matches`を`t`にセットします。これによりソースバッファーのマッチを表示するとき、ソース行全体ではなく、正確なマッチだけがハイライトされます。

コンパイルコマンド([Compilation](#Compilation)を参照)のときと同様、grepコマンド実行中には、モードラインにはそれまでに見つかったマッチ数が表示されて、ハイライトされます。

`grep`コマンドは、実行前にバッファーの保存を提案するでしょう。これは、変数`grep-save-buffers`により制御されます。利用できる値は`nil`(保存しない)、`ask`(保存前に尋ねる)、または述語として使用される関数(ファイル名をパラメーターとして呼び出され、バッファーを保存する場合は非`nil`をリターンすべきである)のいずれかである。その他の非`nil`値は、すべてのバッファーが確認なしで保存されるべきであることを意味します。デフォルト値は`ask`です。

grep-find
find-grep
コマンド`M-x grep-find`(`M-x find-grep`でも利用可能)は、`M-x
grep`と似ていますが、コマンドにたいして提供される初期のデフォルトが異なります — このデフォルトは`find`と`grep`の両方を実行するもので、これによりディレクトリーツリーの各ファイルを検索できます。[Dired and Find](#Dired-and-Find)の`find-grep-dired`コマンドも参照してください。

lgrep
rgrep
zrgrep
コマンド`M-x lgrep` (local grep)および`M-x rgrep` (recursive grep)は、`grep`および`grep-find`のユーザーフレンドリーなバージョンで、これらはマッチにたいする正規表現、検索するファイル、検索の基準となるディレクトリーを個別に尋ねます。検索での大文字小文字の区別は、`case-fold-search`の値で制御されます。コマンド`M-x
zrgrep`は`M-x
rgrep`と似ていますが、これは`grep`のかわりに`zgrep`を呼び出し、gzipされたファイルの内容を検索します。

これらのコマンドは、変数`grep-template`(`lgrep`用)、および`grep-find-template`(`rgrep`用)にもとづいてシェルコマンドを構築します。検索するファイルには、変数`grep-files-aliases`で定義されたエイリアスを使用できます。

grep-find-ignored-directories
変数`grep-find-ignored-directories`にリストされたディレクトリーは、`M-x
rgrep`の検索で自動的にスキップされます。デフォルト値には、さまざまなバージョンコントロールシステムで使用されるデータディレクトリーが含まれます。

オンザフライで構文エラーを見つける
----------------------------------

checking syntax
FlymakeモードはC、C++、Perl、HTML、TEX/LATEXを含む、多くのプログラミング言語およびマークアップ言語の構文チェックを、オンザフライ(on-the-fly)で処理するマイナーモードです。これは通常の人間の言語にたいしてスペルチェックを処理する、Flyspellモード([Spelling](#Spelling)を参照してください)と、その方法において類似しています。Flymakeモードはファイルの編集にしたがい、そのバッファーの一時的なコピーを使用して、適切な構文チェックツールをバックグラウンドで実行します。それからエラーメッセージと警告メッセージを解析して、そのバッファーの間違った行をハイライトします。使用される構文チェックツールは、言語に依存します。たとえば通常、C/C++ファイルの場合は、Cコンパイラーです。Flymakeは、複雑なプロジェクトにたいしてのチェックでは、`make`のようなビルドツールを使うこともできます。

Flymakeモードを有効にするには、`M-x flymake-mode`とタイプします。`M-x
flymake-goto-next-error`および`M-x
flymake-goto-prev-error`を使用して、これが見つけたエラーにジャンプすることができます。カレント行に関連するエラーメッセージを表示するには、`M-x
flymake-display-err-menu-for-current-line`とタイプしてください。

Flymakeの使用についての詳細は、 section “Flymake” in The Flymake Manualを参照してください。

Emacs下でのデバッガーの実行
---------------------------

debuggers
GUD library
GDB
DBX
SDB
XDB
Perldb
JDB
PDB
GUD(Grand Unified Debugger)ライブラリーは、広範なシンボリックデバッガーにたいするEmacsのインターフェースを提供します。これはGNUデバッガー(GDB)、同様にDBX、SDB、XDB、GuileのREPLのデバッグコマンド、Paerlのデバッグモード、PythonデバッガーのPDB、JavaデバッガーのJDBを実行することができます。

EmacsはGDBにたいする特別なインターフェースを提供します。これはデバッグされているプログラムの状態を表示する追加のEmacsウィンドウを使用します。[GDB Graphical Interface](#GDB-Graphical-Interface)を参照してください。

Emacsは、Emacs Lispプログラムにたいするビルトインのデバッガーももっています。section “The Lisp Debugger” in the Emacs Lisp Reference Manualを参照してください。

### GUDの開始

デバッガーサブプロセスを開始する複数のコマンドがあり、それらは特定のデバッガープログラムに対応しています。

`M-x gdb`  
gdb

GDBをサブプロセスとして実行し、IDE-likeなEmacsインターフェースを通じてやりとりをします。このコマンドに間する詳細は、[GDB Graphical Interface](#GDB-Graphical-Interface)を参照してください。

`M-x gud-gdb`  
gud-gdb

GDBサブプロセスとの入出力に、GUD interactionバッファーを使用してGDBを実行します(([Debugger Operation](#Debugger-Operation)を参照してください))。そのようなバッファーがすでに存在している場合はそのバッファーに切り替え、存在しない場合はバッファーを作成して切り替えます。

ここにリストされている他のコマンドは、他のデバッガープログラムにたいして同じことを行います。

`M-x perldb`  
perldb

Perlインタープリターをデバッグモードで実行します。

`M-x jdb`  
jdb

Javaデバッガーを実行します。

`M-x pdb`  
pdb

Pythonデバッガーを実行します。

`M-x guiler`  
guiler

Guile Schemeプログラムをデバッグするために、Guile REPLを実行します。

`M-x dbx`  
dbx

DBXデバッガーを実行します。

`M-x xdb`  
xdb

gud-xdb-directories

XDBデバッガーを実行します。

`M-x sdb`  
sdb

SDBデバッガーを実行します。

これらの各コマンドは、ミニバッファーを使ってデバッガーを呼び出すコマンドラインを読み取ります。ミニバッファーの初期内容は、デバッガーの標準的な実行ファイル名とオプションで、デバッグしたいと推測される実行ファイル名の場合もあります。シェルのワイルドカードと変数は、このコマンドラインでは使用できません。Emacsは‘`-`’で始まらない最初のコマンド引数を、実行ファイル名とみなします。

remote host, debugging on
Trampは、同じリモートホスト上のデバッガーとプログラムによる、リモートデバッグ機能を提供します。詳細については、section “Running a debugger on a remote host” in The Tramp Manualを参照してください。これはGDBのリモートデバッグ機能とは別の物です、なぜなら、プログラムとデバッガーは違うマシンで実行されるからです(section “Debugging Remote Programs” in The GNU debuggerを参照してください)。

### デバッガーの操作

GUD interaction buffer
GUD interactionバッファーは、デバッガーサブプロセスにテキストコマンドを送ったり、それの出力を記録するのに使用されるEmacsバッファーです。これは`M-x
gud-gdb`や、 [Starting GUD](#Starting-GUD)にリストされた他のコマンドで使用される、デバッガーとやりとりするための基本的なインターフェースです。 `M-x
gdb`コマンドは、ブレークポイント、スタックフレーム、その他のデバッガーの状態の様相を制御する、追加の特別なバッファーにより、この機能を拡張します([GDB Graphical Interface](#GDB-Graphical-Interface)を参照してください)。

GUD interactionはShellモードの変種を使用するので、Shellモードで定義されたEmacsコマンドが利用可能です([Shell Mode](#Shell-Mode)を参照してください)。ほとんどのデバッガーコマンドにたいして補完([Completion](#Completion)を参照してください)が利用可能で、それらを繰り返すのに、通常のShellモードのヒストリーコマンドを使うことができます。 GUD interactionバッファーで使用できる特別なコマンドについては、[Commands of GUD](#Commands-of-GUD) を参照してください。

プログラムをデバッグすると、Emacsは関連するソースファイルをEmacsバッファーにvisitして、カレント実行行には左フリンジに矢印が表示されます(テキスト端末では最初の2列に‘`=>`’の矢印が表示されます)。そのようなバッファーでのポイントの移動は、矢印を移動しません。これらのソースファイルの編集はできますが、行の挿入や削除により矢印の位置は失われることに注意してください。なぜならEmacsには編集されたソース行が、デバッガーサブプロセスから報告されるどの行に対応するか、知る手立てがないからです。この情報を更新するには通常、プログラムのリコンパイルと再実行が必要です。

GUD Tooltip mode
mode, GUD Tooltip
gud-tooltip-mode
gud-tooltip-echo-area
GUD Tooltipモードは、GUDにツールチップサポートを追加するグローバルなマイナーモードです。このモードに切り替えるには、`M-x
gud-tooltip-mode`とタイプします。このモードはデフォルトで無効になっています。有効にした場合、変数、関数、マクロ(識別子として総称される)にマウスポインターを移動すると、それらの値がツールチップで表示されます([Tooltips](#Tooltips)を参照)。値を表示したい式の上にマウスポインターを置くだけでは値が表示されない場合は、マウスでその式をドラッグしてマークし、マウスポインターをそのマークされた領域内に置いたままにすることにより、より明示的にEmacsに指示することができます。かわりにマウスをドラッグして識別子または式をマークしてから、マウスをマークした領域から離すと、式の値がツールチップに表示されます。GUD Tooltipモードは、GUD interactionバッファー、および`gud-tooltip-modes`にリストされたメジャーモードの、すべてのソースバッファーで効果があります。変数`gud-tooltip-echo-area`が非`nil`の場合、またはツールチップモードがオフの場合は、ツールチップではなくエコーエリアに値が表示されます。

`M-x gud-gdb`でGUD Tooltipモードを使用する場合、GDBにより表示される式の値は、マクロを展開する場合があり、これはデバッグされているプログラムに副作用をもたらすかもしれません。この理由により、`gud-gdb`ではツールチップの使用は無効になっています。`M-x
gdb`インターフェースを使用する場合、この問題は発生しません。なぜなら副作用を避ける特別なコードがあるからです。さらにプログラムが実行されていないときに、識別子に関連付けられたマクロの定義を表示することもできます。

### GUDのコマンド

GUDはブレークポイントのセットとクリアー、スタックフレームの選択、プログラムのステップ実行のためのコマンドを提供します。

`C-x C-a C-b`  
C-x C-a C-b

ポイントのあるソース行にブレークポイントをセットします。

ソースバッファーから`C-x C-a C-b` (`gud-break`)が呼び出された場合、カレントソース行にデバッガーのブレークポイントをセットします。このコマンドはGUDを開始した後だけ利用可能です。デバッガーサブプロセスに関連付けられていないバッファーで呼び出すと、エラーをシグナルします。

C-x C-a (GUD)
以下のコマンドは、GUD interactionバッファーとグローバルの両方で利用可能ですが、キーバインドが異なります。キーが`C-c`で始まるものはGUD interactionバッファーだけで利用可能で、`C-x
C-a`で始まるものはグローバルに利用可能です。コマンドのいくつかはツールバーを通じても利用可能です。また、特定のデバッガーではサポートされないものもあります。

`C-c C-l`; `C-x C-a C-l`  
gud-refresh

GUD interactionバッファーで参照される最後のソース行を、別のウィンドウに表示します(`gud-refresh`)。

`C-c C-s`; `C-x C-a C-s`  
gud-step

次の1行を実行します(`gud-step`)。その行が関数呼び出しを含む場合、関数呼び出しに入った後に実行をストップします。

`C-c C-n`; `C-x C-a C-n`  
gud-next

次の1行を実行します(`gud-next`)。その行が関数呼び出しを含む場合、関数の中でストップせずに関数をステップオーバーします。

`C-c C-i`; `C-x C-a C-i`  
gud-stepi

機械語の1命令を実行します(`gud-stepi`)。

`C-c C-p`; `C-x C-a C-p`  
gud-print

ポイント位置の式を評価します(`gud-print`)。表示したい正確な式をEmacsが表示しない場合、最初に式をリージョンとしてマークします。

`C-c C-r`; `C-x C-a C-r`  
gud-cont

停止位置を指定せずに実行を継続します。プログラムは、ブレークポイントに達する、プログラム終了、またはデバッガーがチェックしているシグナルを受けとるまで実行を続けます。

`C-c C-d`; `C-x C-a C-d`  
gud-remove

カレントソース行にブレークポイントがある場合、ブレークポイントを削除します。GUD interactionバッファーでこのコマンドを使用する場合、プログラムが最後に停止した位置に適用されます。

`C-c C-t`; `C-x C-a C-t`  
gud-tbreak

カレントソース行に、一時的なブレークポイントをセットします(`gud-tbreak`)。GUD interactionバッファーでこのコマンドを使用した場合、プログラムが最後に停止した位置に適用されます。

`C-c <`; `C-x C-a <`  
gud-up

次の外側のスタックフレームを選択します(`gud-up`)。これはGDBコマンドの‘`up`’と等価です。

`C-c >`; `C-x C-a >`  
gud-down

次の内側のスタックフレームを選択します(`gud-down`)。これはGDBコマンドの‘`down`’と等価です。

`C-c C-u`; `C-x C-a C-u`  
gud-until

カレント行まで実行を継続します(`gud-until`)。プログラムは、ブレークポイントに達する、プログラム終了、またはデバッガーがチェックしているシグナルを受けとる、またはカーソルがある行に到達するまで実行を続けます。

`C-c C-f`; `C-x C-a C-f`  
gud-finish

選択されたフレームがリターンするか、他の理由により停止するまでプログラムを実行します(`gud-finish`)。

GDBを使用している場合、追加のキーバインディングが利用可能です:

`C-x C-a C-j`  
C-x C-a C-j (GUD)

gud-jump

ソースバッファーだけで有用です。`gud-jump`はプログラムの実行箇所をカレント行に転送します。別の言い方をすると、プログラムが次に実行するのは、このコマンドを与えた位置になります。新しく実行される行が前の関数とは異なる場合、多分奇妙な結果になるので、GDBは確認を求めます。詳細は、GDBマニュアルのエントリー`jump`を参照してください。

`TAB`  
TAB (GUD)

gud-gdb-complete-command

GDBの場合、シンボル名を補完します(`gud-gdb-complete-command`)。このキーはGUD interactionバッファーだけで利用可能です。

これらのコマンドは、それが意味がある場合には、数引数を繰り返し回数と解釈します。

TABは補完コマンドに割り当てられているので、GDBでデバッグしているプログラムへのタブの入力には使えません。タブの入力には`C-q
TAB`とタイプしてください。

### GUDのカスタマイズ

gdb-mode-hook
dbx-mode-hook
sdb-mode-hook
xdb-mode-hook
perldb-mode-hook
pdb-mode-hook
jdb-mode-hook
guiler-mode-hook
起動時にGUDは以下のフックの1つを実行します: GDBを使用している場合は`gdb-mode-hook`、 DBXを使用している場合は`dbx-mode-hook`、 SDBを使用している場合は`sdb-mode-hook`、 XDBを使用している場合は`xdb-mode-hook`、Guile REPLのデバッグには`guiler-mode-hook`、 Perlのデバッグモードを使用している場合は`perldb-mode-hook`、 PDBを使用している場合は`pdb-mode-hook`、 JDBを使用している場合は`jdb-mode-hook`を実行します。 [Hooks](#Hooks)を参照してください。

Lispマクロ`gud-def`(section “Defining Macros” in the Emacs Lisp Reference Manualを参照してください)は、デバッガーに特定のコマンド文字列を送るEmacsコマンドを定義して、GUD interactionバッファーで、それにたいするキーバインドをセットアップする便利な方法を提供します:

gud-def
    (gud-def function cmdstring binding docstring)

これはデバッガープロセスにcmdstringを送る、ドキュメント文字列がdocstringの、functionという名前のコマンドを定義します。コマンドfunctionを、任意のバッファーで使用できます。bindingが非`nil`の場合、`gud-def`はそのコマンドを、GUDバッファーのモードでは`C-c
binding`、グローバルには`C-x C-a binding`にバインドします。

コマンド文字列cmdstringには、functionが呼び出されたときに書き込まれるデータのための、特定の‘`%`’シーケンスを含めることができます:

‘`%f`’  
カレントソースファイルの名前です。カレントバッファーがGUDバッファーの場合、カレントソースファイルはプログラムがストップしているファイルです。

‘`%l`’  
カレントソース行の番号です。カレントバッファーがGUDバッファーの場合、カレントソース行はプログラムがストップしている行です。

‘`%e`’  
transient-mark-modeでは、リージョンがアクティブの場合はリージョンのテキストです。そうでない場合、ポイント位置またはそれに隣接する位置にあるCのlvalue(左辺値)、または関数呼び出し式です。

‘`%a`’  
ポイント位置またはそれに隣接する位置にある、16進アドレスのテキストです。

‘`%p`’  
呼び出された関数の数引数の10進数です。コマンドに数引数が指定されなかった場合、‘`%p`’は空文字列になります。

コマンド文字列に‘`%p`’を使用しない場合、定義したコマンドは数引数を無視します。

‘`%d`’  
カレントソースファイルのディレクトリー名です。

‘`%c`’  
ポイントを取り囲む式から派生された、完全に記述されたされたclass名(fully qualified class name)です(jdbのみ)。

### GDBのグラフィカルインターフェース

コマンド`M-x
gdb`はブレークポイント、スタックフレーム、その他のデバッグ状態の様相を制御するために特化したバッファーで、IDE-likeなインターフェースでGDBを開始します。これは、たとえばマウスソースバッファーのフリンジをクリックすることにより、そこにブレークポイントをセットするなどの、マウスによりデバッグセッションを制御する追加の方法も提供します。

gud-gdb-command-name
これらの追加機能を使わずにGUD interactionバッファーのインターフェースだけを使ってGDBを実行するには、`M-x gud-gdb` ([Starting GUD](#Starting-GUD)を参照してください)を使用します。これは、(現在のところ`M-x
gdb`ではサポートされていない)1つのEmacsセッションで複数のプログラムをデバッグしたいときだけ使用しなければなりません。

内部的には、`M-x
gdb`はGDBにたいしてスクリーンサイズに制限がないと告げます。正しい操作のために、デバッグセッションの間はGDBのスクリーンの高さと幅の値を変更してはいけません。

#### GDBのユーザーインターフェースのレイアウト

GDB User Interface layout
gdb-many-windows
gdb-show-main
変数`gdb-many-windows`が`nil`(デフォルト)の場合、`M-x gdb`は通常GUD interactionバッファーだけを表示します。しかし`gdb-show-main`が非`nil`の場合、2つのウィンドウで開始します。その場合、1つはGUD interactionバッファーを表示して、もう一方はデバッグするプログラムの`main`関数のソースを表示します。

`gdb-many-windows`が非`nil`の場合、`M-x gdb`は以下のフレームレイアウトを表示します。

    +--------------------------------+--------------------------------+
    |   GUD interaction buffer       |   Locals/Registers buffer      |
    |--------------------------------+--------------------------------+
    |   Primary Source buffer        |   I/O buffer for debugged pgm  |
    |--------------------------------+--------------------------------+
    |   Stack buffer                 |   Breakpoints/Threads buffer   |
    +--------------------------------+--------------------------------+

gdb-restore-windows
gdb-many-windows
ウィンドウのレイアウトを変更した場合、`M-x
gdb-restore-windows`とタイプして、複数ウィンドウのレイアウトをリストアできます。複数ウィンドウレイアウトと、GUD interactionバッファーとソースファイルだけの単純なレイアウトを切り替えるには、`M-x
gdb-many-windows`とタイプしてください。

ウィンドウを複雑にセットアップをしていて、`gdb-many-windows`がそれを混乱させるのを望まない場合は、別のフレーム内で`M-x
gdb`を呼び出すほうがよいでしょう。その場合は、元のフレームのウィンドウのアレンジに影響はありません。テキスト端末で作業する場合は、GDBセッションに別のフレームを使用すれば、各ウィンドウにたいするスクリーン資源が最活用される可能性があるので、特に便利になり得ます。

同じフレームまたは異なるフレームに、GDBに関連した追加のバッファーを表示するように指定できます。`M-x
gdb-display-buffertype-buffer`または`M-x
gdb-frame-buffertype-buffer`とタイプして、望むバッファーを選択します。ここでbuffertypeは‘`breakpoints`’のような、該当するバッファータイプです。‘`GUD`’メニューの、サブメニュー‘`GDB-Windows`’または‘`GDB-Frames`’により、メニューバーから同じことができます。

デバッグを終えたら`C-x k`でGUD interactionバッファーをkillすれば、このセッションでの関連するすべてのバッファーをkillできます。しかしEmacsでソースコードの編集とリコンパイル終えて、さらにデバッグを続けたいときは、これを行う必要はありません。実行を再開すると、GDBは自動的に新しい実行ファイルを見つけます。GUD interactionバッファーを残しておけば、シェルヒストリー、同様にGDBブレークポイントを残すことができる利点があります。最近編集したソースファイルのブレークポイントが、正しい場所にあるかチェックする必要があります。

#### Sourceバッファー

fringes, for debugging
`mouse-1` (in fringe)  
その行のカレントブレークポイントをセット、またはクリアーします(`gdb-mouse-set-clear-breakpoint`)。

`C-mouse-1` (in fringe)  
その行のブレークポイントを有効または無効にします(`gdb-mouse-toggle-breakpoint-margin`)。

`mouse-3` (in fringe)  
その行まで実行を継続します(`gdb-mouse-until`)。

`C-mouse-3` (in fringe)  
その行にジャンプします(`gdb-mouse-jump`)。

グラフィカルなディスプレーでは、sourceバッファーのフリンジを`mouse-1`でクリックして、その行にブレークポイントをセットできます([Fringes](#Fringes)を参照してください)。クリックした場所に赤いドットが表示されます。すでにそこにブレークポイントが存在する場合、クリックでそれを削除します。既存のブレークポイントを`C-mouse-1`でクリックすることにより、有効または無効にします。クリアーされておらず無効になったブレークポイントは、グレイのドットで示されます。

テキスト端末またはフリンジが無効な場合、有効なブレークポイントはウィンドウの左端に、‘`B`’という文字で示されます。無効なブレークポイントは‘`b`’で示されます(余白はブレークポイントがあるときだけ表示されます)。

sourceバッファーの左フリンジの塗りつぶされた矢印は、デバッグされているプログラムがストップした最内フレームの行を示します。中抜きの矢印はより高いレベルのフレームの現在実行されている行を示します。フリンジの矢印を`mouse-1`でドラッグすると、ボタンを離した行まで実行が進みます。かわりにフリンジを`mouse-3`でクリックすることにより、その行まで実行を進めることができます。フリンジを`C-mouse-3`でクリックすることにより、間にある行を実行せずに、その行にジャンプできます。このコマンドは後方へもジャンプできるので、すでに実行中のコードの実行の詳細を調べるのに便利です。

gdb-mi-decode-strings
ソースファイル名が8進エスケープで表示される場合には、変数`gdb-mi-decode-strings`に適切なコーディングシステム(おそらく大抵は`utf-8`)をセットしてください(GDBはデコードが望まれない状況で8進エスケープを出力するかもしれず、またデバッグされるプログラムが使用するであろうエンコーディングは、あなたのシステム上の非ASCIIエンコードとは異なるかもしれないので、これのデフォルトは`nil`になっている)。

#### Breakpointsバッファー

GDB Breakpointsバッファーは、デバッガーセッションのブレークポイント(breakpoint)、ウォッチポイント(watchpoint)、キャッチポイント(catchpoint)を表示します。section “Breakpoints” in The GNU debuggerを参照してください。これは以下のコマンドを提供します。これらのコマンドのほとんどはカレントブレークポイント(ポイントのあるブレークポイント)に適用されます。

`SPC`  
SPC (GDB Breakpoints buffer)

gdb-toggle-breakpoint

カレントブレークポイントを有効または無効にします(`gdb-toggle-breakpoint`)。グラフィカルなディスプレーでは、これはsourceバッファーのフリンジのドットのカラーを変更します。ドットのカラーは、ブレークポイントが有効なときは赤、無効なときはグレーです。

`D`  
D (GDB Breakpoints buffer)

gdb-delete-breakpoint

カレントブレークポイントを削除します(`gdb-delete-breakpoint`)。

`RET`  
RET (GDB Breakpoints buffer)

gdb-goto-breakpoint

カレントブレークポイントのソース行をvisitします(`gdb-goto-breakpoint`)。

`mouse-2`  
mouse-2 (GDB Breakpoints buffer)

クリックしたブレークポイントのソース行をvisitします(`gdb-goto-breakpoint`)。

gdb-show-threads-by-default
`gdb-many-windows`が非`nil`の場合、GDB Breakpointsバッファーは、GDB Threadsバッファーとウィンドウを共有します。一方から他方へ切り替えるには、ヘッダー行の関連するボタンを`mouse-1`でクリックします。`gdb-show-threads-by-default`が非`nil`の場合、GDB Threadsバッファーがデフォルトとして表示されます。

#### Threadsバッファー

gdb-select-thread
GDB Threadsバッファーは、デバッグされているプログラムのスレッドのサマリーを表示します。section “Debugging programs with multiple threads” in The GNU debuggerを参照してください。スレッドを選択するには、ポイントをそこに移動してRET (`gdb-select-thread`)を押すか、それを`mouse-2`でクリックします。これにより、それに関連するsourceバッファーが表示され、他のGDBバッファーの内容も更新されます。

GDB Threadsバッファー内に含まれる項目を選択するために、`gdb-buffers`グループ配下の変数をカスタマイズできます。

`gdb-thread-buffer-verbose-names`  
gdb-thread-buffer-verbose-names

‘`Thread 0x4e2ab70 (LWP 1983)`’のような長いスレッド名を表示します。

`gdb-thread-buffer-arguments`  
gdb-thread-buffer-arguments

スレッドのトップフレームの引数を表示します。

`gdb-thread-buffer-locations`  
gdb-thread-buffer-locations

ファイル情報またはライブラリー名を表示します。

`gdb-thread-buffer-addresses`  
gdb-thread-buffer-addresses

threadバッファーのスレッドフレームのアドレスを表示します。

複数のスレッドの情報を同時に閲覧するには、GDB Threadsバッファーの以下のコマンドを使用します。

`d`  
d (GDB threads buffer)

gdb-display-disassembly-for-thread

カレント行のスレッドのdisassemblyバッファーを表示します(`gdb-display-disassembly-for-thread`)。

`f`  
f (GDB threads buffer)

gdb-display-stack-for-thread

カレント行のスレッドのGDB Stackバッファーを表示します(`gdb-display-stack-for-thread`)。

`l`  
l (GDB threads buffer)

gdb-display-locals-for-thread

カレント行のスレッドのGDB Localsバッファーを表示します(`gdb-display-locals-for-thread`)。

`r`  
r (GDB threads buffer)

gdb-display-registers-for-thread

カレント行のスレッドのGDB Registersバッファーを表示します(`gdb-display-registers-for-thread`)。

これらのコマンドの大文字`D`、`F`、`L`、`R`は、対応するバッファーを新しいフレームに表示します。

特定のスレッドについての情報を表示するバッファーを作成した場合、それはそのスレッドにバインドされて、プログラムをデバッグする間、情報を表示し続けます。各GDBバッファーのモードインジケーターには、バッファーに情報が表示されているスレッドの番号が表示されます。スレッドの番号はバインドされたバッファーのバッファー名にも含まれます。

GDB Threadsバッファーでは、さらに他のコマンドも利用可能で、それはプログラムの実行を制御するのに使われるGDBのモードに依存します。[Multithreaded Debugging](#Multithreaded-Debugging)を参照してください。

#### Stackバッファー

GDB Stackバッファーは、コールスタック(call stack)を表示します。これは、1行がデバッガーセッションでのネストされたサブルーチン呼び出し(stack frames: スタックフレーム)にそれぞれ対応します。section “Backtraces” in The GNU debuggerを参照してください。

gdb-frames-select
グラフィカルなディスプレーでは、選択されたスタックフレームは、フリンジの矢印で示されます。テキスト端末、またはフリンジが無効な場合、選択されたスタックフレームは反転して表示されます。スタックフレームを選択するには、ポイントをその行に移動してRET (`gdb-frames-select`)とタイプするか、それを`mouse-2`でクリックします。これを行うことにより、Localsバッファーも更新されます ([Other GDB Buffers](#Other-GDB-Buffers)を参照してください)。

gdb-stack-buffer-addresses
各スタックフレームのフレームアドレスを表示したい場合は、変数`gdb-stack-buffer-addresses`を非`nil`値にカスタマイズしてください。

#### その他のGDBバッファー

Localsバッファー  
このバッファーは、カレントフレームのローカル変数の値を、簡単なデータ型で表示します(section “Information on a frame” in The GNU debuggerを参照してください)。値を編集したいときは、そこでRETを押すか、`mouse-2`でクリックしてください。

配列と構造体については、その型だけが表示されます。GDB 6.4以降では、ポイント位置でRETをタイプ、または`mouse-2`でクリックすることにより、ローカル変数の値を調べることができます。それより前のバージョンのGDBでは、型の説明(‘`[struct/union]`’または‘`[array]`’)にたいして、RETまたは`mouse-2`を使用します。[Watch Expressions](#Watch-Expressions)を参照してください。

Registersバッファー  
toggle-gdb-all-registers

このバッファーは、レジスターに保持されている値を表示します(section “Registers” in The GNU debuggerを参照してください)。値を編集したいときは、そのレジスターでRETを押すか、`mouse-2`をクリックします。GDB6.4以降では、最近変化したレジスター値は、`font-lock-warning-face`で表示されます。

Assemblerバッファー  
assemblerバッファーは、カレントフレームをマシン語コードで表示します。矢印はカレント命令を指し、sourceバッファーのようにブレークポイントのセットと削除ができます。ブレークポイントのアイコンも、フリンジまたは余白に表示されます。

Memoryバッファー  
memoryバッファーは、プログラムのメモリーセクションを調べるためのバッファーです(section “Examining memory” in The GNU debuggerを参照してください)。ヘッダー行の適切な箇所を`mouse-1`でクリックすることにより、そのバッファーが表示するメモリーの開始アドレス、またはデータアイテムの数が変化します(または`S`および`N`を使用)。ヘッダー行を`mouse-3`でクリックすることにより、データアイテムのフォーマット、またはユニットサイズのどちらを表示するか選択します。

`gdb-many-windows`が非`nil`の場合、breakpointsバッファーとthreadsバッファーがウィンドウを共有するように、localsバッファーとregistersバッファーもウィンドウを共有します。一方から他方へ切り替えるには、ヘッダー行の関連するボタンを`mouse-1`でクリックしてください。

#### ウォッチ式

Watching expressions in GDB
gud-watch
C-x C-a C-w (GUD)
プログラムを停止するたびに、変数がどのように変化するか見たいときは、ポイントを変数名に移動して、ツールバーのウォッチアイコンをクリック(`gud-watch`)するか、`C-x
C-a C-w`とタイプします。プレフィクス引数を指定した場合、変数名をミニバッファーで入力することができます。

各ウォッチ式は、speedbarに表示されます([Speedbar](#Speedbar)を参照してください)。配列や、構造体、共有体のような複雑なデータ型はツリー形式で表示されます。ツリーの子ノード、および単純なデータ型では、式の名前とその値が表示され、speedbarフレームが選択されたときは型がツールチップで表示されます。それより高いレベルでは名前、型、ポインターのアドレス値、そうでない場合は名前と型だけが表示されます。ルート式では、それらがどこで定義されているかを識別するために、ツールチップでフレームアドレスも表示されます

複雑なデータ型を展開または折り畳むには、式の左のタグを`mouse-2`をクリックするかSPCを押します。式の子にあたるデータの数が、変数`gdb-max-children`の値を超える場合、Emacsは式を展開する前に確認を求めます。

D (GDB speedbar)
gdb-var-delete
複雑なウォッチ式を削除するには、speedbarのルート式にポイントを移動して、`D` (`gdb-var-delete`)とタイプしてください。

RET (GDB speedbar)
gdb-edit-value
単純なデータ型の変数、または複雑なデータ型の単純な要素を編集するには、speedbarのその箇所にポイントを移動して、RET (`gdb-edit-value`)とタイプするか、値を`mouse-2`でクリックして、それを編集します。どちらの方法も、ミニバッファーを使って新しい値を読み取ります。

gdb-show-changed-values
変数`gdb-show-changed-values`を非`nil`値(デフォルト)にセットした場合、Emacsは最近変化した値を`font-lock-warning-face`でハイライトし、スコープから外れた変数は目立たない`shadow`フェイスで表示します。変数がスコープから外れた場合、値を変更することはできません。

gdb-delete-out-of-scope
変数`gdb-delete-out-of-scope`が非`nil`(デフォルト)の場合、Emacsはスコープから外れたときウォッチ式を自動的に削除します。この変数を`nil`にしておけば、プログラムが同じ関数に複数回再入したとき、新たにウォッチ式を作成しなくてよいので便利かもしれません。

gdb-use-colon-colon-notation
変数`gdb-use-colon-colon-notation`が非`nil`の場合、Emacsは‘`function::variable`’というフォーマットを使います。これにより同じ変数名を共有するウォッチ式を表示することができます。デフォルト値は`nil`です。

gdb-speedbar-auto-raise
ウォッチ式の表示が更新されるたびに、自動的にspeedbarを前に表示するには、`gdb-speedbar-auto-raise`を非`nil`にセットします。これはEmacsフレームを全画面表示にしてデバッグしているとき便利です。

#### マルチスレッドのデバッグ

Multithreaded debugging in GDB
Non-stop debugging in GDB
GDBのall-stop modeでは、プログラムが停止すると、すべてのスレッドの実行が停止します。同様に、プログラムを再開すると、すべてのスレッドが実行を開始します。section “All-Stop Mode” in The GNU debuggerを参照してください。マルチスレッド化されたいくつかのターゲットにたいして、GDBはこれを超える操作のためのモードをサポートします。これはnon-stop modeと呼ばれ、他のスレッドが自由に実行を継続している間に、デバッガーで停止したプログラムのスレッドを調べることができます。section “Non-Stop Mode” in The GNU debuggerを参照してください。GDBのバージョン7.0以前では、non-stop modeはサポートされておらず、すべてのターゲットにたいしては機能しません。

gdb-non-stop-setting
変数`gdb-non-stop-setting`は、EmacsがGDBをall-stop modeとnon-stop modeのどちらで実行するかを決定します。デフォルトは`t`で、これは利用可能な場合はnon-stop modeを使うことを意味します。値を`nil`に変更した場合、またはnon-stop modeが利用不可の場合、EmacsはGDBをall-stop modeで実行します。この変数はEmacsがデバッグセッションを開始したときに効果をもちます。値を変更した場合、アクティブなデバッグセッションを再起動する必要があります。

gdb-switch-when-another-stopped
non-stop modeモードでスレッドが停止すると、通常Emacsはそのスレッドに切り替えます。すでに選択したスレッドから停止した他のスレッドへの切り替えを行わないようにするには、変数`gdb-switch-when-another-stopped`を`nil`に変更してください。

gdb-switch-reasons
Emacsが停止したスレッドに切り替えるかどうかの決定は、そのスレッドが停止した理由に依存します。変数`gdb-switch-reasons`をカスタマイズすることにより、スレッドの切り替えを行う停止理由を選択できます。

gdb-stopped-functions
変数`gdb-stopped-functions`には、あるスレッドが停止したときに実行する関数を指定できます。

non-stop modeでは、GUDの実行制御コマンドのための異なるモードを切り替えることができます。

gdb-gud-control-all-threads
Non-stop/A  
`gdb-gud-control-all-threads`が`t`(デフォルト)の場合、中断および継続のためのコマンドはすべてのスレッドに適用されるので、`gud-stop-subjob`または`gud-cont`の1コマンドで、すべてのスレッドを停止または継続できます。少なくとも1つのスレッドが停止している場合、ツールバーに‘`Go`’ボタンが表示されます。また、少なくとも1つのスレッドが実行中の場合、‘`Stop`’ボタンが表示されます。

Non-stop/T  
`gdb-gud-control-all-threads`が`nil`の場合、カレントスレッドだけを停止または継続します。GUDツールバーの‘`Go`’および‘`Stop`’のボタンの表示は、カレントスレッドの状態に依存します。

`gdb-gud-control-all-threads`のカレント値は、ツールバーまたは‘`GUD->GDB-MI`’メニューで変更できます。

ステップコマンドは常にカレントスレッドに適用されます。

non-stop modeでは、スレッドを選択せずにスレッドを中断または継続できます。threadsバッファーで、ポイント位置のスレッドにたいして`i`をタイプすると中断、`c`で継続、`s`でステップ実行します。今後さらにそのようなコマンドが追加されるかもしれません。

スレッドを中断した場合、停止理由は‘`signal
received`’になることに注意してください。この理由が`gdb-switch-reasons`に含まれている場合(デフォルトでは含まれています)、Emacsはそのスレッドに切り替えます。

Lisp式の実行
------------

Emacsには、Lispのいくつかの変種のためのメジャーモードがあります。これらは他のプログラミング言語のモードと同じ編集コマンドを使用します([Programs](#Programs)を参照してください)。それに加えて、Lisp式を実行するための特別なコマンドを提供します。

Emacs Lispモード  
Emacs Lispのソースファイルを編集するためのモードです。このモードはカレントのトップレベルのLisp式を評価する`C-M-x`を定義します。[Lisp Eval](#Lisp-Eval)を参照してください。

Lisp Interactionモード  
Emacs Lispとの対話的なセッションのためのモードです。このモードはポイントの前の式を評価して、その値をバッファーに挿入する`C-j`を定義します。[Lisp Interaction](#Lisp-Interaction)を参照してください。

Lispモード  
Emacs Lispではない、他のLispを実行するプログラムのソースファイルを編集するためのモードです。このモードは、カレントのトップレベルの式を外部のLispで評価する`C-M-x`を定義します。[External Lisp](#External-Lisp)を参照してください。

Inferior Lispモード  
Emacsのサブプロセス(またはinferior process: 下位プロセス)として実行される外部Lispと、対話的にセッションするためのモードです。 [External Lisp](#External-Lisp)を参照してください。

Schemeモード  
Lispモードと同様ですが、Schemeプログラムのためのモードです。

Inferior Schemeモード  
Inferior Lispモードと同様ですが、Schemeのためのモードです。

EmacsのためのLispコードによるライブラリー
-----------------------------------------

libraries
loading Lisp code
Emacs Lispのコードは、慣習として`.el`で終わる名前のファイルに保存されます。このようなファイルは、自動的にEmacs Lispモードでvisitされます。

byte code
Emacs Lispのコードは、loadが速く省スペースで、実行も速いバイトコードにコンパイルできます。慣習により、コンパイルされたEmacs Lispのコードは‘`.elc`’で終わる名前の別のファイルに保存されます。たとえば、`foo.el`をコンパイルしたコードは`foo.elc`になります。section “Byte Compilation” in the Emacs Lisp Reference Manualを参照してください。

load-file
Emacs Lispファイルをロード(load)するには、`M-x
load-file`とタイプします。このコマンドはミニバッファーを使ってファイル名を読み取り、そのファイル内容をEmacs Lispコードとして実行します。最初にファイルをvisitしておく必要はありません。このコマンドは、既存のEmacsバッファーからではなく、ディスクからファイルを直接読み込みます。

load
load-library
load-prefer-newer
load path for Emacs Lisp
Emacs Lispファイルが、Emacs Lispのロードパス(load path: 以下で定義)にインストールされている場合、`M-x load-file`ではなく`M-x
load-library`とタイプしてロードできます。`M-x
load-library`コマンドは、ファイル名ではなくライブラリー名(library name)の入力を求めます。これはEmacs Lispのロードパスの各ディレクトリーを検索して、そのライブラリー名にマッチするファイルを見つけようと試みます。ライブラリー名が‘`foo`’の場合、ファイル名`foo.elc`、`foo.el`、`foo`を見つけようと試みます。デフォルトの動作では、最初に見つかったファイルをロードします。このコマンドは`.el`より`.elc`を優先します。それはコンパイルされたファイルの方が、ロードと実行が速いからです。`lib.el`が`lib.elc`より新しい場合、警告を発します。この場合、誰かが`.el`を変更したもののリコンパイルを忘れたようだが、ともかく`.elc`をロードする、という警告です(この振る舞いにより、編集が終わっておらず、まだリコンパイルする準備ができていないEmacs Lispのソースファイルを保存することができます)。しかしオプション`load-prefer-newer`を非`nil`値にセットした場合、上記の手順ではなく、Emacsは新しいファイルのバージョンをロードします。

Emacs Lispプログラムは通常、`load`関数を使用してEmacs Lispファイルをロードします。これは`load-library`と似ていますが、より低レベルで追加の引数を指定できます。section “How Programs Do Loading” in the Emacs Lisp Reference Manualを参照してください。

load-path
Emacs Lispのロードパスは、変数`load-path`により指定されます。この変数の値は、ディレクトリー(文字列)のリストです。これらのディレクトリーは、`M-x
load-library`コマンド、低レベルの`load`関数、その他のEmacs Lispライブラリーを探すEmacs関数により、指定された順に検索されます。`load-path`のリストの要素には、特別な値`nil`も指定できます。これはカレントのデフォルトディレクトリーを意味しますが、その意味するところはEmacsが`load-path`を使用する際のカレントディレクトリーに依存するはずなので、これを使うのは大抵間違っています(リストに`nil`を含めたいと思うとき、大抵の場合は、本当に望んでいるのは`M-x
load-file`を使用することです)。

`load-path`のデフォルト値は、Emacs自身がLispコードを格納するディレクトリーのリストです。他のディレクトリーに独自のライブラリーがある場合、ロードパスにそのディレクトリーを追加できます。このマニュアルで説明されている他の大半の変数とは異なり、`load-path`はCustomizeインターフェース([Easy Customization](#Easy-Customization)を参照してください)を通じての変更はできません。しかしinitファイルに以下のような行を記述して、ディレクトリーを追加できます([Init File](#Init-File)を参照してください):

    (add-to-list 'load-path "/path/to/my/lisp/library")

autoload
いくつかのコマンドは、自動ロード(autoload)されます。これらを実行するとき、Emacsは最初に関連するライブラリーを自動的にロードします。たとえば`M-x
compile`コマンド([Compilation](#Compilation)を参照してください)は、自動ロードされます。これを呼び出した場合、Emacsは最初に、自動的に`compile`ライブラリーをロードします。対照的にコマンド`M-x
recompile`は、自動ロードされません。そのため、このコマンドは`compile`ライブラリーをロードするまで利用できません。

help-enable-auto-load
自動的なロードは、自動ロードされたコマンドのドキュメントを探すとき([Name Help](#Name-Help)を参照してください)にも発生します。それは、ドキュメントがライブラリーの他の関数や変数を参照する場合です(ライブラリーのロードにより`*Help*`バッファーのハイパーリンクが適切にセットアップされます)。この機能を無効にするには、変数`help-enable-auto-load`を`nil`に変更してください。

load-dangerous-libraries
Lisp files byte-compiled by XEmacs
デフォルトではEmacsは、XEmacs —Emacsの変更されたバージョン — でコンパイルされたコンパイル済みのLispファイルのロードを拒絶します。なぜならそれはEmacsのクラッシュをさせるからです。これらのロードを試みる場合は、変数`load-dangerous-libraries`に`t`をセットしてください。

Emacs Lisp式の評価
------------------

Emacs Lispモード
mode, Emacs Lisp
evaluation, Emacs Lisp
emacs-lisp-mode
Emacs LispモードはEmacs Lispを編集するためのメジャーモードです。これのモードコマンドは`M-x
emacs-lisp-mode`です。

Emacsは、Emacs Lisp式を評価するためのコマンドをいくつか提供します。記述しているEmacs Lispコードをテストするために、これらのコマンドをEmacs Lispモードで使用できます。たとえば、関数を書き換えた後、以降の関数呼び出しでそれを有効にするために、関数定義を評価します。これらのコマンドはグローバルに利用可能で、Emacs Lispモード以外でも使用できます。

`M-:`  
1つのEmacs Lisp式をミニバッファーで読み取り、それを評価して、値をエコーエリアに出力します(`eval-expression`)。

`C-x C-e`  
ポイントの前のEmacs Lisp式を評価して、値をエコーエリアに出力します(`eval-last-sexp`)。

`C-M-x` (Emacs Lispモード); `M-x eval-defun`  
ポイントの後またはポイントを含むdefunを評価して、値をエコーエリアに出力します(`eval-defun`)。

`M-x eval-region`  
リージョンのすべてのEmacs Lisp式を評価します。

`M-x eval-buffer`  
バッファーのすべてのEmacs Lisp式を評価します。

M-:
eval-expression
`M-:` (`eval-expression`)は、ミニバッファーを使って式を読み取り、それを評価します(式を評価する前に、カレントバッファーは、式をタイプするためのミニバッファーではなく、`M-:`をタイプしたときカレントだったバッファーに切り替わります)。

C-x C-e
eval-last-sexp
コマンド`C-x C-e` (`eval-last-sexp`)は、そのバッファーのポイントの前にあるEmacs Lisp式を評価して、その値をエコーエリアに表示します。評価した結果が整数のときは、他のフォーマット(8進、16進、`eval-expression-print-maximum-character`の制限を超えなければ文字)とともに値を表示します。

`M-:`および`C-x
C-e`にプレフィクス引数を与えた場合、値をエコーエリアに表示するのではなく、カレントバッファーのポイント位置に値を挿入します。プレフィクス引数が0の場合、整数出力は他のフォーマット(8進、16進、文字)と一緒に挿入されます。プレフィクス引数は、`eval-expression-print-level`および`eval-expression-print-length`にしたがった出力の省略も防ぎます(以下参照)。同様にプレフィックス引数`-1`は、`eval-expression-print-length`の効果をオーバーライドします。

C-M-x (Emacs Lisp mode)
eval-defun
`eval-defun`コマンドは、Emacs Lispモードでは`C-M-x`にバインドされています。これはポイントを含む、またはポイントの後ろのトップレベルのLisp式を評価して、値をエコーエリアに出力します。このコンテキストでは、トップレベルの式は“defun”として参照されますが、実際の`defun`(関数定義)である必要はありません。このコマンドは`defvar`式を特別に扱います。通常、`defvar`式を評価しても、それが定義する変数がすでに値をもっている場合は、何も起こりません。しかし、このコマンドは無条件に`defvar`で指定された初期値に変数をリセットします。これはEmacs Lispプログラムをデバッグするとき便利です。式`defcustom`および`defface`も同様に扱われます。このセクションで説明している他のコマンドは、この特別な機能をもっていません。

プレフィクス引数を指定すると、`C-M-x`はEmacs LispデバッガーのEdebugのために関数定義をインストルメント(instrument: 処置)します。section “Instrumenting for Edebug” in the Emacs Lisp Reference Manualを参照してください。

eval-region
eval-buffer
コマンド`M-x
eval-region`は、リージョンのテキストを1つ以上のLisp式として解析して、それらを1つずつ評価します。`M-x
eval-buffer`も同様ですが、これはバッファー全体を評価します。

eval-expression-print-level
eval-expression-print-length
eval-expression-print-maximum-character
eval-expression-debug-on-error
オプション`eval-expression-print-level`および`eval-expression-print-length`は、評価コマンドが結果を出力する前に省略する、リストの最大の深さと長さを制御します。`eval-expression`または`eval-last-sexp`にプレフィクス引数0を指定すると、リストはすべて出力されます。`eval-expression-debug-on-error`は、これらのコマンドが使用されるとき、評価エラーによりデバッガーを呼び出すかを制御します、デフォルトは`t`です。`eval-expression-print-maximum-character`は、文字として表示される最大の整数を超える値を抑制します。

Lisp Interactionバッファー
--------------------------

lisp-interaction-mode
Emacsを開始したとき、`*scratch*`という名前のバッファーが含まれます、これはEmacs Lisp式の対話的な評価を提供します。このバッファーのメジャーモードは、Lisp Interactionモードです。`M-x
lisp-interaction-mode`とタイプしても、Lisp Interactionモードを有効にできます。

eval-print-last-sexp
C-j (Lisp Interaction mode)
`*scratch*`バッファー、およびその他のLisp Interactionモードのバッファーでは、`C-j` (`eval-print-last-sexp`)はポイントの前のLisp式を評価して、値をポイント位置に挿入します。したがってバッファーに式をタイプするたび、その後ろで`C-j`をタイプすることにより、そのバッファーは式の評価とその値を記録した写しになります。その他すべてのLisp Interactionモードのコマンドは、Emacs Lispモードと同じです。

initial-scratch-message
起動時には、`*scratch*`バッファーは、それが何かを説明するLispコメント形式の短いメッセージを含んでいます。このメッセージは変数`initial-scratch-message`により制御され、値にはドキュメント文字列または`nil`(メッセージを抑止するという意味)を指定します。

ielm
Emacs Lisp式を対話的に評価する別の方法は、Inferior Emacs Lispモードを使う方法です。これはEmacs Lisp式の評価にShellモード([Shell Mode](#Shell-Mode)を参照してください)に似たインターフェースを提供します。`M-x
ielm`とタイプすることにより、このモードを使用する`*ielm*`というバッファーが作成されます。詳細は、コマンドのドキュメントを参照してください。

外部Lispの実行
--------------

Lispモード
mode, Lisp
Common Lisp
Lispモードは、Common Lispのような一般用途のためのLisp方言で記述されたプログラムを記述するためのメジャーモードです。これのモードコマンドは`M-x
lisp-mode`です。Emacsは名前が`.l`、`.lsp`、`.lisp`で終わるファイルにたいして、自動的にLispモードを使用します。

run-lisp
inferior-lisp-program
C-x C-z
外部LispセッションをEmacsのサブプロセス、または下位プロセス(inferior process)として実行して、式を評価するために渡すことができます。外部Lispセッションを開始するには、`M-x
run-lisp`とタイプします。これは`lisp`という名前のプログラムを実行して、`*inferior-lisp*`という名前のEmacsバッファーを通じて入出力を行うようにセットアップします。`M-x
run-lisp`で実行されるLispプログラムの名前を変更するには、変数`inferior-lisp-program`を変更してください。

`*lisp*`バッファーのためのメジャーモードはInferior Lispモードで、これはLispモードの性質とShellモード([Shell Mode](#Shell-Mode)を参照してください)の性質をあわせ持っています。Lispセッションに入力を送るには、`*lisp*`バッファーの最後に移動して、入力をタイプしてからRETをタイプします。Lispセッションからの端末出力は、自動的にそのバッファーに挿入されます。

C-M-x (Lisp mode)
lisp-eval-defun
LispプログラムをLispモードで編集する場合、`C-M-x` (`lisp-eval-defun`)とタイプして、Lispモードのバッファーから、`M-x
run-lisp`で開始したLispセッションに式を送ることができます。送信される式はポイント位置、またはポイントの後ろのトップレベルのLisp式です。結果となる値は通常どおり、`*inferior-lisp*`バッファーに送られます。Lispモードでの`C-M-x`の効果は、それが評価されるEmacsに送られるのではなく、異なるLisp環境に送られる点を除けば、Emacs Lispモード([Lisp Eval](#Lisp-Eval)を参照してください)での効果とよく似ていることに注意してください。

scheme-mode
run-scheme
Schemeモード
mode, Scheme
C-M-x (Scheme mode)
Schemeコードを編集して、式をSchemeサブプロセスに送る機能は、よく似ています。Schemeソースファイルは、Schemeモードで編集されます。このモードは`M-x
scheme-mode`で明示的に有効にできます。`M-x
run-scheme`とタイプすることにより、Schemeセッションを開始し、`C-M-x`とタイプして式の送ることができます(Schemeと対話するためのバッファーは、`*scheme*`という名前です)。

大きなプログラムの保守
======================

このチャプターでは、中規模から大規模のプログラムやパッケージを保守するためのEmacsの機能を説明します。これらの機能には、以下が含まれます:

-   − ソースファイルにたいする変更履歴を記録するバージョンコントロールシステム(VCS: Version Control Systems)にたいする、統一されたインターフェースのサポート。

-   − プログラムの変更にたいして日時順のログを提供する、`ChangeLog`の保守に特化したモード。

-   − シンボル定義(“識別子(identifiers)”とも言います)を表示する一連のコマンドである、Xref。

-   − Emacs自身のIDEである、EDE。

-   − 開発の別ブランチで行なわれたプログラム変更をマージするためのモード。

Lispの大きなプログラムをメンテナンスしている場合は、ここで説明している機能に加え、ERT(Emacs Lisp Regression Testing)ライブラリーも便利だと思うかもしれません(section “ERT” in Emacs Lisp Regression Testingを参照してください)。

バージョンコントロール
----------------------

version control
バージョンコントロールシステム(version control system)は、ソースファイルの複数のバージョンを記録したり、それらのバージョンの作成日時などや、誰が作成したか、何が変更されたかの説明などを記録できるプログラムのことです。

VC
Emacsのバージョンコントロールのためのインターフェースは、VCと呼ばれます。VCコマンドは、複数の異なるバージョンコントロールシステムで機能します。現在のところ、Bazaar、CVS、Git、Mercurial、Monotone、RCS、SRC、SCCS/CSSC、Subversionがサポートされます。これらの中で、GNUプロジェクトのディストリビューションはCVS、RCS、Bazaarです。

バージョン管理システムで生成されたファイルをvisitすると、自動的にVCが有効になります。VCを無効にするには、カスタマイズ可能な変数`vc-handled-backends`を`nil`をセットします ([Customizing VC](#Customizing-VC)を参照してください)。

vc-refresh-state
vc-state-refresh
カレントバッファーでvisitされているファイルにたいするVC状態の情報を更新するには、コマンド`vc-refresh-state`を使用します。Emacsの外(たとえばシェルプロンプト)でバージョンコントロールコマンドを実行したときや、そのバッファーのファイルを別のバージョンコントロールシステム下に置いたとき、バージョンコントロールからそのファイルを完全に削除したときに、このコマンドは有用です。

### バージョンコントロールの紹介

VCは、Emacsからのバージョンコントロールシステムの使用、およびバージョンコントロールの操作と編集をスムーズに統合します。VCは、多くのバージョンコントロールシステムでの一般的な操作にたいする、統一されたインターフェースを提供します。

リポジトリー設定の変更など、非一般的または複雑なバージョンコントロールの操作は、VCではサポートされません。そのようなタスクは、VCの外(たとえばコマンドライン)で処理する必要があります。

このセクションは、バージョンコントロールの一般的な概観を提供し、VCがサポートするバージョンコントロールを説明します。すでに使いたいバージョンコントロールシステムをよく知っている場合、このセクションはスキップできます。

#### 問題の背景を理解する

バージョンコントロールシステムは、3つの重要な能力を提供します。

-   Reversibility(可逆性): ある変更が間違い、または間違えた考えにもとづくものだと気づいたときに、前の状態に戻す能力です。

-   Concurrency(並列性): 多くの人が同じファイルコレクションを変更するとき、変更の衝突を検知して解決する能力です。

-   History(履歴): それを変更した背後の意図を説明するコメントなど、履歴データをデータに付す能力です。1人で作業するプログラマーでさえ、変更履歴は記憶を助けるのに重要です。複数人のプロジェクトでは、開発者間のコミュニケーション形式として、とても重要です。

#### サポートされるバージョンコントロールシステム

back end (version control)
VCは現在のところ、多くの異なるバージョンコントロールで機能し、それらをバックエンド(back ends)として参照します:

-   SCCS
    SCCSは、これまでに構築された一番最初のバージョンコントロールシステムで、ずっと以前に、もっと進んだものに取って代わられました。SCCSにない特定の機能のためのVCコンポーネントは、それら自身により実装されています。複数ブランチなど、その他のVC機能は単に利用不可です。SCCSはフリーではないので、これを避けることを推奨します。

-   CSSC
    CSSCはSCCSのフリーな置き換えです。何らかの理由により、もっと新しい、より良いデザインのバージョンコントロールシステムを使うことができないときだけ、CSSCを使うべきです。

-   RCS
    RCSは、VCが最初に構築された頃の、フリーなバージョンコントロールシステムです。これは比較的に初期のものです。これはネットワークを超えて使うことはできず、ファイルに個別のレベルで機能します。RCSでできるほとんどのことは、VCを通じて行うことができます。

-   CVS
    CVSは、フリーなバージョンコントロールシステムであり、2008年y頃まではフリーソフトウェアプロジェクトの大半で使われていました。それ以降は、新しいシステムに徐々に置き換えらました。CVSではローカルまたはネットワーク越しの、複数ユーザーによる並列開発が可能です。新しいシステムとは異なり、アトミックなコミットとファイルの移動・リネームにたいするサポートがありません。VCはCVS下での基本的な編集操作をサポートします。

-   SVN
    Subversion
    Subversion(svn)は、CVSと同じようにデザインされた、フリーなバージョンコントロールシステムですが、CVSのもつ問題はありません(たとえば、これはファイルセットのアトミックなコミット、ディレクトリーのバージョニング、シンボリックリンク、メタデータ、リネーム、コピー、削除をサポートします)。

-   git
    Gitは、最初にLinus TorvaldsによりLinux(彼のkernel)の開発をサポートするために考案されました。VCは多くのGit操作をサポートしますが、その他のリポジトリーの同期などはコマンドラインを使わなければなりません。

-   hg
    Mercurial
    Mercurial(hg)は、Gitに酷似した分散化されたバージョンコントロールシステムです。VCは、リポジトリーの同期操作を除いて、ほとんどのMercurialコマンドをサポートします。

-   bzr
    Bazaar
    Bazaar(bzr)は、リポジトリーベースと分散化されたバージョニングの両方をサポートする、分散化されたバージョンコントロールシステムです。VCはBazaar下でのほとんどの基本的な編集操作をサポートします。

-   SRC
    src
    SRC (src)はRCSの再実装で、1人による単一ファイルのプロジェクトために特化してデザインされたバージョンコントロールシステムです。これは1つのディレクトリーの中に、独立したバージョンコントロール履歴をもつ複数ファイルを許容します。したがって、これは小さなドキュメントやスクリプト、ドットファイルを保守するのに適しています。これはRCSのリビジョンストレージを使用するので、非lock操作(lockless operation)や、シーケンシャルな整数リビジョン番号をもつ、現代的なユーザーインターフェースを提供します。

#### バージョンコントロールの概念

repository
registered file
ファイルがバージョンコントロールの配下にある時、それがバージョンコントロールシステムに登録されている(registered)と言います。バージョンコントロールシステムは、リポジトリー(repository)をもちます。これはファイルの現在の状態、および古いバージョンから現在のバージョンを再構成するのに充分な変更履歴の、両方を保存します。リポジトリーには、各ファイルに行われた変更の説明であるログエントリー(log entries)など、その他の情報も含まれます。

work file
checking out files
実際に編集する、バージョンコントロールされたファイルのコピーのことを、作業ファイル(work file)と呼びます。作業ファイルは、通常のファイルを同じように変更できます。一連の変更を終えた後、その変更をコミット(commit)またはチェックイン(check in)します。これにより、その変更はログエントリーの記述とともに、リポジトリーに記録されます。

working tree
作業ファイルのディレクトリツリーを、作業ツリー(working tree)と呼びます。

revision
revision ID
commitするたびに、リポジトリーに新しいリビジョン(revision)が作成されます。バージョンコントロールシステムは、過去のすべてのリビジョンと、各リビジョンで行われた変更を記録します。各リビジョンには、リビジョンID(revision ID)により名前がつけられます。リビジョンIDのフォーマットは、バージョンコントロールシステムに依存します。もっとも簡単なケースでは、リビジョンIDは単なる整数です。

これらの基本的な概念を超えるにつれ、各バージョンコントロールシステムの違いの、3つの様相を理解する必要がでてくるでしょう。以降の3つのセクションで説明するように、各バージョンコントロールシステムには、ロックベース(lock-based)とマージベース(merge-based)、ファイルベース(file-based)と変更セットベース(changeset-based)、集中型(centralized)と分散型(decentralized)の違いがあります。VCはこれらすべてのモードの操作を処理しますが、それらの違いを隠蔽することはできません。

#### バージョンコントロールにおけるマージベースとロックベース

バージョンコントロールシステムは通常、同じファイルを変更したい複数ユーザーを調整するために、何らかのメカニズムをもちます。これを行うには2つの方法 — マージとロック — があります。

merging-based version
マージを使うバージョンコントロールシステムでは、各ユーザーはいつでも作業ファイルを変更します。バージョンコントロールシステムは、コミットされていない変更を含むユーザーの作業ファイルを、他のユーザーによりコミットされた最新の変更とマージします。

locking-based version
古いバージョンコントロールシステムは、かわりにロック(locking)を使います。この場合、作業ファイルは通常は読み取り専用です。ファイルを編集するには、それをロックすることにより書き込み可能にできるか、バージョンコントロールシステムに尋ねます。ある時点で、そのファイルをロックできるユーザーは1人だけです。この手順は、通常のファイルの同時編集をEmacsが検知する方法と類似しているようですが、異なります([Interlocking](#Interlocking)を参照してください)。変更をコミットすると、ファイルはアンロック(unlocks)され、作業ファイルは再び読み取り専用になります。他のユーザーは、変更するためにそのファイルをロックすることができます。

ロックおよびマージの両方のシステムは、複数ユーザーが同じときに同じファイルの変更を試みたときに問題が発生し得ます。ロックを使うシステムには、ロックの衝突(lock conflicts)があります。あるユーザーはファイルのチェックアウトを試みますが、それがすでにロックされている場合はロックできません。マージを使うシステムには、マージの衝突(merge conflicts)があります。これはファイルに行った変更をコミットするとき、それが後からチェックアウトした他の誰かによる変更のコミットと衝突するときに発生します。どちらの衝突も、人間の判断と意思疎通により解決する必要があります。経験から、開発者に取っての利便性と、実際に発生する衝突の重大性と数を最小にするという両方の点で、マージはロックに優ります。

SCCSは常にロックを使います。RCSはデフォルトではロックベースですが、マージスタイルで処理するように指示できます。CVSとSubversionはデフォルトではマージベースですが、ロックモードで処理するように指示できます。Git、Mercurialのような分散型のバージョンコントロールシステムは、マージベースだけです。

VCはロックとマージの両方のバージョンコントロールをサポートします。“commit(コミット)”と“update(更新)”という用語は、新しいバージョンコントロールシステムで使用されます。古いロックベースのシステムでは、“check in(チェックイン)”と“check out(チェックアウト)”という用語が使用されます。VCはこれらの違いをできる限り隠蔽します。

#### バージョンコントロールに置ける変更セットベースとファイルベース

file-based version control
SCCS、RCS、CVS、およびその他の初期のバージョンコントロールシステム(SRCも含む)では、バージョンコントロールの操作はファイルベース(file-based)です。各ファイルは、他のすべてのファイルとは別に、ファイル自身のコメントとリビジョン履歴をもちます。Subversionで始まる新しいシステムは、変更セットベース(changeset-based)です。コミットは複数ファイルにたいする変更を含むときがあり、一連の変更全体を1つの単位として扱います。変更にたいするコメントは1つのファイルではなく、変更セットに属します。

changeset-based version control
変更セットベースのバージョンコントロールは、ファイルベースのバージョンコントロールより、柔軟で強力です。通常、複数ファイルの変更を元に戻す必要がある時、それを簡単に識別してすべてを削除できます。

#### リポジトリーにおける分散型と集中型

centralized version control
decentralized version control
distributed version control
初期のバージョンコントロールシステムは、集中型(centralized)モデルでデザインされていて、各プロジェクトはすべての開発者が使用するただ1つのリポジトリーをもちます。SCCS、RCS、CVS、Subversion、SRCはこの種のモデルを共有します。このモデルの欠点の1つは、リポジトリーが信頼性と効率の要衝となることです。

GNU Archは、分配型(distributed)または分散型(decentralized)のバージョンコントロールの先駆で、後にGit、Mercurial、Bazaarで実装されました。プロジェクトは複数の異なるリポジトリーをもつことができ、これらのシステムはリポジトリー間で変更履歴を調停する、ある種のスーパーマージをサポートします。開発者ごとに1つのリポジトリーがあり、リポジトリーのマージがコミット操作を代行します。

VCは個人の作業ファイルと、リポジトリーとの間で行われる通信を管理する手助けをします。VCは、リポジトリーが唯一のマスターなのか、それともネットワークのピアーのリポジトリーの1つなのかは関知しません。

#### ログファイルのタイプ

types of log file
log File, types of
version control log
バージョンコントロールシステムを使うプロジェクトは、変更にたいする2つのタイプのログをもつことができます。1つはバージョンコントロールシステムで保守されるログです。変更をコミットするたびに、変更にたいするログエントリー(log entry)を入力します([Log Buffer](#Log-Buffer)を参照してください)。これはバージョンコントロールログ(version control log)と呼ばれます。

もう1つの種類のログは、`ChangeLog`です([Change Log](#Change-Log)を参照してください)。これはプログラムの大きな部分(通常は1つのディレクトリーと、そのサブディレクトリー)にたいする変更の記録を、年代順に記録します。小さなプログラムは、1つの`ChangeLog`を使用するでしょう。大きなプログラムは、主要なディレクトリーごとに`ChangeLog`をもつかもしれません。[Change Log](#Change-Log)を参照してください。プログラマーは、バージョンコントロールシステムのずっと前からChangeLogを使ってきました。

変更セットベースのバージョンシステムは、通常システム全体にたいして変更セットベースの修正ログを保守します。これはChangeLogを冗長なものにします。ChangeLogを残す利点の1つは、他のディレクトリーとは別に、1つのディレクトリーの履歴トランザクションが見れるのは便利なときがあるからです。他の利点として、多くのバージョンコントロールシステムはコミットログを特定できないからです。

バージョンコントロールで管理されるプロジェクトは、バージョンコントロールログだけを使用するか、両方の種類のログを使用します。あるファイルにたいしては1つのログを使い、他のファイルにたいしては別の方法を使うこともできます。プロジェクトごとに、したがうべきポリシーがあります。

両方を使うというポリシーの場合は通常、変更にたいして1度だけエントリーを書いて、それを両方のログに書き込みたいと思うでしょう。`ChangeLog`にエントリーを記述して、変更をコミットするとき`C-c
C-a`でログバッファーにコピーできます。または変更をコミットするときログバッファーにエントリーを記述して、後で`C-x v
a`コマンドでそれを`ChangeLog`にコピーできます ([Change Logs and VC](#Change-Logs-and-VC)を参照してください)。

### バージョンコントロールとモードライン

VC mode line indicator
バージョンコントロール配下のファイルをvisitしたとき、Emacsはモードラインにそれを示します。たとえば‘`Bzr-1223`’と表示された場合、そのファイルにBazaarが使用され、カレントのリビジョンIDが1223であることを示します。

version control status
バックエンド名とリビジョンIDの間の文字は、作業ファイルのバージョンコントロール状態(version control status)を示します。マージベースのバージョンコントロールシステムでは、文字‘`-`’は作業ファイルが変更されていないことを示し、文字‘`:`’は作業ファイルが変更されていることを示します。文字‘`!`’は最新のマージ処理の結果により、そのファイルに衝突が含まれていることを示すか([Merging](#Merging)を参照してください)、そのファイルがバージョンコントロールから削除されたことを示します。最後に、文字‘`?`’は、そのファイルがバージョンコントロールの配下にあるが、作業ツリーにないことを示します。

ロックベースのシステムでは、‘`-`’はファイルがロックされていないことを示し、‘`:`’はファイルが他のユーザー(たとえば‘`jim`’)にロックされていることを示し、‘`RCS:jim:1.3`’のように表示されます。‘`@`’は、そのファイルがローカルに追加されたが、まだマスターリポジトリーにコミットされていないことを示します。

グラフィカルなディスプレーでは、モードラインのインジケーターの上にマウスを移動すると、ツールチップが表示され、それにはバージョンコントロール状態の、より多くの説明が表示されます。インジケーターを`mouse-1`でクリックすると、メニューバーの‘`Tools
/ Version Control`’と同じVCコマンドがのメニューがポップアップします。

auto-revert-check-vc-info
Auto Revertモード([Reverting](#Reverting)を参照してください)がバージョンコントロール配下のバッファーをリバートするとき、これはモードラインのバージョンコントロール情報を更新します。しかし、Auto Revertモードは、作業ファイルの変更をともなわない、カレントのEmacsセッションの外でのバージョンコントロール状態の変化の情報は、正しく更新しないかもしれません。`auto-revert-check-vc-info`を`t`にセットすると、Auto Revertモードは、作業ファイル自身を変更していなくても、`auto-revert-interval`秒ごとにバージョンコントロール状態の情報を更新します。CPU使用率はバージョンコントロールシステムに依存しますが、通常はそれほど高価な処理ではありません。

### バージョンコントロール下での基本的な編集

filesets, VC
VC filesets
ほとんどのVCコマンドは、VCファイルセット(VC filesets)にたいして処理を行います。VCファイルセットは、VC操作が機能する1つ以上のファイルのコレクションです。バージョンコントロールされたファイルをvisitしているバッファーでVCコマンドをタイプすると、VCファイルセットは単にそのファイル1つだけになります。VC Directoryバッファーで、いくつかのファイルをマークしているときにVCコマンドをタイプしたときは、VCファイルセットはマークされたファイルです([VC Directory Mode](#VC-Directory-Mode)を参照してください)。

現代的な変更セットベースのバージョンコントロールシステム([VCS Changesets](#VCS-Changesets)を参照してください)では、VCコマンドは複数ファイルからなるVCファイルセットを1つのグループとして扱います。たとえば複数ファイルからなるVCファイルセットをコミットすると、それらすべてのファイルにたいする変更を含む、1つのリビジョンが生成されます。CVSのような古いファイルベースのバージョンコントロールシステムでは、複数ファイルからなるVCファイルセットの各ファイルは個別に処理されます。たとえば、コミットにより、変更されたファイル後とに1つのリビジョンが生成されます。

`C-x v v`  
カレントVCファイルセットにたいして、次の適切なバージョンコントロール操作を処理します。

vc-next-action
C-x v v
重要なVCコマンド`C-x v v` (`vc-next-action`)は多目的なもので、カレントのVCファイルセットにたいして、もっとも適切な操作を処理します。このコマンドは、それをバージョンコントロールシステムに登録するか、コミットするか、ロックを外すか、変更をマージします。正確な動作の詳細は、以下のサブセクションで説明します。`C-x
v v`は、ファイルをvisitしているバッファーと、VC Directoryバッファーの両方で使うことができます。

VCファイルセットは、ファイルを閲覧したりvisitするためのグループ機能として使用される、名前つきファイルセット(named filesets)とは別の物だということに注意してください([Filesets](#Filesets)を参照してください)。名前つきファイルセットとは異なり、VCファイルセットは名前をもたず、セッションをまたいで持続しません。

#### マージでの基本的なバージョンコントロール

マージベースのバージョンコントロールシステム(たとえばもっとも現代的な方法の1つ。[VCS Merging](#VCS-Merging)を参照してください)では、`C-x v v`は以下のことを行います:

-   VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョンコントロール状態と矛盾する場合、エラーをシグナルします(しかしファイルセットには、新しく追加されたファイルと、変更されたファイルを含むことができることに注意してください。[Registering](#Registering)を参照してください)。

-   VCファイルセットに、バージョンコントロールシステムに登録されたファイルがない場合、VCファイルセットを登録(たとえばバージョンコントロールの配下に置く)します。[Registering](#Registering)を参照してください。Emacsが登録すべきシステムを見つけられない場合、リポジトリータイプの入力を求め、新しいリポジトリーを作成して、VCファイルセットをそれに登録します。

-   VCファイルセットの、すべての作業ファイルが変更されていない場合は、何もしません。

-   VCファイルセットの各作業ファイルが変更されている場合、変更をコミットします。これを行うには、Emacsが`*vc-log*`バッファーをポップアップするので、新しいリビジョンのログエントリーをタイプしてから、`C-c
    C-c`でコミットします。[Log Buffer](#Log-Buffer)を参照してください。

    共有リポジトリーにコミットする場合、最後に更新したときからリポジトリーが変更されているときは、コミットが失敗するでしょう。このような場合、再試行する前に更新をしなければなりません。分散型のバージョンコントロールシステムでは、`C-x
    v +`([Pulling / Pushing](#Pulling-_002f-Pushing)を参照してください)、またh`C-x v
    m`を使用します([Merging](#Merging)を参照してください)。集中型のバージョンコントロールシステムでは、リポジトリーに変更をマージするために、再度`C-x
    v v`とタイプしてください。

-   最後に、集中型のバージョンコントロールシステムでは、VCファイルセットの各ファイルが最新かチェックします。リポジトリーで変更されたファイルがある場合、更新を提案します。

これらのルールは、変更はリポジトリーから自動的にマージされない点をのぞき、RCSを非ロックモードで使用している場合も適用されます。あなたがファイルの編集を始めた後に、他のユーザーが同じファイルをコミットした場合、何の情報も与えられません。あなたのリビジョンをコミットしたとき、他のユーザーの変更は失われます(しかし、それはリポジトリーには残るので、決定的に失われるわけではありません)。したがって、変更をコミットする前に、カレントリビジョンが変更されていないことを調べなければなりません。それに加えて、このモードでもRCSでロックすることが可能です。変更されていないファイルでの`C-x
v v`は、RCSの通常のロックモードのようにそのファイルをロックします。([VC With A Locking VCS](#VC-With-A-Locking-VCS)を参照してください)。

#### ロックでの基本的なバージョンコントロール

ロックベースのバージョンコントロールシステム(SCCSやRCSのデフォルトモードなど)では、`C-x v v`は以下のことを行います:

-   VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョンコントロール状態と矛盾する場合、エラーをシグナルします。

-   VCファイルセットに、バージョンコントロールシステムに登録されたファイルがない場合、VCファイルセットを登録します。[Registering](#Registering)を参照してください。Emacsが登録すべきシステムを見つけられない場合、リポジトリータイプの入力を求め、新しいリポジトリーを作成して、VCファイルセットをそれに登録します。

-   各ファイルが登録されていてロックされていなければ、それを書き込み可能にするためにロックして、編集を開始できるようにします。

-   各ファイルのロックを獲得していて、それらが変更を含む場合、その変更をコミットします。これを行うことにより、Emacsは`*vc-log*`バッファーをポップアップするので、新しいリビジョンのログエントリーをタイプしてから、C-c C-cでコミットします([Log Buffer](#Log-Buffer)を参照してください)。

-   各ファイルのロックをすでに獲得していて、変更がない場合、ファイルを再び読み取り専用にするために、ロックを開放します。

-   各ファイルが他のユーザーによりロックされている場合、ロックを横取りする(steal the lock)か、確認を求めます。これにyesと応えると、あなたがロックを獲得して、その前にファイルをロックしていたユーザーに、警告メッセージが送られます。

このルールは、CVSがロックの横取りをサポートしない点をのぞき、CVSをロックモードで使用している場合も適用されます。

#### `C-x v v`の高度な制御

revision ID in version control
`vc-next-action`にプレフィクス引数を与えた場合(`C-u C-x v
v`)、論理的に次のバージョンコントロール操作を処理する点に変わりはありませんが、どのように操作を行うかを正確に指定するために、追加の引数を指定できるようになります。

-   specific version control system
    バージョンコントロールシステムの名前を指定できます。これは、ファイルセットが複数のバージョンコントロールシステムで管理されていて、Emacsが正しいものを検知するのに失敗するとき便利です。

-   そうでない場合で、CVS、RCS、SRCを使用しているときは、リビジョンIDを指定できます。

    ファイルセットが変更(またはロック)されている場合、Emacsは指定したリビジョンIDでそれをコミットします。適切なリビジョンIDを与えることにより、新しいブランチを作成できます([Branches](#Branches)を参照してください)。

    ファイルセットが変更(またはロック)されていない場合、これは指定したリビジョンを作業ツリーにチェックインします。リビジョンIDまたはブランチIDを与えることにより、他のブランチのリビジョンを指定できます([Switching Branches](#Switching-Branches)を参照してください)。空の引数(例: `C-u C-x v v
    RET`)は、カレントブランチの最新のリビジョン(head)をチェックアウトします。

    これは、分散型のバージョンコントロールシステムでは単に無視されます。これらのシステムでは、独自のリビジョンIDは指定できず、個別のファイルを“チェックアウト”するという概念も使いません。

### Log Entryバッファーの機能

C-c C-c (Log Edit mode)
log-edit-done
VCに変更のコミットを指示したとき、`*vc-log*`という名前のバッファーがポップアップします。このバッファーには、行った変更を説明するログエントリー(log entry)を書き込みます。書き込んだら`C-c C-c` (`log-edit-done`)とタイプして, そのバッファーを抜けて、ログエントリーとともに変更をコミットします。

Log Edit mode
mode, Log Edit
vc-log-mode-hook
`*vc-log*`バッファーのためのメジャーモードはLog Editモードで、これはTextモードの変種です([Text Mode](#Text-Mode)を参照してください)。Log Editモードに入ると、Emacsはフック`text-mode-hook`および`vc-log-mode-hook`を実行します([Hooks](#Hooks)を参照してください)。

`*vc-log*`バッファーでは、１行以上のヘッダー行(header lines)を記入できます。これにはバージョンコントロールシステムにより提供される、追加の情報を指定します。各ヘッダー行は、そのバッファーの最初の1行を占めなければなりません。ヘッダー行でない最初の行は、ログエントリーの開始として扱われます。たとえば以下のヘッダー行は、その変更が他の開発者によるものだということを示します:

    Author: J. R. Hacker <jrh@example.com>

‘`Author`’ヘッダーとは別に、Emacsは‘`Summary`’ヘッダー(changesetの1行要約)、‘`Date`’ヘッダー(手入力で指定されたコミット日時)、‘`Fixes`’ヘッダー(変更によるバグフィクスへの参照)を認識します。すべてのバージョンコントロールシステムが、すべてのヘッダーを認識するわけではありません。そのシステムでサポートされていないヘッダーを指定した場合、それはログエントリーの一部として扱われます。

C-c C-f (Log Edit mode)
log-edit-show-files
C-c C-d (Log Edit mode)
log-edit-show-diff
`*vc-log*`バッファーにいる間は、カレントVCファイルセット(current VC fileset)とは、`C-c
C-c`とタイプすることによりコミットされるファイルセットだと考えられます。そのVCファイルセットのファイル一覧を閲覧するには、`C-c
C-f` (`log-edit-show-files`)とタイプします。そのVCファイルセットと、編集を開始したバージョンとのdiffを閲覧するには、`C-c
C-d` (`log-edit-show-diff`)とタイプしてください。

C-c C-a (Log Edit mode)
log-edit-insert-changelog
VCファイルセットが1つ以上の`ChangeLog`([Change Log](#Change-Log)を参照してください)ファイルを含む場合、`C-c
C-a` (`log-edit-insert-changelog`)とタイプすると、関連するエントリーを、`*vc-log*`バッファーに引用します。各`ChangeLog`ファイルの一番上のアイテムが、今日の日付でユーザー名があなたの場合、このコマンドはコミットされるファイルにマッチするエントリーのアイテムを検索して、それを挿入します。 CVSまたはRCSを使用している場合は、反対のこと — Log EditバッファーからChangeLogエントリーを生成 — を行います。[Change Logs and VC](#Change-Logs-and-VC)を参照してください。

コミットを中止するには、そのバッファーで単に`C-c
C-c`を*タイプしない*で、バッファーを切り替えて他の編集を行うことができます。他のコミットを試みなければ、編集していたエントリーは`*vc-log*`に残っているので、後でそのバッファーに戻ってコミットを完了できます。

M-n (Log Edit mode)
M-p (Log Edit mode)
M-s (Log Edit mode)
M-r (Log Edit mode)
コミットコメントをコピーするために、以前のログエントリーの履歴を閲覧することもできます。これは、似たようなコメントで複数のコミットを行いたいとき便利です。これを行うコマンド`M-n`、`M-p`、`M-s`、`M-r`は、これらがミニバッファーの外で使用される点を除けば、ミニバッファーのヒストリーコマンド([Minibuffer History](#Minibuffer-History)を参照してください)と同様です。

### バージョンコントロールへのファイルの登録

`C-x v i`  
visitしているファイルを、バージョンコントロールに登録します。

C-x v i
vc-register
コマンド`C-x v i` (`vc-register`)は、カレントVCファイルセットの各ファイルを、バージョンコントロールの配下に置きます。これは登録されていないVCファイルセットにたいして、`C-x
v v`が行う動作と基本的に同じですが、VCファイルセットがすでに登録されているとき([Basic VC Editing](#Basic-VC-Editing)を参照してください)、`C-x v v`は他の操作を処理しますが、`C-x v
i`はエラーをシグナルする、という点が異なります。

ファイルを登録するために、Emacsはバージョンコントロールシステムを選択しなければなりません。複数ファイルのVCファイルセットにたいしては、VC Directoryバッファーが使用するシステムを指定します([VC Directory Mode](#VC-Directory-Mode)を参照してください)。VCファイルセットのファイルが1つで、そのファイルのディレクトリーがすでにバージョンコントロールシステムに登録されたファイルを含むか、そのディレクトリーがバージョンコントロールシステムにより制御される作業ツリーの一部の場合、Emacsはそのシステムを選択します。複数のバージョンコントロールシステムが当てはまる場合、Emacsは変数 `vc-handled-backends`に最初に表れるシステムを使用します(see [Customizing VC](#Customizing-VC))。 Emacsがファイルを登録するバージョンコントロールシステムを見つけられなかった場合、リポジトリータイプの入力を求め、新しいリポジトリーを作成して、そのリポジトリーにファイルを登録します。

ほとんどのバージョンコントロールシステムでは、`C-x v i`または`C-x v
v`でファイルを登録することにより、それを作業ツリー(working tree)に追加しますが、リポジトリーには追加しません。そのようなファイルは、VC Directoryバッファーでは‘`added`’とラベル付けされ、モードラインのリビジョンIDには‘`@@`’が表示されます。リポジトリーにたいして登録を有効にするには、コミットを行わなければなりません([Basic VC Editing](#Basic-VC-Editing)を参照してください)。1つのコミットに、ファイルの追加と、既存ファイルの編集の両方を含むことができるのに注意してください。

ロックベースのバージョンコントロールシステム([VCS Merging](#VCS-Merging)を参照してください)では、ファイルの登録により、ファイルはロックされていない読み取り専用の状態に留まります。編集を開始するには、`C-x
v v`とタイプします。

### 古いリビジョンの調査と比較

`C-x v =`  
カレントVCファイルセットの作業ファイルと、編集を開始したバージョンを比較します(`vc-diff`)。プレフィクス引数を指定した場合、カレントVCファイルセットの2つのリビジョンの入力を求め、それらを比較します。このコマンドをDiredバッファーから呼び出すこともできます([Dired](#Dired)を参照してください)。

`M-x vc-ediff`  
`C-x v =`と同様ですが、Ediffを使用します。section “Ediff” in The Ediff Manualを参照してください。

`C-x v D`  
編集を開始したリビジョンの、作業ツリー全体を比較します(`vc-root-diff`)。プレフィクス引数を指定した場合、2つのリビジョンの入力を求め、それらのツリーを比較します。

`C-x v ~`  
カレントファイルのリビジョンの入力を求め、それを別のバッファーでvisitします(`vc-revision-other-window`)。

`C-x v g`  
カレントファイルの、注釈付きのバージョンを表示します。各行には、その行が変更された最新のリビジョンが表示されます(`vc-annotate`)。

vc-diff
C-x v =
`C-x v =` (`vc-diff`)は、diffを表示します。これはカレントVCファイルセットの各作業ファイルを、編集を開始したときのバージョンと比較します。diffは別のウィンドウに、`*vc-diff*`という名前のDiff modeモードのバッファー([Diff Mode](#Diff-Mode)を参照してください)で表示されます。このバッファーでは、通常のDiffモードコマンドが利用可能です。特に`g` (`revert-buffer`)コマンドは、ファイル比較を再び行い、新しいdiffを生成します。

C-u C-x v =
カレントVCファイルセットの、任意の2つのリビジョンを比較するには、`C-u C-x v
=`のようにプレフィクス引数を指定して、`vc-diff`を呼び出します。これは2つのリビジョンID([VCS Concepts](#VCS-Concepts)を参照してください)の入力を求め、ファイルセットのそれらのバージョンの間のdiffを表示します。このコマンドは、バージョンコントロールシステムが変更セットベースではなくファイルベースの場合(たとえばCVS)に、複数ファイルのVCファイルセットにたいして確実に動作しません。なぜなら同じリビジョンIDをもつ異なるファイル同士を、意味のある方法で関連させることができないからです。

リビジョンIDではなく、他のフォーマットでリビジョンを指定するバージョンコントロールシステムもいくつかあります。たとえばBazaarでは、`C-u
C-x v
=`(および関連するコマンド)に‘`date:yesterday`’と入力でき、これは昨日以降コミットされた最初のリビジョンを指定します。詳細については、バージョンコントロールシステムのドキュメントを参照してください。

Diredバッファー([Dired](#Dired)を参照してください)で`C-x v =`または`C-u C-x v
=`を呼び出すと、カレント行にリストされたファイルが、カレントVCファイルセットとして扱われます。

vc-ediff
`M-x vc-ediff`は、`C-x v =`と同じように機能しますが、Ediffセッションを使用します。section “Ediff” in The Ediff Manualを参照してください。

vc-root-diff
C-x v D
`C-x v D` (`vc-root-diff`)は、`C-x v
=`と似ていますが、カレント作業ツリー全体の変更を表示します(たとえばカレントVCファイルセットを含む作業ツリー)。このコマンドをDiredバッファーから呼び出すと、そのディレクトリーを含む作業ツリーに適用されます。

vc-diff-switches
`C-x v =`および`C-x v
D`が、diffを生成するために使用する`diff`オプションをカスタマイズできます。オプションには、変数`vc-backend-diff-switches`、`vc-diff-switches`、`diff-switches`(see [Comparing Files](#Comparing-Files))の順に、最初の非`nil`の値が使用されます。ここでbackendは、関連するバージョンコントロールシステムで、たとえばBazaarの場合は`bzr`です。`nil`は順番に次の変数をチェックすることを意味するので、スイッチを指定しない場合は最初の2つの値を`t`にします。ほとんどの`vc-backend-diff-switches`変数のデフォルトは`nil`ですが、いくつかのbackendのデフォルトは`t`です。Subversionのように、これらのバージョンコントロールシステムの`diff`実装は、一般的なdiffオプションを受け付けません。

vc-revision-other-window
C-x v ~
ファイルの古いバージョンを直接調べるには、作業ファイルをvisitして、`C-x v ~ revision RET` (`vc-revision-other-window`)とタイプします。これはrevisionに対応するバージョンのファイルを取得して、それを`filename.~revision~`に保存してから、別のウィンドウでvisitします。

vc-annotate
vc-annotate-background-mode
C-x v g
多くのバージョンコントロールシステムでは、`C-x v g` (`vc-annotate`)とタイプして、行ごとにリビジョン情報の注釈付き(annotated)でファイルを閲覧できます。これは新しい“annotate”バッファーを作成して、各行に古さを示すカラーをつけて、ファイルのテキストを表示します。赤いテキストは新しく、古いものは青、その中間色は中間のバージョンを示します。デフォルトでは、一番古い変更を青、一番新しい変更を赤で、すべてのバージョンレンジにカラーをスケーリングします。変数`vc-annotate-background-mode`が非`nil`の場合、各行の世代を表すカラーはバックグラウンドカラーに適用され、フォアグラウンドカラーはデフォルトのカラーのままです。

このコマンドにプレフィクス引数を指定した場合、Emacsはミニバッファーを使って、表示および注釈つけする(カレントファイル内容のかわりの)リビジョンと、カラーレンジがカバーすべきタイムスパンの、2つの引数を読み取ります。

“annotate”バッファーでは、‘`VC-Annotate`’メニューから、これら、または他のカラースケールオプションが利用可能です。このバッファーでは、過去のリビジョンの注釈の表示、diffの閲覧、ログエントリーの閲覧を行うために、以下のキーを使うこともできます:

`p`  
前のリビジョン(たとえば現在の注釈付きのリビジョンの1つ前のリビジョン)に注釈を付けます。数引数は繰り返し回数となるので、`C-u 10
p`は10個前のリビジョンに注釈を付けます。

`n`  
次のリビジョン(たとえば現在の注釈付きのリビジョンの1つ後のリビジョン)に注釈を付けます。数引数は繰り返し回数です。

`j`  
カレント行に示されたリビジョンに解釈を付けます。

`a`  
カレント行に示されたリビジョンの、1つ前のリビジョンに注釈を付けます。これはカレント行が変更される前の状態のファイルを見るとき便利です。

`f`  
カレント行に示されたリビジョンのファイルを、バッファーに表示します。

`d`  
カレント行のリビジョンと、その前のリビジョンの間のdiffを表示します。これはカレント行のリビジョンが実際にどのように変更されたか、ファイルを見るとき便利です。

`D`  
カレント行のリビジョンと、その前のリビジョンの間で、(変更セットをサポートするバージョンコントロールシステムの)変更セットのすべてのファイルのdiffを表示します。これはカレント行のリビジョンが、実際にどのように変更されたかツリー内を見るとき便利です。

`l`  
カレント行のリビジョンのログを表示します。これはカレント行のリビジョンの変更にたいする執筆者(author)の説明を見るのに便利です。

`w`  
作業中のリビジョン(編集中のもの)に注釈を付けます。`p`や`n`を使って他のリビジョンを表示している場合、このキーで作業中のリビジョンに戻ることができます。

`v`  
注釈の表示・非表示を切り替えます。これは邪魔になる注釈抜きでファイル内容だけを見たいとき便利です。

### VC Change Log

`C-x v l`  
カレントファイルセットの変更履歴を表示します(`vc-print-log`)。

`C-x v L`  
カレントリポジトリーの変更履歴を表示します(`vc-print-root-log`)。

`C-x v I`  
pull操作が取り込む変更を表示します(`vc-log-incoming`)。

`C-x v O`  
push操作が送信する変更を表示します(`vc-log-outgoing`)。

C-x v l
vc-print-log
`C-x v l` (`vc-print-log`)は、`*vc-change-log*`という名前のバッファーを表示して、誰が変更したのか、その日時、各変更のログエントリー(これらは`*vc-log*`バッファーを通じて入力したログエントリーと同じです。[Log Buffer](#Log-Buffer)を参照してください)を含む、カレントファイルに行われた変更の履歴を表示します。現在visitしているファイルのリビジョンに、ポイントが配されます。プレフィクス引数を指定した場合、このコマンドはポイントが配されるリビジョンと、表示するリビジョンの最大数の入力を求めます。

VC Directoryバッファー([VC Directory Mode](#VC-Directory-Mode)を参照してください)、またはDiredバッファー([Dired](#Dired)を参照してください)から`C-x v
l`を呼び出した場合、カレント行にリストされたファイルにたいして適用されます。

vc-print-root-log
log-view-toggle-entry-display
`C-x v L` (`vc-print-root-log`)は、`*vc-change-log*`バッファーを表示して、バージョンコントロールされたディレクトリーツリー全体を表示します(RCS、SCCS、CVS、SRCはこの機能をサポートしない)。このコマンドはプレフィクス引数を指定した場合、表示するリビジョンの最大数の入力を求めます。

`C-x v
L`では履歴は簡略化された形式で表示され、通常は各ログエントリーの最初の行だけが表示されます。しかし`*vc-change-log*`バッファーでRET (`log-view-toggle-entry-display`)とタイプすると、ポイント位置のリビジョンのログエントリー全体を表示します。2回目のRETで、再びそれを隠します。

分散型のバージョンコントロールシステムでは、`C-x v I` (`vc-log-incoming`)コマンドは、次回にバージョンコントロールのpullコマンドを実行するときに、他のリポジトリーから受け取る新しいリビジョンにより適用される変更を、ログバッファーに表示します([Pulling / Pushing](#Pulling-_002f-Pushing)を参照してください)。ここで他のリポジトリーとは、バージョンコントロールシステムで定義される、変更がpullされるリポジトリーのことです。プレフィクス引数を指定すると、`vc-log-incoming`は特定のリポジトリーの入力を求めます。同様に、`C-x
v O` (`vc-log-outgoing`)は、次回にpushコマンドを実行するときに、他のリポジトリーに送る変更を表示します。プレフィクス引数を指定すると、特定の送信先リポジトリーの入力を求めます。

`*vc-change-log*`バッファーでは、リビジョンのログまたはファイル間の移動や、過去のリビジョン([Old Revisions](#Old-Revisions)を参照してください)を調べたり比較するために、以下のキーを使うことができます:

`p`  
前のリビジョンエントリーに移動します(logバッファーのリビジョンエントリーは通常、日時の降順になっているので、前のリビジョンアイテムは通常、もっと新しいリビジョンに対応します)。数引数は繰り返し回数です。

`n`  
次のリビジョンエントリーに移動します。数引数は繰り返し回数です。

`P`  
複数ファイルのVCファイルセットのログを表示している場合は、前のファイルのログに移動します。そうでない場合は、単にログの先頭に移動します。数引数は繰り返し回数です。

`N`  
複数ファイルのVCファイルセットのログを表示している場合は、次のファイルのログに移動します。数引数は繰り返し回数です。

`a`  
カレント行のリビジョンに注釈を付けます([Old Revisions](#Old-Revisions)を参照してください)。

`e`  
ポイント位置に表示された変更コメントを修正します。すべてのバージョンコントロールシステムが、変更コメントの修正をサポートするわけではないことに注意してください。

`f`  
カレント行に示されたリビジョンをvisitします。

`d`  
ポイント位置のリビジョンと、次に古いリビジョンとの間で、特定のファイルにたいするdiffを表示します。

`D`  
ポイント位置のリビジョンと、次に古いリビジョンとの間で、変更セットのdiffを表示します。これは、そのリビジョンですべてのファイルにたいして行われた変更を表示します。

`RET`  
簡略形式のlogバッファー(たとえば`C-x v
L`で作成されたバッファー)で、ポイント位置のログエントリーにたいして、完全なログエントリーの表示・非表示を切り替えます。

vc-log-show-limit
多くのログエントリーを取得するには時間がかかるので、`*vc-change-log*`バッファーは、デフォルトで2000を超えるリビジョンは表示しません。変数`vc-log-show-limit`はこの制限を指定します。この値を0にセットすると、制限が削除されます。既存の`*vc-change-log*`で、バッファーの最後のボタン‘`Show
2X entries`’または‘`Show unlimited
entries`’をクリックして、表示するリビジョン数を増やすこともできます。しかしRCS、SCCS、CVS、SRCはこの機能をサポートしません。

C-x v h
vc-region-history
変更を確認する有用な変種は、コマンド`vc-region-history` (デフォルトでは`C-x v
h`にバインド)により提供され、これはカレントファイルのポイントとマーク([Mark](#Mark)を参照してください)の間にあるリージョンの変更履歴を、`*VC-history*`バッファーに表示します。変更履歴にはコミットログメッセージ(commit log messages)と、その変更自体のDiff形式も含まれます。

カレントファイルの興味がある変更にたいしてリージョンをマークした後に、このコマンドを呼び出します。このコマンドがポップアップする`*VC-history*`バッファーでは、上述した`*vc-change-log*`バッファーで利用可能なコマンドすべてと、Diffモード([Diff Mode](#Diff-Mode)を参照してください)で定義されたコマンドも使用できます。

このコマンドは現在のところGitだけで利用可能です。

### バージョンコントロール操作のアンドゥ

`C-x v u`  
カレントVCファイルセットの作業ファイルを、最後のリビジョンにリバートします(`vc-revert`)。

C-x v u
vc-revert
vc-revert-show-diff
カレントVCファイルセットにたいするすべての変更を破棄したい場合、`C-x v u` (`vc-revert`)とタイプします。これは作業ファイルと、編集を開始したときのリビジョンのdiffを表示して、変更を破棄するか確認を求めます。これに同意するとファイルセットはリバートされます。`C-x
v
u`でdiffを表示させたくない場合は、変数`vc-revert-show-diff`に`nil`をセットします(この設定をしても`C-x
v =`で直接diffを表示できます。[Old Revisions](#Old-Revisions)を参照してください)。`C-x v
u`は通常のアンドゥコマンドでは戻せないので、注意して使用してください([Undo](#Undo)を参照してください)。

ロックベースのバージョンコントロールシステムでは、`C-x v
u`はファイルをロックしないまま残します。編集を再開するには、再度ロックしなければなりません。ファイルをロックしてから、やはりそれを変更しないと決めたときも、`C-x
v u`でファイルのロックを開放できます。

### バージョンコントロールファイルを無視する

`C-x v G`  
カレントのバージョンコントロールシステム配下のファイルを無視します(`vc-ignore`)。

C-x v G
vc-ignore
ソースツリーの多くは、エディターのバックアップや、オブジェクトファイル、バイトコードファイル、ビルドされるプログラムなどの、バージョン管理する必要のないファイルを含みます。これらは単に追加しないだけでも構いませんが、常に不明なファイルとして現れるでしょう。ツリーのトップの、無視するファイルのリストにこれらのファイルを追加して、それらを無視するようにバージョンコントロールシステムに指示することもできます。これを行うには`C-x
v G` (`vc-ignore`)が助けとなるでしょう。プレフィクス引数を指定すると、無視するファイルリストからファイルを削除できます。

### VC Directoryモード

VC Directory buffer
VC Directoryバッファーは、ディレクトリーツリーにあるファイルのバージョンコントロール状態を見て、それらのファイルにバージョンコントロール操作を実行するために特化したバッファーです。特に複数ファイルのVCファイルセットにたいして、`C-x
v v`のようなコマンドを適用するのに使用されます([VC Directory Commands](#VC-Directory-Commands)を参照してください)。

C-x v d
vc-dir
VC Directoryバッファーを使用するには、`C-x v d` (`vc-dir`)とタイプします。これはミニバッファーを使用してディレクトリーの名前を読み取り、そのディレクトリーにたいするVC Directoryバッファーに切り替えます。デフォルトでは、バッファーの名前は`*vc-dir*`です。その内容については、 [VC Directory Buffer](#VC-Directory-Buffer)で説明します。

`vc-dir`コマンドは、指定したディレクトリーで使用されているバージョンコントロールシステムを自動的に検知します。そのディレクトリーにたいして複数のバージョンコントロールシステムが使用されている場合、`C-u
C-x v d`のようにプレフィクス引数を指定して、このコマンドを呼び出す必要があるでしょう。これはVC Directoryバッファーが使用すべきバージョンコントロールシステムの入力を求めます。

PCL-CVS
cvs
CVS directory mode
VC Directoryバッファーに加えて、EmacsにはCVSに特化したPCL-CVSと呼ばれる似た機能があります。section “About PCL-CVS” in PCL-CVS—The Emacs Front-End to CVSを参照してください。

#### VC Directoryバッファー

VC Directoryバッファーは、バージョンコントロールされたファイルと、それらのバージョンコントロール状態を含みます。これは、(`C-x
v
d`を呼び出すことにより指定される)カレントディレクトリーの、注目すべき状態のファイルとサブディレクトリーをだけリストします。最新のファイル(リポジトリーのものと同じ)は省略されます。サブディレクトリーのファイルがすべて最新の場合、そのサブディレクトリーもリストされません。例外として、VCコマンドの直接の結果として最新になったファイルはリストされます。

以下はVC Directoryバッファーのリストの例です:

                         ./
        edited           configure.ac
    *   added            README
        unregistered     temp.txt
                         src/
    *   edited           src/main.c

2つの作業ファイル、カレントディレクトリーの`configure.ac`と、サブディレクトリー`src/`の`main.c`は、変更されていますがコミットされていません。`README`という名前のファイルは追加されましたが、まだコミットされていません。そして`temp.txt`はバージョンコントロールの配下にありません([Registering](#Registering)を参照してください)。

エントリー`README`および`src/main.c`の隣の‘`*`’という文字は、ユーザーがそれらのファイルをカレントVCファイルセットとしてマークしたことを示します ([VC Directory Commands](#VC-Directory-Commands)を参照してください)。

上記は、Bazaar、Git、Mercurialのような分散型のバージョンコントロールシステムでの典型的な例です。他のシステムでは、他の状態も見られます。たとえばCVSは、リポジトリーが変更されていて、それがまだ作業ファイルに適用されていないときは、‘`needs-update`’という状態を表示します。RCSとSCCSは、ロックされているファイルの状態に、ロックしているユーザーの名前を表示します。

CVSでは通常、`vc-dir`コマンドは更新のチェックのために、おそらくはリモートマシン上にあるであろうリポジトリーにアクセスします。変数`vc-cvs-stay-local`を`nil` ([CVS Options](#CVS-Options)を参照)に変更すると、EmacsはVC Directoryバッファーが生成されるときのリモートのリポジトリーへのアクセスを避けます(コミットを行うときなど、必要なときはアクセスします)。これは、オフラインで作業していたり、ネットワークが遅いときは望ましいでしょう。

vc-directory-exclusion-list
VC Directoryバッファーは、変数`vc-directory-exclusion-list`にリストされているサブディレクトリーを省略します。この変数のデフォルト値には、バージョンコントロールシステムにより内部的に使用されるディレクトリーが含まれています。

#### VC Directoryコマンド

EmacsはVC Directoryバッファーの操作と、カレントVCファイルセットに属させるために、ファイルをマークするためのコマンドをいくつか提供します。

`n`; `SPC`  
次のエントリーにポイントを移動します(`vc-dir-next-line`)。

`p`  
前のエントリーにポイントを移動します(`vc-dir-previous-line`)。

`TAB`  
次のディレクトリーエントリーに移動します(`vc-dir-next-directory`)。

`S-TAB`  
前のディレクトリーエントリーに移動します(`vc-dir-previous-directory`)。

`RET`; `f`  
カレント行にリストされたファイル、またはディレクトリーをvisitします(`vc-dir-find-file`)。

`o`  
カレント行にリストされたファイル、またはディレクトリーを別のウィンドウでvisitします(`vc-dir-find-file-other-window`)。

`m`  
カレント行のファイルまたはディレクトリーをマークして、それをカレントVCファイルセットに加えます(`vc-dir-mark`)。リージョンがアクティブのときは、リージョンの中のすべてのファイルをマークします。

すでにマークされたディレクトリーの中のファイル、またはそのサブディレクトリーは、このコマンドではマークされません。同様に、ツリーの中のいくつかのファイルがマークされているディレクトリーは、このコマンドではマークされません。

`M`  
ポイントがファイルエントリーにあるときは、同じ状態のすべてのファイルをマークします。ポイントがディレクトリーエントリーにあるときは、そのディレクトリーツリーのすべてのファイルをマークします(`vc-dir-mark-all-files`)。プレフィクス引数を指定した場合、リストされたファイルとディレクトリーのすべてをマークします。

`q`  
VC Directoryバッファーを終了して、隠します(`quit-window`)。

`u`  
カレント行のファイル、またはディレクトリーのマークを外します(`vc-dir-unmark`)。リージョンがアクティブのときは、リージョンの中のすべてのファイルのマークを外します。

`U`  
ポイントがファイルエントリーにあるときは。同じ状態のすべてのファイルのマークを外し、ポイントがディレクトリーエントリーにあるときは、そのディレクトリーツリーのすべてのファイルのマークを外します(`vc-dir-unmark-all-files`)。プレフィクス引数を指定した場合、すべてのファイルおよびディレクトリーのマークを外します。

`x`  
状態が‘`up-to-date`’、または‘`ignored`’のファイルを隠します(`vc-dir-hide-up-to-date`)。プレフィクス引数を指定した場合、状態がポイント位置のアイテムと同じアイテムを隠します。

vc-dir-mark
vc-dir-mark-all-files
VC Directoryバッファーでは、`m` (`vc-dir-mark`)または`M` (`vc-dir-mark-all-files`)でマークしたすべてのファイルが、カレントVCファイルセットになります。ディレクトリーエントリーを`m`でマークした場合、そのディレクトリーツリーにリストされたすべてのファイルが、カレントVCファイルセットになります。カレントVCファイルセットに属するファイルとディレクトリーは、VC Directoryではバージョンコントロール状態の隣に、文字‘`*`’が示されます。この方法により`C-x v v` ([Basic VC Editing](#Basic-VC-Editing)を参照してください)、`C-x v =` ([Old Revisions](#Old-Revisions)を参照してください)、`C-x v u` ([VC Undo](#VC-Undo)を参照してください)のようなVCコマンドが作用する、複数ファイルのVCファイルセットをセットアップできます。

VC Directoryバッファーは、`C-x
v`というプレフィクスをもつコマンドを、1キーで入力するショートカット(`=`、`+`、`l`、`i`、`D`、`L`、`G`、`I`、`O`、`v`)を定義します。

たとえば、VC Directoryバッファーで開いて編集された一連のファイルは、‘`edited`’という状態でリストされ、それらのファイルをマークして、`v`または`C-x
v v` (`vc-next-action`)でコミットできます。バージョンコントロールシステムが変更セットベースの場合、Emacsはそれらのファイルを1つのリビジョンとしてコミットします。

VC Directoryバッファーでは、以下のコマンドによりカレントVCファイルセットの検索と置換を処理することもできます:

`S`  
ファイルセットを検索します(`vc-dir-search`)。

`Q`  
ファイルセットにたいして、正規表現による問い合わせ置換を行います(`vc-dir-query-replace-regexp`)。

`M-s a C-s`  
ファイルセットにたいして、インクリメンタル検索を行います(`vc-dir-isearch`)。

`M-s a C-M-s`  
ファイルセットにたいして、インクリメンタルな正規表現検索を行います(`vc-dir-isearch-regexp`)。

複数ファイルに作用する点を除けば、これらのコマンドは1つのバッファーに作用する同等のコマンドに似ています([Search](#Search)を参照してください)。

VC Directoryバッファーは、追加でブランチ関連のコマンドを定義し、それらはプレフィックス`B`で始まります:

`B c`  
新たなブランチを作成します(`vc-create-tag`)。

`B l`  
ブランチ名の入力を求め、そのブランチの変更履歴を表示します(`vc-print-branch-log`)。

`B s`  
ブランチを切り替えます(`vc-retrieve-tag`)。[Switching Branches](#Switching-Branches)を参照してください。

stashes in version control
shelves in version control
上記のコマンドは、メニューバーおよび`mouse-2`によるコンテキストメニューを通じても利用可能です。さらにVCのバックエンドのいくつかは、そのバックエンド特有のコマンドを提供するメニューを使用します。たとえばGitとBazaarでは、stashes(隠してあるもの)とshelves(棚)(コミットされていない変更を一時的に除外して、後でそれを戻すコマンド)を操作できます。

### バージョンコントロールのブランチ

branch (version control)
バージョンコントロールの活用法の1つとして、ブランチ(branches)と呼ばれる複数の独立した開発ラインのサポートがあります。中でもとりわけブランチは、プログラムの安定版(stable)と開発版(development)を個別に保守したり、関係のない機能を他の版から隔離して開発するのに使用されます。

現在のところVCのブランチ操作にたいするサポートは、かなり制限されています。分散型のバージョンコントロールシステムにたいしては、あるブランチを他のブランチのコンテンツで更新するコマンドと、2つの異なるブランチの変更をマージするコマンドを提供します。集中型のバージョンコントロールシステムにたいしては、異なるブランチからチェックアウトして、新規または異なるブランチにコミットするコマンドを提供します。

#### ブランチ間の切り替え

さまざまなバージョンコントロールシステムにおいて、ブランチが実装される方法は異なり、VCはこれらの違いを完全に隠蔽することはできません。

BazaarとMercurialを含む分散型バージョンコントロールシステムのいくつかは、ノーマルモードの操作では、各ブランチは自身の作業ディレクトリーツリーをもつので、ブランチの切り替えは単にディレクトリーを切り替えるだけです。Gitでは、ブランチは通常、同じディレクトリーの共通ロケーション(co-located)を使用し、ブランチの切り替えは、作業ツリーの内容をそのブランチに一致するように変更する、`git
checkout`を使用して行われます。Bazaarも共通ロケーションをサポートし、この場合は`bzr
switch`コマンドによりカレントディレクトリーでブランチを切り替えます。Subversionでは他のブランチに切り替えるのに、`svn
switch`コマンドを使用します。

カレントディレクトリーの他のブランチに切り替えるVCコマンドは、`C-x v r branch-name RET` (`vc-retrieve-tag`)です。

集中型のバージョンコントロールシステムでは、最新の作業ファイルで`C-u C-x v v`とタイプして([Advanced C-x v v](#Advanced-C_002dx-v-v)を参照してください)、他のブランチのリビジョンIDを入力することにより、ブランチ間を切り替えることもできます。たとえばCVSでは、trunk(幹の意。開発の主要ラインを示します)のリビジョンは通常、1.1、1.2、1.3、…という形式をもち、最初のブランチがリビジョン1.2から作成された場合、リビジョン1.2は1.2.1.1、1.2.1.2、…というリビジョンIDをもち、さらに2番目のブランチが同じくリビジョン1.2から作成された場合、それは1.2.2.1、1.2.2.2、…という形式になります。ブランチのリビジョンIDから最後の部分を除いた(たとえば1.2.1)、ブランチID(branch ID)を指定して、そのブランチの最新のリビジョンに切り替えることもできます。

ロックベースのシステムでは、他のブランチに切り替えることにより、作業ツリーのロックが解除(書き込み禁止)になります。

1度ブランチを切り替えると、そのブランチを他に切り替えるまで、VCコマンドはそのブランチに適用されます。たとえば任意のVCファイルセットをコミットすると、そのブランチにコミットされるようになります。

#### ブランチへ/からの変更のpull/push

`C-x v P`  
分散型のバージョンコントロールシステムでは、カレントブランチからの変更により、その変更で他のロケーションを更新(変更を“push”する、とも言います)します。この概念は集中型のバージョンコントロールシステムには存在しません。

`C-x v +`  
分散型のバージョンコントロールシステムでは、他のロケーションから変更を“pull”することにより、カレントのブランチを更新します。

集中型のバージョンコントロールシステムでは、カレントVCファイルセットを更新します。

C-x v P
vc-push
分散型のバージョンコントロールシステムでは、コマンド`C-x v P` (`vc-push`)は、カレントブランチからの変更により他のロケーションを更新します。プレフィクス引数を与えた場合、このコマンドは実行する正確なバージョンコントロールコマンドの入力をもとめます。これにより変更をどこにpushするか指定できます。デフォルトは、Bazaarでは`bzr
push`、Gitでは`git push`、Mercurialでは`hg
push`です。デフォルトのコマンドは常に、ブランチ設定からバージョンコントロールシステムにより決定されるデフォルトのロケーションにpushします。

pullする前に`C-x v O` (`vc-log-outgoing`)を使用して、送信される変更のlogバッファーを閲覧できます。[VC Change Log](#VC-Change-Log)を参照してください。

bound branch (Bazaar VCS)
現在のところ、このコマンドはBazaar、Git、Mercurialだけでサポートされます。“push”という概念は集中型のバージョンコントロールシステムには存在しません。なぜなら、この操作は変更セットのコミットの一部なので、集中型のVCSでこのコマンドを呼び出すと、エラーをシグナルします。Bazaarのbound branchでこのコマンドを試みたときもエラーをシグナルします。変更セットのコミットは、自動的に変更を(ローカルのブランチがバインドされている)リモートのリポジトリーにpushするからです。

C-x v +
vc-pull
分散型のバージョンコントロールシステムでは、コマンド`C-x v +` (`vc-pull`)は、カレントブランチと作業ツリーを更新します。これは通常、リモートのブランチのコピーを更新するのに使用されます。プレフィクス引数を与えた場合、このコマンドは使用する正確なバージョンコントロールコマンドの入力をもとめます。これにより変更をどこからpullするか指定できます。プレフィクス引数を指定しない場合は、バージョンコントロールシステムにより決定される、デフォルトのロケーションからpullします。

分散型のバージョンコントロールシステムの中で、現在`C-x v
+`がサポートするのはBazaar、Git、Mercurialだけです。Bazaarでは、これは通常のブランチにたいしては、(マスターブランチをミラーリングされたブランチにpullするために)`bzr
pull`を呼び出し、バインドされたブランチにたいしては、(中心となるリポジトリーからpullするために)`bzr
update`を呼び出します。Gitでは、これはリモートのリポジトリーから変更を取得して、それをカレントブランチにマージするために、`git
pull`を呼び出します。Mercurialでは、デフォルトのリモートリポジトリーから変更を取得して、作業ディレクトリーを更新するために`hg
pull -u`を呼び出します。

pullする前に`C-x v I` (`vc-log-incoming`)を使用して、適用される変更のlogバッファーを閲覧できます。[VC Change Log](#VC-Change-Log)を参照してください。

CVSのような集中型のバージョンコントロールシステムでは、`C-x v +`はリポジトリーからカレントVCファイルセットを更新します。

#### ブランチのマージ

merging changes
`C-x v m`  
分散型のバージョンコントロールシステムでは、カレントのブランチに他のブランチの変更をマージします。

集中型のバージョンコントロールシステムでは、カレントVCファイルセットに他のブランチの変更をマージします。

ブランチで開発している場合、すでに他のブランチで行われた変更をマージ(merge)する必要があるときがあります。これは2つのブランチでの変更が重なる場合もあるため、些細な操作とはいえません。

分散型のバージョンコントロールシステムでは、マージはコマンド`C-x v m` (`vc-merge`)により行われます。Bazaarでは、これは`bzr
merge`に渡す正確な引数の入力を求めます。そのとき、可能であれば目的にかなったデフォルトを提示します。Gitでは、これはマージするブランチ名の入力を求めます。このとき、(カレントリポジトリーが知っているブランチ名にもとづく)補完を行います。マージコマンドの実行による出力は、他のバッファーに表示されます。

CVSのような集中型のバージョンコントロールシステムでは、`C-x v
m`はブランチID、または2つのリビジョンIDの入力を求めます。コマンドはそのブランチからの変更点、または指定した2つのリビジョン間の差分を探して、それらの変更をカレントVCファイルセットにマージします。`RET`だけをタイプした場合、Emacsは単にそのファイルをチェックアウトしたブランチに行われた変更をマージします。

conflicts
resolving conflicts
マージを処理した直後は、作業ツリーだけが変更されており、`C-x v
D`および関連するコマンドで、マージにより生成された変更をレビューできます([Old Revisions](#Old-Revisions)を参照してください)。2つのブランチが重なった変更をもつ場合、マージは衝突(conflict)を生成します。その場合、マージコマンドの出力には警告が現れ。影響のある作業ファイルの、衝突する2つの変更の周囲に、衝突マーカー(conflict markers)が挿入されます。衝突を解決するには、衝突するファイルを編集しなければなりません。編集が終わったら、マージが効果を発揮するように、通常の方法により変更したファイルをコミットしなければなりません([Basic VC Editing](#Basic-VC-Editing)を参照してください)。

#### 新しいブランチの作成

CVSのような集中型のバージョンコントロールシステムでは、Emacsはコミット操作の一部として、新しいブランチの作成をサポートします。変更されたVCファイルセットをコミットするとき、`C-u
C-x v v` (`vc-next-action`のようにプレフィクス引数を指定します。[Advanced C-x v v](#Advanced-C_002dx-v-v)を参照してください).すると、Emacsは新しいリビジョンのリビジョンIDの入力を求めます。ここでカレントリビジョンから開始するブランチの。適切なブランチIDを指定する必要があります。たとえば、カレントリビジョンIDが2.5の場合、ブランチIDは2.5.1、2.5.2、...となるべきでしょう。ブランチIDは、その時点での既存のブランチの番号に依存します。

(すでにブランチのヘッドではない)古いリビジョンに新しいブランチを作成するには、最初にそのリビジョンを選択します([Switching Branches](#Switching-Branches)を参照してください)。その後の手順は、ロックベースのバージョンコントロールシステムを使っているか、マージベースのものを使っているかで異なります。

ロックベースのバージョンコントロールシステムでは、`C-x v
v`で古いリビジョンのブランチを選択します。古いリビジョンを選択する場合、本当に新しいブランチを作成したいのか確認を求めます。これにnoと応えた場合、かわりに最新のリビジョンをロックする機会が与えられます。マージベースのバージョンコントロールシステムでは、このステップはスキップします。

変更を行なってから、再び`C-x v
v`とタイプして、新しいリビジョンをコミットします。これは選択されたリビジョンから始まる、新しいブランチを作成します。

ブランチが作成された後は、それ以降のコミットは、そのブランチに新しいリビジョンを作成します。ブランチを離れるには、`C-u C-x v
v`で明示的に異なるリビジョンを選択しなければなりません。

### VCのその他のコマンドと機能

このセクションでは、それほど頻繁には使用されないVCの機能を説明します。

#### 変更ログとVC

`ChangeLog`ファイル ([Change Log](#Change-Log)を参照してください)をもつプロググラムにたいしてRCSやCVSを使用する場合、 バージョンコントロールの以前のコミットのログエントリーから、ChangeLogのエントリーを生成することができます。

これはRCSとCVSだけで機能することに注意してください。この手段は特に、現代的な変更セットベースのバージョンコントロールシステムには不適切です。なぜなら、`ChangeLog`ファイルへの変更自体が、通常は変更セットの一部としてコミットされるからです。この場合、最初にChangeLogエントリーを記述して、コミットするときにそれを‘`*vc-log*`’バッファーに引用します ([Log Buffer](#Log-Buffer)を参照してください)。

`C-x v a`  
C-x v a

vc-update-change-log

カレントディレクトリーの`ChangeLog`ファイルをvisitして、そのディレクトリーの登録されたファイルにたいして、最新のChangeLogエントリー以降にコミットされたバージョンにたいする、新しいエントリーを作成します。(`vc-update-change-log`)。

`C-u C-x v a`  
上記と同様ですが、カレントバッファーのファイルにたいするエントリーだけを探します。

たとえば、`ChangeLog`の最初の行の日付が1999-04-10で、それ以降のチェックインは1999-05-22のNathaniel Bowditchによる`rcs2log`だけで、それのログエントリーが‘`Ignore log messages that start
with '#'.`’だったとします。その場合、`C-x v a`は`ChangeLog`エントリーとして、以下を挿入します:

    1999-05-22  Nathaniel Bowditch  <nat@apn.org>

            * rcs2log: Ignore log messages that start with '#'.

バージョンコントロールのログエントリーが、(行頭にカッコで括られて記述される)関数名を指定する場合、それは`ChangeLog`のエントリーに反映されます。たとえば`vc.el`にたいするログエントリーが‘`(vc-do-command):
Check call-process status.`’の場合、`ChangeLog`のエントリーは以下のようになります:

    1999-05-06  Nathaniel Bowditch  <nat@apn.org>

            * vc.el (vc-do-command): Check call-process status.

`C-x v
a`が複数のChangeLogエントリーを1度に追加するとき、それらがすべて同じ作者に、ほぼ同じ日時にチェックインされている場合、関連するログエントリーとしてそれらをグループ化します。複数のファイルにたいするログエントリーがすべての同じテキストの場合、それらを1つのエントリーにまとめます。

#### バージョンコントロールされたファイルの削除とリネーム

renaming version-controlled files
`M-x vc-delete-file`  
ファイル名の入力を求め、そのファイルを作業ツリーから削除して、コミット時に削除するようスケジュールします。

`M-x vc-rename-file`  
2つのファイル名oldおよびnewの入力を求め、作業ツリーのファイルをリネームし、コミット時にリネームを行うようスケジュールします。カレントバッファーのファイルがVC配下にある場合は、そのファイルがoldのデフォルトファイルになります。

vc-delete-file
バージョンコントロールされたファイルを削除したい場合、コマンド`M-x
vc-delete-file`を使用します。これはファイル名の入力を求め、バージョンコントロールシステムを通じてそれを削除します。ファイルは作業ツリーから削除され、VC Directoryバッファー ([VC Directory Mode](#VC-Directory-Mode)を参照してください) では、状態に‘`removed`’が表示されます。それをコミットするとき、リポジトリー内で削除が実行されます。

vc-rename-file
バージョンコントロールされたファイルをリネームするには、`M-x
vc-rename-file`とタイプします。これは2つの引数の入力を求めます。それはリネームしたいファイルの名前を、それの新しい名前です。そしてバージョンコントロールシステムを通じてリネームを処理します。作業ツリーではリネームは即座に行われます。リネームされたファイルをコミットするとき、リポジトリーに反映されます。

現代的なバージョンコントロールシステムは、リネームにたいするビルトインのサポートがあり、リネームされたファイルは元のファイルのすべての変更履歴を保持します。CVSおよび古いバージョンコントロールシステムでは、`vc-rename-file`コマンドは、実際には古いファイルを新しい名前にコピーして、それを登録してから古いファイルを削除することにより機能します。この場合、変更履歴は保存されません。

#### リビジョンタグ

revision tag
tags for version control
ほとんどのバージョンコントロールシステムは、バージョンコントロールされたツリーの特定のバージョンにたいして、リビジョンタグ(revision tag)を適用できます。現代的な変更セットベースのバージョンコントロールシステムでは、リビジョンタグは単に特定のリビジョンにたいするシンボリック名です。CVSのようなファイルベースの古いシステムで、各タグははバージョンコントロールされた一連のファイル全体に追加され、それらを1つの単位として処理できるようにします。リビジョンタグは一般的にユーザーに配布されるリリースを識別するのに使用されます。

タグにたいする2つの基本的なコマンドがあります。1つは与えられた名前でタグを作成し、もう1つは名前がつけられたタグを取得するコマンドです。

`C-x v s name RET`  
カレントディレクトリーまたはその配下のディレクトリーの、すべての登録されたファイルの作業リビジョンにたいする、nameという名前のタグを定義します(`vc-create-tag`)。

C-x v r

vc-retrieve-tag

`C-x v r name RET`  
カレントディレクトリーまたはその配下のディレクトリーの、すべての登録されたファイルにたいして、リビジョンのタグがnameのものを取得します。nameがブランチ名で、バージョンコントロールシステムがタグからブランチを区別する場合、このコマンドはブランチを切り替えます。(`vc-retrieve-tag`).

カレントディレクトリーまたは配下のディレクトリーのファイルがロックされている場合、このコマンドは何もせずにエラーを報告します。これは作業中の上書きを避けるためです。

`C-x v =`または`C-x v ~`の引数として、タグまたはブランチ名を与えることができます ([Old Revisions](#Old-Revisions)を参照してください)。 したがって、カレントファイルとタグ付けされたバージョンを比較したり、タグ付けされたバージョン同士を比較することができます。

SCCSでは、VC自身がタグを実装しているので、VCを通じてのみタグを見ることができます。それより新しいほとんどのシステム(CVS、Subversion、bzr、git、hgを含む)は、ネイティブのタグ機能をもっており、利用可能な場合、VCはそれを使用します。これらのタグは、VCを通さなくても見ることができます。

ファイルベースのバージョンコントロールシステムでは、登録されたファイルをリネームするとき、それのマスターもリネームする必要があります。コマンド`vc-rename-file`は、これを自動的に行います ([VC Delete/Rename](#VC-Delete_002fRename)を参照してください)。 SCCSを使用している場合、、そのファイルが新しい名前になったことを告げるために、タグの記録も更新しなければなりません(`vc-rename-file`もこれを行います)。記録された名前では、すでに存在しないマスターファイルを参照する古いタグは無効になります。VCはそれを取得しません。RCSおよびSCCSでのタグの手修正は、このマニュアルの範囲を超えるでしょう。`vc-rename-file`を使用することにより、ファイルを取得できる有効なタグを作成できますが、それですべての問題が解決されるわけではありません。たとえば、プログラムのいくつかのファイルは、他のファイルを名前で参照するかもしれません。少なくともmakefileはリネームしたファイルを参照するでしょう。古いタグを取得した場合、リネームされたファイルは、makefileが期待しない新しい名前で取得されます。そのため、プログラムはうまく機能しないでしょう。

#### バージョンコントロールヘッダーの挿入

Subversion、CVS、RCS、SCCSでは、バージョンヘッダー(version headers)と呼ばれる文字列を、ファイル内に置くことができます。そのファイルがコミットされたとき、バージョンコントロールシステムは自動的にリビジョン番号、コミットしたユーザーの名前、その他関連する情報をバージョンヘッダーに挿入します。

vc-consult-headers
VCは通常、バージョンヘッダーの情報を使用しません。例外として、RCSを使用している場合、EmacsはRCSのマスターファイルより信頼できる場合が多いという理由で、ファイルのバージョンを決定するためにバージョンヘッダーを使用します。この方法でバージョンヘッダーを使用するのを禁ずるには、変数`vc-consult-headers`を`nil`に変更します。その場合、VCは常に(それが信用できると推測されれば)ファイルパーミッションを使用し、それ以外はマスターファイルをチェックします。

vc-insert-headers
vc-
backend
-header
カレントバッファーに適切なヘッダー文字列を挿入するには、コマンド`M-x
vc-insert-headers`を使用します。このコマンドはSubversion、CVS、RCS、SCCSだけで機能します。変数`vc-backend-header`には、バージョンヘッダーに挿入されるキーワードのリストが含まれます。たとえばCVSは`vc-cvs-header`を使用し、これのデフォルト値は`'("\$Id\$")`です(余分なバックスラッシュは、もしEmacs Lispファイルがバージョンコントロールにより保守されるときに、文字列定数がヘッダーと解釈されるのを防ぐためのものです)。`vc-insert-headers`コマンドは。ポイント位置の新しい行にリストのタブで囲まれた各キーワードを挿入し、必要ならばコメント区切りで囲みます。

vc-static-header-alist
変数`vc-static-header-alist`は、バッファー名にもとづき追加する文字列を指定します。これの値は、`(regexp
.
format)`という形式の要素からなるリストです。regexpがバッファー名にマッチした場合、バージョンヘッダーの一部としてformatも挿入されます。formatの中の‘`%s`’は、そのファイルのバージョンコントロールのタイプに置換されます。

### VCのカスタマイズ

vc-handled-backends
変数`vc-handled-backends`は、どのバージョンコントロールシステムが処理するかを決定します。デフォルト値は`(RCS
CVS SVN SCCS SRC Bzr Git Hg Mtn
Arch)`で、これには、現在サポートされている、すべてのバージョンコントロールが含まれています。VCにこれらのシステムの1つ以上を無視させたい場合、リストからそのシステムの名前を除外します。VC全体を無効にするには、変数に`nil`をセットしてください。

リストのシステム順序には意味があります。これらのシステムの1つ以上に登録されているファイルをvisitした場合、デフォルトではVCは`vc-handled-backends`で最初にくるシステムを使用します。ファイルを最初に登録するときも、この順序が意味をもちます ([Registering](#Registering)を参照してください)。

#### 一般的なオプション

vc-make-backup-files
Emacsは通常、バージョンコントロールにより保守されるソースファイルのバックアップファイルを保存しません。バージョンコントロールを使用したファイルにもバックアップファイルを作成したいときは、変数`vc-make-backup-files`に非`nil`値をセットしてください。

vc-follow-symlinks
symbolic links (and version control)
そのファイルがバージョンコントロールされていると知らずに、シンボリックリンクを通じてバージョンコントロールされたファイルを編集すると、予期せぬ結果を招くことがあります。変数`vc-follow-symlinks`は、バージョンコントロールされたファイルを指すシンボリックリンクをvisitしようと試みたときの、Emacsの振る舞いを制御します。値が`ask`(デフォルト)の場合、Emacsは確認を求めます。値が`nil`の場合、Emacsは警告メッセージを表示するだけです。値が`t`の場合、Emacsは自動的にリンクをたどって、かわりに実際のファイルをvisitします。

vc-suppress-confirm
`vc-suppress-confirm`が非`nil`の場合、`C-x v v`および`C-x v
i`は確認を求めずにカレントバッファーを保存し、`C-x v u`も確認を求めず処理を行います。

vc-command-messages
VCモードは多くの処理を、バージョンコントロールシステムにたいする適切なシェルコマンドを実行することにより行います。`vc-command-messages`が非`nil`の場合、VCはそれが実行するシェルコマンドを示すメッセージと、コマンドが終了したときの追加のメッセージを表示します。

#### RCSとSCCSにたいするオプション

non-strict locking (RCS)
locking, non-strict (RCS)
デフォルトでは、複数ユーザーの活動を調停するためにRCSはロックを使用しますが、最初にファイルをロックしなくても変更をチェックインできる、厳密でないロック(non-strict locking)と呼ばれるモードもあります。特定のファイルにたいして厳密でないロックに切り替えるには、‘`rcs
-U`’を使用します。詳細については、`rcs`のman-pageを参照してください。

RCSファイルのバージョンコントロール状態を推論するとき、VCは最初にそのファイルのRCSバージョンヘッダー文字列を調べます([Version Headers](#Version-Headers)を参照してください)。ヘッダー文字列がない場合、VCは通常、作業ファイルのパーミッションを調べます。これは速い処理です。ファイルのパーミッションが信頼できない状況もあるかもしれません。そのような場合はマスターファイルが調べられます。これはより高価な処理です。マスターファイルから判るのは、*もし*そのファイルにたいして何らかのロックがある場合、作業ファイルが実際にロックされたバージョンを含むかどうか、だけです。

`vc-consult-headers`を`nil`にセットすることにより、VCがファイル状態を決定するのにバージョンヘッダーを使用しないように指定できます。その場合、VCは常に、(それが信用できると思われる場合は)ファイルのパーミッションを使うか、マスターファイルをチェックします。

VCがSCCSの配下にあるファイルのバージョンコントロール状態を決定する方法は、RCSとほぼ同じです。しかしSCCSのバージョンヘッダーは考慮しません。したがって、`vc-consult-headers`はSCCSの使用に影響しません。

#### CVSに特有のオプション

vc-cvs-global-switches
変数`vc-cvs-global-switches`で、すべてのCVS操作に渡す追加のコマンドラインオプションを指定できます。これらのスイッチは`cvs`コマンドの直後、呼び出す操作名の前に挿入されます。

vc-cvs-stay-local
remote repositories (CVS)
リモートマシン上でCVSリポジトリを使用する際は、ネットワーク通信を最小に維持するようVCに試行させることができます。これは、変数`vc-cvs-stay-local`により制御されます。`vc-cvs-stay-local`が`only-file`(デフォルト)の場合、VCはローカルのCVSサブディレクトリーのエントリーと、前のCVSコマンドから戻された情報だけを使って、各ファイルのバージョンコントロール状態を決定します。結果として、あなたがファイルを変更しているとき、他の誰かが他の変更をチェックインした場合、それのコミットを試みるまで衝突は通知されません。

`vc-cvs-stay-local`を`nil`に変更した場合、ローカルのリポジトリーと同じように、`vc-next-action` (`C-x v v`)が何を行うか決定する*前*に、VCはリモートのリポジトリーに問い合わせを行います。

`vc-cvs-stay-local`に、リポジトリーのあるホスト名にマッチする正規表現を指定することもできます。この場合、ホスト名がパターンにマッチしたときは、VCはローカルに留まります。

automatic version backups
リモートのリポジトリーを使用する場合、Emacsは通常、編集された各ファイルのオリジナルバージョンである、自動バージョンバックアップ(automatic version backups)を作成します。これらのローカルのバックアップは、変更を最初にファイルに保存したときに作成され、リポジトリーに変更をコミットした後で削除されます(これらは通常のEmacsのバックアップファイルとは異なることに注意してください。 [Backup](#Backup)を参照してください)。 `C-x v =`や`C-x v
u`のようなコマンドは、ネットワークへのアクセスを避けるため、可能な場合は自動バージョンバックアップを使用します。

`vc-cvs-stay-local`を`nil`にセットすることにより、自動バージョンバックアップの作成を無効にできます。

manual version backups
自動バージョンバックアップは、`file.~version.~`という形式の名前をもちます。これは`C-x
v ~`が古いバージョンを保存するときの名前と似ています ([Old Revisions](#Old-Revisions)を参照してください)。 例外は、バージョンの後ろにある追加のドット(‘`.`’)です。関連するVCコマンドは、これら両方の種類のバージョンバックアップを使用できます。主な違いは、`C-x
v ~`により手動で作成されたバージョンバックアップは、コミットしたとき自動的に削除されないことです。

locking (CVS)
デフォルトでCVSはロックを使用しませんが、CVSREADまたはwatchの機能を使用して、ロックのような振る舞いを有効にする方法があります。詳細については、CVSのドキュメントを参照してください。そのような場合、ロックベースのバージョンコントロールシステムで行うように、Emacsで`C-x
v v`を使用して、ロックを切り替えることができます ([VC With A Locking VCS](#VC-With-A-Locking-VCS)を参照してください)

変更ログ
--------

change log
多くのソフトウェアプロジェクトでは、変更ログ(change log)を管理します。これは通常、いつどのようにして、そのプログラムが変更されたかの日付順の記録を含む、`ChangeLog`という名前のファイルです。これらのファイルは、バージョンコントロールシステムに保存された変更ログエントリーから自動的に生成されたり、それらの変更ログエントリーを自動的に生成するのに使われる場合もあります。複数の変更ログファイルがあり、それぞれが1つのディレクトリー、またはディレクトリーツリーに対応する場合もあります。

### 変更ログコマンド

C-x 4 a
add-change-log-entry-other-window
Emacsコマンド`C-x 4
a`は、編集しているファイルにたいする新しいエントリーを、変更ログファイルに追加します(`add-change-log-entry-other-window`)。そのファイルが実際にはバックアップファイルの場合、このコマンドはそのファイルの元のファイルのエントリーを適切に作成します — これはカレントバージョンから削除された関数のログエントリーを作成するとき便利です。

`C-x 4
a`は変更ログファイルをvisitして、一番最近のエントリーが今日の日付であなたの名前でない場合は、新しいエントリーを作成します。これはカレントファイルにたいする、新しいアイテムも作成します。このコマンドは多くの言語にたいして、変更された関数またはその他のオブジェクトを推測することすらできます。

変更ログファイルを探すために、Emacsは編集中ファイルのディレクトリーからディレクトリー構造を上方に検索します。デフォルトでは、バージョンコントロールディレクトリーのルートと思われるディレクトリーが見つかると、検索はストップします。これを変更するには、`change-log-directory-files`をカスタマイズしてください。

add-log-keep-changes-together
変数`add-log-keep-changes-together`が非`nil`の場合、`C-x 4
a`は新しいアイテムを開始せず、そのファイルにたいする既存のアイテムに追加します。

同じ性質の複数の変更を1つにまとめることができます。最初の`C-x 4 a`の後にテキストを何も入力せずに、続けて`C-x 4
a`をタイプしていくと、他のシンボルが変更ログエントリーに追加されます。

add-log-always-start-new-record
`add-log-always-start-new-record`が非`nil`の場合、最後のエントリーが同じ日付のあなたによる変更だったときでも、`C-x
4 a`は常に新しいエントリーを作成します。

change-log-version-info-enabled
change-log-version-number-regexp-list
file version in change log entries
変数`change-log-version-info-enabled`の値が非`nil`の場合、`C-x 4
a`は、ファイルのバージョン番号を変更ログのエントリーに追加します。これは変数`change-log-version-number-regexp-list`の正規表現を使用して、ファイルの最初の10%から、バージョン番号を探します。

Change Log mode
change-log-mode
変更ログファイルは、Change Logモードでvisitされます。このメジャーモードでは、グループ化されたアイテムの集まりは1つのパラグラフと扱われ。各エントリーはページとみなされます。これはエントリーの編集を容易にします。`C-j`およびauto-fillは、新しい行を前の行と同様にインデントします。これはエントリーの内容を入力するとき便利です。

Change Logモードがオンの場合、`next-error`コマンド(デフォルトでは`` C-x
` ``にバインドされています)を使用して、変更ログのエントリー間を移動することができます。次の変更ログエントリーだけでなく、そのファイルが変更された実際の場所にジャンプすることもあるでしょう。同じリストを戻って移動するのに、`previous-error`を使うこともできます。

change-log-merge
コマンド`M-x change-log-merge`を使用して、他のログファイルを、エントリーの日付順を保持したまま、Change Logモードのバッファーにマージできます。

プログラムの変更を追跡して変更ログを維持する他の方法として、バージョンコントロールシステムがあります。VC logバッファーでは、`C-c
C-a` (`log-edit-insert-changelog`)とタイプすると、変更ログが存在する場合は、関連する変更ログのエントリーを追加します。

### ChangeLogの書式

変更ログエントリーは、現在の日付、名前(変数`add-log-full-name`より取得)、電子メールアドレス(変数`add-log-mailing-address`より取得)を含むヘッダー行から開始されます。ヘッダー行を除いた変更ログの各行は、スペースまたはタブで開始されます。エントリーの大部分は、空白文字とアスタリスクで行が開始される、アイテム(items)から構成されます。以下は2つのアイテムおよび1つのアイテムをもつ、日付が1993年5月の、2つのエントリーの例です。

    1993-05-25  Richard Stallman  <rms@gnu.org>

            * man.el: Rename symbols 'man-*' to 'Man-*'.
            (manual-entry): Make prompt string clearer.

            * simple.el (blink-matching-paren-distance):
            Change default to 12,000.

    1993-05-24  Richard Stallman  <rms@gnu.org>

            * vc.el (minor-mode-map-alist): Don't use it if it's void.
            (vc-cancel-version): Doc fix.

1つのエントリーで複数の変更を記述できます。変更はそれぞれアイテム、またはアイテムの中の行を占めます。アイテムの間には通常、空行があります。アイテムが関連している場合(異なる場所での同じ変更など)、それらの間に空行を置かずにそれらをグループ化します。

変更ログファイルの最後には、著作権表示と使用許諾を配すべきです。以下は例です:

    Copyright 1997, 1998 Free Software Foundation, Inc.
    Copying and distribution of this file, with or without modification, are
    permitted provided the copyright notice and this notice are preserved.

これはもちろん、正しい年と版権所有者に置き換えて使う必要があります。

識別子のリファレンスを探す
--------------------------

xref
識別子(identifier)とは、プログラムの構文的なサブユニットの名前であり、関数(function)、サブルーチン(subroutine)、メソッド(method)、クラス(class)、データ型(data type)、マクロ(macro)などが該当します。プログラミング言語では、識別子はその言語の構文をもつシンボルです。そのプログラムの開発と保守では、プロジェクト全体を横断して識別子をリネームする等から、識別子がどこで定義されているか(defined)、どこから参照されているか(referenced)を素早く見つける能力が求められます。

これらの能力は、プログラミング言語をサポートするよう定義されたモード以外のメジャーモードでも、リファレンスを見つけるために有用です。たとえばテキストやTEXドキュメントのチャプター(chapters)、セクション(sections)、アペンディクス(appendices)も同様にサブユニットとなり得るし、それらの名前も識別子として使用できます。このチャプターでは、プログラムのソース、同様に他の種類のテキストの中の、任意の種類のサブユニットの名前を正確に参照するために、“識別子(identifiers)”という用語を使用します。

これらの能力のために、Emacsは‘`xref`’と呼ばれる統一されたインターフェースを提供します。

xref backend
`xref`が処理を行なうには、そのメジャーモード特有の情報とメソッドを使用する必要があります。どのファイルから識別子を検索するか、識別子にたいするリファレンス(references: 参照)を探す方法、識別子を補完する方法、これら(およびそれ以上のこと)は、モード固有の知識です。`xref`は処理のモード固有な部分を、そのモードにより提供されるバックエンド(backend)に委託します。これには、いくつかのコマンドにたいするデフォルトや、そのモード自体が提供しないモードにたいするデフォルトも含まれます。

バックエンドはこれらの能力をさまざまな方法で実装できます。いくつかの例を示します:

1.  その言語のシンボルを探すために、ビルトインの方法を提供するモードがいくつかあります。たとえばEmacs Lispのシンボルは、パッケージのロード履歴からの検索から識別され、Emacs Lispインタープリターにより保守され、ビルトインのドキュメント文字列(built-in documentation strings)で調べます。シンボル定義を探すために、Emacs Lispモードは、モードのバックエンドの中の、これらの機能を使用します(この種のバックエンドの不利な点の1つは、インタープリターにロードされたサブユニットしか認識しないことです)。

2.  外部プログラムは関連するファイルをスキャンしてリファレンスを抽出して、これらにたいするデータベースをビルドすることができます。リファレンスをリストしたり調べるために、バックエンドは必要なときにこのデータベースにアクセスできます。Emacsのディストリビューションには`etags`が含まれています。これはプログラム中の識別子の定義にタグ付けするコマンドで、リファレンスをタグテーブル(tags tables)に抽出することにより、多くのプログラミング言語、およびHTMLのようなその他のモードをサポートします。[Create Tags Table](#Create-Tags-Table)を参照してください。`etags`によりサポートされた言語にたいするメジャーモードは、そのバックエンドの基準でタグテーブルを使用できます(この種のバックエンドの不利な点の1つは、タグテーブルは有効性を維持するために最新である必要があり、度々リビルドしなければならないことです)。

### 識別子を探す

このサブセクションでは識別子にたいするリファレンスを探したり、識別子にたいしてさまざまな問い合わせを行なうコマンドを説明します。リファレンスは識別子を*定義(define)*するかもしれません(プログラム内のサブユニットを実装、ドキュメントのセクションのテキストなど)。あるいは識別子を*使用(use)*するかもしれません(関数やメソッドの呼び出し、変数への値の割り当て、クロスリファレンスで引用されるチャプターなど)。

#### 識別子の照合

find definition of symbols
identifier, finding definition of
find references to symbols
`xref`が可能にすることの中で一番重要なのは、指定した識別子の定義を探すことです。

`M-.`  
識別子の最初の定義を探します(`xref-find-definitions`)。

`C-M-. pattern RET`  
patternにマッチする名前の識別子を探します(`xref-find-apropos`)。

`C-x 4 . RET`  
識別子の最初の定義を探して、他のウィンドウに表示します(`xref-find-definitions-other-window`)。

`C-x 5 . RET`  
識別子の定義を探して、それを新しいフレームに表示します(`xref-find-definitions-other-frame`)。

`M-,`  
前に`M-.`または同種のコマンドを呼び出した場所に戻ります(`xref-pop-marker-stack`)。

`M-x xref-etags-mode`  
`etags`バックエンドを使用するように、`xref`を切り替えます。

M-.
xref-find-definitions
xref-prompt-for-identifier
`M-.` (`xref-find-definitions`)は、ポイント位置の識別子の定義を表示します。プレフィックス引数を与えた、またはポイント位置に識別子がない場合は、識別子の入力を求めます(常に識別子を尋ねるようにしたい場合は、`xref-prompt-for-identifier`を`t`にカスタマイズする)。

指定された識別子の定義が1つだけの場合は、その定義にジャンプします。識別子に該当する定義が複数ある場合(たとえばオブジェクト指向言語や、同じな前の関数や変数がある場合)、`*xref*`バッファーに定義の候補と、その定義が見つかったファイルを表示します。候補の選択は、定義の候補で`RET`をタイプするか`mouse-2`をクリックして行い、これにより対応する定義を表示するバッファーがポップアップします。

`M-.`の引数に識別子を入力するとき、通常のミニバッファーの補完コマンドを使用できます([Completion](#Completion)を参照してください)。補完では、既知の識別子の名前が補完候補になります。

C-x 4 .
xref-find-definitions-other-window
C-x 5 .
xref-find-definitions-other-frame
バッファーを切り替えるほとんどのコマンドと同様に、`xref-find-definitions`は新しいバッファーを他のウィンドウ、または新しいバッファーのために新しいフレームを作成する変種をもっています。前者は`C-x
4 .` (`xref-find-definitions-other-window`)、後者は`C-x 5 .` (`xref-find-definitions-other-frame`)です。

xref-find-apropos
C-M-.
コマンド`C-M-.` (`xref-find-apropos`)は、指定した正規表現にマッチする１つ以上の識別子を探します。これは`M-.`と同じですが、固定長文字列として評価されたシンボル名にたいするマッチではなく、regexpにマッチする識別子です。

上記コマンドにより複数の定義が見つかった場合は、候補となる定義を`*xref*`バッファーに表示します。このバッファーでは、[Xref Commands](#Xref-Commands)で説明されている、複数の特化されたコマンドが使用できます。

M-,
xref-pop-marker-stack
xref-marker-ring-length
定義の検索を*開始した場所*に戻るには、`M-,` (`xref-pop-marker-stack`)を使用します。これは最後に`M-.`を呼び出したポイントにジャンプします。したがって、`M-.`により何らかの定義を見つけて確認したら、`M-,`で戻ることができます。`M-,`は変数`xref-marker-ring-length`により決定される深さ(デフォルトは16)で、ステップを再トレースできます。

xref-etags-mode
いくつかのメジャーモードは、特定の識別子の検索に失敗するかもしれない`xref`サポート機能をインストールするかもしれません。たとえば、Emacs Lispモード([Lisp Eval](#Lisp-Eval)を参照)では、デフォルトでは`M-.`はカレントEmacsセッションにロードされた、あるいは自動ロード(section “Autoload” in The Emacs Lisp Reference Manualを参照)されるLispパッケージの関数と変数だけを検索します。`M-.`が何らかの識別子の検索に失敗する場合は、`xref`に`etags`バックエンド([Xref](#Xref)を参照)の使用を強制することができます。これを行うには、`M-x
xref-etags-mode`を呼び出してXref Etagsマイナーモードをオンに切り替えて、再度`M-.`を呼び出します(これが機能するためには、ソースファイルのディレクトリーツリー内でtagテーブルを作成するために、必ず`etags`を実行すること。[Create Tags Table](#Create-Tags-Table)を参照されたい)。

#### `*xref*`バッファーで利用可能なコマンド

commands in
\*xref\*
buffers
XREF mode
以下のコマンドは`*xref*`バッファーのXREFモードにより提供されるコマンドです:

`RET`; `mouse-2`  
カレント行のリファレンスを表示します。

`n`; `.`  
xref-next-line

次のリファレンスに移動して、それを別のウィンドウに表示します(`xref-next-line`)。

`p`; `,`  
xref-prev-line

前のリファレンスに移動して、それを別のウィンドウに表示します(`xref-prev-line`)。

`C-o`  
xref-show-location-at-point

カレント行のリファレンスを別のウィンドウに表示します(`xref-show-location-at-point`)。

`TAB`  
xref-quit-and-goto-xref

カレント行のリファレンスを表示して、`*xref*`バッファーを隠し(bury)ます(`xref-quit-and-goto-xref`)。

`r pattern RET replacement RET`  
patternにマッチするリファレンスにたいしてインタラクティブな問い合わせつき置換(query-replace)を行ない、マッチをreplacementに置換します。[Identifier Search](#Identifier-Search)を参照してください。

xref-quit

`q`  
`*xref*`バッファーを表示しているウィンドウをquitします(`xref-quit`)。

これらに加えて、リファレンスを表示せずにバッファー内を移動するために、`C-n`や`C-p`のような、通常のナビゲーションコマンドも利用可能です。

#### 識別子の検索と置換

search and replace in multiple source files
multiple source file search and replace
このセクションのコマンドは、識別子自身、またはファイル内の識別子にたいするリファレンスにたいして、様々な検索と置換を行ないます。

`M-?`  
ポイント位置の識別子にたいする、すべてのリファレンスを探します。

`M-x xref-query-replace-in-results RET regexp RET replacement RET`  
`*xref*`バッファーに表示されているすべての識別子の名前にたいして、regexpをreplacementにインタラクティブに置換します。

`M-x tags-search RET regexp RET`  
選択されたタグテーブルのファイルから、regexpを検索します。

`M-x tags-query-replace RET regexp RET replacement RET`  
選択されたタグテーブルの各ファイルにたいして、`query-replace-regexp`を実行します。

`M-x tags-loop-continue`  
ポイントのカレント位置から、上記コマンドの最後の2つを再開します。

M-?
xref-find-references
`M-?`は、ポイント位置の識別子にたいして、必要に応じて補完つきで識別子の入力を促しつつ、すべてのリファレンスを探します。カレントのバックエンド(see [Xref](#Xref))に依存して、ポイント位置に有効な識別子を見つけた場合でも、このコマンドは識別子の入力を促すかもしれません。プレフィクス引数が指定された場合、このコマンドは常に識別子の入力を求めます(常に入力を求めるようにしたい場合は`xref-prompt-for-identifier`を`t`、ポイント位置に利用できる識別子がない場合のみ入力を求めるようにするには`nil`にカスタマイズすればよい)。それからこのコマンドは、その識別子にたいするすべてのリファレンスについて、ファイル名と識別子が参照されている行を、`*xref*`バッファーに表示します。このバッファーではXREFモードのコマンドが利用可能です。[Xref Commands](#Xref-Commands)を参照してください。

xref-query-replace-in-results
`M-x xref-query-replace-in-results`は、通常の`M-x
query-replace-regexp`と同様に、識別子の名前にマッチするregexpと、置換する文字列を読み取ります。それから、その識別子が参照されている、すべてのファイルのすべての場所で、マッチする識別子の名前にたいして指定された置換を行ないます。これはリファクタリングの一部として、識別子のリネームを行なうときに有用です。このコマンドは`M-?`により生成された`*xref*`バッファーで呼び出されるべきです。

tags-search
`M-x
tags-search`は、ミニバッファーを使用してregexpを読み取り、選択されたタグテーブルのすべてのファイルから、1ファイルずつマッチを検索します。これは検索しているファイル名を表示するので、進行状況を確認することができます。マッチが見つかった場合、`tags-search`はリターンします。このコマンドには利用可能なタグテーブル([Tags Tables](#Tags-Tables)を参照してください)が必要です。

tags-loop-continue
`tags-search`で1つのマッチが見つかったら、おそらく残りのすべてについても検索したいと思うでしょう。`M-x
tags-loop-continue`は、多くのマッチを探すために`tags-search`を再開します。これはカレントバッファーの残りの部分を検索して、その後タグテーブルの残りのファイルを検索します。

tags-query-replace
`M-x
tags-query-replace`は、タグテーブルのすべてのファイルにたいして、1つの`query-replace-regexp`を実行します。これは、通常の`M-x
query-replace-regexp`と同様、検索するregexpと、それを置換する文字列を読み取ります。この検索はむしろ`M-x
tags-search`に似ていますが、入力へのマッチを繰り返し処理します。問い合わせ付き置換については、[Query Replace](#Query-Replace)を参照してください。

tags-case-fold-search
case-sensitivity and tags search
変数`tags-case-fold-search`の値をカスタマイズすることにより、タグ検索コマンドの大文字小文字の扱いを制御できます。デフォルトには、`case-fold-search`の値と同じ設定が使用されます([Lax Search](#Lax-Search)を参照してください)。

1回の`M-x
tags-query-replace`の呼び出しで、タグテーブルのすべてのファイルを検索することが可能です。しかし、一時的に検索を抜けられると便利なときもあります。これは、問い合わせ付き置換として特別な意味をもたない入力イベントで行うことができます。つづけて問い合わせ付き置換を再開するには、`M-x
tags-loop-continue`とタイプします。このコマンドは、最後のタグ検索または置換コマンドを再開します。たとえばカレントファイルの残りをスキップするには、`M->
M-x tags-loop-continue`とタイプします。

上記で説明したコマンドは、`xref-find-definitions`系の検索より広範な検索を行うことに注意してください。`xref-find-definitions`コマンドは、部分文字列または正規表現にマッチする識別子の定義だけを検索します。コマンド`xref-find-references`、`tags-search`、`tags-query-replace`は、通常の検索および置換コマンドがカレントバッファーにたいして行うように、識別子またはregexpにたいするマッチを検索します。

`xref-find-references`や`tags-search`のかわりに、サブプロセスとして`grep`を実行して、Emacsにマッチした行を1つずつ表示させることができます。[Grep Searching](#Grep-Searching)を参照してください。

#### 識別子の照会

`C-M-i`; `M-TAB`  
タグテーブルがロードされているときは、できるだけ選択されたタグテーブルを使って、ポイント周囲のテキストの置換を行います(`completion-at-point`)。

`M-x xref-find-apropos RET regexp RET`  
regexpにマッチする、既知のすべての識別子のリストを表示します。

`M-x list-tags RET file RET`  
プログラムファイルfileで定義されている識別子のリストを表示します。

`M-x next-file`  
選択されたタグテーブルに記録されているファイルをvisitします。

プログラミング言語のモードのほとんどでは、`C-M-i`または`M-TAB` (`completion-at-point`)とタイプして、ポイント位置のシンボルを補完できます。このコマンドのために、モードに特化した補完候補を提供するモードもあります。補完候補を提供しないモードでは、選択されたタグテーブルがある場合、補完候補を生成するためにこのコマンドを使用することができます。[Symbol Completion](#Symbol-Completion)を参照してください。

list-tags
`M-x
list-tags`は、選択されたタグテーブルでカバーされたファイルの名前を1つ読み取り、そのファイルで定義されたタグのリストを表示します。タグテーブルに記録されたファイル名にディレクトリーが含まれない場合は、ファイル名にディレクトリーを含めないでください。このコマンドはバックエンドがetagsのときだけ機能し、そのプロジェクトのために利用可能なタグテーブルが必要です。[Tags Tables](#Tags-Tables)を参照してください。

next-file
`M-x
next-file`は、選択されたタグテーブルでカバーされるファイルをvisitします。最初に呼び出したとき、テーブルでカバーされた最初のファイルをvisitします。続けて呼び出すことにより、次のカバーされたファイルをvisitしていきます。プレフィクス引数を指定した場合、最初のファイルに戻ります。このコマンドには、選択されたタグテーブルが必要です。

### tagsテーブル

tags and tag tables
タグテーブル(tags table)は、特定のプログラムまたはドキュメントのソースコードをスキャンすることにより抽出されたタグ[15]を記録します。生成されたファイルから抽出されたタグは、タグ抽出の際にスキャンされる生成されたファイルではなく、その元になるファイルを参照します。生成されたファイルの例として、Cwebソース、Yaccパーサー、Lexスキャナー定義から生成されたCファイルや、プリプロセスされたCファイルの`.i`、`.fpp`ソースファイルをプリプロセスすることにより生成されるFortranファイルがあります。

etags
タグテーブルを生成するには、ドキュメントまたはソースコードファイルにたいして、シェルコマンド`etags`を実行します。‘`etags`’プログラムは、タグテーブルファイル(tags table file)、または略記してタグファイル(tags file)にタグを書き込みます。タグファイルは慣習的に`TAGS`という名前です。[Create Tags Table](#Create-Tags-Table)を参照してください(同じフォーマットでこのようなテーブルを生成できる他のコマンドを使用して、タグテーブルを作成することも可能です)。

Emacsは、`xref`にたいするサポートされたバックエンドとして、`etags`パッケージを通じてタグテーブルを使用します。タグテーブルはEmacsディストリビューションの一部である`etags`コマンドにより生成されるので、ここではタグテーブルについて、より詳細に説明します。

C++ class browser, tags
tags, C++
class browser, C++
Ebrowse
Ebrowse機能は`etags`に似ていますが、C++に特化したものです。section “Ebrowse” in Ebrowse User’s Manualを参照してください。 Semanticパッケージは、`etags`機能とは別の、タグを生成して使用する他の方法を提供します。[Semantic](#Semantic)を参照してください。

#### ソースファイルタグの構文

以下は、もっともポピュラーな言語でタグ構文が定義される方法です:

-   Cコードでは、Cの関数やtypedefはタグなので、`struct`、`union`、`enum`の定義もタグです。タグテーブルを作成するとき、‘`--no-defines`’を指定しなければ、`#define`マクロ定義、`#undef`および`enum`定数もタグになります。同様に、‘`--no-globals`’を指定しなければグローバル変数もタグで、‘`--no-members`’を指定していなければ構造体のメンバーもタグです。‘`--no-globals`’、‘`--no-defines`’、‘`--no-members`’を使用することにより、タグテーブルを小さくすることができます。

    `etags`に‘`--declarations`’オプションを与えることにより、関数定義(function definitions)に加えて、関数宣言(function declarations)と外部変数(external variables)もタグ付けできます。

-   C++コードでは、Cコードのすべてのタグ構成に加えて、メンバー関数も認識されます。‘`--no-members`’オプションを使用しなければ、メンバー変数も認識されます。`operator`定義は、‘`operator+`’のような名前をもちます。‘`--class-qualify`’オプションを指定した場合、クラスの変数および関数にたいするタグは、‘`class::variable`’および‘`class::function`’という名前になります。デフォルトでは、クラスのメソッドとメンバーはクラス修飾されていません。これにより、ソース内でより正確に、それらの名前が識別可能になります。

-   Javaコードでは、C++で認識されるのすべてのタグ構成に加えて、`interface`、`extends`、`implements`もタグとして認識されます。クラスの変数および関数にたいするタグは、‘`class.variable`’および‘`class.function`’という名前になります。

-   LATEXドキュメントでは、`\chapter`、`\section`、`\subsection`、`\subsubsection`、`\eqno`、`\label`、`\ref`、`\cite`、`\bibitem`、`\part`、`\appendix`、`\entry`、`\index`、`\def`、`\newcommand`、`\renewcommand`、`\newenvironment`、`\renewenvironment`にたいする引数がタグになります。

    `etags`を呼び出す前に、環境変数TEXTAGSで指定することにより、他のコマンドも同様にタグにできます。この環境変数の値には、コロンで区切られたコマンド名のリストを指定します。たとえば、

        TEXTAGS="mycommand:myothercommand"
        export TEXTAGS

    これは、(Bourneシェルの構文の使用して)コマンド‘`\mycommand`’と‘`\myothercommand`’もタグとして定義します。

-   Lispコードでは、`defun`で定義された任意の関数、`defvar`および`defconst`で定義された任意の変数、および一般的に列0から‘`(def`’で始まる任意の式の最初の引数はタグです。例外として`(defvar
    foo)`という形式の式は、宣言として扱われ、‘`--declarations`’オプションが与えられたときだけタグになります。

-   Schemeコードでは、`def`で定義されたすべて、または名前が‘`def`’で始まる構成がタグに含まれます。これらは、ファイルのトップレベルで`set!`でセットされる変数も含まれます。

他の言語もいくつかサポートされます:

-   Adaコードでは、関数(functions)、プロシージャー(procedures)、パッケージ(packages)、タスク(tasks)、タイプ(types)がタグです。‘`--packages-only`’オプションを使用することにより、タグをパッケージにたいしてだけ作成できます。

    Adaでは、異なる種類のエンティティー(たとえば関数とプロシージャー)に、同じ名前を使うことができます。またパッケージ、プロシージャー、関数と似たものに、スペック(spec、たとえばinterface)およびボディー(body、たとえばimplementation)があります。欲しい定義を簡単に取り出すために、Adaのタグ名にはエンティティーのタイプを示す接尾辞がつきます:

    ‘`/b`’  
    パッケージのボディー(package body)。

    ‘`/f`’  
    関数(function)

    ‘`/k`’  
    タスク(task)。

    ‘`/p`’  
    プロシージャー(procedure)。

    ‘`/s`’  
    パッケージのスペック(package spec)。

    ‘`/t`’  
    タイプ(type)。

    したがって、`M-x find-tag RET bidule
    RET`は単に`bidule`という任意のタグを検索しますが、`M-x find-tag RET
    bidule/b RET`は直接パッケージ`bidule`のボディーに移動します。

-   アセンブラーコードでは、行の開始に現れ、後にコロンが続くラベルがタグです。

-   BisonまたはYaccの入力ファイルでは、各構文規則で定義する非終端記号がタグです。ファイル内に含まれるCコードの部分は、Cコードとして解析します。

-   Cobolコードでは、タグはパラグラフ名なので、列8から始まり、後にピリオドが続く任意の単語がタグです。

-   Erlangコードでは、ファイルで定義された関数(functions)、レコード(records)、マクロ(macros)がタグです。

-   Fortranコードでは、サブルーチン(subroutines)およびブロックデータ(block data)がタグです。

-   Goコードでは、関数(functions)、タイプ(types)がタグです。

-   HTML入力ファイルでは、`title`、および`h1`、`h2`、`h3`ヘッダーがタグです。アンカー内の`name=`、およびすべての`id=`もタグです。

-   Lua入力ファイルでは、すべての関数(functions)がタグです。

-   makefileでは、ターゲット(targets)がタグで、‘`--no-globals`’を指定しなければ変数(variables)もタグです。

-   Objective Cコードでは、クラスにたいするObjective C定義、クラスカテゴリー(class categories)、メソッド(methods)、プロトコル(protocols)が含まれます。クラスの変数および関数にたいするタグの名前は、‘`class::variable`’および‘`class::function`’になります。

-   Pascalコードでは、ファイル内で定義された関数およびプロシージャーがタグです。

-   Perlコードでは、パッケージ、サブルーチン、変数がタグで、キーワード`package`、`sub`、`use
    constant`、`my`、`local`で定義されます。グローバル変数をタグ付けしたい場合、‘`--globals`’を使用します。サブルーチンにたいするタグの名前は、‘`package::sub`’になります。デフォルトのパッケージで定義されたサブルーチンの名前は、‘`main::sub`’になります。

-   PHPコードでは、関数(functions)、クラス(classes)、定義(defines)がタグです。‘`--no-members`’オプションを使用しなければ、変数(vars)もタグです。

-   PostScriptコードでは、関数がタグです。

-   Prologコードでは、行頭の述語(predicates)とルール(rules)がタグです。

-   Pythonコードでは、行頭の`def`および`class`はタグを生成します。

-   Rubyコードでは、行の先頭にある`def`、`class`、`module`はタグを生成します。定数もタグを生成します。

他の書式や言語を扱うために、regexpにたいするマッチにもとづいてタグを生成することもできます([Etags Regexps](#Etags-Regexps)を参照してください)。

#### タグテーブルの作成

etags
program
`etags`プログラムは、タグテーブルファイルを作成するために使用されます。このコマンドは、 [Tag Syntax](#Tag-Syntax)で説明している複数の構文を理解します。 以下は`etags`を実行する方法です:

    etags inputfiles…

`etags`プログラムは、指定されたファイルを読み込んで、カレント作業ディレクトリーの`TAGS`という名前のファイルに、タグテーブルを書き込みます。‘`--output=file`’オプションを使用して、タグテーブルに異なる名前のファイル名を指定することもできます。ファイル名に`-`を指定すると、タグテーブルを標準出力に出力します。‘`--append`’オプションを使用して、既存のファイルに新たに作成したtagテーブルを追加することもできます。

指定されたファイルが見つからない場合、`etags`はそれらの圧縮されたバージョンを探して、それらを解凍して読み込みます。MS-DOSでは、コマンドラインに‘`mycode.c`’が与えられ、‘`mycode.c`’が存在しないとき、`etags`は`mycode.cgz`のような名前のファイルを探します。

ファイルの内容が変更されてタグテーブルが古くなったときは、`etags`を再び実行することにより、タグテーブルを更新できます。タグテーブルにタグが記録されていなかったり、間違ったファイルにたいして記録している場合、タグテーブルを更新するまで、Emacsはそれの定義を見つけることができません。しかしタグに記録されている位置が、(編集により)少し間違っているようなときは、少しの遅れは生じますがEmacsは正しい位置を見つけることができます。

したがって、編集するたびにタグテーブルを更新する必要はありません。リストしたい新しいタグを定義したときや、タグ定義をあるファイルから他のファイルへ移動したとき、または大幅な変更を施したときは、タグテーブルを更新するべきです。

`etags`に‘`--include=file`’オプションを渡すことにより、タグテーブルに他のタグテーブルをインクルード(include)できます。これによりインクルードされたタグファイルでカバーされる、すべてのファイルをカバーできます。

`etags`を実行するとき、ソースファイルを相対ファイル名で指定した場合、タグファイルには、そのタグファイルが最初に書き込まれたディレクトリーにたいする相対ファイル名が含まれます。この方法を使えば、ディレクトリーツリー全体を移動しても、タグファイルは正しくソースファイルを参照します。しかしタグファイルが`-`または`/dev`のときは、ファイル名はカレント作業ディレクトリーにたいする相対ファイル名になります。これはタグを標準出力に書き込むときに便利です。

相対ファイル名を使う場合、違うディレクトリーにあるタグファイルを指すシンボリックリンクを指定するべきではありません。なぜならこれは一般的にファイル名を無効にするからです。

`etags`の引数に絶対ファイル名を指定した場合、タグファイルには絶対ファイル名が含まれます。この方法では、ソースファイルが同じ場所にある限り、タグファイルを移動してもタグファイルは同じ名前を参照します。絶対ファイル名は‘`/`’で開始されるか、MS-DOSおよびMS-Windowsでは‘`device:/`’で開始されます。

非常に大きな数のファイルからタグテーブルを作成したい場合、それをコマンドラインに指定すると問題が発生するかもしれません。なぜならコマンドライン引数の長さに制限のあるシステムもあるからです。この制限は、以下のようにファイル名の場所にダッシュを指定して、`etags`にファイル名を標準入力から読み込むように指示して回避することができます。

    find . -name "*.[chCH]" -print | etags -

`etags`はファイル名とファイル内容にもとづいて、入力ファイルで使用されている言語を認識します。これは最初に、特定の言語にたいして一般的に使用されるファイル名と拡張子にたいするマッチを試みます。いくつかの言語には、既知の名前のインタープリター(Perlの`perl`、Prologの`pl`など)があるので、`etags`は次に入力ファイルの最初の行でインタープリター指定‘`#!interp`’を調べて、既知のインタープリターとのマッチを行います。これが失敗、または言語の自動検知をオーバーライドしたい場合は、‘`--language=name`’オプションで、明示的に言語を指定できます。このオプションはファイル名に混ぜることができます。各指定はその後に続くファイル名に適用されます。‘`--language=auto`’の指定は、ファイル名とファイル内容から言語を推測するよう`etags`に指示します。‘`--language=none`’を指定すると、言語に特有の処理を完全にオフに切り替えます。この場合、`etags`はregexpのマッチングだけでタグを認識します([Etags Regexps](#Etags-Regexps)を参照してください)。これは、`etags`がまだサポートしていない言語を使用するファイルが入力の際に、`etags`がデフォルト言語としてFortranおよびCにフォールバックするのを抑止します。

オプション‘`--parse-stdin=file`’は、`etags`をプログラムから呼び出すときに便利です。これは、(1回だけ)コマンドラインからファイル名を読み取るとき使用できます。`etags`は標準入力から読み取り、生成されたタグがファイルfileに属するとマークします。

‘`etags
--help`’オプションは`etags`が認識する言語と、言語を推測するためのファイル名ルールのリストを出力します。これは利用可能な`etags`オプションと、簡単な説明のリストも出力します。このオプションの後に、1つ以上の‘`--language=lang`’を指定すると、langにたいするタグの生成方法の詳細を出力します。

#### etagsのregexp

‘`--regex`’オプションは、正規表現のマッチにもとづいて`etags`がタグを認識できるようにします。このオプションはファイル名と混ぜることができます。オプションは、それぞれのオプション後に続くソースファイルに適用されます。複数の‘`--regex`’を指定した場合、それらすべては並列に使用されます。構文は以下のとおりです:

    --regex=[{language}]/tagregexp/[nameregexp/]modifiers

オプション値の肝心な部分はtagregexpで、これはタグにマッチするregexpです。これは常に位置が固定されており、行の開始だけにマッチします。インデントされたタグの場合、最初の空白文字にマッチさせるために、‘`[
\t]*`’で始まるregexpを使用します。

これらの正規表現では、‘`\`’は次の文字をクォートします。またCのエスケープ文字シーケンスのすべて、すなわち‘`\a`’(bell)、‘`\b`’(back space)、‘`\e`’(escape)、‘`\f`’(formfeed)、‘`\n`’(newline)、‘`\r`’(carriage return)、‘`\t`’(tab)、and ‘`\v`’(vertical tab)がサポートされます。これらに加えて、‘`\\d`’は`DEL`文字を意味します。

理想的には、tagregexpはタグとして認識させるのに必要な文字以上にマッチさせるべきではありません。構文がそれを求める場合、タグより多くの文字にマッチするtagregexpを記述して、そのマッチからタグだけをピックアップするために、nameregexpを追加するべきです。これはEmacsがより正しくタグを見つけて、タグ名の補完をより確実にすることを可能にします。nameregexp内においてはこれは、tagregexp内でのカッコによるグループ化にたいする“後方参照(back references)” ([Regexp Backslash](#Regexp-Backslash)を参照)として有用であり、頻繁に使用されます。たとえば、‘`\\1`’はそのようなカッコによる最初のグループを参照します。以下でいくつかの例を見つけることができるでしょう。

modifiers(修飾子)は、`etags`がマッチングを行う方法を変更するための0文字以上の文字シーケンスです。修飾子がないregexpは、大文字小文字を区別する方法で、入力ファイルの各行にたいして順番に適用されます。修飾子とその意味は以下のとおりです:

‘`i`’  
このregexpのマッチングで、大文字小文字を無視します。

‘`m`’  
この正規表現はファイル全体にマッチするので、複数行のマッチが可能です。

‘`s`’  
この正規表現はファイル全体にマッチし、tagregexp内の‘`.`’は改行にマッチします。

‘`-R`’オプションは、それの前に‘`--regex`’で定義されたregexpをすべて取り消します。これは後に続くファイル名にも適用されます。以下は例です:

    etags --regex=/reg1/i voo.doo --regex=/reg2/m \
        bar.ber -R --lang=lisp los.er

この例では、`etags`は`voo.doo`と`bar.ber`にたいして。ファイル内容に一致する解析用の言語を選択します。`etags`は、`voo.doo`内の追加のタグを認識するためにreg1も使用し、`bar.ber`内の追加のタグを認識するためにreg1とreg2の両方を使用します。`voo.doo`と`bar.ber`の各行にたいして大文字小文字を区別せずにreg1がチェックされ、`bar.ber`のファイル全体にたいして大文字小文字を区別してreg2がチェックされ、これは複数行へのマッチが許されます。`los.er`のタグの認識にはユーザー指定のregexpマッチは行わず、Lispのタグルールだけが使用されます。

オプションのプレフィクス{language}を使用して、与えられた言語だけに‘`--regex`’オプションを制限できます(‘`etags
--help`’で`etags`が認識する言語のリストが表示されます)。これはファイルに、`etags`にたいして事前に定義された多くの正規表現が含まれている場合に便利です。以下の例は、EmacsのC言語のソースファイルの`DEFVAR`マクロにたいするタグです:

    --regex='{c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/'

正規表現が複雑な場合、そのリストをファイルに保存することができます。以下のオプション構文は、`etags`に正規表現が保存された2つのファイルを指示します。2つ目のファイルに含まれる正規表現は、大文字小文字を区別せずにマッチします。

    --regex=@case-sensitive-file --ignore-case-regex=@ignore-case-file

`etags`にたいするregexファイルは、行ごとに1つの正規表現を含みます。空行およびスペースかタブで始まる行は無視されます。表の開始が‘`@`’の場合、`etags`はその行の残りを他の正規表現ファイルとみなすので、そのようなファイルを他のファイルをインクルードできます。他のすべての行は正規表現です。最初の非空白文字が‘`--`’の場合、その行はコメントです。

たとえば、以下の内容の‘`emacs.tags`’という名前のファイルを作成できます:

            -- This is for GNU Emacs C source files
    {c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/

これは以下のように使用します:

    etags --regex=@emacs.tags *.[ch] */*.[ch]

さらに例を示しましょう。regexpはシェルから解釈され内容にクォートされています。

-   Octaveファイルのタグ:

        etags --language=none \
              --regex='/[ \t]*function.*=[ \t]*\([^ \t]*\)[ \t]*(/\1/' \
              --regex='/###key \(.*\)/\1/' \
              --regex='/[ \t]*global[ \t].*/' \
              *.m

    タグはスクリプトにたいして生成されるので、そのスクリプトにジャンプしたいときは、あなた自身で‘`###key
    scriptname`’という形式の行を追加する必要があることに注意してください。

-   Tclファイルのタグ:

        etags --language=none --regex='/proc[ \t]+\([^ \t]+\)/\1/' *.tcl

-   VHDLファイルのタグ:

        etags --language=none \
          --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/' \
          --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
          \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'

### タグテーブルの選択

visit-tags-table
Emacsは常に、選択されたタグテーブルを最大で1つもちます。タグテーブルにたいして機能するすべてのコマンドは、選択されたタグテーブルを使用します。タグテーブルを選択するには、`M-x
visit-tags-table`とタイプします。これは、引数としてタグテーブルファイル名を読み取ります。デフォルトディレクトリーの`TAGS`がデフォルトです。

tags-file-name
Emacsは、タグテーブルを使用するまでは実際にタグテーブルの内容を読み込みません。`visit-tags-table`が行うのは、ファイル名を変数`tags-file-name`に格納することだけです。この変数の初期値は`nil`です。この変数の値は、タグテーブルにたいして機能するすべてのコマンドに、使用するタグテーブルファイル名を知らせます。

タグテーブルがすでにロードされているときに`visit-tags-table`を使用すると、2つの選択肢が与えられます。つまり、タグテーブルのカレントリストに新しいタグを追加するか、あるいは新しいリストを開始することもできます。タグコマンドは、カレントリストのすべてのタグテーブルを使用します。新しいリストを開始した場合、他のものの*かわりに*、新しいタグテーブルが使用されます。カレントリストに新しいタグテーブルを追加した場合、それは他のものと*同じように*使用されます。

tags-table-list
以下のようにして、変数`tags-table-list`に文字列のリストをセットすることにより、タグテーブルのリストを正確に指定できます:

    (setq tags-table-list
          '("~/.emacs.d" "/usr/local/lib/emacs/src"))

This tells the tags commands to look at the `TAGS` files in your `~/.emacs.d` directory and in the `/usr/local/lib/emacs/src` directory. The order depends on which file you are in and which tags table mentions that file.

`tags-file-name`と`tags-table-list`の両方をセットしてはいけません。

Emacs開発環境
-------------

EDE (Emacs Development Environment)
Emacs Development Environment
Integrated development environment
EDE(Emacs Development Environment: Emacs開発環境)は、Emacsでの大きなプログラムの作成、ビルド、デバッグなどのタスクを単純化するパッケージです。これはEmacsにおいて、IDE(Integrated Development Environment: 統合開発環境)の機能をいくつか提供します。

このセクションは、EDEの簡単な説明を提供します。 完全な詳細については、section “EDE” in Emacs Development Environmentを参照してください。

EDEは、グローバルなマイナーモードとして実装されています([Minor Modes](#Minor-Modes)を参照してください)。有効にするには`M-x
global-ede-mode`とタイプするか、‘`Tools`’メニューの‘`Project Support
(EDE)`’アイテムをクリックします。以下の行をinitファイルに追加することにより、Emacs開始時にEDEを有効にすることもできます。

    (global-ede-mode t)

EDEを有効にすることにより、メニューバーに‘`Development`’という名前のメニューが追加されます。以下で説明するコマンドを含めて、多くのEDEコマンドをこのメニューから呼び出すことができます。

EDEは、ファイルをプロジェクト(projects)に編成します。プロジェクトはディレクトリーに対応します。プロジェクトルート(project root)は、プロジェクトの最上層のディレクトリーです。新しいプロジェクトを定義するには、プロジェクトルートのファイルをvisitして、`M-x
ede-new`とタイプします。このコマンドはプロジェクトタイプ(project type)の入力を求めます。これはEDEがプロジェクトを背後で管理する方式です(section “EDE” in Emacs Development Environmentを参照してください)。もっとも一般的なプロジェクトタイプは、Makefilesを使用する‘`Make`’、およびGNU Automake(section “Automake” in Automakeを参照してください)を使用する‘`Automake`’です。どちらの場合も、EDEはプロジェクトに関する情報を格納する、`Project.ede`という名前のファイルを作成します。

プロジェクトには、1つ以上のターゲット(targets)を含めることができます。ターゲットとは、プロジェクトの1つ以上のファイルからビルドされるオブジェクトファイル、実行ファイル、またはその他の種類のファイルです。

プロジェクトに新しいターゲット(target)を追加するには、`C-c . t` (`M-x
ede-new-target`)とタイプします。このコマンドは、カレントファイルをそのターゲットに追加するか尋ねます。これはターゲットがそのファイルからビルドされることを意味します。ターゲットを定義した後は、`C-c
. a` (`ede-add-file`)とタイプすることにより、ターゲットにファイルを追加することができます。

ターゲットをビルドするには、`C-c . c` (`ede-compile-target`)とタイプします。プロジェクトのすべてのターゲットをビルドするには、`C-c . C` (`ede-compile-project`)とタイプします。EDEはターゲットがどのようにビルドされるべきか推測するために、ファイルタイプを使用します。

Emergeでのファイルのマージ
--------------------------

Emerge
merging files
行き違いの指示を受けて、同じプログラムを異なる2つの方向に修正してしまうのは、プログラマーにとって珍しいことではありません。この混乱を正常な状態に戻すには、2つのバージョンをマージする必要があります。Emergeはこれを簡単にします。ファイルを比較する他の方法については、 [Comparing Files](#Comparing-Files)、 およびsection “Ediff” in The Ediff Manualを参照してください。

### Emergeの概要

Emergeを開始するには、以下の4つのコマンドの1つを実行します:

`M-x emerge-files`  
emerge-files

指定した2つのファイルをマージします。

`M-x emerge-files-with-ancestor`  
emerge-files-with-ancestor

共通の祖先(ancestor)を参照して、指定した2つのファイルをマージします。

`M-x emerge-buffers`  
emerge-buffers

2つのバッファーをマージします。

`M-x emerge-buffers-with-ancestor`  
emerge-buffers-with-ancestor

第3のバッファーにある共通の祖先を参照して、2つのバッファーをマージします。

merge buffer (Emerge)
A and B buffers (Emerge)
Emergeコマンドは2つのファイルまたはバッファーを比較して、3つのバッファーにそれ表示します。最初の2つは入力テキスト(AバッファーとBバッファー)で、残りの1つ(マージバッファー)はどこにマージが行われたかを表示します。マージバッファーは相違だけではなく、マージされたテキストをすべて表示します。2つの入力テキストが異なる場所では、どちらをマージバッファーに含めるか選択できます。

既存のバッファーから入力を得るEmergeコマンドは、そのバッファーがナローされている場合は、バッファーのアクセス可能な部分だけを使用します。 [Narrowing](#Narrowing)を参照してください。

2つのマージされるテキストの元となる、共通の祖先となるバージョンが利用可能な場合は、Emergeはどちらが正しい候補かを推測するために、それを使用することができます。一方のカレントバージョンが祖先に一致する場合、Emergeはもう一方のカレントバージョンが、マージされたバージョンに残すべき、意図した変更であると仮定します。共通の祖先となるテキストを指定したい場合は、‘`with-ancestor`’がつくコマンドを使用します。これらのコマンドは3つのファイルまたはバッファーの名前 — バージョンA、バージョンB、そして共通の祖先の名前を読み取ります。

比較が終了してバッファーの準備ができた後、対話的なマージが開始されます。マージバッファーで特別なマージコマンドをタイプすることにより、マージを制御できます([Merge Commands](#Merge-Commands)を参照してください)。入力テキストの相違それぞれにたいして、どちらを残すか、または両方編集するか選択することができます。

マージバッファーはこれらの選択を行うために、Emergeモードという特別なメジャーモードを使用します。しかし、そのバッファーでは通常のEmacsコマンドで編集することもできます。

常にEmergeの注目は、選択された相違と呼ばれる、特定の相違に焦点を置きます。この相違は、3つのバッファーで以下のようにマークされます:

    vvvvvvvvvvvvvvvvvvvv
    text that differs
    ^^^^^^^^^^^^^^^^^^^^

Emergeはすべての相違に順番に番号をふり、モードラインには選択された相違の番号が常に表示されます。

マージバッファーは通常、バージョンAのテキストで開始されます。しかしバージョンAの相違が共通の祖先と一致する場合、その相違の初期値にはバージョンBが優先されます。

マージバッファーを抜けるとき、Emergeはマージされたテキストを残します。このとき、`C-x
C-w`で、それをファイルに保存できます。`emerge-files`または`emerge-files-with-ancestor`に数引数を与えた場合、ミニバッファーを使用して、出力するファイル名を読み取ります(これは、このコマンドが読み取るファイル名の最後のファイル名です)。その後Emergeから抜けると、マージされたテキストを出力ファイルに保存します。

通常、Emergeコマンドは終了するとき出力バッファーを、そのバッファーのファイルに保存します。Emergeを`C-]`で中断した場合、Emergeコマンドは出力バッファーを保存しませんが、もし保存したいときは自分で保存することができます。

### Emergeのサブモード

マージコマンドに与える2つのモード — FastモードとEditモードを選択することができます。Fastモードでは、基本的なマージコマンドは1文字ですが、通常のEmacsコマンドは利用不可です。これはマージコマンドだけを使いたいときは便利です。Editモードでは、すべてのマージコマンドはプレフィクスキー`C-c
C-c`で始まり、通常のEmacsコマンドも利用可能です。これによりマージバッファーで編集することができますが、Emerge操作は遅くなります。

`e`でEditモード、`C-c C-c
f`でFastモードに切り替わります。モードラインにはEditモードおよびFastモードは、‘`E`’と‘`F`’で示されます。

Emergeは、特定のマージコマンドがどのように機能するかに影響を与える、2つの追加的なサブモード — Auto AdvanceモードとSkip Prefersモードがあります。

Auto Advanceモードが効力をもつ場合、`a`または`b`コマンドで次の相違に移動します。これは候補を単に選んでいくだけで、素早くマージすることができます。Auto Advanceモードの場合、モードラインに‘`A`’が示されます。

Skip Prefersモードが効力をもつ場合、`n`および`p`コマンドは、状態が“prefer-A”と“prefer-B”の相違をスキップします([State of Difference](#State-of-Difference)を参照してください)。したがって、どちらのバージョンも正しいと推定できない相違だけを見ていくことができます。Skip Prefersモードの場合、モードラインに‘`S`’が示されます。このモードは祖先がある場合にだけ適しています。

emerge-auto-advance
emerge-skip-prefers
Auto Advanceをセットまたはクリアーするには、コマンド`s a` (`emerge-auto-advance`)を使用します。Skip Prefersモードをセットまたはクリアーするには、`s s` (`emerge-skip-prefers`)を使用します。これらのコマンドは、正の引数の場合はモードをオンにして、負または0の引数のときはモードをオフにし、引数がないときはモードのオン・オフを切り替えます。

### 相違の状態

マージバッファーでは、相違は文字‘`v`’および‘`^`’のラインでマークされます。各相違は、以下の7つの状態のうち1つをもちます:

A  
相違にはバージョンAが表示されています。`a`コマンドは常にこの状態を生成します。モードラインには‘`A`’が示されます。

B  
相違にはバージョンBが表示されています。`b`コマンドは常にこの状態を生成します。モードラインには‘`B`’が示されます。

default-A; default-B  
選択を行っていないので、相違にはデフォルトとしてAまたはBの状態が表示されています。すべての相違はdefault-A状態で開始されます(したがってマージバッファーはAバッファーのコピーとなります)が、例外として、もう一方のほうがpreferred(好ましい)な場合を除きます(以下参照)。

相違を選択したときに、状態はdefault-Aまたはdefault-Bから、AまたはBに遷移します。したがって、選択された相違が状態default-Aまたはdefault-Bをもつことはなく、これらの状態がモードラインに表示されることはありません。

コマンド`d a`は、デフォルトの状態にdefault-Aを選択し、`d
b`はdefault-Bを選択します。これらで選択されるデフォルトは、まだ1度も選択していないか、好ましい候補をもたないすべての相違に適用されます。順番に移動しながらマージを行っている場合、一度も選択されていない相違とは、選択された相違の後のすべての相違です。したがって順番に移動しながら、セクションの間で`d
a`と`d
b`を使い分けることにより、マージバッファーのあるセクションにたいしてはバージョンAをデフォルトに、他のセクションにはバージョンBを効果的に選択できます。

prefer-A; prefer-B  
相違には、状態Aまたは状態Bが表示されています。なぜなら、それがpreferred(好ましい)からです。これはまだ明示的な選択を行なっていないが、一方の候補は共通の祖先と同じなので、もう一方の候補の方が正しく見えることを意味します。したがってAバッファーが共通の祖先と同じ場合、バージョンBの方が好ましいといえます。なぜなら、それは実際に変更されているからです。

これら2つの状態は、モードラインに‘`A*`’と‘`B*`’で表示されます。

combined  
`x c`または`x C`コマンドの結果として、相違は状態Aおよび状態Bが混合されたものを表示しています。

相違が1度この状態になると、`a`コマンドと`b`コマンドは、数引数を与えないかぎり何もしません。

モードラインには状態‘`comb`’が表示されます。

### マージコマンド

以下はFastモードのマージコマンドです。Editモードでは前に`C-c C-c`をつけてください:

`p`  
前の相違を選択します。

`n`  
次の相違を選択します。

`a`  
この相違にバージョンAを選択します。

`b`  
この相違にバージョンBを選択します。

`C-u n j`  
番号nの相違を選択します。

`.`  
ポイントを含む相違を選択します。

`q`  
終了 — マージを終了します。

`C-]`  
中断 — マージをexitして出力を保存しません。

`f`  
Fastモードに移行します(Editモードでは実際には`C-c C-c f`です)。

`e`  
Editモードに移行します。

`l`  
3つのウィンドウにたいして、(`C-l`のように)再センタリングをします。引数を指定すると、デフォルトの3ウィンドウ表示を再構築します。

`-`  
数引数の一部を指定します。

`digit`  
これも数引数の一部を指定します。

`d a`  
ポイント位置からマージバッファーの下方へ、バージョンAをデフォルトとして選択します。

`d b`  
ポイント位置からマージバッファーの下方へ、バージョンBをデフォルトとして選択します。

`c a`  
この相違のバージョンAを、killリングにコピーします。

`c b`  
この相違のバージョンBを、killリングにコピーします。

`i a`  
この相違のバージョンAを、ポイント位置に挿入します。

`i b`  
この相違のバージョンBを、ポイント位置に挿入します。

`m`  
相違の周囲に、ポイントとマークを配します。

`^`  
3つのウィンドウすべてを、(`M-v`のように)下にスクロールします。

`v`  
3つのウィンドウすべてを、(`C-v`のように)上にスクロールします。

`<`  
3つのウィンドウすべてを、(`C-x <`のように)左にスクロールします。

`>`  
3つのウィンドウすべてを、(`C-x >`のように)右にスクロールします。

`|`  
3つのウィンドウすべての水平スクロールをリセットします。

`x 1`  
マージウィンドウを1行に縮めます(フルサイズに復元するには`C-u l`を使用します)。

`x c`  
この相違の2つのバージョンを合成します([Combining in Emerge](#Combining-in-Emerge)を参照してください)。

`x f`  
Emergeが操作しているファイルまたはバッファーの名前を、Helpウィンドウに表示します(ウィンドウを復元するには`C-u
l`を使用します)。

`x j`  
この相違を次の相違に結合します(`C-u x j`は前の相違に結合します)。

`x s`  
この相違を2つの相違に分割します。このコマンドを使う前に、3つのバッファーで、相違を分割したい位置にポイントを配してください。

`x t`  
相違の上部と下部にある、同じ行を取り除きます。このような行は、バージョンAとバージョンBが同じでも、それらが祖先となるバージョンと異なる場合に発生します。

### Emergeの終了

`q`コマンド(`emerge-quit`)はマージを終了して、指定されている場合は結果を出力ファイルに保存します。これはバッファーAおよびBの内容を正しいものに復元するか、もしそれらがEmergeにより作成され、何も変更されていないときはkillします。これによりマージバッファーでEmergeコマンドは使えなくなります。なぜならそれらを実行することにより、さまざまなバッファーの内容にダメージを与えるからです。

`C-]`はマージを中断します。これは出力ファイルに書き込まずに終了することを意味します。出力ファイルを指定していない場合、マージの終了と中断に実際の違いはありません。

Emergeコマンドが他のLispプログラムから呼び出された場合、正常終了の戻り値は`t`で、中断(abort)のときは`nil`です。

### 2つのバージョンの合成

特定の相違にたいして両方の候補を使いたいときがあります。これを行なうにはマージバッファーを以下のように編集する`x c`を使用します:

    #ifdef NEW
    version from B buffer
    #else /* not NEW */
    version from A buffer
    #endif /* not NEW */

emerge-combine-versions-template この例はCプリプロセッサー条件が2つのバージョン候補を区切っていますが、区切りに使う文字列は、変数`emerge-combine-versions-template`に選択した文字列をセットすることにより、指定することができます。この文字列で‘`%a`’はバージョンA、‘`%b`’はバージョンBです。上記の結果を生成するデフォルトのセッティングは、以下のようなものです:

    "#ifdef NEW\n%b#else /* not NEW */\n%a#endif /* not NEW */\n"

### Emergeの細かい注意点

マージの間、AおよびBバッファーを自分で編集してはいけません。Emergeは一時的にこれらを変更しますが、最終的には元の内容に戻します。

複数のマージを一度に行うことができます — ただし、ある1つのバッファーを複数のマージの入力として使用しないでください。なぜなら、これらのバッファーに加えられる一時的な変更が、1つのバッファーに加えられてしまうからです。

ファイル全体を比較する必要があるため、Emergeの開始には時間がかかることもあります。Emacsは、`diff`が終了するまで他のことを行なえません。入力ファイルが大きいときはバックグラウンドで比較を行なうように、誰かがEmergeを変更するかもしれません — そうなればEmergeがコマンドを受け付けられるようになるまでの間、Emacsで他の作業を続けることができるでしょう。

emerge-startup-hook
マージをセットアップした後、Emergeはフック`emerge-startup-hook`を実行します。 [Hooks](#Hooks)を参照してください。

abbrev(略語)
============

abbrevs
expansion (of abbrevs)
定義されたabbrev(abbreviation: 略語の意)とは、挿入したとき他のテキストに展開される単語のことです。abbrevは、特別な方法で展開されるようにユーザーにより定義されます。たとえば‘`foo`’を、‘`find
outer otter`’に展開されるように定義したとします。その後、`f o o
SPC`とタイプすることにより、バッファーに‘`find outer otter `’を挿入できます。

略語機能の2番目の種類は、動的abbrev展開(dynamic abbrev expansion)と呼ばれます。ポイントの前の文字で始まる単語をバッファーから探して、その文字を展開するために、明示的なコマンドで動的abbrev展開を使用します。[Dynamic Abbrevs](#Dynamic-Abbrevs)を参照してください。

3番目の種類のhippie expansion(ヒッピー展開)は、略語展開を一般化したものです。section “Hippie Expansion” in Features for Automatic Typingを参照してください。

abbrevの概念
------------

abbrevとは、特定の展開結果に展開されるために定義された単語のことです。abbrevの後ろに単語の区切りとなる文字を挿入したとき、それはabbrevを展開し、abbrevを展開結果に置き換えます。たとえば‘`foo`’が‘`find
outer otter`’に展開されるabbrevとして定義された場合、`f o o .`とタイプすると‘`find outer
otter.`’が挿入されます。

abbrev-mode
Abbrev mode
mode, Abbrev
abbrevは、バッファーローカルなマイナーモードのAbbrevモードが有効なときだけ展開されます。Abbrevモードを無効にすると、定義したabbrevは忘れられますが、再びAbbrevモードを有効にすると展開されます。コマンド`M-x
abbrev-mode`は、Abbrevモードを切り替えます。数引数を指定した場合、引数が正のときはAbbrevモードをオン、他の場合はオフに切り替えます。[Minor Modes](#Minor-Modes)を参照してください。

abbrevは、あるメジャーモードのときだけアクティブになる、モード特有(mode-specific)な定義をもつことができます。abbrevは、すべてのメジャーモードでアクティブになる、グローバル(global)な定義をもつこともできます。同じabbrevが、グローバルな定義と、異なるメジャーモードのための、さまざまなモード特有の定義をもつことができます。カレントのメジャーモードにたいするモード特有の定義は、グローバルな定義をオーバーライドします。

Abbrevモードが有効かにかかわらず、編集セッションの間に対話的にabbrevを定義できます。それ以降のセッションでリロードして使用するために、ファイルにabbrev定義のリストを保存することもできます。

abbrevの定義
------------

`C-x a g`  
ポイントの前の1つ以上の単語を使用して、それが展開結果となるabbrevを定義します(`add-global-abbrev`)。

`C-x a l`  
同じですが、カレントメジャーモードに特有のabbrevを定義します(`add-mode-abbrev`)。

`C-x a i g`  
バッファーの単語をabbrevとして定義します(`inverse-add-global-abbrev`)。

`C-x a i l`  
バッファーの単語を、モード特有のabbrevとして定義します(`inverse-add-mode-abbrev`)。

`M-x define-global-abbrev RET abbrev RET exp RET`  
abbrevを、expに展開されるabbrevとして定義します。

`M-x define-mode-abbrev RET abbrev RET exp RET`  
abbrevを、expに展開されるモード特有のabbrevとして定義します。

`M-x kill-all-abbrevs`  
すべてのabbrev定義を削除して、白紙状態にします。

C-x a g
add-global-abbrev
abbrevを定義する通常の方法は、abbrevに展開させたいテキストを入力して、ポイントをその後ろに配し、`C-x a g` (`add-global-abbrev`)とタイプします。これはミニバッファーを使ってabbrev自身を読み取り、ポイントの前の1つ以上の単語にたいするabbrevとして定義します。数引数を使用してポイントの前のいくつの単語が展開結果となるかを指定します。たとえば、上述したabbrevの‘`foo`’を定義するには、‘`find
outer otter`’とテキストをタイプしてから、`C-u 3 C-x a g f o o RET`とタイプします。

`C-x a g`の引数に0を指定すると、それは定義するabbrevの展開結果として、リージョンの内容を使用することを意味します。

C-x a l
add-mode-abbrev
`C-x a l` (`add-mode-abbrev`)は似ていますが、これはカレントのメジャーモードにたいする、モード特有のabbrevを定義します。引数の機能は`C-x
a g`と同じです。

C-x a i g
inverse-add-global-abbrev
C-x a i l
inverse-add-mode-abbrev
`C-x a i g` (`inverse-add-global-abbrev`)と`C-x a i l` (`inverse-add-mode-abbrev`)は、逆のことを行ないます。abbrevとなるテキストがすでにバッファーに存在する場合、これらのコマンドはミニバッファーに展開結果を指定することにより、abbrevを定義します。これらのコマンドは、この定義を使ってabbrevテキストを展開します。

define-mode-abbrev
define-global-abbrev
abbrevまたは展開結果をバッファーに入力せずに、コマンド`define-global-abbrev`で定義することができます。これは2つの引数 — abbrevと展開結果を読み取ります。コマンド`define-mode-abbrev`は、モード特有のabbrevにたいして同様のことを行います。

abbrevの定義を変更するには、単に新しい定義を作成するだけです。abbrevがすでに定義をもつ場合、abbrev定義コマンドはそれを置換する前に確認を求めます。

kill-all-abbrevs
abbrev定義を削除するには、`C-u - C-x a g`や`C-u - C-x a
l`のように、abbrev定義コマンドに負の引数を与えます。前者はグローバルな定義を削除し、後者はモード特有の定義を削除します。`M-x
kill-all-abbrevs`は、すべてのabbrevにたいしてグローバルとローカルの両方の定義を削除します。

abbrev展開の制御
----------------

Abbrevモードが有効な場合、バッファーのポイントの前にabbrevがあり、そこで自己挿入文字として空白文字か区切り文字(SPCやカンマなど)を挿入したときは、常にabbrevが展開されます。より正確には、単語を構成しない任意の文字はabbrevを展開し、単語を構成する任意の文字はabbrevの一部となります。もっとも一般的なabbrevの使用法は、まずabbrevを挿入し、それから区切り文字か空白文字を挿入してabbrevを展開する方法です。

abbrev-all-caps
abbrevの展開は、大文字小文字を維持します。つまり‘`foo`’は‘`find outer
otter`’に、‘`Foo`’は‘`Find outer
otter`’に展開されます。デフォルトでは‘`FOO`’は‘`Find Outer
Otter`’に展開されますが、変数`abbrev-all-caps`を非`nil`値に変更した場合は、‘`FIND
OUTER OTTER`’に展開されます。

以下はabbrevの展開を制御するコマンドです:

`M-'`  
プレフィクスと、その後の展開されるabbrevを分割します(`abbrev-prefix-mark`)。

`C-x a e`  
expand-abbrev

ポイントの前のabbrevを展開します。(`expand-abbrev`)。これはAッbレvモードが有効でなくても効果があります。

`M-x unexpand-abbrev`  
unexpand-abbrev

最後に展開したabbrevをアンドゥします。

`M-x expand-region-abbrevs`  
リージョンで見つかったいくつか、またはすべてのabbrevを展開します。

M-’
abbrev-prefix-mark
abbrevを展開して、その展開結果にプレフィクスをつけたい場合があるかもしれません。たとえば、‘`cnst`’が‘`construction`’に展開されるとき、これを使って‘`reconstruction`’を入力したいと思うかもしれません。しかし、`recnst`とタイプしてもうまくいきません。なぜなら、それがabbrevとして定義される必要があるからです。これは、プレフィクス‘`re`’とabbrevの‘`cnst`’の間で、コマンド`M-'` (`abbrev-prefix-mark`)を使うことにより行なうことができます。最初にまず‘`re`’を挿入します。そこで`M-'`をタイプします。これにより、コマンドが機能していることを示すためバッファーにハイフンが挿入されます。その後、abbrevの‘`cnst`’を入力します。このときバッファーには‘`re-cnst`’が含まれます。そこで単語を構成しない文字を挿入すると、abbrevの‘`cnst`’が‘`construction`’に展開されます。この展開ステップでは、`M-'`が使用中であることを示していたハイフンも削除されます。結果は期待した通り‘`reconstruction`’となります。

abbrevを展開せずにabbrevのテキストをバッファーに残したい場合、abbrevの後ろの区切り文字を`C-q`で挿入して、これを行なうことができます。したがって`foo
C-q ,`とタイプすると、それは展開されず、バッファーには‘`foo,`’が残ります。

間違ってabbrevを展開した場合、`C-/` (`undo`)で展開をアンドゥできます。これはabbrev展開による挿入をアンドゥし、それをabbrevテキストに戻します。期待する結果が展開されないabbrevと終端となる非単語文字の場合、`C-q`でクォートして終端文字を再挿入しなければなりません。`M-x
unexpand-abbrev`を使えば終端文字を削除せずに、最後の展開を取り消すことができます。

expand-region-abbrevs
`M-x
expand-region-abbrevs`は、リージョン内の定義されたabbrevを検索し、見つかったabbrevそれぞれにたいして、abbrevを展開結果に置き換えるか尋ねます。このコマンドはabbrevを使ってテキストを挿入したが、最初にAbbrevモードをオンにするのを忘れたときに便利です。これは特別なabbrev定義のセットで、複数のグローバルな置き換えを一度に行なうときにも便利です。このコマンドは、Abbrevモードが有効でなくても効果があります。

関数`expand-abbrev`は、`abbrev-expand-function`が指定する関数を呼び出すことにより展開を行ないます。この関数を変更することにより、abbrevの展開を自由に変更できます。section “Abbrev Expansion” in The Emacs Lisp Reference Manualを参照してください。

abbrevのテストと編集
--------------------

`M-x list-abbrevs`  
すべてのabbrev定義のリストを表示します。数引数を指定した場合は、ローカルなabbrevのリストだけを表示します。

`M-x edit-abbrevs`  
abbrevのリストを編集します。定義の追加、変更、削除ができます。

list-abbrevs
`M-x list-abbrevs`の出力は以下のようなものです:

    他のさまざまなテーブル…
    (lisp-mode-abbrev-table)
    "dk"          0    "define-key"
    (global-abbrev-table)
    "dfn"         0    "definition"

(空行に意味はありません。また他のabbrevテーブルは省略しています。)

カッコで括られた名前を含む行は、特定のabbrevテーブルのabbrevにたいするヘッダーです。`global-abbrev-table`はすべてのグローバルなabbrevを含み、その他のメジャーモードの後ろについたabbrevテーブルは、モード特有のabbrevを含みます。

それぞれのabbrevテーブルで、空行でない行は1つのabbrevの定義です。行の先頭の単語はabbrevです。その後ろの数字は、そのabbrevが展開された回数です。Emacsはこれを追跡することにより、実際に使用されているabbrevを調べて、ときどきしか使わないものを削除するのを助けます。行の最後の文字列はabbrevの展開結果です。

‘`(sys)`’とマークされているabbrevもいくつかあります。これらはsystem abbrevs(システムの略語)で、さまざまなモードにたいして事前に定義されており、ユーザーのabbrevファイルには保存されません(section “Abbrevs” in The Emacs Lisp Reference Manualを参照してください)。systemのabbrevを無効にするには、同じ名前で展開結果がabbrev自身と同じになるabbrevを定義し、それをabbrevファイルに保存してください。

edit-abbrevs
C-c C-c (Edit Abbrevs)
`M-x
edit-abbrevs`を使うと、Emacsバッファーでabbrevのリストを編集することにより、abbrev定義の追加、変更、killができます。リストの書式は、上記で説明した書式を同じです。abbrevのバッファーは`*Abbrevs*`と呼ばれ、モードはEdit-Abbrevsモードです。このバッファーで`C-c
C-c`をタイプすると、そのバッファーで指定されたabbrev定義がインストールされ、リストに定義されていないabbrevは削除されます。

コマンド`edit-abbrevs`は、実際には`list-abbrevs`と同じですが、`list-abbrevs`が単に`*Abbrevs*`を他のウィンドウに表示するのに比べ、このコマンドはそのバッファーを選択する点が異なります。

abbrevの保存
------------

以下のコマンドにより、編集セッション間でabbrev定義を維持できます。

`M-x write-abbrev-file RET file RET`  
すべてのabbrev定義の記述を、ファイルfileに書き込みます。

`M-x read-abbrev-file RET file RET`  
ファイルfileを読み込み、そこで指定されているabbrevを定義します。

`M-x define-abbrevs`  
カレントバッファーの定義からabbrevを定義します。

`M-x insert-abbrevs`  
すべてのabbrevとそれらの展開結果を、カレントバッファーに挿入します。

write-abbrev-file
`M-x
write-abbrev-file`は、ミニバッファーを使用してファイル名を読み取り、すべてのカレントのabbrev定義の記述を、そのファイルに書き込みます。これは後のセッションで使用するために、abbrev定義を保存するのに使われます。ファイルに保存されるテキストは一連のLisp式で、それが実行されると保存したときと同じabbrevを定義します。

read-abbrev-file
quietly-read-abbrev-file
abbrev-file-name
abbrev file
`M-x
read-abbrev-file`は、ミニバッファーを使用してファイル名を読み取り、ファイル内容に対応するabbrevを定義します。関数`quietly-read-abbrev-file`も同様ですが、これはエコーエリアにメッセージを表示しません。これを対話的に呼び出すことはできず、主にinitファイル([Init File](#Init-File)を参照してください)で使用されます。どちらの関数も引数に`nil`が指定されると、変数`abbrev-file-name`で与えられるファイルを使用します。この変数のデフォルトは`~/.emacs.d/abbrev_defs`です。これは標準のabbrev定義ファイルで、Emacsは起動時にこのファイルから自動的にabbrevをロードします(例外としてEmacsがバッチモードで開始されたときはabbrevファイルをロードしません。バッチモードについての説明は、[Initial Options](#Initial-Options)を参照してください)。

save-abbrevs
abbrevのどれかを変更した場合、Emacsは((`C-x s`や`C-x
C-c`などで)、すべてのファイルの保存するか尋ねるときにabbrevについても尋ねます。これは`abbrev-file-name`で指定したファイルに、それらを保存します。この機能は変数`save-abbrevs`を`nil`にセットすることにより抑止できます。`silently`にセットすることにより、確認なしでabbrevが保存されるようになります。

insert-abbrevs
define-abbrevs
コマンド`M-x insert-abbrevs`および`M-x
define-abbrevs`は、前のコマンドと似ていますが、Emacsバッファーのテキストにたいして機能します。`M-x
insert-abbrevs`は、カレントのabbrev定義の記述をカレントバッファーのポイントの後ろにテキストとして挿入します。`M-x
define-abbrevs`は、カレントバッファー全体を解析して、対応するabbrevを定義します。

動的abbrev展開
--------------

上記で説明したabbrev機能は、テキストの挿入にしたがい自動的に処理されますが、すべてのabbrevを明示的に定義しなければなりません。対照的に、動的abbrev(dynamic abbrevs)は、バッファーの内容から略語の展開結果を自動的に決定することができます、しかし動的abbrevの展開は、明示的に要求したときだけ行なわれます。

M-/
C-M-/
dabbrev-expand
dabbrev-completion
`M-/`  
バッファーのポイントの前の単語を動的abbrevとして、その略語で始まる単語を検索することにより展開します(`dabbrev-expand`)。

`C-M-/`  
ポイントの前の単語を動的abbrevとして補完します(`dabbrev-completion`)。

dabbrev-limit
たとえばバッファーが‘`does this follow `’が含んでいて、`f o
M-/`とタイプすると、これは‘`follow`’を挿入します。なぜならそれが‘`fo`’で始まる、そのバッファーの最後の単語だからです。`M-/`に数引数を指定すると、それはポイントから後方に検索して2番目、3番目、...の異なる展開結果を検索します。`M-/`を繰り返すと他の展開結果を後方に検索します。ポイントの前のテキストをすべて検索した後は、ポイントの後のテキストを検索します。変数`dabbrev-limit`が非`nil`の場合、それはバッファーの中で展開結果を探す範囲を指定します。

dabbrev-check-all-buffers
dabbrev-check-other-buffers
カレントバッファーを検索した後、通常`M-/`は他のバッファーを検索します。`dabbrev-check-all-buffers`と`dabbrev-check-other-buffers`は、他のバッファー(もし存在するなら)のどれが検索されたか決定するのに使用できます。

dabbrev-ignored-buffer-names
dabbrev-ignored-buffer-regexps
どのバッファーを検索するかを制御するには、変数`dabbrev-ignored-buffer-names`および`dabbrev-ignored-buffer-regexps`をカスタマイズします。前者の値は、スキップするバッファー名のリストです。後者の値は正規表現のリストで、バッファー名がこれらの正規表現のどれかにマッチした場合、動的abbrev展開はそのバッファーをスキップします。

`C-u -
M-/`のように`M-/`に負の引数を指定すると、これは最初にポイントの後ろの展開結果を検索し、その後は他のバッファーを検索し、ポイントの前の展開結果は最後に報告します。他の展開結果を探すために`M-/`を繰り返す場合は、引数に何もしていしないでください。`M-/`を繰り返すことにより、ポイントの後、その後はポイントの前の展開結果を巡回します。

動的abbrevを展開した後、その展開結果の元のコンテキストで展開結果の後ろに続く、追加の単語をコピーすることができます。コピーしたい追加の単語ごとに、単に`SPC
M-/`とタイプします。単語間のスペースおよび区切り文字は、単語とともにコピーされます。

`M-/`が展開する単語を決定する方法と、それを展開する方法を制御できます。[Dabbrev Customization](#Dabbrev-Customization)を参照してください。

コマンド`C-M-/` (`dabbrev-completion`)は、動的abbrevの補完を行ないます。利用可能な展開結果を1つずつ試すかわりに、これはすべてを検索して、それらがもつ共通のテキストを挿入します。共通部分がない場合、`C-M-/`は、通常の方法で選択することができる補完リストを表示します。[Completion](#Completion)を参照してください。

動的abbrev展開は、Abbrevモードとは完全に独立しています。`M-/`での単語の展開は、その単語が通常のabbrevとして定義されていることとは無関係です。

動的abbrevのカスタマイズ
------------------------

動的abbrev展開は通常、展開結果の検索で大文字小文字を無視します。したがって、展開結果と展開する単語は、大文字小文字が一致する必要はありません。

dabbrev-case-fold-search
この機能は変数`dabbrev-case-fold-search`により制御されます。この値が`t`の場合、検索で大文字小文字は無視されます。`nil`の場合、単語と展開結果は大文字小文字が一致していなければなりません。値が`case-fold-search`(デフォルト)の場合、変数`case-fold-search`が展開結果の検索で、大文字小文字を無視するかどうかを制御します([Lax Search](#Lax-Search)を参照してください)。

動的abbrev展開は通常、大文字小文字のパターンにしたがって展開結果を変換することにより、*展開する動的abbrev*の大文字小文字のパターンを維持します。

dabbrev-case-replace
変数`dabbrev-case-replace`は、動的abbrevの大文字小文字のパターンを維持するかどうかを制御します。この値が`t`の場合、動的abbrevの大文字小文字のパターンはほとんどのケースで維持されます。`nil`の場合、展開結果は常にそのままコピーされます。値が`case-replace`(デフォルト)の場合、変数`case-replace`が展開結果をそのままコピーするかどうかを制御します([Replacement and Lax Matches](#Replacement-and-Lax-Matches)を参照してください)。

しかし、展開結果が複雑にミックスされた大文字小文字のパターンを含む場合、そして動的abbrevがそのパターンにある程度マッチする場合、これらの変数の値にかかわらず、展開結果は常にそのままコピーされます。したがって、たとえばバッファーが`variableWithSillyCasePattern`というテキストを含む場合、`v
a M-/`とタイプすると、大文字小文字のパターンを含めて展開結果をコピーします。

dabbrev-abbrev-char-regexp
変数`dabbrev-abbrev-char-regexp`が非`nil`の場合、これは動的展開の目的のために、どの文字を単語の一部とするかを制御します。正規表現は2文字以上ではなく、ただ1文字だけにマッチしなければなりません。同じ正規表現が、どの文字が展開結果の一部となるかも決定します。値が`nil`(デフォルト)の場合は特別な意味をもちます。動的abbrev(たとえばポイント位置の単語)は単語構成文字から構成されますが、それらの展開結果は単語とシンボル文字のシーケンスから取得されます。これはプログラムソース内、および多くの言語による人間が読むことができるテキストにたいするシンボルの展開にたいして、一般的にこれは適切ですが、一般的ではない句読点を含むテキストバッファーにおいては、おそらくあなたが望むものではないかもしれません。そのような場合は、値`\"\\\\sw\"`がよい結果を生成するかもしれません。

dabbrev-abbrev-skip-leading-regexp
シェルスクリプトおよびmakefileでは、変数名にプレフィクス‘`$`’があるときと、ないときがあります。このタイプのテキストのためのメジャーモードは、オプションのプレフィクスを扱うために、変数`dabbrev-abbrev-skip-leading-regexp`をセットして、動的abbrev展開をカスタマイズできます。この値には、動的abbrev展開が無視すべきオプションのプレフィクスにマッチする正規表現を指定します。デフォルトは`nil`で、これは文字をスキップしないことを意味します

Dired (ディレクトリーエディター)
================================

Dired
file management
Diredはディレクトリー、およびオプションでそれのサブディレクトリーのリストを含む、Emacsバッファーを作成します。このバッファー内を移動するために、通常のEmacsコマンドと、リストされたファイルを操作するための、特別なコマンドを使うことができます。Diredはローカルとリモートの両方のディレクトリーで機能します。

通常はDiredバッファーは読み取り専用で、テキストの挿入はできません(とはいえWdiredモードではそれが可能。[Wdired](#Wdired)を参照されたい)。`d`や`x`のような通常のプリント文字は、特別なDiredコマンドに再定義されています。Diredコマンドには、カレントファイル(カレント行のファイルのこと)をマークしたり、フラグをつけるものがいくつかあり、他のコマンドは、マークされたファイルやフラグがつけられたファイルにたいして処理を行ないます。最初に特定のファイルをマークして、それらすべてにたいして1つのコマンドで操作を行なうのです。

Dired-Xパッケージは、Diredモードのためのさまざまな特別の機能を提供します。section “Dired-X” in Dired Extra User’s Manualを参照してください。

ディレクトリーのファイルのリストは、`C-x C-d` (`list-directory`)でも閲覧することができます。Diredとは異なり、このコマンドではリストされたファイルにたいする操作はできません。[Directories](#Directories)を参照してください。

Diredの起動
-----------

dired
C-x d
dired-listing-switches
Diredを呼び出すには、`C-x d` (`dired`)とタイプします。これはミニバッファーを使用してディレクトリー名を読み取り、そのディレクトリーのファイルを一覧するするDiredバッファーを開きます。ミニバッファーの引数に、ワイルドカードによるファイル名パターンを与えることもできます。この場合、Dliredバッファーには、そのパターンにマッチする、すべてのファイルが一覧されます。ディレクトリー部分にワイルドカードが出現することもあります。たとえば、

    C-x d  ~/foo/*.el  RET
    C-x d  ~/foo/*/*.el  RET

1つ目の例は、ディレクトリー‘`foo`’内の、拡張子‘`.el`’のすべてのファイルをリストします。2つ目の例は、‘`foo`’のすべてのサブディレクトリー内の、拡張子‘`.el`’のファイルをリストします。

ミニバッファー内では、通常のヒストリー、および補完のコマンドが使用できます。特に、`M-n`は(もしあれば)visitされているファイルの名前を配します([Minibuffer History](#Minibuffer-History)を参照)。

`C-x C-f` (`find-file`)にディレクトリー名を与えて、Diredを呼び出すこともできます。

変数`dired-listing-switches`は、ディレクトリーをリストするために、`ls`に与えるオプションを指定します。この文字列には、‘`-l`’が*含まれていなければなりません*。`dired`コマンドにプレフィクス引数を使用した場合、ディレクトリーの指定の前に、`ls`のためのスイッチを指定できます。スイッチが指定される方法は問いません。`ls`のスイッチには、引数を要求しない短いオプション(1文字)と、長いオプション(‘`--`’で始まり、引数は‘`=`’で指定される)を含めることができます。

dired-use-ls-dired
システムの`ls`コマンドが‘`--dired`’オプションをサポートする場合、Diredは自動的にそのオプションを渡します。これにより、Diredが名前を解析できないという特殊なファイル名にたいして、`ls`が特別なエスケープシーケンスを付します。Emacsセッションで最初にDiredを実行するとき、`ls`コマンドに‘`--dired`’オプションを指定して呼び出すことにより、そのスイッチをサポートするかどうかチェックします。exitコードが0の場合、それ以降Diredは‘`--dired`’オプションを使用し、それ以外の場合は使用しません。変数`dired-use-ls-dired`をカスタマイズすることにより、このチェックを抑止することができます。値`unspecified`(デフォルト)は、チェックを行なうことを意味します。その他の非`nil`値は、‘`--dired`’オプションを使用することを意味します。`nil`は、‘`--dired`’オプションを使用しないことを意味します。

MS-WindowsやMS-DOSシステム、およびいくつかのリモートシステムでは、Emacsが`ls`をエミュレートします。このエミュレーションのオプションと特性については、[ls in Lisp](#ls-in-Lisp)を参照してください。

dired-other-window
C-x 4 d
dired-other-frame
C-x 5 d
Diredバッファーを他のウィンドウに表示するには、`C-x 4 d` (`dired-other-window`)を使用します。`C-x 5 d` (`dired-other-frame`)は、Diredバッファーを別のフレームに表示します。

q (Dired)
quit-window, in Dired buffers
`q` (`quit-window`)とタイプすると、Diredバッファーは隠され(bury)ます。ウィンドウがそのバッファーのためだけに作成された場合は、そのウィンドウを削除します。

Diredバッファーでの移動
-----------------------

C-n (Dired)
C-p (Dired)
dired-next-line
dired-previous-line
Emacsの通常のカーソル移動コマンドは、Diredバッファーでも利用可能です。キー`C-n`と`C-p`はそれぞれ`dired-next-line`と`dired-previous-line`を実行して、行の先頭ではなくファイル名の先頭にカーソルを配するように、再定義されています。

SPC (Dired)
特に利便性のために、DiredでのSPCおよび`n`は、`C-n`と等価になっています。`p`は`C-p`と等価です(行の移動はDiredでは一般的な操作なので、タイプしやすいようにするべきです)。DEL(上に移動してフラグを外す)は、単なる上への移動でも便利なときがあります([Dired Deletion](#Dired-Deletion)を参照してください)。

dired-goto-file
j (Dired)
`j` (`dired-goto-file`)は、ミニバッファーを使用してファイル名の入力を求め、Diredバッファーで、そのファイルが記述されている行にポイントを移動します。

searching Dired buffers
dired-isearch-filenames
dired-isearch-filenames
dired-isearch-filenames-regexp
M-s f C-s (Dired)
M-s f M-C-s (Dired)
`M-s f C-s` (`dired-isearch-filenames`)は、Diredバッファーで前方へのインクリメンタル検索を行ないます。これはファイル名にたいするマッチだけを検索し、それ以外のバッファーのテキストは無視します。`M-s
f M-C-s` (`dired-isearch-filenames-regexp`)も同じことを行ないますが、これは正規表現による検索です。変数`dired-isearch-filenames`を`t`に変更した場合、通常の検索コマンドも検索対象がファイル名だけに制限されるようになります。たとえば`C-s`は、`M-s
f
C-s`と同様に振る舞います。変数の値が`dwim`の場合、ポイントの最初の位置がファイル名にあるときだけ、検索コマンドはファイル名にマッチします。インクリメンタル検索についての情報は、[Search](#Search)を参照してください。

複数ディレクトリーにたいするものも含めて、Diredバッファーでは追加の移動コマンドが利用可能です。[Subdirectory Motion](#Subdirectory-Motion)を参照してください。

Diredでのファイルの削除について
-------------------------------

flagging files (in Dired)
deleting files (in Dired)
もっともよく使われるDiredの使用法は、最初にファイルを削除するためにフラグ(flag)をつけて、その後にフラグがつけられたファイルを削除をする方法です。

`d`  
削除するために、このファイルにフラグをつけます(`dired-flag-file-deletion`)。

`u`  
削除フラグを外します(`dired-unmark`)。

`DEL`  
その行の削除フラグを外して、ポイントを前の行に移動します(`dired-unmark-backward`)。

`x`  
削除のフラグがつけられたファイルを削除します(`dired-do-flagged-delete`)。

d (Dired)
dired-flag-file-deletion
ファイルが記述されている行に移動して、`d` (`dired-flag-file-deletion`)とタイプすることにより、ファイルを削除するためのフラグをつけることができます。削除フラグは行頭に‘`D`’が表示されます。このコマンドはポイントを次の行に移動するので、`d`コマンドを繰り返すことにより、連続してファイルにフラグをつけることができます。数引数は繰り返し回数を指定します。負の引数は前のファイルにフラグをつけることを意味します。

リージョンがアクティブの場合、`d`コマンドはリージョンのすべてのファイルに削除のフラグをつけます。この場合、コマンドはポイントを移動せず、プレフィクス引数も無視します。

u (Dired deletion)
DEL (Dired)
ファイルを即座に削除せず、削除のフラグをファイルにつける理由は、意図しないファイルを削除する危険を軽減するためです。フラグがついたファイルをDiredに削除をさせる前に、コマンド`u`またはDELで、削除フラグを外すことができます。`u` (`dired-unmark`)は`d`と同じように機能しますが、これはフラグをつけるのではなくフラグを外します。DEL (`dired-unmark-backward`)は、上に移動してフラグを外します。これは`u`に引数−1を指定するのと同じです。どちらのコマンドも、数引数は繰り返し回数で、負の引数は反対方向にフラグを外していくことを意味します。リージョンがアクティブの場合、ポイントを移動せずにリージョン内のすべてのファイルのフラグを外します。

x (Dired)
dired-do-flagged-delete
フラグがついたファイルを削除するには、`x` (`dired-do-flagged-delete`)とタイプします。このコマンドは削除フラグがついた、すべてのファイルのリストを表示して、確認を求めます。もしこれに`yes`と応えた場合、Diredはフラグがついたファイルを削除して、それらのファイルにたいするDiredバッファーの行を削除します。Diredバッファーの行数は少し減り、バッファーは選択されたまま残ります。

確認を求められたとき`no`と応えるか、`C-g`で中断した場合は、即座にDiredに戻ります。バッファーの削除フラグはそのまま残り、実際に削除されたファイルはありません。

recursive deletion
dired-recursive-deletes
空ディレクトリーは他のファイルと同様に削除できますが、Diredは通常、空でないディレクトリーは削除できません。しかし変数`dired-recursive-deletes`が非`nil`の場合には、Diredはディレクトリーの内容も含めて、空でないディレクトリーを削除できます。`dired-recursive-deletes`を`nil`にセットしている場合でも、ディレクトリーの内容すべてについて問い合わせされることなく、ディレクトリーを再帰的に削除したいこともあるかもしれません。これには若干の危険が伴います。変数の値が`always`の場合は、さらに危険性は増すとはいえ、Diredは空でないディレクトリーを再帰的に削除するでしょう。

`dired-recursive-deletes`を`nil`にセットしている場合でも、ディレクトリーの内容すべてについて問い合わせされることなく、ディレクトリーを再帰的に削除したいこともあるかもしれません。たとえば、多くのディレクトリーにたいして、それらすべてを安全に削除できると確信がもてるときは、それらに削除のマークを付与したいと思うかもしれません。空でないディレクトリーすべてにたいして、確認が求められますが、`all`と応えた場合は、それ以上の問い合わせなしで残りすべてのディレクトリーが削除されます。

delete-by-moving-to-trash, and Dired
変数`delete-by-moving-to-trash`を`t`に変更した場合、上記の削除コマンドは対象となるファイルおよびディレクトリーを削除するかわりに、システムのTrash(ゴミ箱)に移動します。[Misc File Ops](#Misc-File-Ops)を参照してください。

ファイルを削除する代替手段は、それらを`m`でマークして`D`で削除する方法です。[Operating on Files](#Operating-on-Files)を参照してください。

大量のファイルに一度にフラグをつける
------------------------------------

flagging many files for deletion (in Dired)
コマンド`#`、`~`、`.`、`% &`、`% d`は、ファイル名にもとづき多くのファイルにフラグをつけます。

`#`  
すべての自動保存ファイル(名前の最初と最後が‘`#`’のファイル)にたいして、削除のフラグをつけます([Auto Save](#Auto-Save)を参照してください)。

`~`  
すべてのバックアップファイル(名前の最後が‘`~`’のファイル)にたいして、削除のフラグをつけます([Backup](#Backup)を参照してください)。

`. (ピリオド)`  
余分な番号付きバックアップファイルに、削除のフラグをつけます。一番古いものと、一番新しいバックアップのいくつかは除外され、その中間のファイルにフラグがつけられます。

`% &`  
簡単にファイルを再作成できることを示唆する、特定の種類の名前をもつすべてのファイルに削除のフラグをつけます。

`% d regexp RET`  
正規表現regexpにマッチする名前の、すべてのファイルに削除のフラグをつけます。

\# (Dired)
dired-flag-auto-save-files
deleting auto-save files
`#` (`dired-flag-auto-save-files`)は、名前が自動保存ファイルに見える — つまり名前の最初と最後が‘`#`’の、すべてのファイルにフラグをつけます。[Auto Save](#Auto-Save)を参照してください。

~ (Dired)
dired-flag-backup-files
`~` (`dired-flag-backup-files`)は、名前がバックアップファイルであることを告げる — つまり名前の最後が‘`~`’の、すべてのファイルにフラグをつけます。[Backup](#Backup)を参照してください。

. (Dired)
dired-kept-versions
dired-clean-directory
`.` (ピリオド、`dired-clean-directory`)は、いくつかのバックアップファイルだけに削除のフラグをつけます。つまり、最古と最新のいくつかのファイルを除く、すべてのファイルです。残すべき最新バージョンの数は通常、変数`dired-kept-versions`(`kept-new-versions`では*ありません*。これは保存時だけ適用されます)で与えられます。残すべき最古バージョンの数は、変数`kept-old-versions`により与えられます。

`C-u 3
.`のように、ピリオドに正の数引数を指定すると、`dired-kept-versions`をオーバーライドして、残すべき最新バージョンの数を指定します。負の引数は`kept-old-versions`をオーバーライドします。引数の値にマイナスをつけると、残すべき最古バージョンの数を指定します。

% & (Dired)
dired-flag-garbage-files
dired-garbage-files-regexp
deleting some backup files
`% &` (`dired-flag-garbage-files`)は、変数`dired-garbage-files-regexp`で指定される正規表現に、名前がマッチするファイルにフラグをつけます。デフォルトでは、TEXにより生成される‘`.bak`’ファイルと、`patch`により生成される‘`.orig`’ファイルと‘`.rej`’ファイルにマッチします。

dired-flag-files-regexp
% d (Dired)
`%
d`は、指定された正規表現に名前がマッチするすべてのファイルにフラグをつけます(`dired-flag-files-regexp`)。マッチングにはファイル名の非ディレクトリー部分だけが使用されます。マッチのアンカーとして‘`^`’と‘`$`’を使用できます。`%
d`を使用するとき、特定のサブディレクトリーを隠して除外できます。[Hiding Subdirectories](#Hiding-Subdirectories)を参照してください。

Diredのファイルをvisitする
--------------------------

Diredバッファーにリストされたファイルをvisitしたり、調べるためのDiredコマンドが、いくつかあります。これらのコマンドは、すべてカレント行のファイルに適用されます。そのファイルが実際にはディレクトリーの場合、これらのコマンドは(別のDiredバッファーを作成して)、そのサブディレクトリーにたいしてDiredを呼び出します。

`f`  
f (Dired)

dired-find-file

`C-x
C-f`とタイプしてファイル名を指定したときと同じように、カレント行に記述されたファイルをvisitします(`dired-find-file`)。[Visiting](#Visiting)を参照してください。

`RET`; `e`  
RET (Dired)

e (Dired)

`f`と等価です。

`o`  
o (Dired)

dired-find-file-other-window

`f`と同じですが、そのファイルのバッファーに別のウィンドウを使用します(`dired-find-file-other-window`)。Diredバッファーは、最初のウィンドウに表示されたまま残ります。これは`C-x
4 C-f`を使用して、ファイルをvisitするのと似ています。[Windows](#Windows)を参照してください。

`C-o`  
C-o (Dired)

dired-display-file

カレント行に記述されたファイルをvisitし、そのバッファーを別のウィンドウで表示しますが、そのウィンドウを選択しません(`dired-display-file`)。

`mouse-1`; `mouse-2`  
dired-mouse-find-file-other-window

クリックした名前のファイルをvisitします(`dired-mouse-find-file-other-window`)。これは`o`コマンドのように、ファイルの表示に別のウィンドウを使います。

`v`  
v (Dired)

dired-view-file

カレント行に記述されたファイルを、Viewモードで表示します(`dired-view-file`)。Viewモードは、バッファーを移動するための便利なコマンドを提供しますが、バッファーの変更はできません。[View Mode](#View-Mode)を参照してください。

`^`  
^ (Dired)

dired-up-directory

カレントディレクトリーの親ディレクトリーをvisitします(`dired-up-directory`)。これは、`..`の行に移動して`f`をタイプするのと等価です。

Diredでのマークとフラグ
-----------------------

marking many files (in Dired)
ファイルに‘`D`’というフラグをつけるのではなく、他の文字(通常は‘`*`’)でファイルをマークすることもできます。ほとんどのDiredコマンドは、‘`*`’でマークされたファイルにたいしてコマンドを処理します。フラグ付けされたファイルだけに作用するコマンドは、それらのファイルを削除する`x`だけです。

以下は‘`*`’でマークしたり、マークを外したり、マークにたいして操作を行なうコマンドです(ファイルにたいしてフラグをつけたり外すコマンドについては、[Dired Deletion](#Dired-Deletion)を参照してください)。

`m`; `* m`  
m (Dired)

\* m (Dired)

dired-mark

カレントファイルを‘`*`’でマークします(`dired-mark`)。リージョンがアクティブの場合、かわりにリージョン内のすべてのファイルをマークします。そうでない場合、数引数nが与えられたときは、カレント行から数えて、次のn個のファイルまでをマークします(nが負の場合、前の−n個のファイルをマークします)。サブディレクトリーのヘッダー行(subdirectory header line: [Subdirectories in Dired](#Subdirectories-in-Dired)を参照)で呼び出さた場合、このコマンドはそのサブディレクトリー内のすべてのファイルをマークします。

`* *`  
\* \* (Dired)

dired-mark-executables

marking executable files (in Dired)

すべての実行ファイルを‘`*`’でマークします(`dired-mark-executables`)。数引数を指定すると、それらのファイルのマークを外します。

`* @`  
\* @ (Dired)

dired-mark-symlinks

marking symbolic links (in Dired)

すべてのシンボリックリンクを、‘`*`’でマークします(`dired-mark-symlinks`)。数引数を指定すると、それらのファイルのマークを外します。

`* /`  
\* / (Dired)

dired-mark-directories

marking subdirectories (in Dired)

`.`と`..`を除く、すべてのディレクトリーを‘`*`’でマークします(`dired-mark-directories`)。数引数を指定すると、それらのディレクトリーのマークを外します。

`* s`  
\* s (Dired)

dired-mark-subdir-files

`.`と`..`を除く、カレントのサブディレクトリー内のすべてのファイルをマークします(`dired-mark-subdir-files`)。

`u`; `* u`  
u (Dired)

\* u (Dired)

dired-unmark

この行の任意のマークを外します(`dired-unmark`)。リージョンがアクティブの場合は、かわりにリージョン内のすべてのファイルのマークを外します。そうでない場合、数引数nが与えられた場合は、カレントファイルから数えて、次のn個のファイルのマークを外します(nが負の場合、前の−n個のファイルのマークを外します)。

`DEL`; `* DEL`  
\* DEL (Dired)

dired-unmark-backward

unmarking files (in Dired)

ポイントを前の行に移動して、その行のマークを外します(`dired-unmark-backward`)。リージョンがアクティブの場合、かわりにリージョン内のすべてのファイルのマークを外します。そうでない場合、数引数nが与えられたときは、カレントファイルから数えて、前のn個のファイルのマークを外します(nが負の場合、次の−n個のファイルのマークを外します)。

`* !`; `U`  
\* ! (Dired)

U (Dired)

dired-unmark-all-marks

Diredバッファーの、すべてのファイルのマークを外します(`dired-unmark-all-marks`)。

`* ? markchar`; `M-DEL`  
\* ? (Dired)

M-DEL (Dired)

dired-unmark-all-files

文字markcharを使用する、すべてのマークを外します(`dired-unmark-all-files`)。`M-DEL`で呼び出された場合、このコマンドはmarkcharの入力を求めます。markcharは1文字です — これを終了させるためにRETを使用しないでください。以下の`*
c`の説明を参照してください。これは1つのマーク文字を、他の文字に置換します。

数引数を指定した場合、このコマンドはマークされたファイルごとに、マークを外すか確認します。`y`はyes(はい)で、`n`はno(いいえ)、`!`は残りのファイルにたいして確認を行なわずにマークを外します。

`* C-n`; `M-}`  
dired-next-marked-file

\* C-n (Dired)

M-} (Dired)

次にマークされたファイルへ下に移動します(`dired-next-marked-file`)。“マークされた”ファイルとは、任意の種類のマークがついているファイルです。

`* C-p`; `M-{`  
dired-prev-marked-file

\* C-p (Dired)

M-{ (Dired)

前のマークされたファイルへ、上に移動します(`dired-prev-marked-file`)。

`t`; `* t`  
t (Dired)

\* t (Dired)

dired-toggle-marks

toggling marks (in Dired)

すべてのマークを切り替えます(`dired-toggle-marks`)。つまり、‘`*`’でマークされたファイルのマークを外し、マークされていないファイルを‘`*`’でマークします。他の方法でマークされたファイルは影響を受けません。

`* c old-markchar new-markchar`  
\* c (Dired)

dired-change-marks

文字old-markcharを使ったすべてのマークを、文字new-markcharを使ったマークに置き換えます(`dired-change-marks`)。このコマンドは主に‘`*`’や‘`D`’以外の文字を使用したマークを作成するのに使われます。引数は1文字です — 終了させるためにRETを使用しないでください。

このコマンドは、マーク文字としてほとんどの任意の文字を使用できるので、ファイルをさまざまなクラスに分類することができます。old-markcharがスペース(‘`
`’)の場合、このコマンドは、すべてのマークされていないファイルにたいして処理を行ないます。new-markcharがスペースの場合、このコマンドは対象となるファイルのマークを外します。

このコマンドの威力を知る例として、以下ではマークされていないファイルすべてにフラグ‘`D`’をセットして、すでに‘`D`’フラグがついているものはフラグを外しています:

    * c D t  * c SPC D  * c t SPC

この例では、すでに‘`t`’でマークされたファイルがないと仮定しています。

`% m regexp RET`; `* % regexp RET`  
dired-mark-files-regexp

% m (Dired)

\* % (Dired)

名前が正規表現regexpにマッチするすべてのファイルを、(‘`*`’で)マークします(`dired-mark-files-regexp`)。このコマンドは`%
d`と似ていますが、‘`D`’のフラグをつけるかわりに、‘`*`’でマークします。

マッチングには、ファイル名のディレクトリー部分以外だけが使用されます。マッチのアンカーとして、‘`^`’と‘`$`’が使用できます。サブディレクトリーを一時的に隠すことにより、それらを除外できます([Hiding Subdirectories](#Hiding-Subdirectories)を参照してください)。

`% g regexp RET`  
dired-mark-files-containing-regexp

% g (Dired)

finding files containing regexp matches (in Dired)

*内容(contents)*に正規表現regexpにたいするマッチを含むすべてのファイルを、(‘`*`’で)マークします(`dired-mark-files-containing-regexp`)。このコマンドは`%
m`と似ていますが、ファイル名ではなくファイル内容を検索する点が異なります。ファイルがEmacsバッファーでvisitされていて、`dired-always-read-filesystem`が`nil`(デフォルト)なら、このコマンドはファイルを再visitせずにバッファーの内容を調べるので、ディスク上のファイル内容が、最後にvisitしたときから変更されている場合は、矛盾した結果になるかもしれません。これを望まない場合は、このコマンドを呼び出す前に、バッファーでvisitされているファイルをリバートしたり、それらのバッファーにたいして`Auto-Revert`モードをオンに切り替えたいと思うかもしれません。[Reverting](#Reverting)を参照してください。ファイルをリバートしたりAuto-Revertモードをオンにせずに、このコマンドに常にファイルを再visitさせたい場合は、`dired-always-read-filesystem`を非`nil`にセットしたいと思うかもしれません。

`C-/`; `C-x u`; `C-_`  
C-\_ (Dired)

dired-undo

Diredバッファーでの、マークの追加や削除などの変更をアンドゥします(`dired-undo`)。*このコマンドは実際のファイル操作をリバートしたり、失われたファイルを回復しません!* これは単にバッファー自身にたいする変更をアンドゥするだけです。

ファイルを操作するコマンドの後でこれを使用することにより、問題が起こる場合もあります。たとえば1つ以上のファイルをリネームしてから、Diredバッファーで`dired-undo`により元の名前にリストアした場合、Diredバッファーと、そのディレクトリーの実際の内容が、同期しなくなります。

ファイルにたいする操作
----------------------

operating on files in Dired
このセクションでは、1つまたは複数のファイルを操作する、基本的なDiredコマンドを説明します。これらのコマンドはすべて大文字で、引数を読み取ったり、実際に動作する前に確認を求めるのに、ミニバッファーを使用します。これらのコマンドはすべて、以下の方法により操作するファイルを指定します:

-   コマンドに数引数nを与えると、カレントファイルから数えて、次のn個のファイルを操作します(nが負の場合、コマンドはカレント行の前の、−n個のファイルを操作します)。

-   上記以外の場合、‘`*`’でマークされたファイルがあるときは、コマンドはそれらすべてのファイルを操作します。

-   上記以外の場合、コマンドはカレントファイルだけを操作します。

コマンド`!`や‘`%`’のような他のDiredコマンドにも、操作対象となるファイルを決定するのに、同じ規則を使うものがあります。

dired-dwim-target
two directories (in Dired)
ファイルのコピーやリネーム、それらにたいするリンクを作成するような、対象ディレクトリーを尋ねるコマンドは、操作のためにデフォルトの対象ディレクトリーの推論を試みます。これらのコマンドは通常、Diredバッファーのデフォルトディレクトリーを提案しますが、変数`dired-dwim-target`が非`nil`で、次のウィンドウに他のDiredバッファーが存在しない場合は、その他のバッファーのディレクトリーをかわりに提案します。

以下は、ファイルにたいして操作を行なうDiredコマンドです。

`C new RET`  
指定されたファイルをコピーします(`dired-do-copy`)。引数newはコピー先のディレクトリー、または(1つのファイルをコピーする場合は)新しいファイル名です。これはシェルコマンド`cp`と似ています。

dired-copy-preserve-time

`dired-copy-preserve-time`が非`nil`の場合、このコマンドでコピーすることにより、‘`cp
-p`’でコピーしたときのように、古いファイルの最終修正時刻(modification time)が保持されます。

dired-recursive-copies

recursive copying

変数`dired-recursive-copies`は、(‘`cp
-r`’のように)ディレクトリーを再帰的にコピーするかを制御します。デフォルトは`top`で、これはディレクトリーを再帰的にコピーする前に、確認を求めることを意味します。

`D`  
dired-do-delete

D (Dired)

指定されたファイルを削除します(`dired-do-delete`)。これはシェルコマンド`rm`と似ています。

このセクションの他のコマンドと同様、このコマンドは*マークされたファイル*、または次のn個のファイルを操作します。対照的に`x` (`dired-do-flagged-delete`)は、フラグがついたすべてのファイルを削除します。

dired-do-rename

R (Dired)

renaming files (in Dired)

moving files (in Dired)

`R new RET`  
指定されたファイルをリネームします(`dired-do-rename`)。1つのファイルをリネームする場合、引数newはファイルの新しい名前です。複数のファイルをリネームする場合、引数newはファイルを移動するディレクトリーです(これはシェルコマンド`mv`と似ています)。

Diredはリネームされたファイルに関連付けられたバッファーによりvisitされたファイルの名前を自動的に変更するので、これらのバッファーは新しい名前を参照します。

dired-do-hardlink

H (Dired)

hard links (in Dired)

`H new RET`  
指定されたファイルのハードリンクを作成します(`dired-do-hardlink`)。これはシェルコマンド`ln`と似ています。引数newはリンクを中に作成するディレクトリー、または(1つのリンクだけを作成する場合は)リンクに与える名前です。

dired-do-symlink

S (Dired)

symbolic links (creation in Dired)

`S new RET`  
指定されたファイルのシンボリックリンクを作成します(`dired-do-symlink`)。これは‘`ln
-s`’と似ています。引数newはリンクを中に作成するディレクトリー、または(1つのリンクだけを作成する場合は)リンクに与える名前です。

dired-do-chmod

M (Dired)

changing file permissions (in Dired)

`M modespec RET`  
指定されたファイルのモード(パーミッションビットとも呼ばれる)を変更します(`dired-do-chmod`)。modespecには、`chmod`プログラムで扱われる引数のような、8進かシンボル表記を指定できます。

dired-do-chgrp

G (Dired)

changing file group (in Dired)

`G newgroup RET`  
指定されたファイルのグループを、newgroupに変更します(`dired-do-chgrp`)。

dired-do-chown

O (Dired)

changing file owner (in Dired)

`O newowner RET`  
指定されたファイルの所有者を。newownerに変更します(`dired-do-chown`。ほとんどのシステムでは、これを行なうことができるのはスーパーユーザーだけです)。

dired-chown-program

変数`dired-chown-program`は、処理を行なうために使用するプログラムの名前を指定します(システムが異なると、`chown`が違う場所に配されている場合があるので、この変数が必要)。

dired-do-touch

T (Dired)

changing file time (in Dired)

`T timestamp RET`  
指定されたファイルにtouchします。これはファイルの修正時刻を、現在時刻で更新することを意味します。これはシェルコマンド`touch`に似ています。

dired-do-print

P (Dired)

printing files (in Dired)

`P command RET`  
指定されたファイルを印刷します(`dired-do-print`)。それらを印刷するためのコマンドを指定しなければなりませんが、ミニバッファー開始時には、変数`lpr-command`および`lpr-switches`(`lpr-buffer`が使用するのと同じ変数。[Printing](#Printing)を参照してください)を使用することにより推定された、適切な初期値が示されます。

dired-do-compress

Z (Dired)

compressing files (in Dired)

`Z`  
指定されたファイルを圧縮します(`dired-do-compress`)。そのファイルがすでに圧縮されたように見える場合は、かわりにそれを解凍します。マークされたファイルはそれぞれ、自身のアーカイブ内に圧縮されます。これには利用可能なら`gzip`、それ以外では`compress`が使用されます。ディレクトリー名にたいしては、このコマンドは`tar`コマンドの出力に`gzip`をパイプして実行することにより、そのディレクトリーのすべてのファイルを含む、圧縮アーカイブ`.tar.gz`を生成します。圧縮されたディレクトリーの解凍は、アーカイブファイル`.tar.gz`や`.tgz`上で`Z`をタイプすることにより、ファイル名から拡張子を除いた名前のディレクトリー内にアーカイブ内のすべてのファイルが解凍されます。

dired-do-compress-to

c (Dired)

`c`  
指定されたファイルを、ファイルシステム上のどこかにある1つのアーカイブに圧縮します(`dired-do-compress-to`)。圧縮アルゴリズムはアーカイブの拡張子により決定されます。`dired-compress-files-alist`を参照してください。

epa-dired-do-decrypt

:d (Dired)

decrypting files (in Dired)

`:d`  
指定されたファイルを復号化します(`epa-dired-do-decrypt`)。section “Dired integration” in EasyPG Assistant User’s Manualを参照してください。

epa-dired-do-verify

:v (Dired)

verifying digital signatures on files (in Dired)

`:v`  
指定されたファイルのデジタル署名を検証します(`epa-dired-do-verify`)。section “Dired integration” in EasyPG Assistant User’s Manualを参照してください。

epa-dired-do-sign

:s (Dired)

signing files (in Dired)

`:s`  
指定されたファイルにデジタル署名します(`epa-dired-do-sign`)。section “Dired integration” in EasyPG Assistant User’s Manualを参照してください。

epa-dired-do-encrypt

:e (Dired)

encrypting files (in Dired)

`:e`  
指定されたファイルを暗号化します(`epa-dired-do-encrypt`)。section “Dired integration” in EasyPG Assistant User’s Manualを参照してください。

dired-do-load

L (Dired)

loading several files (in Dired)

`L`  
指定されたEmacs Lispファイルをロードします(`dired-do-load`)。[Lisp Libraries](#Lisp-Libraries)を参照してください。

dired-do-byte-compile

B (Dired)

byte-compiling several files (in Dired)

`B`  
指定されたEmacs Lispファイルをバイトコンパイルします(`dired-do-byte-compile`)。section “Byte Compilation” in The Emacs Lisp Reference Manualを参照してください。

A (Dired)

dired-do-find-regexp

search multiple files (in Dired)

`A regexp RET`  
指定されたすべてのファイルにたいして、正規表現regexpを検索します(`dired-do-find-regexp`)。

このコマンドは`xref-find-references` (see [Identifier Search](#Identifier-Search))の変種で、必要に応じて、[Xref Commands](#Xref-Commands)で説明されているコマンドを使用することにより、マッチ間を移動したり、それらを表示することができる`*xref*`バッファーを表示します。

grep-find-ignored-files (Dired)

grep-find-ignored-directories (Dired)

マークされたファイルやディレクトリーがある場合、このコマンドはそれらのディレクトリーにあるすべてのファイルとサブディレクトリーを再帰的に検索します。ただし名前が`grep-find-ignored-files`にマッチするファイルと、`grep-find-ignored-directories`にマッチするサブディレクトリーは除外されます。

Q (Dired)

dired-do-find-regexp-and-replace

search and replace in multiple files (in Dired)

`Q regexp RET to RET`  
指定された各ファイルにたいして`query-replace-regexp`を行い、regexpにたいするマッチを、文字列toに置換します(`dired-do-find-regexp-and-replace`)。

このコマンドは`xref-query-replace-in-results`の変種です。これはregexpにたいするすべてのマッチをリストする`*xref*`バッファーを表示します。このバッファーでは特別なコマンド(see [Xref Commands](#Xref-Commands))を使用できます。特に、問い合わせつき置換のループ(query replace loop)をexitした場合は、そのバッファーで更に置換を行なうために`r`を使用できます。[Identifier Search](#Identifier-Search)を参照してください。

`dired-do-find-regexp`と同様に、マークされたファイルがディレクトリーの場合、このコマンドはそれらのディレクトリー内、およびそれらのサブディレクトリーのすべてのファイルの置換を再帰的に行います。ただし、名前が`grep-find-ignored-files`にマッチするファイル、および名前が`grep-find-ignored-directories`にマッチするサブディレクトリーは除外されます。

Diredでのシェルコマンド
-----------------------

shell commands, Dired
dired-do-shell-command
! (Dired)
X (Dired)
Diredコマンド`!` (`dired-do-shell-command`)は、ミニバッファーでシェルのコマンド文字列を読み取り、そのシェルコマンドを1つ以上のファイルにたいして実行します。シェルコマンドが処理するファイルは、Diredコマンドが操作するファイルを決定する方法と同じです([Operating on Files](#Operating-on-Files)を参照してください)。コマンド`X`は、`!`の別名です。

コマンド`&` (`dired-do-async-shell-command`)は同じことを行ないますが、これはシェルコマンドを非同期で実行する点が異なります(`!`でシェルコマンドの最後に文字‘`&`’を追加しても、同じことを行なうことができます)。コマンドが複数のファイルを処理する場合、ファイルごとに指定したシェルコマンドの複数コピーを並行で実行します。例外として、指定されたシェルコマンドが‘`;`’または‘`;&`’で終わる場合、バックグラウンドで実行されるシェルコマンドは、各ファイルにたいして順番に実行されます。Emacsは次のコマンドを実行する前に、呼び出したシェルコマンドが終了するのを待ちます。

`!`と`&`のどちらも、シェルコマンドの作業ディレクトリーは、Diredバッファーのトップレベルのディレクトリーです。

`!`または`&`に複数ファイルを処理させる場合、シェルコマンド文字列は、シェルコマンドにそれらのファイルを渡す方法を決定します。

-   コマンド文字列の中で、空白文字に囲まれた‘`*`’を使用した場合、コマンドは1度だけ実行され、‘`*`’はファイル名のリストに置換されます。ファイル名の順番は、Diredバッファーでの出現順になります。

    したがって`! tar cf foo.tar *
    RET`は、ファイル名全体のリストにたいして`tar`を実行し、それらをtarファイル`foo.tar`に格納します。

    空白文字で囲まれたシェルのワイルドカードとして‘`*`’を使用したい場合は、‘`*""`’と記述します。シェルではこれは‘`*`’と等価です。しかし‘`*`’が空白文字で囲まれていないので、Diredはこれを特別に扱うことができるのです。

-   上記以外の場合で、コマンド文字列が空白文字で囲まれた‘`?`’、または‘`` `?` ``’を含むとき、Emacsは*各ファイル*ごとに一度シェルコマンドを実行します。その際、‘`?`’および‘`` `?` ``’はカレントファイルに置換されます。コマンドで複数回‘`?`’または‘`` `?` ``’を使用でき、それぞれ同じファイル名に置換されます。これらを‘`*`’とともに使用した場合、このコマンドはエラーをシグナルします。

-   コマンド文字列が‘`*`’、‘`?`’、‘`` `?` ``’のいずれも含まない場合、Emacsは各ファイルにたいしてシェルコマンドを1度実行し、その際ファイル名はコマンド文字列の最後に追加されます。たとえば`!
    uudecode RET`は、各ファイルにたいして`uudecode`を実行します。

もっと複雑な方法でファイル名を繰り返すには、明示的なシェルループを使用したいと思うかもしれません。たとえば以下は、各ファイルをuuencodeして、入力ファイル名に‘`.uu`’を追加して出力ファイル名を作成する例です:

    for file in * ; do uuencode "$file" "$file" >"$file".uu; done

以下は、‘`` `?` ``’表記による同じ例です:

    uuencode ? ? > `?`.uu

コマンド`!`および`&`は、新しいファイル、または変更されたファイルを表示するために、Diredバッファーを更新しようとはしません。なぜならこれらのコマンドは、どのファイルが変更されたかを知らないからです。Diredバッファーを更新するには、`g`を使用します([Dired Updating](#Dired-Updating)を参照してください)。

Diredの外でシェルコマンドを実行する情報に関しては、[Single Shell](#Single-Shell)を参照してください。

Diredでのファイル名の変更
-------------------------

このセクションでは、ファイル名を系統的な方法で変更する、Diredコマンドを説明します。各コマンドは、既存の名前を変換することにより作成される新しい名前を使って、マークされたファイルのいくつか、またはすべてのマークされたファイルを操作します。

基本的なDiredのファイル操作コマンド([Operating on Files](#Operating-on-Files)を参照してください)と同じように、ここで説明するコマンドは次のnファイル、または‘`*`’でマークされたすべてのファイル、またはカレントファイルにたいして操作を行ないます(ファイルをマークする方法は[Marks vs Flags](#Marks-vs-Flags)で説明されています)。

このセクションで説明するすべてのコマンドは、*対話的*に機能します。つまり候補となるファイルごとに確認を求めます。したがって、実際に操作が必要なファイルより多くのファイルを選択(たとえばregexpにより多くのファイルを選択)して、コマンドが確認を求めるときに`y`または`n`をタイプすることにより、選択されたファイルを絞り込むことができます。

`% u`  
選択されたファイルを、大文字の名前にリネームします(`dired-upcase`)。古いファイル名が`Foo`と`bar`の場合、新しい名前は`FOO`と`BAR`になります。

`% l`  
dired-downcase

% l (Dired)

downcase file names

選択されたファイルを、小文字の名前にリネームします(`dired-downcase`)。古いファイル名が`Foo`と`bar`の場合、新しい名前は`foo`と`bar`になります。

`% R from RET to RET`; `% C from RET to RET`; `% H from RET to RET`; `% S from RET to RET`  
% S (Dired)

dired-do-symlink-regexp

これら4つのコマンドは、それぞれリネーム、コピー、ハードリンクの作成、ソフトリンクの作成を行い、古いファイル名にたいして正規表現による置換を行って、新しい名前を作成します。

正規表現の置換を行なう4つのコマンドは、実際には選択されたファイルの名前にたいして検索と置換を行ないます。これらのコマンドは2つの引数を読み取ります。それは式fromと、置換パターンtoです。これらは古いファイル名にマッチしたfromを、toに置き換えます。`replace-regexp` ([Regexp Replace](#Regexp-Replace)を参照してください)のように、古い名前にマッチしたパターンの全体または一部を参照するために、toの中で‘`\&`’や‘`\digit`’を使用できます。正規表現がファイル名の複数の箇所にマッチする場合は、最初のマッチだけが置換されます。

たとえば`% R ^.*$ RET x-\&
RET`は、選択された各ファイルの名前の前に‘`x-`’を追加してリネームします。逆に各ファイル名の前の‘`x-`’を削除することも可能です。1つは`%
R ^x-\(.*\)$ RET \1 RET`とする方法です。他にも`% R ^x- RET
RET`とする方法もあります(ファイル名の範囲を指定するために、アンカーへのマッチ‘`^`’および‘`$`’を使用しています)。

置換処理は通常、ファイルのディレクトリー名は考慮しません。これはディレクトリーにあるファイル名だけを操作します。しかし数引数を0にした場合、置換はディレクトリー名を含めた絶対ファイル名に作用します(非0の引数は、操作するファイルの個数を指定します)。

一連のファイルを操作対象に選択するために、それらを操作するときに使うのと同じ正規表現fromを使いたいと思うかもしれません。これを行なうには`%
m from
RET`でそれらのファイルをマークして、それらのファイルを操作するコマンドで同じ正規表現を使用します。もっと便利にするために、ファイルを操作する`%`コマンドは、最後の`%`コマンドで指定された正規表現をデフォルトで使用します。

Diredでのファイル比較
---------------------

file comparison (in Dired)
compare files (in Dired)
dired-diff
= (Dired)
`=` (`dired-diff`)コマンドは、`diff`プログラムを使用して、カレントファイル(ポイント位置のファイル)と他のファイル(ミニバッファーを使用して指定)を比較します。ミニバッファーで指定されたファイルは、`diff`の1番目の引数となり、ポイント位置のファイルは2番目の引数になります。`diff`プログラムの出力は、Diffモードを使用するバッファーで表示されます([Comparing Files](#Comparing-Files)を参照してください)。

リージョンがアクティブの場合、ミニバッファーを使って読み取られるファイル名のデフォルトは、マーク(Diredのマークではなく、Emacsの通常のマークのこと。[Setting Mark](#Setting-Mark)を参照してください)の位置のファイルになります。リージョンがアクティブでない場合、ポイント位置のファイルがバックアップファイル([Backup](#Backup)を参照してください)のときは、それがデフォルトになります。

`ediff-files`を使用してファイルを比較することもできます。section “Major Entry Points” in Ediff User’s Manualを参照してください。

Diredでのサブディレクトリー
---------------------------

subdirectories in Dired
expanding subdirectories in Dired
Diredバッファーは通常、1つのディレクトリーだけを表示しますが、オプションでサブディレクトリーも同様に含めることができます。

1つのDiredバッファーに複数のディレクトリーを含める一番簡単な方法は、`ls`にオプション‘`-lR`’を指定して実行する方方です(Diredを実行するとき数引数を指定すると、ミニバッファーでこれらのオプションを指定できます)。これはすべてのサブディレクトリーの、すべてのレベルにたいして、再帰的にディレクトリーを一覧します。

特定のサブディレクトリーだけを見たいときもあります。これは`i` (`dired-maybe-insert-subdir`)により行なうことができます:

`i`  
inserted subdirectory (Dired)

in-situ subdirectory (Dired)

サブディレクトリーの内容を、バッファーの最後に挿入します。

ディレクトリーを記述する行でこのコマンドを使用した場合、同じDiredバッファーにそのディレクトリーの内容を挿入して、そこに移動します。サブディレクトリーの内容は、‘`ls
-lR`’の出力と同じように、Diredバッファーのトップレベルのディレクトリーの後に挿入されます。

サブディレクトリーの内容がすでにバッファーに表示されている場合、`i`コマンドはそこに移動するだけです。

どちらの場合もm`i`は移動する前にマークをセットするので、`C-u
C-SPC`でDiredバッファーの元の位置に戻ることができます([Setting Mark](#Setting-Mark)を参照してください)。‘`^`’を使って、同じDiredバッファーの親ディレクトリーに戻ることもできます([Dired Visiting](#Dired-Visiting)を参照してください)。

`l` (`dired-do-redisplay`)コマンドを使用すると、サブディレクトリーの内容を更新し、サブディレクトリーのヘッダー行で`C-u
k`を使用すると、サブディレクトリーのリストを削除します([Dired Updating](#Dired-Updating)を参照してください)。挿入したサブディレクトリーを、隠したり表示したりすることもできます([Hiding Subdirectories](#Hiding-Subdirectories)を参照してください)。

Diredでのサブディレクトリーにたいするスイッチ
---------------------------------------------

`C-u
i`を使うことにより、`ls`のスイッチを指定して、Diredバッファーにサブディレクトリーを挿入できます。すでに挿入されたサブディレクトリーの`ls`スイッチを変更するには、その位置で`C-u
l`を使用します。

バッファーをリバートしたとき、Diredはこれらのスイッチを保持します。サブディレクトリーを削除すると、それにたいするスイッチは忘れられます。

`dired-undo` ([Marks vs Flags](#Marks-vs-Flags)を参照してください) を使用することにより、スイッチを明示的に指定して挿入されたサブディレクトリーにたいして、それらのスイッチを記憶する(または忘れる)ためのDiredの機構をバイパスして、それらのサブディレクトリーの再挿入または削除を行なうことができます。`dired-undo`を使用してサブディレクトリーを削除しても、それのスイッチは記憶されています。後で`i`を使ってサブディレクトリーを再挿入すると、これは古いスイッチを使用してサブディレクトリーを再挿入します。(`dired-undo`ではなく)通常のDiredコマンドを使って削除されたサブディレクトリーを、`dired-undo`を使って再挿入すると、最初は古いスイッチを使ってサブディレクトリーを挿入します。しかしバッファーをリバートすると。バッファーのデフォルトのスイッチを使って再リストします。これが問題な場合、`C-u
i`か`C-u l`で、この状況を正すことができます。

Diredは`R`スイッチを記憶しません。`R`スイッチを含むスイッチでサブディレクトリーを挿入すると、それはそのサブディレクトリーの各サブディレクトリーそれぞれにたいして、残りのスイッチを使用して挿入を行なうのと等価です。たとえば`R`で挿入されたサブディレクトリを更新またはkillしても、それのサブディレクトリーは更新またはkillされません。

バッファーのデフォルトスイッチは、明示的にスイッチを指定して挿入されたサブディレクトリーに影響を与えません。特にバッファーのスイッチを変更する`s`のようなコマンドは、そのようなサブディレクトリーに影響を与えません(しかし明示的にスイッチを割り当てられていないサブディレクトリーには影響します)。

`M-x
dired-reset-subdir-switches`を使うことにより、Diredにサブディレクトリーにたいするスイッチをすべて忘れさせて、すべてのサブディレクトリーを再びリストさせることができます。これはDiredのバッファーもリバートします。

サブディレクトリー間の移動
--------------------------

Diredバッファーがサブディレクトリーを一覧している場合、ディレクトリー全体を移動するためのページ移動コマンド`C-x
[`および`C-x ]`を使用することができます。

header line (Dired)
directory header lines
以下のコマンドは、ディレクトリー単位で移動したり、Diredバッファーのディレクトリーツリーを上下に移動します。これらのコマンドは、ディレクトリーヘッダー行に移動します。ディレクトリーヘッダー行とは、ディレクトリーの名前を示す行で、ディレクトリー内容の最初に表示されます。

`C-M-n`  
ディレクトリーのレベルに関係なく、次のサブディレクトリーのヘッダー行に移動します(`dired-next-subdir`)。

dired-prev-subdir

C-M-p (Dired)

`C-M-p`  
ディレクトリーのレベルに関係なく、前のサブディレクトリーのヘッダー行に移動します(`dired-prev-subdir`)。

dired-tree-up

C-M-u (Dired)

`C-M-u`  
親ディレクトリーのヘッダー行に移動します(`dired-tree-up`)。

dired-tree-down

C-M-d (Dired)

`C-M-d`  
次のサブディレクトリーのヘッダー行に、ディレクトリーツリーを下に移動します(`dired-tree-down`)。

dired-prev-dirline

&lt; (Dired)

`<`  
前のディレクトリーファイル行に、上へ移動します(`dired-prev-dirline`)。これは親ディレクトリーのファイルとして、ディレクトリーが記述されている行のことです。

dired-next-dirline

&gt; (Dired)

`>`  
次のディレクトリーファイル行に、下へ移動します(`dired-next-dirline`)。

サブディレクトリーを隠す
------------------------

hiding subdirectories (Dired)
showing hidden subdirectories (Dired)
サブディレクトリーを隠すとは、ヘッダー行を除きそれを非表示にすることを意味します。

`$`  
dired-hide-subdir

$ (Dired)

ポイント位置のサブディレクトリーを隠す、または表示します(`dired-hide-subdir`)。これは切り替えコマンドです。数引数は繰り返し回数として機能します。

`M-$`  
dired-hide-all

M-$ (Dired)

Diredバッファーのすべてのサブディレクトリーを、ヘッダー行だけを残して隠します(`dired-hide-all`)。1つでも隠されたサブディレクトリーがある場合、すべてのサブディレクトリーを再表示します。非常に深いディレクトリーツリーの概観を得たり、離れた場所のサブディレクトリーに素早く移動するために、このコマンドを使うことができます。

通常のDiredコマンドは、隠されたサブディレクトリーの中のファイルは考慮しません。たとえばマークされたファイルを操作するコマンドは、たとえファイルがマークされていても、それが隠されたディレクトリーの中にある場合は、それらを無視します。したがって、サブディレクトリーのファイルにつけられたDiredマークを外さなくても、そのサブディレクトリーを一時的に隠せば、操作対象から除外することができます。

サブディレクトリーのリストを挿入する方法については[Subdirectories in Dired](#Subdirectories-in-Dired)を、それを削除する方法については[Dired Updating](#Dired-Updating)を参照してください。

Diredバッファーの更新
---------------------

updating Dired buffer
refreshing displayed files
このセクションでは、外部(Diredではない)のディレクトリーやファイルに対する変更を反映してDiredバッファーを更新したり、Diredバッファーの一部を削除するコマンドを説明します。

`g`  
Diredバッファーの内容全体を更新します(`revert-buffer`)。

`l`  
指定したファイルを更新します(`dired-do-redisplay`)。`l`にたいするファイルの指定は、ファイル操作にたいするファイル指定と同じ方法で行ないます。

`k`  
指定した*ファイル行*(ファイルではなく、その行だけ)を削除します(`dired-do-kill-lines`)。

`s`  
並び替えをアルファベット順、日時順に切り替えます(`dired-sort-toggle-or-edit`)。

`C-u s switches RET`  
switchesを`dired-listing-switches`に使用して、Diredバッファーを更新します。

g (Dired)
revert-buffer (Dired)
`g` (`revert-buffer`)とタイプすると、リストされたファイルやディレクトリーにたいする変更にもとづき、Diredバッファーの内容を更新します。消されたファイルを除き、すでにあるマークはすべて保持されます。隠されたサブディレクトリーも更新されますが、隠されたまま残ります。

l (Dired)
dired-do-redisplay
いくつかのファイルだけ更新するには、`l` (`dired-do-redisplay`)とタイプします。Diredのファイル操作コマンドと同様に、このコマンドは次のnファイル(または前の−nファイル)、または(もしあれば)マークされたファイル、またはカレントファイルを操作します。ファイルの更新とは、ファイルの現在の状態を読み取り、バッファーの対応する行がその状態を示すように、その行を更新することを意味します。

サブディレクトリーのヘッダー行で`l`を使用した場合、対応するサブディレクトリーの内容を更新します。

dired-auto-revert-buffer
`C-x
d`や他のDiredコマンドを使用して、すでにDiredバッファーで表示されているディレクトリーをvisitする場合、Diredはそのバッファーに切り替えますが更新はしません。そのバッファーが最新でない場合、Diredは`g`をタイプして更新するよう警告を表示します。再visitしたとき、自動的にDiredバッファーをリバートするようEmacsに指示するには、変数`dired-auto-revert-buffer`を非`nil`値にセットしてください。

k (Dired)
dired-do-kill-lines
バッファーから*ファイル行* — 実際のファイルではなく ｰｰｰ を削除するには、`k` (`dired-do-kill-lines`)とタイプします。ファイル操作コマンドと同じように、このコマンドは次のnファイル、またはもしあればマークされたファイルを操作します。しかし、間違って`k`をタイプしたとき面倒なので、カレントファイルは操作しません。

すでにDiredバッファーにサブディレクトリーとして挿入したディレクトリーファイル行で、`k`(see [Subdirectories in Dired](#Subdirectories-in-Dired)を参照してください)とタイプすると、これはサブディレクトリーのリストも同様に削除します。サブディレクトリーのヘッダー行で`C-u
k`とタイプしても、Diredバッファーからサブディレクトリーの行を削除できます。

この方法でkillした個別の行は`g`で元通り表示されますが、サブディレクトリーについては、`i`を使ってサブディレクトリーを再挿入しなければなりません。

Dired sorting
sorting Dired buffer
s (Dired)
dired-sort-toggle-or-edit
Diredバッファーのファイルは通常、ファイル名のアルファベット順で一覧されます。かわりにDiredは日時順でソートすることもできます。Diredコマンド`s` (`dired-sort-toggle-or-edit`)は2、つのソートモードを切り替えます。Diredバッファーのモードラインには、現在のソート方法がby nameやby dateのように示されます。

`C-u s switches
RET`で、`dired-listing-switches`に新しい値を指定できます。

Diredと`find`
-------------

find
and Dired
ファイルを選択するために`find`ユーティリティーを使うことにより、Diredバッファーに表示する一連のファイルを、より柔軟に選択できます。

find-name-dired
ワイルドカードパターンに名前がマッチするファイルを検索するには、`M-x
find-name-dired`を使います。これは引数directoryとpatternを読み取り、directoryおよびそのサブディレクトリーで、名前がpatternにマッチするすべてのファイルを選択します。

これにより選択されたファイルはDiredバッファーに表示され、通常のDiredコマンドが利用可能です。

find-grep-dired
ファイルの名前ではなく内容をテストしたいときは、`M-x
find-grep-dired`を使用します。ものコマンドはミニバッファーで2つの引数directoryとregexpを読み取ります。これはdirectoryまたはそれのサブディレクトリーで、内容がregexpにマッチするすべてのファイルを選択します。このコマンドは、プログラム`find`および`grep`を実行することにより機能します。[Grep Searching](#Grep-Searching)の`M-x
grep-find`も参照してください。正規表現を記述するときは、Emacsにたいしてではなく、`grep`にたいして記述することを忘れないでください(与えられたregexpに内容がマッチするファイルを表示する別の方法として、`%
g regexp`があります。[Marks vs Flags](#Marks-vs-Flags)を参照してください)。

find-dired
この系列でもっとも一般的なコマンドは`M-x
find-dired`で、これは`find`がテストできる任意の条件を指定することができます。これはミニバッファーで2つの引数directoryとfind-argsを受け取ります。このコマンドは、`find`がどのような条件でテストを行なうかを指定するfind-argsを引数として、directoryで`find`を実行します。このコマンドを使うためには、`find`の使い方を理解する必要があります。

find-ls-option
これらのコマンドで生成されるリストの書式は変数`find-ls-option`により制御されます。これは一対のオプションです。1番目にファイル一覧を生成するために`find`をどのように呼び出すか、2番目にその出力をDiredが解析するかを指定します。

locate
locate-with-filter
file database (locate)
locate-command
コマンド`M-x locate`は、`locate`プログラムと似たインターフェースを提供します。`M-x
locate-with-filter`も同様ですが、与えられた正規表現に名前がマッチするファイルだけを保持します。

これらのバッファーは、通常のDiredバッファーと完全に同じようには機能しません。ファイル操作は機能しますが、常にバッファーを自動的に更新するわけではありません。`g`でバッファーをリバートすると、挿入されたサブディレクトリーは削除され、フラグとマークはすべてリセットされます。

Diredバッファーの編集
---------------------

wdired mode
wdired-change-to-wdired-mode
Wdiredは、Diredバッファーを直接変更することによりファイル操作を行なうことができる、特別なモードです(“Wdired”の“W”は、“writable: 書き込み可能”が由来です)。Wdiredモードに入るには、Diredバッファーで`C-x C-q` (`dired-toggle-read-only`)とタイプします。かわりに、メニューアイテムの‘`Immediate / Edit
File Names`’を使うこともできます。

wdired-finish-edit
Wdiredモードでは、Diredバッファーに表示されているファイルの名前を編集することにより、ファイルをリネームできます。矩形操作や`query-replace`も含めて、通常のEmacs編集コマンドがすべて利用できます。編集を終えたら`C-c
C-c` (`wdired-finish-edit`)とタイプします。これにより変更が適用され、通常のDiredモードに戻ります。

単なるファイルのリネーム以外に、ファイルの新しい名前をタイプすることにより(絶対ファイル名でも相対ファイル名でも可)、ファイルを他のディレクトリーに移動することもできます。ファイルに削除のマークをつけるには、ファイル名全体を削除します。シンボリックリンクのリンク先を変更するには、リンク名の隣に表示されているリンク先の名前を編集します。

新たなサブディレクトリーを作成するためにファイル名を編集する場合、Wdiredはそれらの新たなディレクトリーを自動的に作成するでしょう。この振る舞いを抑止したい場合は、`wdired-create-parent-directories`を`nil`にセットしてください。

ファイルサイズや修正時刻など、バッファーの残りのテキストは読み込み専用にマークされているので、編集できません。しかし`wdired-allow-to-change-permissions`を`t`にセットした場合、ファイルのパーミッションを編集できます。たとえば‘`-rw-r--r--`’を‘`-rw-rw-rw-`’に変更することにより、そのファイルを誰でも書き込めるようにできます。これらの変更は、`C-c
C-c`をタイプしたときに効果をもちます。

Diredでのイメージとサムネイルの閲覧
-----------------------------------

image-dired
mode
image-dired
Image-Diredは、イメージファイルをブラウズする機能です。これはイメージファイルにたいして、Emacs内または外部ビューアーを用いた、サムネイルまたはフルサイズでの閲覧を提供します。

C-t d (Image-Dired)
image-dired-display-thumbs
Image-Diredに入るには、Diredバッファーで見たいイメージファイルを、通常のように`m`を使ってマークします。それから`C-t
d` (`image-dired-display-thumbs`)とタイプします。これはマークしたファイルに対応するimage-diredのバッファーを作成して切り替えます。

`M-x
image-dired`とタイプすることにより、直接Image-Diredに入ることもできます。これはディレクトリーの入力を求めるので、イメージファイルがあるディレクトリーを指定します。これによりそのディレクトリーにある、すべてのイメージファイルのサムネイルが作成され、それらはthumbnailバッファーに表示されます。ディレクトリーに大量のイメージファイルがある場合は長時間を要するため、イメージファイルの数が、`image-dired-show-all-from-dir-max-files`を越える場合は確認を求めます。

thumbnailバッファーのサムネイルにポイントを移動して、RET (`image-dired-display-thumbnail-original-image`)とタイプすると、サイズ調整されたバージョンを別のウィンドウに表示します。これはイメージをウィンドウにフィットするようにサイズ調整します。バッファー内の移動は矢印キーを使用します。簡単にブラウズするには、次のイメージに移動して、それを表示するSPC (`image-dired-display-next-thumbnail-original`)を使用します。DEL (`image-dired-display-previous-thumbnail-original`)とタイプすると、前のサムネイルに戻って、かわりにそれを表示します。

image-dired-external-viewer
イメージをオリジナルのサイズで閲覧するには、RETを押す前にプレフィクス引数(`C-u`)を与えるか、`C-RET` (`image-dired-thumbnail-display-external`)とタイプして、イメージを外部ビューアーで表示します。これは最初に、`image-dired-external-viewer`を設定しなければなりません。

Image-Diredを通じて、イメージを削除することもできます。`d` (`image-dired-flag-thumb-original-file`)とタイプすると、Diredバッファーでそのイメージに削除のフラグをつけます。thumbnailバッファーで`C-d` (`image-dired-delete-char`)とタイプすることにより、サムネイルイメージを削除することもできます。

さらに上級の機能として、イメージタグ(image tags)があります。これはイメージをカテゴリー分けするために使用されるメタデータです。このタグは、`image-dired-db-file`により設定されるプレーンテキストファイルに格納されます。

イメージファイルにタグ付けするには、それらをDiredバッファーでマークして(thumbnailバッファーで`m`をタイプして、Diredのファイルをマークすることもできます)、`C-t
t` (`image-dired-tag-files`)とタイプします。このコマンドはミニバッファーでタグ名読み取ります。特定のタグをもつファイルをマークするには、`C-t
f` (`image-dired-mark-tagged-files`)とタイプします。特定のタグをもつイメージファイルをマークした後は、`C-t
d`を使ってそれらを閲覧することができます。

thumbnailバッファーから直接ファイルにタグ付けするには`t t`とタイプし、タグを削除するには`t
r`とタイプします。各ファイルにたいして、“コメント”と呼ばれる特別なタグがあります(コメントは他のタグと正確に同じ意味でのタグではありません。コメントは若干異なる扱いをされるからです)。コメントタグは、イメージについてのコメントや説明を入力するのに使用されます。thumbnailバッファーでコメントするには、`c`とタイプします。これはコメントの入力を求めます。Diredからコメントを追加するには、`C-t
c` (`image-dired-dired-comment-files`)とタイプしてください。

Image-Diredは、シンプルなイメージ操作も提供します。thumbnailバッファーで`L`とタイプすると、オリジナルのイメージを反時計回りに90度ローテートし、`R`で時計回りにローテートします。このローテーションは損失がなく、`jpegtran`と呼ばれる外部ユーティリティーを使用し、これは最初にインストールする必要があります。

その他のDiredの機能
-------------------

+ (Dired)
dired-create-directory
コマンド`+` (`dired-create-directory`)はディレクトリー名を読み取り、そのディレクトリーを作成します。そのディレクトリーがすでに存在する場合は、エラーをシグナルします。

searching multiple files via Dired
M-s a C-s (Dired)
M-s a M-C-s (Dired)
dired-do-isearch
dired-do-isearch-regexp
コマンド`M-s a C-s` (`dired-do-isearch`)は、マークされたファイルにたいして、複数ファイルにたいするインクリメンタル検索を開始します。ファイル終端で検索が失敗した場合、`C-s`とタイプすると、マークされた次のファイルで検索を繰り返します。マークされた最後のファイルの終端に達すると、マークされた最初のファイルに戻って検索します。コマンド`M-s
a M-C-s` (`dired-do-isearch-regexp`)は、同じことを正規表現検索で行ないます。検索の繰り返しに関する情報は、[Repeat Isearch](#Repeat-Isearch)を参照してください。

adding to the kill ring in Dired
w (Dired)
dired-copy-filename-as-kill
コマンド`w` (`dired-copy-filename-as-kill`)は、マークされたファイル(または次のnファイル)の名前を、あたかも`C-w`でkillしたかのように、killリングに配します。ファイル名はスペースで区切られます。

プレフィクス引数に0を指定した場合、マークされた各ファイルの絶対ファイル名を使用します。プレフィクス引数に`C-u`だけを指定した場合、Diredバッファーのデフォルトディレクトリーからの相対ファイル名を使用します(サブディレクトリーから行なった場合はスラッシュが含まれます)。特別なケースとして、ポイントがディレクトリーのヘッダー行にある場合、`w`で、そのディレクトリーの絶対パスを得ることができます。この場合、プレフィクス引数とマークされたファイルは無視されます。

このコマンドの主な目的は、他のEmacsコマンドの引数として、ファイル名をyankすることです。これはkillリングに何が追加されたかも表示するので、現在マークされているファイルを、エコーエリアに表示するためにも使用できます。

W (Dired)
browse-url-of-dired-file
ファイルリストの中にHTMLファイルがある場合は、そのファイルをブラウザで閲覧できると便利かもしれません。`W` (`browse-url-of-dired-file`)コマンドは、そのファイルの閲覧に標準に設定されたブラウザを使用します。

( (Dired)
dired-hide-details-mode
dired-hide-details-hide-symlink-targets
dired-hide-details-hide-information-lines
hiding details in Dired
コマンド`(` (`dired-hide-details-mode`)は、カレントのDiredバッファーでの、ファイル所有者やファイルパーミッションなどの、詳細表示を切り替えます。デフォルトでは、シンボリックリンクのリンク先や、ヘッダー行とファイルやディレクトリーの一覧以外のすべての行も隠します。これを変更するには、オプション`dired-hide-details-hide-symlink-targets`と`dired-hide-details-hide-information-lines`をカスタマイズしてください。

Dired and version control
visitしているディレクトリーが、バージョンコントロール([Version Control](#Version-Control))の配下にある場合、選択されたファイルにたいして、通常のVC diffおよびVC logコマンドが処理を行ないます。

dired-compare-directories
コマンド`M-x
dired-compare-directories`は、カレントのDiredバッファーと、他のディレクトリーを比較するために使用されます。2つのディレクトリーで異なる、すべてのファイルがマークされます。カレントのDiredバッファーも含めて、それらのファイルをリストする、すべてのDiredバッファーでマークが付されます。

(入力を求められたときRETをタイプすると使用される)デフォルトの比較方法では、ファイル名だけを比較します — つまり別のディレクトリーに存在しないファイルは、異なります。Lisp式を入力して、より厳密な比較を指定することができます。この場合、変数`size1`と`size2`はファイルサイズ、`mtime1`と`mtime2`は最終修正時刻を秒で表した浮動小数点数、`fa1`と`fa2`はファイルの属性リスト(関数`file-attributes`で返される形式)です。この比較は、同じ名前のファイルごとに評価され、式の値が非`nil`の場合、それらのファイルは異なります。

たとえばシーケンス`M-x dired-compare-directories RET (> mtime1 mtime2)
RET`は、別のディレクトリーよりこのディレクトリーのファイルが新しい場合はマークし、このディレクトリーより別のディレクトリーのファイルが古い場合にマークします。相手がいないファイルも、両方のディレクトリーでマークが付されます。

drag and drop, Dired
X Windowシステムでは、Emacsはドラッグアンドドロップをサポートします。ファイルオブジェクトを他のプログラムにドラッグしたり、Diredバッファーにドロップできます。これは、そのディレクトリーのファイルの移動、コピー、またはリンクを作成します。正確に言うと、どのアクションが選択されるかは、プログラムの動作により決定されます。Diredバッファーの外へのファイルのドラッグは、現在のところサポートされていません。

カレンダーとダイアリー
======================

calendar
calendar
Emacsは、過去のイベントや将来のプランのためのダイアリーをもつ、卓上カレンダー機能を提供します。これにはアポイントメントを管理したり、特定のプロジェクトにどれだけ時間を費やしているか追跡する機能もあります。

カレンダーを起動するには、`M-x
calendar`とタイプします。これは3ヶ月分のカレンダーを表示します。当月が中央に表示され、今日の日付にポイントが配されます。`C-u
M-x
calendar`のように数引数を指定すると、3ヶ月カレンダーの中央に表示する、月と年の入力を求めます。カレンダーは自身のバッファーを使用し、メジャーモードはCalendarモードです。

カレンダーの中で`mouse-3`をクリックすると、特定の日付にたいする操作メニューが表示されます。`mouse-2`をクリックすると、特定の日付とは関係のない、一般的に使用されるカレンダー機能のメニューが表示されます。カレンダーを終了するには、`q`とタイプします。

カレンダーでの移動
------------------

moving inside the calendar
Calendarモードは日、週、月、年のような論理的な単位で、カレンダーを移動するコマンドを提供します。最初に表示されている3ヶ月の外に移動すると、カレンダーの表示は選択された日付が表示されるように、自動的にスクロールします。ある日付に移動することにより、その日が何の休日かを表示したり、ダイアリーのエントリーを表示したり、他のカレンダーに変換できます。単にカレンダーをスクロールするのは、長い期間を移動するのにも便利です。

### 標準的な時間間隔での移動

カレンダーバッファーでの移動コマンドは、テキスト内での移動コマンドと似ています。日、週、月、年を前方および後方に移動できます。

`C-f`  
ポイントを、1日前方に移動します(`calendar-forward-day`)。

`C-b`  
ポイントを、1日後方に移動します(`calendar-backward-day`)。

`C-n`  
ポイントを、1週前方に移動します(`calendar-forward-week`)。

`C-p`  
ポイントを、1週後方に移動します(`calendar-backward-week`)。

`M-}`  
ポイントを、1月前方に移動します(`calendar-forward-month`)。

`M-{`  
ポイントを、1月後方に移動します(`calendar-backward-month`)。

`C-x ]`  
ポイントを、1年前方に移動します(`calendar-forward-year`)。

`C-x [`  
ポイントを、1年後方に移動します(`calendar-backward-year`)。

C-f (Calendar mode)
calendar-forward-day
C-b (Calendar mode)
calendar-backward-day
C-n (Calendar mode)
calendar-forward-week
C-p (Calendar mode)
calendar-backward-week
dayおよびweekのコマンドは、文字単位または行単位で移動するためのEmacsコマンド、自然に類似しています。通常`C-n`は、後続の行の同じ列に移動しますが、Calendarモードでは翌週の同じ日に移動します。`C-p`は、前の週の同じ日に移動します。

他のモードで通常振る舞うように、矢印キーは`C-f`、`C-b`、`C-n`、`C-p`と等価です。

M-} (Calendar mode)
calendar-forward-month
M-{ (Calendar mode)
calendar-backward-month
C-x \] (Calendar mode)
calendar-forward-year
C-x \[ (Calendar mode)
calendar-backward-year
月単位および年単位の移動のためのコマンドは、週単位の移動コマンドに似ていますが、より長い期間を移動します。monthコマンドの`M-}`および`M-{`は、月全体を前方または後方に移動します。yearコマンドの`C-x
]`および`C-x [`は、年全体を前方または後方に移動します。

これらのコマンドを簡単に覚える方法は、月および年が、テキストのパラグラフとページに類似するものだと考えることです。しかし、カレンダーの移動コマンド自体は、テキスト間の移動コマンドと非常に類似している訳ではありません。Emacsのパラグラフコマンドは通常、パラグラフの先頭または最後に移動しますが、月コマンドと年コマンドは、月または年の同じ日を保ちながら、月単位または年単位で移動します。

これらのコマンドは、繰り返し回数として数引数を受け取ります。Calendarモードでは便宜上、メタ修飾なしの数字キーとマイナス記号で、数引数を指定できます。たとえば`100
C-f`は、現在の位置から100日前方へポイントを移動します。

### 週、月、年の開始と終了

週(または月や年)は、単に日が集まったものではなく、特定に日付から開始されると考えます。そのためCalendarモードは週、月、年の、最初と最後に移動するコマンドを提供します。

`C-a`  
週の最初にポイントを移動します(`calendar-beginning-of-week`)。 C-e (Calendar mode) calendar-end-of-week

`C-e`  
週の最後にポイントを移動します(`calendar-end-of-week`)。 M-a (Calendar mode) calendar-beginning-of-month

`M-a`  
月の最初にポイントを移動します(`calendar-beginning-of-month`)。 M-e (Calendar mode) calendar-end-of-month

`M-e`  
月の最後にポイントを移動します(`calendar-end-of-month`)。 M-&lt; (Calendar mode) calendar-beginning-of-year

`M-<`  
年の最初にポイントを移動します(`calendar-beginning-of-year`)。 M-&gt; (Calendar mode) calendar-end-of-year

`M->`  
年の最後にポイントを移動します(`calendar-end-of-year`)。

これらのコマンドは繰り返し回数として数引数を受け取り、繰り返し回数で、何週、何ヶ月、何年前方または後方へ移動するかを示します。

calendar-week-start-day
calendar-weekend-days
weeks, which day they start on
calendar, first day of week
デフォルトでは、週は日曜日から開始されます。週が月曜日から開始されるようにするには、変数`calendar-week-start-day`を1にセットします。どの日付ヘッダーを週末としてハイライトするか変更するには、変数`calendar-weekend-days`をセットしてください。

### 日付の指定

Calendarモードは、さまざまな方法で、指定された特定の日付へ移動するコマンドを提供します。

`g d`  
指定した日付にポイントを移動します(`calendar-goto-date`)。

`g D`  
年の指定された日にポイントを移動します(`calendar-goto-day-of-year`)。

`g w`  
年の指定された週にポイントを移動します(`calendar-iso-goto-week`)。

`o`  
指定された月をカレンダーの中央にします(`calendar-other-month`)。

`.`  
今日の日付にポイントを移動します(`calendar-goto-today`)。

g d (Calendar mode)
calendar-goto-date
`g d` (`calendar-goto-date`)は年、月、月の何日目かの入力を求め、その日付に移動します。カレンダーは西暦の最初からすべての日付を含むので、年は全部タイプしなければなりません。つまり、‘`10`’ではなく‘`2010`’とタイプしてください。

g D (Calendar mode)
calendar-goto-day-of-year
g w (Calendar mode)
calendar-iso-goto-week
`g D` (`calendar-goto-day-of-year`)は、年と日数の入力を求め、その日付に移動します。負の日数は年の最後から後方に数えます。`g
w` (`calendar-iso-goto-week`)は、年と週数の入力を求め、その週に移動します。

o (Calendar mode)
calendar-other-month
`o` (`calendar-other-month`)は、月と年の入力を求め、3ヶ月カレンダーの中央にその月を配します。

. (Calendar mode)
calendar-goto-today
`.` (`calendar-goto-today`)で今日の日付に戻ることができます。

カレンダーでのスクロール
------------------------

scrolling in the calendar
カレンダーの表示は、ポイントが表示部分の外に移動すると、自動的にスクロールします。手動でスクロールすることもできます。カレンダーのウィンドウに、月が書き込まれた細長い紙が含まれているのを想像してみてください。カレンダーのスクロールとは、この紙を水平方向に動かして、そのウィンドウに新しい月を表示することを意味します。

`>`  
カレンダーを1月前方にスクロールします(`calendar-scroll-left`)。

`<`  
カレンダーを1月後方にスクロールします(`calendar-scroll-right`)。

`C-v`; `PageDown`; `next`  
カレンダーを3月前方にスクロールします(`calendar-scroll-left-three-months`)。

`M-v`; `PageUp`; `prior`  
カレンダーを3月後方にスクロールします(`calendar-scroll-right-three-months`)。

&gt; (Calendar mode)
calendar-scroll-left
&lt; (Calendar mode)
calendar-scroll-right
もっとも基本的なカレンダーのスクロールコマンドは、1度に1月スクロールします。これはコマンドの前後の表示で、2月がオーバーラップして表示されることを意味します。`>`は内容を、1度に1月前方にスクロールします。`<`は内容を、1度に1月後方にスクロールします。

C-v (Calendar mode)
PageDown (Calendar mode)
next (Calendar mode)
calendar-scroll-left-three-months
M-v (Calendar mode)
PageUp (Calendar mode)
prior (Calendar mode)
calendar-scroll-right-three-months
コマンド`C-v`および`M-v`は、カレンダーを画面全体 — つまり3月スクロールします。この動作は、これらのコマンドが通常意味する動作と類似しています。`C-v`は後の日付を表示し、`M-v`は前の日付を表示します。これらのコマンドは、繰り返し回数として数引数を受け取ります。特に`C-u`は次のコマンドを4倍するので、`C-u
C-v`は1年前方にカレンダーをスクロールし、`C-u M-v`は1年後方にカレンダーをスクロールします。

他のモードのときと同様に、ファンクションキーのPageDown (またはnext)とPageUp (またはprior)は、`C-v`や`M-v`と等価です。

日付のカウント
--------------

`M-=`  
カレントリージョン内の日数を表示します(`calendar-count-days-region`)。

M-= (Calendar mode)
calendar-count-days-region
ある範囲の日数を数えるには、`C-SPC`で日付をマークし、他の日付にポイントを移動して、`M-=` (`calendar-count-days-region`)とタイプします。表示される日数は*包括的(inclusive)*です。つまりマークとポイントで指定された日も、日数に含まれます。

その他のカレンダーコマンド
--------------------------

`p d`  
day-in-year(1年で何日目か)を表示します(`calendar-print-day-of-year`)。

`C-c C-l`  
カレンダーウィンドウを再生成します(`calendar-redraw`)。

`SPC`  
次のウィンドウを上にスクロールします(`scroll-other-window`)。

`DEL`; `S-SPC`  
次のウィンドウを下にスクロールします(`scroll-other-window-down`)。

`q`  
カレンダーをexitします(`calendar-exit`)。

p d (Calendar mode)
day of year
calendar-print-day-of-year
年の初めからの経過日数と、年の最後までの残り日数を表示するには、`p d` command (`calendar-print-day-of-year`)とタイプします。これは、それら両方の日数をエコーエリアに表示します。経過日数には選択された日付も含まれます。残り日数に、その日は含まれません。

C-c C-l (Calendar mode)
calendar-redraw
カレンダーウィンドウのテキストがおかしくなった場合は、再描画するために`C-c C-l` (`calendar-redraw`)とタイプします(これはCalendarモード以外のモードの編集コマンドを使ったときだけ発生します)。

SPC (Calendar mode)
Calendarモードでは、SPC (`scroll-other-window`)とDEL (`scroll-other-window-down`)を使って、(もしあれば)他のウィンドウを上または下にスクロールします。これは休日のリストやダイアリーのエントリーを他のウィンドウに表示しているときなどに便利です。

q (Calendar mode)
exit-calendar
calendar-remove-frame-by-deleting
カレンダーからexitするには、`q` (`calendar-exit`)とタイプします。これはカレンダーに関連するすべてのバッファーを隠し(bury)、他のバッファーを選択します(フレームがカレンダー専用のウィンドウを含む場合、カレンダーをexitすることによりそのフレームは、削除またはアイコン化されます。これは変数`calendar-remove-frame-by-deleting`の値に依存します)。

カレンダーファイルの記述
------------------------

カレンダーとダイアリーのエントリーを、HTMLやLATEXに書き出すことができます。

calendar and HTML
Calendar HTMLコマンドは、カレンダー、休日、ダイアリーのエントリーを含む、HTMLコードのファイルを生成します。各ファイルは1ヶ月に対応し、`yyyy-mm.html`という形式の名前をもちます。ここでyyyyは4桁の年、mmは2桁の月です。変数`cal-html-directory`は、HTMLファイルのためのデフォルトの出力先ディレクトリーを指定します。休日が表示されないようにするには、`cal-html-holidays`をカスタマイズしてください。

cal-html-css-default
`<`と`>`で囲まれたダイアリーのエントリー(たとえば、this is a diary entry with &lt;font color=”red”&gt;some red text&lt;/font&gt;)は、HTMLタグと解釈されます。HTMLファイルを含むディレクトリーの中にあるスタイルシート`cal.css`を通じて、表示されるHTMLページの全体的な外観を変更できます(関連するスタイルセッティングについては、変数`cal-html-css-default`の値を参照してください)。

H (Calendar mode)
`H m`  
1ヶ月のカレンダーを生成します(`cal-html-cursor-month`)。

`H y`  
1年の各月のカレンダーファイルを生成し、同様にインデックスページも生成します(`cal-html-cursor-year`)。デフォルトでは、このコマンドはファイルをサブディレクトリーyyyyに書き込みます。これを変更した場合、各年の間のハイパーリンクは機能しなくなるでしょう。

変数`cal-html-print-day-number-flag`が非`nil`の場合、マンスリーカレンダーにはday-of-the-year(年の何日目か)の数字が表示されます。変数`cal-html-year-index-cols`は、年のインデックスページの列数を指定します。

calendar and LATEX
Calendar LATEXコマンドは、カレンダーとしてプリントされるLATEXコードのバッファーを生成します。どのコマンドを使うかにより、プリントされるカレンダーは、ポイントのある日、週、月、年をカバーします。

t (Calendar mode)
`t m`  
1ヶ月のカレンダーを生成します(`cal-tex-cursor-month`)。

`t M`  
横向き印刷(sideways-printing)で、1ヶ月のカレンダーを生成します(`cal-tex-cursor-month-landscape`)。

`t d`  
1日のカレンダーを生成します(`cal-tex-cursor-day`)。

`t w 1`  
時間を併記した、1週間の1ページカレンダーを生成します(`cal-tex-cursor-week`)。

`t w 2`  
時間を併記した、1週間の2ページカレンダーを生成します(`cal-tex-cursor-week2`)。

`t w 3`  
時間なしで、1週間のISOスタイルのカレンダーを生成します(`cal-tex-cursor-week-iso`)。

`t w 4`  
時間を併記した、月曜で始まる1週間のカレンダーを生成します(`cal-tex-cursor-week-monday`)。

`t w W`  
時間なしで、1週間の2ページカレンダーを生成します(`cal-tex-cursor-week2-summary`)。

`t f w`  
2週間を見開きする、Filofaxスタイルのカレンダーを生成します(`cal-tex-cursor-filofax-2week`)。

`t f W`  
1週間を見開きする、Filofaxスタイルのカレンダーを生成します(`cal-tex-cursor-filofax-week`)。

`t y`  
1年のカレンダーを生成します(`cal-tex-cursor-year`)。

`t Y`  
横向き印刷(sideways-printing)で、1年のカレンダーを生成します(`cal-tex-cursor-year-landscape`)。

`t f y`  
1年のFilofaxスタイルのカレンダーを生成します(`cal-tex-cursor-filofax-year`)。

これらのコマンドの中には、カレンダーを(ランドスケープモードで)横向きに印刷するものがあり、その場合は縦長ではなく横長になります。Filofaxの用紙サイズ(3.75in x 6.75in)を使うものもあります。これらのコマンドはすべてプレフィクス引数を指定でき、これは何日、何週間、何ヶ月、何年分を印刷するかを指定します(常に選択された日付から開始されます)。

変数`cal-tex-holidays`が非`nil`(デフォルト)の場合、プリンとされたカレンダーには`calendar-holidays`の休日が表示されます。変数`cal-tex-diary`が非`nil`(デフォルトは`nil`)の場合、ダイアリーのエントリーも含まれます(マンスリー、Filofax、isoの週カレンダーのみ)。変数`cal-tex-rules`が非`nil`(デフォルトは`nil`)の場合、カレンダーは充分な空間のある、罫線ページのスタイルで表示されます。そのカレンダーがどんな機能をサポートするかは、個別のcal-tex関数のドキュメントを参照してください。

必要なら、変数`cal-tex-preamble-extra`を使用して、生成されたドキュメントのプリアンブル(preamble)に、追加のLATEXコマンドを挿入できます。

休日
----

holidays
Emacsのカレンダーは、多くのメジャーおよびマイナーな休日を知っており、それらを表示することができます。デフォルトリストに、あなた自身の休日を追加できます。

`mouse-3 Holidays`; `h`  
選択された日付の休日を表示します(`calendar-cursor-holidays`)。

`x`  
カレンダーウィンドウの休日をマークします(`calendar-mark-holidays`)。

`u`  
カレンダーウィンドウのマークを外します(`calendar-unmark`)。

`a`  
表示された3ヶ月の休日を別のウィンドウにリストします(`calendar-list-holidays`)。

`M-x holidays`  
今日を含む3ヶ月の休日を別のウィンドウにリストします。

`M-x list-holidays`  
年の指定した範囲の休日を別のウィンドウにリストします。

h (Calendar mode)
calendar-cursor-holidays
calendar-view-holidays-initially-flag
ある日付が休日かどうか見るには、カレンダーウィンドウのその日付にポイントを置いて、`h`コマンドを使用します。その日付を`mouse-3`でクリックして表示されるメニューで、`Holidays`を選択しても見ることができます。どちらの方法も、その日付にたいする休日を、エコーエリアか、エコーエリアに収まらない場合は別のウィンドウに表示します。

x (Calendar mode)
calendar-mark-holidays
u (Calendar mode)
calendar-unmark
calendar-mark-holidays-flag
カレンダーに表示された、すべての日付にたいする休日の分布を閲覧するには、`x`コマンドを使用します。これは休日を異なるフェイスで表示します。 [calendar-holiday-marker](#Calendar-Customizing)を参照してください。 このコマンドは、現在表示されている月と、スクロールすることにより見ることができる他の月の両方に適用されます。マークをオフにして現在のマークを消すには、`u`をタイプします。これはダイアリーマークも消します([Diary](#Diary)を参照してください)。変数`calendar-mark-holidays-flag`が非`nil`の場合、カレンダーの作成または更新により、自動的に休日がマークされます。

a (Calendar mode)
calendar-list-holidays
さらに詳細な情報を得るには、`a`コマンドを使用します。これはカレントの3ヶ月の範囲のすべての休日を含むリストを、別のバッファーに表示します。カレンダーウィンドウでSPCおよびDELを使用することにより、そのリストを上または下にスクロールできます。

holidays
コマンド`M-x
holidays`は、今月および前月と来月の休日のリストを表示します。これはカレンダーウィンドウがないときでも機能します。変数`calendar-view-holidays-initially-flag`が非`nil`の場合、カレンダーの作成により、休日がこの方法で表示されます。違う月を中心にした3ヶ月の休日リストが欲しい場合は、月と年の入力を求める`C-u
M-x holidays`を使用してください。

Emaceが知っている休日には、United States、major Bahá’í、Chinese、Christian、Islamic、Jewishの休日、および夏至と冬至(solstices)、春分と秋分(equinoxes)が含まれます。

list-holidays
`M-x
holiday-list`は、ある年の範囲にたいする休日のリストを表示します。この関数は年の開始と終了の入力を求め、すべての休日、または複数のカテゴリーの中の1つのカテゴリーに属する休日を選択することができます。このコマンドは、カレンダーウィンドウがないときでも使用することができます。

休日に使用される日付は、歴史的事実ではなく、*現在の慣習(current practice)*にもとづきます。たとえばVeteran’s Day(退役軍人の日)は1919年に始まった休日ですが、それより前の年でも表示されます。

日の出と日の入りの時刻
----------------------

sunrise and sunset
特別なカレンダーコマンドにより、任意の日付にたいする日の出(sunrise)と日の入り(sunset)の時刻を、1、2分の範囲で調べることができます。

`mouse-3 Sunrise/sunset`; `S`  
選択された日付の、日の出と日の入りの時刻を表示します(`calendar-sunrise-sunset`)。

`M-x sunrise-sunset`  
今日の日の出と日の入りの時刻を表示します。

`C-u M-x sunrise-sunset`  
指定した日付の日の出と日の入りの時刻を表示します。

`M-x calendar-sunrise-sunset-month`  
選択された月の日の出と日の入りの時刻を表示します。

S (Calendar mode)
calendar-sunrise-sunset
sunrise-sunset
カレンダーからは、見たい日付にポイントを移動して`S`をタイプすると、エコーエリアに日の出と日の入りの時刻を、*地方時間*で表示します。日付を`mouse-3`でクリックし、表示されたメニューの‘`Sunrise/sunset`’を選択しても表示することができます。今日、または指定した日付にたいしてこの情報を表示するために、カレンダーの外からでも、コマンド`M-x
sunrise-sunset`が利用可能です。今日以外の日付を指定するには、年、月、日の入力を求める`C-u M-x
sunrise-sunset`を使用してください。

`C-u C-u M-x
sunrise-sunset`により、任意の地域の任意の日付にたいして、日の出と日の入りの時刻を表示できます。これは経度(longitude)、緯度(latitude)、調整済みグリニッジ平均時(Coordinated Universal Time)との分差、日付の入力を求め、その地域の、その日付の日の出と日の入りの時刻を表示します。

日の出と日の入りの時刻は地球上の位置に依存するので、これらのコマンドを使用する前に、Emacsに経度(latitude)、緯度(longitude)、地域名(location name)を指定する必要があります。以下は何をセットするかの例です:

calendar-location-name
calendar-longitude
calendar-latitude
    (setq calendar-latitude 40.1)
    (setq calendar-longitude -88.2)
    (setq calendar-location-name "Urbana, IL")

`calendar-latitude`と`calendar-longitude`には、小数点以下1位までの数値を使用します。

タイムゾーン(time zone)も、地方時間での日の入りと日の出の時刻に影響を与えます。Emacsは通常、タイムゾーンの情報をオペレーティングシステムから得ますが、その情報が間違っている場合(またはオペレーティングシステムがその情報を提供しない場合)、これらを自分でセットしなければなりません。以下は例です:

calendar-time-zone
calendar-standard-time-zone-name
calendar-daylight-time-zone-name
    (setq calendar-time-zone -360)
    (setq calendar-standard-time-zone-name "CST")
    (setq calendar-daylight-time-zone-name "CDT")

`calendar-time-zone`の値は地方標準時(local standard time)と、調整済みグリニッジ平均時(Coordinated Universal Time)、またはグリニッジ時(Greenwich time: GMT)との分差です。`calendar-standard-time-zone-name`と`calendar-daylight-time-zone-name`の値は、あなたのタイムゾーンで使用される略語です。Emacsは、*サマータイム(daylight saving time)*で調整済みの、日の出と日の入りの時刻を表示します。サマータイムが決定される方法については、[Daylight Saving](#Daylight-Saving)を参照してください。

ユーザーとしては`.emacs`で、普段いる場所をカレンダーの位置変数にセットすると便利だと思うかもしれません。システム管理者としては、`default.el`で、すべてのユーザーにたいして、これらの変数をセットしたいと思うかもしれません。[Init File](#Init-File)を参照してください。

月の位相
--------

phases of the moon
moon, phases of
以下のカレンダーコマンドは、月の位相(phases of the moon)、つまり新月(new moon)、上弦(first quarter)、満月(full moon)、下弦(last quarter)の日付と時刻を表示します。この機能は、月の位相に依存する問題をデバッグするのに便利です。

`M`  
表示されている3ヶ月にたいして、月のすべての4位相の日付と時刻を表示します(`calendar-lunar-phases`)。

`M-x lunar-phases`  
今日を含む3ヶ月にたいして、月のすべての4位相の日付と時刻を表示します。

M (Calendar mode)
calendar-lunar-phases
カレンダーからは`M`を使用して、カレントの3ヶ月の範囲での月の位相を、別のバッファーに表示します。数分の誤差で、日付と時刻がリストされます。

lunar-phases
カレンダーの外からは、コマンド`M-x
lunar-phases`で今月と前後1ヶ月の、月の位相のリストが表示されます。違う月についての情報は、月と年の入力を求める`C-u M-x
lunar-phases`を使用してください。

月の位相にたいして与えられる日付と時刻は、(それが適切なときはサマータイム調整されて)地方時間で与えられます。前のセクションの議論を参照してください。[Sunrise/Sunset](#Sunrise_002fSunset)を参照してください。

他のカレンダーとの間の変換
--------------------------

Gregorian calendar
Emacsのカレンダーは、*常に*グレゴリオ暦(Gregorian calendar)で表示されます。これは、新暦(New Style calendar)と呼ばれることもあり、今日では世界のほとんどで使用されています。しかし、このカレンダーは16世紀より前には存在しておらず、、18世紀より前は広く使われていませんでした。ユリウス暦(Julian calendar)を置き換えて、世界的に受け入れられたのも20世紀初頭です。Emacsカレンダーは、西暦1年1月から任意の月を表示できますが、グレゴリオ歴がまだ存在しない日付にたいしても、カレンダーは常にグレゴリオ暦で表示されます。

Emacsは他のカレンダーを表示できませんが、日付を他のカレンダーに変換することができます。

### サポートされるカレンダーシステム

ISO commercial calendar
ISO商用暦(ISO commercial calendar)は、ビジネスで使われることがあります。

Julian calendar
ユリウス暦(Julian calendar)は、ジュリアス・シーザー(Julius Caesar)から名前がつけられたカレンダーで、中世ヨーロッパで使用され、19世紀まで多くの国で使用されてきました。

Julian day numbers
astronomical day numbers
天文学者は、ユリウス歴のB.C.4713年1月1日正午からの、単純な通算日を使用します。この経過日はユリウス日(Julian day: JD)、または天文日(Astronomical day)と呼ばれます。

Hebrew calendar
ヘブライ暦(Hebrew calendar)は伝統的にユダヤ教(Jewish religion)で使用されます。EmacsのカレンダープログラムはJewishの休日を決定するためにヘブライ暦を使用します。ヘブライ暦では日没が1日の開始と終了です。

Islamic calendar
イスラム暦(Islamic calendar)は、主にIslamic国で広く使用されます。EmacsはIslamicの休日の日付を決定するのに、これを使用します。Islamicの世界では、カレンダーについての世界的な取り決めが存在しません。Emacsは広く受け入れられているバージョンを使用しますが、Islamicの休日の正確な日付は、計算によってではなく、宗教的な権威による公告に依存することがしばしばあります。結果として、行事の正確な日付はEmacsが計算する日付と若干違う場合があります。イスラム暦では、日没が1日の開始と終了です。

French Revolutionary calendar
フランス革命暦(French Revolutionary calendar)は、より非宗教的で自然にもとづいた観点により1年のサイクルを表すために、1789年の革命後にジャコバン派(Jacobins)により作成されました。これはメートル法のような、合理的な目安により1週が10日に設定されます。フランス政府は1805年の終わりに、このカレンダーを公式に放棄しました。

Mayan calendars
中央アメリカのマヤには、互いに個別で重複した3つのカレンダーシステム*long count*、*tzolkin*、*haab*があります。Emacsはこれら3つのカレンダーすべてを知っています。専門家はマヤのカレンダーと私たちのカレンダーとの正確な関連を議論しています。Emacsは、Goodman-Martinez-Thompsonの相関関係を使用して計算を行ないます。

Coptic calendar
Ethiopic calendar
コプト教徒(Copts: エジプト教会のクリスチャン)は、エジプト古代の太陽暦にもとづいたカレンダーを使用します。彼らのカレンダーは30日からなる12の月と、その後に余分の5日が含まれます。4年に1度、余分な5日に閏日を加えて6日とします。エチオピア暦は構造的に同じですが、異なる年数と月の名前をもちます。

Persian calendar
ペルシャ人は、Omar Khayyamのデザインにもとづく太陽暦を使用します。かれらのカレンダーは12の月を含み、最初の6ヶ月は31日、次の5ヶ月は30日、最後の月は、通常の年は29日で、閏年は30日です。閏年は4年または5年後との複雑なパターンで発生します。ここで実装されているカレンダーは、Birashkにより指示されている数学的なペルシャ歴で、2820年周期にもとづいています。天文学的なペルシャ暦との違いは、それが天文学的なイベントにもとづいている点です。これを記述している時点で、2つの歴に最初に矛盾が発生すると予測されるのは、2025年の3月20日です。現時点では、そのときのイランの公式カレンダーが何になるかは、明確ではありません。

Chinese calendar
旧暦(Chinese calendar)は、太陽年に太陰月を組み込んだ複雑なシステムです。年は60周期で、各年は通常の年は12ヶ月、閏年は13ヶ月です。各月は通常の月は29日または30日です。年、通常月、日は10のcelestial stemsと、12のterrestrial branchesの組み合わせにより名前がつけられ、これが合計で60個の名前となり、60回周期で繰り返されます。

Bahá’í calendar
Bahá’íのカレンダーシステムは、19日を持つ19ヶ月の太陽周期にもとづきます。のこり4日の閏日(intercalary days)は、18ヶ月目と19ヶ月目の間に配されます。

### 他のカレンダーへの変換

以下のコマンドは、選択された日付(ポイント位置の日付)をさまざまなカレンダーシステムで記述します:

`mouse-3  Other calendars`; `p o`  
選択された日付を、他のさまざまなカレンダーで表示します(`calendar-print-other-dates`)。 calendar-iso-print-date

`p c`  
選択された日付を、ISO商用暦(ISO commercial calendar)で表示します(`calendar-iso-print-date`)。 calendar-julian-print-date

`p j`  
選択された日付を、ユリウス日(Julian date)で表示します(`calendar-julian-print-date`)。 calendar-astro-print-day-number

`p a`  
選択された日付を、ユリウス日にもとづく天文日(astronomical day)で表示します(`calendar-astro-print-day-number`)。 calendar-hebrew-print-date

`p h`  
選択された日付を、ヘブライ暦の日付(Hebrew date)で表示します(`calendar-hebrew-print-date`)。 calendar-islamic-print-date

`p i`  
選択された日付を、イスラム暦の日付(Islamic date)で表示します(`calendar-islamic-print-date`)。 calendar-french-print-date

`p f`  
選択された日付を、フランス革命暦の日付(French Revolutionary date)で表示します(`calendar-french-print-date`)。 calendar-bahai-print-date

`p b`  
選択された日付を、Bahá’í dateで表示します(`calendar-bahai-print-date`)。 calendar-chinese-print-date

`p C`  
選択された日付を、旧暦の日付(Chinese date)で表示します(`calendar-chinese-print-date`)。 calendar-coptic-print-date

`p k`  
選択された日付を、Coptic dateで表示します(`calendar-coptic-print-date`)。 calendar-ethiopic-print-date

`p e`  
選択された日付を、Ethiopic dateで表示します(`calendar-ethiopic-print-date`)。 calendar-persian-print-date

`p p`  
選択された日付を、ペルシャ暦の日付(Persian date)で表示します(`calendar-persian-print-date`)。 calendar-mayan-print-date

`p m`  
選択された日付を、マヤ暦の日付(Mayan date)で表示します(`calendar-mayan-print-date`)。

変換したい日付にポイントを移動して、上記のテーブルから`p`で始まる適切なコマンドをタイプします。プレフィクスの`p`は、“print”のニーモニックです。これは、Emacsが」変換した日付を、エコーエリアに“プリント”するからです。`p
o`は日付を、Emacsが知るすべての形式で表示します。`mouse-3`でクリックして表示されるメニューから、`Other
calendars`を選択することもできます。これは、日付をEmacsが知るすべての形式でメニュー形式で表示します(メニュー形式で表示されるさまざまな形式の日付を選択しても、何もおこりません。この場合、メニューは表示のためだけに使用されます)。

### 他のカレンダーからの変換

サポートされている他のカレンダーで日付を指定して、その日付に移動することができます。このセクションでは、マヤ暦以外のカレンダーを使用してこれを行なうコマンドを説明します。マヤ暦については、以降のセクションを参照してください。

g
char
(Calendar mode)
calendar-iso-goto-date
calendar-julian-goto-date
calendar-astro-goto-day-number
calendar-bahai-goto-date
calendar-hebrew-goto-date
calendar-islamic-goto-date
calendar-french-goto-date
calendar-chinese-goto-date
calendar-persian-goto-date
calendar-coptic-goto-date
calendar-ethiopic-goto-date
`g c`  
ISO商用暦(ISO commercial calendar)で指定された日付に移動します(`calendar-iso-goto-date`)。

`g w`  
ISO商用暦で指定された週に移動します(`calendar-iso-goto-week`)。

`g j`  
ユリウス暦(Julian calendar)で指定された日付に移動します(`calendar-julian-goto-date`)。

`g a`  
ユリウス暦にもとづく天文日で指定された日付に移動します(`calendar-astro-goto-day-number`)。

`g b`  
Bahá’í calendarで指定された日付に移動します(`calendar-bahai-goto-date`)。

`g h`  
ヘブライ暦(Hebrew calendar)で指定された日付に移動します(`calendar-hebrew-goto-date`)。

`g i`  
イスラム暦(Islamic calendar)で指定された日付に移動します(`calendar-islamic-goto-date`)。

`g f`  
フランス革命暦(French Revolutionary calendar)で指定された日付に移動します(`calendar-french-goto-date`)。

`g C`  
旧暦(Chinese calendar)で指定された日付に移動します(`calendar-chinese-goto-date`)。

`g p`  
ペルシャ暦(Persian calendar)で指定された日付に移動します(`calendar-persian-goto-date`)。

`g k`  
コプト暦(Coptic calendar)で指定された日付に移動します(`calendar-coptic-goto-date`)。

`g e`  
エチオピア暦(Ethiopic calendar)で指定された日付に移動します(`calendar-ethiopic-goto-date`)。

これらのコマンドは、他のカレンダーの日付の入力を求め、その日付と等価なグレゴリオ暦(Ethiopic calendar)の日付に移動して、他のカレンダーの日付をエコーエリアに表示します。Emacsは月の名前を入力するとき、常に強い補完([Completion Exit](#Completion-Exit)を参照してください)を使うので、ヘブライ、イスラム、フランスの名前のスペルを心配する必要はありません。

calendar-hebrew-list-yahrzeits
yahrzeits
ヘブライ暦に関する一般的な問題として、yahrzeitと呼ばれる死亡日にたいする記念日の計算があります。Emacsのカレンダーには、そのような計算の機能が含まれています。カレンダーにいるときは、コマンド`M-x
calendar-hebrew-list-yahrzeits`により、まず年の範囲の入力を求め、ポイント位置の日付により、それらの年のyahrzeitの日付のリストを表示します。カレンダーにいないときは、このコマンドは最初に死亡日、次に年の範囲の入力を求め、yahrzeitの日付の一覧を表示します。

ダイアリー
----------

diary
Emacsのダイアリーはカレンダーと共に、日常のアポイントメントやその他のイベントを管理します。ダイアリー機能を使うには、最初にイベントとその日付を含むダイアリーファイル(diary file)を作成しなければなりません。Emacsは今日、近い将来、指定された日付のイベントを自動的にピックアップして表示します。

ダイアリーの作成を手作業で行なおうと考えているかもしれませんが、Emacsはダイアリーのエントリーを閲覧、追加、変更するいくつかのコマンドを提供します。

### ダイアリーファイル

diary file
diary-file
ダイアリーファイル(diary file)とは、特定の日付に関連付けられたイベントを記録するファイルです。ダイアリーファイルの名前は、変数`diary-file`により指定されます。デフォルトは`~/.emacs.d/diary`ですが、古いバージョンのEmacsとの互換性のため、`~/diary`が存在する場合は、それを使用します。

ダイアリーファイルの各エントリーは、1つ以上の行からなる1つのイベントを記述します。エントリーは、常に左端の日付指定で開始されます。エントリーの残りの部分は、イベントを説明するテキストです。エントリーが複数行の場合、2行目以降はそれが前のエントリーの継続行であることを示すために、空白文字で開始しなければなりません。有効な日付で開始されておらず、前のエントリーの継続行でもない行は無視されます。以下は例です:

    12/22/2015  Twentieth wedding anniversary!
    10/22       Ruth's birthday.
    * 21, *:    Payday
    Tuesday--weekly meeting with grad students at 10am
             Supowit, Shen, Bitner, and Kapoor to attend.
    1/13/89     Friday the thirteenth!!
    thu 4pm     squash game with Lloyd.
    mar 16      Dad's birthday
    April 15, 2016 Income tax due.
    * 15        time cards due.

この例では、ほとんどのエントリーにたいして、余分なスペースでイベント説明を位置揃えしています。このようなフォーマットは、純粋に好みの問題です。

ダイアリーエントリーの最初の行が、日付または曜日名(後にブランクも句読点もない)だけの形式を使うこともできます。たとえば:

    02/11/2012
          Bill B. visits Princeton today
          2pm Cognitive Studies Committee meeting
          2:30-5:30 Liz at Lawrenceville
          4:00pm Dentist appt
          7:30pm Dinner at George's
          8:00-10:00pm concert

このエントリーは、シンプルなダイアリー表示を使ったときは、異なる表示になります ([Diary Display](#Diary-Display)を参照してください)。 シンプルなダイアリー表示は最初の日付行を省略して、継続行だけが表示されます。このスタイルのエントリーは、1日分だけのエントリーを表示するときはうまく表示されますが、複数日のエントリーの場合は混乱するかもしれません。

### ダイアリーの表示

1度ダイアリーファイルを作成すると、カレンダーを使ってそれを閲覧できます。Calendarモードの外で、今日のイベントを閲覧することもできます。以下はCalendarバッファーで参照されるキーバインドです。

`mouse-3 Diary`; `d`  
選択された日付の、すべてのダイアリーエントリーを表示します(`diary-view-entries`)。

`s`  
ダイアリーファイル全体を表示します(`diary-show-all-entries`)。

`m`  
表示されている日付で、ダイアリーエントリーをもつものをすべてマークします(`diary-mark-entries`)。

`u`  
カレンダーウィンドウのマークを外します(`calendar-unmark`)。

`M-x diary-print-entries`  
表示されているダイアリーのハードコピーを印刷します。

`M-x diary`  
今日の日付の、すべてのダイアリーエントリーを表示します。

`M-x diary-mail-entries`  
近づきつつあるダイアリーエントリーのリマインダーとして、あなた自身にメールします。

d (Calendar mode)
diary-view-entries
calendar-view-diary-initially-flag
`d`でダイアリーエントリーを表示すると、カレンダーで選択された日付のダイアリーエントリーが別のバッファーに表示されます。新しいバッファーのモードラインには、ダイアリーエントリーの日付が表示されます。休日はバッファーとモードラインの両方で表示され、それは選択した表示方法に依存します ([Diary Display](#Diary-Display)を参照してください)。 `d`に数引数を指定した場合、選択した日付から指定した日数までのすべてのダイアリーエントリーを表示します。したがって、`2
d`は選択された日と、その次の日のすべてのエントリーを表示します。

ある日付にたいするダイアリーエントリーを表示する別の方法は、日付を`mouse-3`でクリックして、表示されるメニューから`Diary
entries`を選択する方法です。変数`calendar-view-diary-initially-flag`が非`nil`の場合、カレンダーの作成により、その日のダイアリーエントリーがリストされます(その日が表示されている場合)。

m (Calendar mode)
diary-mark-entries
calendar-mark-diary-entries-flag
より広い視点でダイアリーが記載されている日を知るには、`m`コマンドを使用します。これはダイアリーエントリーをもつ日付を、異なるフェイスでマークします。 [diary-entry-marker](#Calendar-Customizing)を参照してください。

このコマンドは現在表示されている月と、スクロールすることにより表示される月の両方に適用されます。マークを消すには`u`をタイプします。これにより休日のマークもオフになります([Holidays](#Holidays)を参照してください)。変数`calendar-mark-diary-entries-flag`が非`nil`の場合、カレンダーの作成または更新により、ダイアリーの日付が自動的にマークされます。

diary-nonmarking-symbol
カレンダーで、特定のダイアリーエントリーのマークを抑止するには、エントリーの開始、日付の前に、`diary-nonmarking-symbol`で指定された文字列(デフォルトは‘`&`’)を挿入します。これはエントリーをダイアリーバッファーで表示する場合は、影響ありません。カレンダーウィンドウで日付をマークするときだけ影響があります。マークされないエントリーは、マークの数が多くなりすぎるような、一般的なエントリーにたいして有用かもしれません。

s (Calendar mode)
diary-show-all-entries
限られたエントリーだけでなく、ダイアリーファイル全体を参照するには、`s`コマンドを使用します。

diary
コマンド`M-x
diary`は、カレンダーの表示とは独立に、その日のダイアリーエントリーと、オプションでその後の何日かのダイアリーエントリーも同様に表示します。何日分を含めるかは変数`diary-number-of-entries`で指定してください。 [diary-number-of-entries](#Diary-Customizing)を参照してください。

`.emacs`ファイルに`(diary)`を記述した場合、Emacsを開始したときに、その日のダイアリーエントリーのウィンドウを自動的に表示します。

diary-mail-entries
diary-mail-days
ダイアリーのイベント通知を、メールで受けとるのを好む人もいます。そのようなメールをあなた自身に送るには、コマンド`M-x
diary-mail-entries`を使用します。プレフィクス引数は、(今日から開始して)何日分をチェックするかを指定します。プレフィクス引数を指定しない場合、変数`diary-mail-days`により、何日分をチェックするかが指定されます。

### 日付のフォーマット

以下は、異なる方法でフォーマットされた日付を説明するために、ダイアリーエントリーの例をいくつか示したものです。この例では、日付はすべてアメリカ形式(月、日、年)ですが、Calendarモードは、オプションでヨーロッパ形式(日、月、年)と、ISO形式(年、月、日)をサポートします。

    4/20/12  Switch-over to new tabulation system
    apr. 25  Start tabulating annual results
    4/30  Results for April are due
    */25  Monthly cycle finishes
    Friday  Don't leave without backing up files

最初のエントリーは、2012年4月20日に1度だけ表示されます。2番目と3番目のエントリーは毎年、指定した日に表示され、4番目のエントリーは月にワイルドカード(アスタリスク)を使っているので、毎月25日に表示されます。最後のエントリーは毎週、金曜日に表示されます。

‘`month/day`’や‘`month/day/year`’のように、日付を表すのに数字だけを使うこともできます。この場合、その後に続く文字は数字以外の文字でなければなりません。日付のmonthとdayは、1桁または2桁の数字です。オプションのyearも数字で、省略形として最後の2桁を使うこともできます。つまり、‘`11/12/2012`’または‘`11/12/12`’を使うことができます。

日付は、‘`monthname day`’または‘`monthname day,
year`’という形式をもつこともできます。月の名前のスペルには完全形、または省略形(最後のピリオドはあってもなくてもよい)を指定できます。月または曜日の優先される省略形は、変数`calendar-abbrev-length`、`calendar-month-abbrev-array`、`calendar-day-abbrev-array`を使ってセットできます。デフォルトは、名前の最初の3文字を省略形として使用します。大文字小文字に違いはありません。

日付はジェネリック(generic) — つまり指定されていない部分があっても構いません。この場合、エントリーは日付に指定された部分にマッチする、すべての日付に適用されます。日付が年を含まない場合、これはジェネリックで、任意の年に適用されます。かわりにmonth、day、yearに‘`*`’を使用することもできます。これは任意の月、任意の日、任意の年にマッチします。したがって、日付は‘`3/*/*`’のダイアリーエントリーは任意の年の3月の任意の日にマッチします。‘`march
*`’も同じです。

calendar-date-style
calendar-set-date-style
ヨーロッパ形式(月の前に日を記述する)、またはISO形式(年、月、日の順で記述する)で日付を記述したい場合は、カレンダーで`M-x
calendar-set-date-style`とタイプするか、変数`calendar-date-style`をカスタマイズします。これはダイアリーの日付がどのように解釈されるか、日付の表示、コマンドが与えられた引数に要求する順序に影響を与えます。

週のある曜日に適用されるジェネリックな日付として、曜日名を使うことができます。曜日名は完全なスペルを記述するか、上述した省略形を使用できます。大文字小文字に違いはありません。

### ダイアリーに追加するコマンド

カレンダーでは、ダイアリーのエントリーを作成するコマンドがいくつかあります。以下は基本的なコマンドの一覧です。より複雑なコマンドは次のセクションで説明します(([Special Diary Entries](#Special-Diary-Entries)を参照してください))。エントリーにはグレゴリオ暦以外も使用できます。 [Non-Gregorian Diary](#Non_002dGregorian-Diary)を参照してください。

`i d`  
選択された日付のダイアリーエントリーを追加します(`diary-insert-entry`)。

`i w`  
選択された曜日のダイアリーエントリーを、各週に追加します(`diary-insert-weekly-entry`)。

`i m`  
選択された日のダイアリーエントリーを、各月に追加します(`diary-insert-monthly-entry`)。

`i y`  
選択された日のダイアリーエントリーを、各年に追加します(`diary-insert-yearly-entry`)。

i d (Calendar mode)
diary-insert-entry
カレンダーウィンドウで日付を選択して、`i
d`コマンドをタイプすることにより、特定の日付にたいするダイアリーエントリーを作成することができます。このコマンドは、ダイアリーファイルの最後の部分を別のウィンドウに表示して、その日付を追加します。その後、ダイアリーエントリーの残りの部分をタイプできます。

i w (Calendar mode)
diary-insert-weekly-entry
i m (Calendar mode)
diary-insert-monthly-entry
i y (Calendar mode)
diary-insert-yearly-entry
毎週、特定の曜日に適用されるダイアリーエントリーを作成したいときは、その曜日(同じ曜日ならどの日でも構いません)を選択して、`i
w`とタイプします。これは曜日をジェネリックな日付として挿入します。そのあとダイアリーエントリーの残りの部分をタイプできます。月ごとのダイアリーエントリーも同じやり方で作成できます。まず月のある日付を選択して、`i
m`コマンドを使い、その後エントリーの残りの部分をタイプします。同様に`i y`コマンドで、年ごとのダイアリーエントリーを挿入できます。

上記のすべてのコマンドは、デフォルトでマークされるダイアリーエントリーを作成します。マークされないダイアリーエントリーを作成するには、コマンドにプレフィクス引数を与えます。たとえば、`C-u
i w`は、マークされない週次のダイアリーエントリーを作成します。

ダイアリーファイルを変更したときは、Emacsを終了する前にそのファイルを保存してください。上記の挿入コマンドを使用した後でダイアリーファイルを保存することにより、それが適切な場合は、カレンダーウィンドウのダイアリーのマークを自動的に更新します。随時に更新させるには、コマンド`calendar-redraw`を使うことができます。

### 特別なダイアリーエントリー

カレンダーの日付にもとづくエントリーに加え、ダイアリーファイルは記念日のような定期的なイベントにたいする、sexpエントリー(sexp entries: S式エントリー)を含むことができます。これらのエントリーは、Emacsがダイアリーファイルをスキャンすることにより評価される、Lisp式(sexp)にもとづきます。日付のかわりに、sexpエントリーは‘`%%`’と、その後ろに続くLisp式を含んでおり、Lisp式はカッコで始まりカッコで終わらなければなりません。Lisp式は、エントリーが適用される日付を決定します。

Calendarモードは、一般的に使用される特定のsexpエントリーを挿入するためのコマンドを提供します:

`i a`  
選択された日付にたいして、記念日ダイアリーエントリー(anniversary diary entry)を追加します。

`i b`  
カレントリージョンにたいして、ブロックダイアリーエントリー(block diary entry)を追加します。

`i c`  
その日付に開始される、周期的ダイアリーエントリー(cyclic diary entry)を追加します。

i a (Calendar mode)
diary-insert-anniversary-entry
特定の日付の記念日に適用されるダイアリーエントリーを作成したい場合は、ポイントをその日付に移動して`i
a`コマンドを使用します。これはダイアリーファイルの最後の部分を別のウィンドウに表示して、記念日の記述を追加します。その後ダイアリーエントリーの残りの部分をタイプできます。エントリーは以下のようになります:

diary-anniversary
    %%(diary-anniversary 10 31 1988) Arthur's birthday

このエントリーは、1988年以降の任意の年の10月31日に適用されます。‘`10 31
1988`’は日付を指定します(ヨーロッパ形式またはISO形式を使用している場合、入力順は月、日、年とは異なります)。この式が開始年を要求する理由は、ダイアリーの上級機能が、経過年数を計算できるようにするためです。

ブロックダイアリーエントリーは、特定の連続する日付範囲に適用されます。以下は2012年6月24日から2012年7月10日までの、すべての日付に適用されるブロックダイアリーエントリーです:

diary-block
    %%(diary-block 6 24 2012 7 10 2012) Vacation

‘`6 24 2012`’は開始日付を示し、‘`7 10
2012`’は終了日付を示します(繰り返しになりますが、ヨーロッパ形式またはISOカレンダー形式を使用している場合、月、日、年の順は異なります)。

i b (Calendar mode)
diary-insert-block-entry
ブロックエントリーを入力するには、開始と終了の範囲となる2つの日付にポイントとマークを配し、`i
b`とタイプします。このコマンドは、ダイアリーファイルの最後の部分を別のウィンドウに表示して、ブロックの記述を挿入します。その後で、ダイアリーエントリーをタイプすることができます。

i c (Calendar mode)
diary-insert-cyclic-entry
周期的(cyclic)ダイアリーエントリーは、ある固定された日数の期間繰り替えされるエントリーです。これを作成するには、開始日を選択して`i
c`コマンドを使用します。コマンドは期間の長さの入力を求め、それから以下のようなエントリーを挿入します:

diary-cyclic
    %%(diary-cyclic 50 3 1 2012) Renew medication

このエントリーは、2012年3月1日以降の50日間適用されます。‘`3 1
2012`’は開始日の指定です(ヨーロッパ形式またはISOカレンダー形式を使用している場合、月、日、年の入力順は異なります)。

これら3つのコマンドはすべて、ダイアリーエントリーをマークします。マークしないダイアリーエントリーを挿入するには、プレフィクス引数を与えます。たとえば`C-u
i a`は、マークされない記念日ダイアリーエントリーを作成します。

カレンダーでsexpダイアリーエントリーを作成すると、カレンダーウィンドウで表示されているすべての日付にたいして個別にチェックしなければならないので、時間がかかるかもしれません。そのため、可能ならsexpダイアリーエントリーを、(‘`&`’を使って)マークされないようにするのがよいでしょう。

その他の複雑なsexpエントリーとして、浮動(floating)ダイアリーエントリーがあります。これは日、週、年のオフセットで指定される、定期的に発生するイベントを指定するためのものです。これは`cron`により解釈されるcrontabエントリーに類似しています。以下はマークされない、浮動ダイアリーエントリーで、11月の第4木曜日に適用されます。

diary-float
    &%%(diary-float 11 4 4) American Thanksgiving

11は11月(11番目の月)を指定し、4は木曜日(週の第4日。日曜日は0)、2番目の4は第4週(1は第1週、2は第2週、−2は最終週から2番目の週)を指定します。月は1つの月、または月のリストを使用できます。したがって上記の11を‘`'(1
2
3)`’に変更すると、このエントリーは1月、2月、3月の第4木曜日に適用されることになります。月が`t`の場合、そのエントリーは年の各月に適用されます。

標準的なsexpダイアリーエントリーは、フェイス名またはカレンダーをマークするときに使用する1文字の文字列を指定する、オプションのパラメーターを受け取ります。一般的には、sexpダイアリーエントリーは、それらが適用されるときを決定するために、任意の計算を処理することができます。 [Sexp Diary Entries](#Sexp-Diary-Entries)を参照してください。

### アポイントメント

appointment notification
appt-display-format
appt-audible
appt-display-mode-line
アポイントメント(appointment: 約束、予約)にたいするダイアリーエントリーがある場合、そのダイアリーエントリーが認識可能な日時で開始されていれば、Emacsは保留されたアポイントメントがあることを警告することができます。Emacsは、変数`appt-display-format`で選択されたフォーマットでメッセージを表示して、アポイントメントにたいする注意を喚起します。`appt-audible`の値が非`nil`の場合、警告には音によるリマインダーも含まれます。加えて、`appt-display-mode-line`が非`nil`の場合、Emacsはアポイントメントまで何分あるかを、モードラインに表示します。

appt-display-duration
appt-disp-window-function
appt-delete-window-function
`appt-display-format`の値が`window`の場合、変数`appt-display-duration`がリマインダーウィンドウを表示する長さを制御します。変数`appt-disp-window-function`および`appt-delete-window-function`は、ウィンドウを生成または破棄する関数の名前を与えます。

appt-activate
アポイントメントの通知を有効にするには、`M-x
appt-activate`とタイプします。正の引数は通知を有効に、負の引数は通知を無効に、引数を指定しない場合は通知のオンとオフを切り替えます。通知を有効にすることにより、ダイアリーファイルから見つかった、認識可能な日時をもつすべてのダイアリーエントリーにより、今日のアポイントメントリストをセットアップし、それらのアポイントメントの直前に注意を促します。

たとえば、ダイアリーファイルに以下のような行が含まれているとします:

    Monday
      9:30am Coffee break
     12:00pm Lunch

appt-message-warning-time
appt-warning-time-regexp
月曜日には、9:20am頃にコーヒーブレーク、11:50am頃にランチの注意が促されます。変数`appt-message-warning-time`には、前もって何分前(デフォルトは12)に警告するかを指定します。これはデフォルトの警告タイムです。`appt-warning-time-regexp`に部分マッチングを追加することにより、各アポイントメントに異なる警告タイムを指定できます(詳細は、この変数のドキュメントを参照してください)。

時刻はam/pmスタイル(‘`12:00am`’は真夜中で、‘`12:00pm`’は正午)、またはヨーロッパ/軍隊の24時間制で記述できます。どちらを使うか一貫性がある必要はありません。ダイアリーファイルで、この2つのスタイルを混交させることができます。時刻が認識されるためは、それがダイアリーエントリーの最初に記述されていなければなりません。

appt-display-diary
Emacsは、真夜中直後にダイアリーファイルから自動的にアポイントメントリストを更新します。アポイントメント通知を再度有効にすることにより、随時に更新させることができます。`appt-display-diary`を`nil`にセットしていなければ、これらのアクションはその日のダイアリーバッファーにも表示されます。アポイントメントリストは、ダイアリーファイル(またはそれをインクルードするファイル。 [Fancy Diary Display](#Fancy-Diary-Display)を参照) に保存されます。Orgモードを使用していて、アポイントメントをOrgアジェンダファイルに保持したい場合は、`org-agenda-to-appt`コマンドを使用して、アポイントメントをアジェンダファイルのリストに追加できます。このコマンドについての詳細は、section “Appointment reminders” in The Org Manualを参照してください。

appt-add
appt-delete
alarm clock
アラーム時計のように、アポイントメント通知機能を使うこともできます。コマンド`M-x
appt-add`は、ダイアリーファイルに影響を与えずに、アポイントメントリストにエントリーを追加します。アポイントメントリストからエントリーを削除するには、`M-x
appt-delete`を使います。

### ダイアリーエントリーのインポートとエクスポート

Emacsのダイアリーファイルと、他のさまざまなフォーマットの間で、ダイアリーエントリーを変換できます。

diary-outlook-formats
Outlookが生成したアポイントメントメッセージから、ダイアリーエントリーをインポートできます。そのようなメッセージをRmailやGnusで閲覧しているときは、エントリーをインポートするために`M-x
diary-from-outlook`を実行します。変数`diary-outlook-formats`をカスタマイズすることにより、このコマンドに追加のアポイントメッセージ形式を認識させることができます。他のメールクライアントは、`diary-from-outlook-function`を適切な値にセットできます。

iCalendar support
icalendarパッケージにより、Emacsダイアリーファイルと、RFC 2445 — Internet Calendaring and Scheduling Core Object Specification (iCalendar)で定義されるiCalendarとの間で、データを変換することができます(初期のvCalendar形式も同様)。

icalendar-import-buffer
コマンド`icalendar-import-buffer`は、カレントバッファーからiCalendarデータを抽出して、それをダイアリーファイルに追加します。この関数は、iCalendarデータを自動的に抽出するためにも適しています。たとえばRmailメールクライアントは、以下を使用できます:

    (add-hook 'rmail-show-message-hook 'icalendar-import-buffer)

icalendar-import-file
コマンド`icalendar-import-file`は、iCalendarファイルをインポートして、その結果をEmacsダイアリーファイルに追加します。たとえば:

    (icalendar-import-file "/here/is/calendar.ics"
                           "/there/goes/ical-diary")

もし違うファイルが存在する場合は、インポートファイルの内容を追加するために、`#include`ディレクティブを使うことができます。 [Fancy Diary Display](#Fancy-Diary-Display)を参照してください。

icalendar-export-file
icalendar-export-region
`icalendar-export-file`を使って、Emacsダイアリーファイル全体をiCalendar形式にエクスポートできます。ダイアリーファイルの一部をエクスポートするには、関連する領域をマークして、`icalendar-export-region`を呼び出します。どちらの場合も、Emacsは結果をターゲットファイルに追加します。

サマータイム
------------

daylight saving time
Emacsは、標準時とサマータイムの違いを理解します。日の出、日の入り、夏至、冬至、春分、秋分、月の位相では、時刻を補正しています。サマータイムのルールは、場所によりさまざまで、歴史的にも異なります。処理を正しく行なうには、Emacsが使用するルールを知る必要があります。

calendar-daylight-savings-starts
calendar-daylight-savings-ends
どこにいるかにより適用されるルールを、追跡するオペレーティングシステムもあります。そのようなシステムでは、Emacsはそのシステムから必要な情報を取得します。これらの情報の一部またはすべてが欠落している場合、Emacsは現在マサチューセッツのケンブリッジで使用されているルールで、そのギャップを埋めます。その結果としてのルールが望むものでない場合、変数`calendar-daylight-savings-starts`および`calendar-daylight-savings-ends`をセットすることにより、Emacsに使用するルールを指定できます。

これらの値は、変数`year`を参照するLisp式で、サマータイムが開始または終了される、`(month
day
year)`という形式のリストによる、グレゴリオ暦の日付として評価されます。その地域がサマータイムを使用しない場合、値は`nil`であるべきです。

Emacsは、サマータイムの開始を決定するためにこれらの式を使い、休日リスト、太陽および月に関する時刻の補正を行ないます。

マサチューセッツのケンブリッジにたいする値は、以下のとおりです:

    (calendar-nth-named-day 2 0 3 year)
    (calendar-nth-named-day 1 0 11 year)

つまり、`year`で指定される年の、3番目の月(3月)の、第2週の0番目の曜日(日曜日)と、、その年の11番目の月(11月)の、第1週の日曜日です。サマータイムが10月1日から開始されるように変更する場合、`calendar-daylight-savings-starts`を以下のように変更します:

    (list 10 1 year)

その地域でサマータイムがない、またはすべての時刻を標準時にしたい場合は、`calendar-daylight-savings-starts`と`calendar-daylight-savings-ends`を、`nil`にセットします。

calendar-daylight-time-offset
変数`calendar-daylight-time-offset`は、サマータイムと標準時の差を、分で指定します。マサチューセッツのケンブリッジでは60です。

calendar-daylight-savings-ends-time
最後に、2つの変数`calendar-daylight-savings-starts-time`と`calendar-daylight-savings-ends-time`は、サマータイムの開始と終了の遷移時に、地方時の真夜中から何分ずれるかを指定します。マサチューセッツのケンブリッジでは、変数の値は両方とも120です。

時間間隔の加算
--------------

time intervals, summing
summing time intervals
timeclock
clocking time
timeclockパッケージは、時間間隔を加算していくので、(たとえば)特定のプロジェクトにどれだけ時間を費やしているか、追跡することができます(より上級の代替手段はOrgモードの時間計測機能の使用である。see section “Clocking work time” in The Org Manualを参照されたい)。

timeclock-in
timeclock-out
timeclock-change
timeclock-workday-remaining
timeclock-when-to-leave
プロジェクトの作業を開始したとき`M-x timeclock-in`コマンドを使用し、作業を終えたら`M-x
timeclock-out`コマンドを使用します。これを行なうたびに、プロジェクトの記録に時間間隔を追加します。違うプロジェクトの作業に変更する場合は、`M-x
timeclock-change`を使用します。

いくつかの時間間隔をからデータを収集したら、`M-x
timeclock-workday-remaining`を使って、その作業にたいして今日の残り時間を見ることができ(1日の作業時間の平均は通常8時間とみなします)、`M-x
timeclock-when-to-leave`で作業を終了する時間を計算します。

timeclock-modeline-display
timeclock-modeline-display
Emacsにたいして、モードラインに作業日の残り時間を表示させたいときは、変数`timeclock-modeline-display`を`t`にセットするか、コマンド`M-x
timeclock-modeline-display`を呼び出します。

timeclock-ask-before-exiting
Emacsのカレントセッションを終了することは、そのプロジェクトの作業を終えることを意味するか不明なので、デフォルトではEmacsは確認を求めます。しかし変数`timeclock-ask-before-exiting`の値を`nil`にカスタマイズすることにより、確認を無視できます。その場合、明示的に`M-x
timeclock-out`か`M-x
timeclock-change`を呼び出した場合だけ、カレントの時間間隔が終了したとEmacsに告げます。

timelog
file
timeclock-file
timeclock-reread-log
timeclock関数は、`~/.emacs.d/timelog`と呼ばれるファイルに、データを集積することにより機能します。変数`timeclock-file`をカスタマイズすることにより、このファイルに違う名前を指定できます。手作業でtimeclockを編集したり、timeclockのカスタマイズ可能な変数の値を変更したときは、コマンド`M-x
timeclock-reread-log`を実行するべきです。

カレンダーとダイアリーの上級な機能
----------------------------------

このセクションでは、カレンダーとダイアリーの、より上級で特別な機能をいくつか説明します。まず最初に、個人的な好みに合うようにカレンダーをカスタマイズする、多くの方法を紹介します。

### カレンダーのカスタマイズ

calendar-intermonth-text
calendar layout
calendar week numbers
残念ながら、カレンダーの表示が3ヶ月であるのを変更することはできませんが、変数`calendar-left-margin`、`calendar-day-header-width`、`calendar-day-digit-width`、`calendar-column-width`、`calendar-intermonth-spacing`をカスタマイズすることにより、使用される空白文字をカスタマイズすることはできます。各月の間に、たとえば週の番号を表示するには、変数`calendar-intermonth-header`と`calendar-intermonth-text`を、変数のドキュメントに記載されているようにカスタマイズします。

calendar-month-header
calendar-day-header-array
変数`calendar-month-header`は、カレンダーの各月の上に表示されるテキストを制御します。デフォルトでは月と年を表示します。変数`calendar-day-header-array`は、各月の各曜日の上に表示されるテキストを制御します。デフォルトでは、各曜日の名前の最初の2文字を表示します。

calendar-holiday-marker
diary-entry-marker
calendar-today-marker
変数`calendar-holiday-marker`は、休日をどのようにマークするか指定します。この変数は、日付の隣に挿入する1文字の文字列か、その日付を表示するのに使用するフェイス名です。同様に、変数`diary-entry-marker`は、ダイアリーエントリーをもつ日を、どのようにマークするか指定します。関数`calendar-mark-today`は、今日の日付をマークするのに`calendar-today-marker`を使用します。デフォルトでは、この目的のためにカレンダーは`holiday`、`diary`、`calendar-today`という名前のフェイスを使います。

calendar-initial-window-hook
カレンダーの開始により、ノーマルフック`calendar-initial-window-hook`が実行されます。カレンダー表示の再計算では、このフックは実行されません。しかし`q`でカレンダーを離れ、再度カレンダーに入ると、このフックが再び実行されます。

calendar-today-visible-hook
calendar-star-date
変数`calendar-today-visible-hook`は、カレンダーバッファーがカレンダーのために準備された後、カレント日付がウィンドウで表示されるときに実行されるノーマルフックです。このフックの用途の1つは、今日の日付のマークです。これを行なうには、関数`calendar-mark-today`または`calendar-star-date`を使います:

calendar-mark-today
    (add-hook 'calendar-today-visible-hook 'calendar-mark-today)

calendar-today-invisible-hook
同様のノーマルフック`calendar-today-invisible-hook`は、カレント日付がウィンドウに表示されなくなるとき実行されます。

calendar-move-hook
カレンダーのカーソル移動コマンドは、カーソルを移動した後に、フック`calendar-move-hook`を実行します。

### 休日のカスタマイズ

calendar-holidays
holiday-oriental-holidays
holiday-solar-holidays
Emacsが知る、デフォルト休日のリスト変数がいくつかあります。それは`holiday-general-holidays`、`holiday-local-holidays`、`holiday-solar-holidays`、`holiday-bahai-holidays`、`holiday-christian-holidays`、`holiday-hebrew-holidays`、`holiday-islamic-holidays`、`holiday-oriental-holidays`、`holiday-other-holidays`です。変数の名前は自己説明的であるべきです。たとえば、`holiday-solar-holidays`は、太陽と月に関連した休日のリストです。

これらの休日リストにたいして、必要に応じて、下記で説明しているように休日を削除したり追加してカスタマイズできます。これらを`nil`にセットすると、関連する休日は表示されなくなります。

holiday-general-holidays
holiday-local-holidays
holiday-other-holidays
一般的な休日、すなわちholiday-general-holidaysは、デフォルトではUnited Statesで一般的な休日です。対照的に、`holiday-local-holidays`と`holiday-other-holidays`は、デフォルトでは空です。前者はシステムワイドなセッティング、後者は個人的な使用を意図しています。

holiday-bahai-holidays
holiday-christian-holidays
holiday-hebrew-holidays
holiday-islamic-holidays
calendar-bahai-all-holidays-flag
calendar-christian-all-holidays-flag
calendar-hebrew-all-holidays-flag
calendar-islamic-all-holidays-flag
デフォルトでは、Emacsは世俗的なカレンダーに一般的に見出されるものを除き、宗教的な休日のすべてを含んではいません。宗教的な休日の、より広範なコレクションのために、変数`calendar-bahai-all-holidays-flag`、`calendar-christian-all-holidays-flag`、`calendar-hebrew-all-holidays-flag`。`calendar-islamic-all-holidays-flag`のどれか(またはすべて)を`t`にセットできます。

holiday forms
それぞれの休日の変数はholiday formsのリストです。各formは休日(休日のリストの場合もある)を記述します。以下は利用可能なholiday formの表です。日付と月は1から数えますが、曜日名(dayname)は日曜日を0として数えます。引数stringは、その休日を説明する文字列です。

`(holiday-fixed month day string)`  
グレゴリオ暦(Gregorian calendar)の固定日付です。

`(holiday-float month dayname k string &optional day)`  
グレゴリオ暦のmonth月day日の前または後のk番目の曜日dayname(dayname=0の場合は日曜日)です。kが負の場合、月の最後から数えます。オプションのdayのデフォルトは、kが正のときは1、負のときはmonthの最後の日になります。

`(holiday-chinese month day string)`  
旧暦(Chinese calendar)の固定日付です。

`(holiday-hebrew month day string)`  
ヘブライ暦(Hebrew calendar)の固定日付です。

`(holiday-islamic month day string)`  
イスラム暦(Islamic calendar)の固定日付です。

`(holiday-julian month day string)`  
ユリウス暦(Julian calendar)の固定日付です。

`(holiday-sexp sexp string)`  
Lisp式sexpにより計算される日付です。式は計算に変数`year`を使い、`(month
day year)`の形式のリストを返すか、その年に休日が発生しない場合は`nil`を返すべきです。

`(if condition holiday-form)`  
条件conditionが真のときだけ休日が発生します。

`(function [args])`  
引数argsを指定して関数functionを呼び出すことにより計算される日付のリストです。

たとえばフランスで有名な7月14日のパリ革命記念日(Bastille Day)を追加したいとしましょう。以下でこれを行なうことができます:

    (setq holiday-other-holidays '((holiday-fixed 7 14 "Bastille Day")))

多くの休日は、特定の月の特定の曜日に発生します。以下はVirgin Islandsで有名な7月第4月曜日のHurricane Supplication Dayを記述します。

    (holiday-float 7 1 4 "Hurricane Supplication Day")

ここで7は7月、1は月曜日(日曜日は0、火曜日は2です)、4はその月の4番目(1は1番目、2は2番目、−1は最後、−2は最後から2番目)を指定しています。

Bahá’í暦、旧暦、ヘブライ暦、イスラム暦、ユリウス暦の固定日付に発生する休日を指定することもできます。たとえば、

    (setq holiday-other-holidays
          '((holiday-hebrew 10 2 "Last day of Hanukkah")
            (holiday-islamic 3 12 "Mohammed's Birthday")
            (holiday-julian 4 2 "Jefferson's Birthday")))

これは、Hanukkahの最後の日(ヘブライ暦の月はNisanを1として数えられます)、Mohammedの誕生日を祝うイスラムの祭日(イスラム暦の月はMuharramを1として数えられます)、そしてユリウス暦の1743年4月2日のThomas Jeffersonの誕生日を記述したものです。

条件付きの休日を含めるには、Emacs Lispの`if`か、`holiday-sexp`形式を使用します。たとえばアメリカ大統領選挙は、4で割りきれる年の11月の第1月曜日の後の、最初の火曜日に発生します:

    (holiday-sexp '(if (zerop (% year 4))
                       (calendar-gregorian-from-absolute
                        (1+ (calendar-dayname-on-or-before
                              1 (+ 6 (calendar-absolute-from-gregorian
                                      (list 11 1 year)))))))
                  "US Presidential Election")

または

    (if (zerop (% displayed-year 4))
        (holiday-fixed 11
               (calendar-extract-day
                 (calendar-gregorian-from-absolute
                   (1+ (calendar-dayname-on-or-before
                         1 (+ 6 (calendar-absolute-from-gregorian
                                  (list 11 1 displayed-year)))))))
               "US Presidential Election"))

休日の決定に特別な計算が含まれるために、上記の形式に当てはまらない休日もあります。そのような場合は、その計算を行なうLisp関数を記述しなければなりません。たとえば食(eclipses)を含めるには`holiday-other-holidays`に`(eclipses)`を追加して、以下のような、カレンダーウィンドウに表示されている月に関連するグレゴリオ暦の日付のリスト(空の場合もあり得る)を返す、Emacs Lisp関数`(eclipses)`を記述します。

    (((6 4 2012) "Lunar Eclipse") ((11 13 2012) "Solar Eclipse") ... )

### マヤ暦からの変換

Mayan calendar
以下は、マヤ暦(Mayan calendar)にもとづく日付を選択するコマンドです:

`g m l`  
long countカレンダーで指定された日付に移動します(`calendar-mayan-goto-long-count-date`)。

`g m n t`  
tzolkinカレンダーの次の周期の日付に移動します(`calendar-mayan-next-tzolkin-date`)。

`g m p t`  
tzolkinカレンダーの前の周期の日付に移動します(`calendar-mayan-previous-tzolkin-date`)。

`g m n h`  
haabカレンダーの次の周期の日付に移動します(`calendar-mayan-next-haab-date`)。

`g m p h`  
haabカレンダーの前の周期の日付に移動します(`calendar-mayan-previous-haab-date`)。

`g m n c`  
マヤ暦の次の周期の日付に移動します(`calendar-mayan-next-calendar-round-date`)。

`g m p c`  
マヤ暦の前の周期の日付に移動します(`calendar-mayan-previous-calendar-round-date`)。

Mayan long count
これらのコマンドを理解するためには、マヤ暦(Mayan calendars)を理解する必要があります。long countは以下の単位にもとづいて日数を計算します:

    1 kin = 1日   1 uinal = 20 kin   1 tun = 18 uinal
    1 katun = 20 tun   1 baktun = 20 katun

g m (Calendar mode)
calendar-mayan-goto-long-count-date
したがってlong countの日付12.16.11.16.6は、12baktunの16katunの11tunの16uinalの6kinを意味します。Emacsのカレンダーはマヤ暦のlong countを7.17.18.13.3まで遡ることができます。`g m l`コマンドを使うときはマヤ暦のlong countの日付baktun、katun、tun、uinal、kinをピリオドで区切って入力します。

calendar-mayan-previous-tzolkin-date
calendar-mayan-next-tzolkin-date
Mayan tzolkin calendar
マヤ暦のtzolkinは、13日と20日の独立した周期を組み合わせた形式からなる260日周期のカレンダーです。この周期が永遠に繰り替えされるので、Emacsはこのサイクルの前または次の位置に、後方または前方に移動するコマンドを提供します。`g
m p
t`は前のtzolkin日付に移動します。Emacsはtzolkin日付の入力を求め、前の周期のその日付にポイントを移動します。同様に、`g m
n t`とタイプすると、次の周期のtzolkin日付に移動します。

calendar-mayan-previous-haab-date
calendar-mayan-next-haab-date
Mayan haab calendar
マヤ暦のhaabは、20日からなる18の月と、月に属さない5日間からなる365日周期のカレンダーです。tzolkinの周期と同様に、この周期は永遠に繰り返されるので、この周期の前または次の位置へ後方または前方に移動するコマンドがあります。`g
m p h`は前のhaab日付に移動します。Emacsはhaab日付の入力を求め、前の周期のその日付にポイントを移動します。同様に、`g m n
h`とタイプすると次の周期のhaab日付に移動します。

calendar-mayan-next-calendar-round-date
Mayan calendar round
マヤ暦ではtzolkin日付とhaab日付を組み合わせた日付も使用されていました。この組み合わせや*calendar round*と呼ばれる、約52年の周期です。`g m p
c`とタイプすると、Emacsはhaab日付とtzolkin日付の入力を求め、前の周期のその組み合わせの日付にポイントを移動します。`g m n
c`を使用すると、次の周期のsぽの組み合わせの日付にポイントを移動します。あり得ないhaab日付とtzolkin日付の組み合わせをタイプした場合は、エラーをシグナルします。

EmacsはMaya暦の名前の入力を求めるときは強い補完 ([Completion Exit](#Completion-Exit)を参照してください) を使うので、スペルについて心配する必要はありません。

### 日付の表示フォーマット

calendar-date-display-form
`calendar-date-display-form`をセットすることにより、ダイアリー、モードライン、メッセージに表示される日付をカスタマイズできます。この変数は、文字列形式の数字をもつ変数`month`、`day`、`year`と、アルファベット文字列をもつ`monthname`、`dayname`を含む式のリストを保持します。アメリカ様式では、このリストのデフォルト値は以下のようになります:

    ((if dayname (concat dayname ", ")) monthname " " day ", " year)

ヨーロッパ様式では、この値のデフォルトは以下のようになります:

    ((if dayname (concat dayname ", ")) day " " monthname " " year)

デフォルトのISO日付は以下のようになります:

    ((format "%s-%.2d-%.2d" year (string-to-number month)
             (string-to-number day)))

他の典型的なアメリカ様式は以下のものです:

    (month "/" day "/" (substring year -2))

### 時刻の表示フォーマット

calendar-time-display-form
カレンダーとダイアリーは、デフォルトで1日の時刻を、‘`am`’または‘`pm`’と、1から12の時刻と分によるアメリカ様式の慣習にしたがって表示します。00から23の時刻による、ヨーロッパ様式(US軍用様式とも呼ばれる)にしたい場合は、変数`calendar-time-display-form`を変更することができます。この変数は式のリストです。このリストには文字列形式の数字をもつ変数`12-hours`、`24-hours`、`minutes`と、アルファベット文字列をもつ`am-pm`、`time-zone`を含めることができます。デフォルト値は以下のとおりです:

    (12-hours ":" minutes am-pm
              (if time-zone " (") time-zone (if time-zone ")"))

以下の値はヨーロッパ形式の時刻を提供します:

    (24-hours ":" minutes
              (if time-zone " (") time-zone (if time-zone ")"))

1日の時刻を返すカレンダー関数は少ないことに注意してください(現在のところsolar関数のみ)。

### ダイアリーのカスタマイズ

diary-show-holidays-flag
ダイアリーウィンドウは通常、ダイアリーエントリーの日付が休日に相当する場合は、モードラインとバッファー自身にそれを示します。休日をチェックするプロセスは時間がかかることがあり、それは定義された休日に依存します。このような場合、`diary-show-holidays-flag`を`nil`にセットすることにより、ダイアリーの表示を速くすることができます。

diary-number-of-entries
変数`diary-number-of-entries`は、1度に表示されるダイアリーエントリーの日数を制御します。これは`calendar-view-diary-initially-flag`が`t`のときの初期表示と、コマンド`M-x
diary`に影響します。たとえば値1(デフォルト)は、その日のダイアリーエントリーだけを表示し、値2は翌日のエントリーも表示します。値には7つの整数のvectorも指定できます。たとえば値が`[0
2 2 2 2 4
1]`の場合、日曜日にはダイアリーエントリーは表示されず、月曜日から木曜日までは当日と翌日のダイアリーエントリーが表示され、金曜日には金曜日から月曜日のエントリーが表示され、土曜日にはその日のエントリーだけが表示されます。

diary-date-forms
変数`diary-date-forms`をセットすることにより、ダイアリーファイルの日付形式をカスタマイズできます。この変数は日付を認識するパターンのリストです。各日付パターンは、要素が正規表現(section “Regular Expressions” in the Emacs Lisp Reference Manualを参照してください)、またはシンボル`month`、`day`、`year`、`monthname`、`dayname`のリストです。これらすべての要素は、ダイアリーファイルの特定の種類のテキストにマッチするパターンに供されます。日付パターン全体がマッチするためには、リストの各要素が連続してマッチしなければなりません。

日付パターンの正規表現は、標準の構文テーブルを変更してそれ自身の通常の方法でマッチするので、‘`*`’は単語の構成要素になります。

シンボル`month`、`day`、`year`、`monthname`、`dayname`は、日付と考えられる月番号、日付番号、年番号、月の名前、曜日名にマッチします。数字にマッチするシンボルは、0で開始することもできます。名前にマッチするものは、大文字名と、(`calendar-month-abbrev-array`と`calendar-day-abbrev-array`で指定されるような)省略形を許容します。ダイアリーエントリーの‘`*`’は“任意の月”の‘任意の日付”などを意味するので、すべてのシンボルは‘`*`’にマッチすることができ、日付とみなされないものにもマッチするべきです。

アメリカ様式での`diary-date-forms`のデフォルト値は、`diary-american-date-forms`により提供されます:

    ((month "/" day "[^/0-9]")
     (month "/" day "/" year "[^0-9]")
     (monthname " *" day "[^,0-9]")
     (monthname " *" day ", *" year "[^0-9]")
     (dayname "\\W"))

変数`diary-european-date-forms`および`diary-iso-date-forms`は、他のデフォルト様式を提供します。

このリストの日付パターンは、*相互排他的(mutually exclusive)*でなければならず、ダイアリーエントリーの任意の部分にマッチせず、日付と1文字の空白文字だけにマッチしなければなりません。相互排他的であるならば、パターンは日付を終端する空白文字を越えて、ダイアリーエントリーの一部にマッチしなければならず、日付パターンの最初の要素は`バックアップ(backup)`されなければなりません。これにより日付識別処理はマッチお終えた後、ダイアリーエントリーの先頭の単語をバックアップします。`backup`を使う場合でも、日付パターンはダイアリーエントリーの最初の単語の部分を越えてマッチしてはなりません。たとえば`diary-european-date-forms`は以下のようなデフォルト値です:

    ((day "/" month "[^/0-9]")
     (day "/" month "/" year "[^0-9]")
     (backup day " *" monthname "\\W+\\<\\([^*0-9]\\|\\([0-9]+[:aApP]\\)\\)")
     (day " *" monthname " *" year "[^0-9]")
     (dayname "\\W"))

3番目のパターンでの`backup`の使用に注目してください。これは4番目のパターンと区別するために、日付自体を越えて単語の一部にマッチする必要があるからです。

### 非グレゴリオ暦を使用するカレンダーエントリー

グレゴリオ暦にもとづくエントリーと同様に、ダイアリーはBahá’í、Chinese、Hebrew、Islamicの日付にもとづくエントリーをもつことができます。そのようなエントリーの識別は時間がかかる場合がありますが、これらを使用する人はほとんどいないので、使用する場合は明示的に有効にしなければなりません。ダイアリーが、ダイアリーエントリーのHebrew日付を識別するようにしたい場合、たとえば以下のようにして、これを行なわなければなりません:

diary-nongregorian-listing-hook
diary-nongregorian-marking-hook
diary-hebrew-list-entries
diary-hebrew-mark-entries
diary-islamic-list-entries
diary-islamic-mark-entries
diary-bahai-list-entries
diary-bahai-mark-entries
diary-chinese-list-entries
diary-chinese-mark-entries
    (add-hook 'diary-nongregorian-listing-hook 'diary-hebrew-list-entries)
    (add-hook 'diary-nongregorian-marking-hook 'diary-hebrew-mark-entries)

同様にIslamic、Bahá’í、Chineseのエントリーにたいしては、`diary-islamic-list-entries`と`diary-islamic-mark-entries`、または`diary-bahai-list-entries`と`diary-bahai-mark-entries`、または`diary-chinese-list-entries`と`diary-chinese-mark-entries`を追加します。

diary-bahai-entry-symbol
diary-chinese-entry-symbol
diary-hebrew-entry-symbol
diary-islamic-entry-symbol
これらのダイアリーエントリーは、グレゴリオ日付のダイアリーエントリーと同じフォーマットをもちます。例外は、Bahá’í日付の前には`diary-bahai-entry-symbol`(デフォルトは‘`B`’)、Chinese日付の前には`diary-chinese-entry-symbol`(デフォルトは‘`C`’)、Hebrew日付の前には`diary-hebrew-entry-symbol`(デフォルトは‘`H`’)、Islamic日付の前には`diary-islamic-entry-symbol`(デフォルトは‘`I`’)が前置されなければならないことです。さらに、非グレゴリオの月の名前は省略できません(最初の3文字では一意にならないものがあるからです。一般的なHebrew年のAdarを使いたい場合は、“Adar I”を使わなければならないことにも注意してください。) たとえばHebrew日付のHeshvan 25にたいするダイアリーエントリーは、以下のようになります:

    HHeshvan 25 Happy Hebrew birthday!

これはヘブライ暦のHeshvan 25に対応する日付のダイアリーに表示されます。以下はIslamic日付のDhu al-Qada 25にマッチするダイアリーエントリーです:

    IDhu al-Qada 25 Happy Islamic birthday!

グレゴリオ日付のダイアリーエントリーのように、非グレゴリオのエントリーも前に`diary-nonmarking-symbol`(デフォルトは‘`&`’)が前置されている場合はマークされません。

以下は、選択された日付または他の日付にたいして、Bahá’í、Chinese、Hebrew、Islamicの日付によるダイアリーエントリーを作成するコマンドの表です:

`i h d`  
`diary-hebrew-insert-entry`

`i h m`  
`diary-hebrew-insert-monthly-entry`

`i h y`  
`diary-hebrew-insert-yearly-entry`

`i i d`  
`diary-islamic-insert-entry`

`i i m`  
`diary-islamic-insert-monthly-entry`

`i i y`  
`diary-islamic-insert-yearly-entry`

`i B d`  
`diary-bahai-insert-entry`

`i B m`  
`diary-bahai-insert-monthly-entry`

`i B y`  
`diary-bahai-insert-yearly-entry`

`i C d`  
`diary-chinese-insert-entry`

`i C m`  
`diary-chinese-insert-monthly-entry`

`i C y`  
`diary-chinese-insert-yearly-entry`

`i C a`  
`diary-chinese-insert-anniversary-entry`

diary-hebrew-insert-entry
diary-hebrew-insert-monthly-entry
diary-hebrew-insert-yearly-entry
diary-islamic-insert-entry
diary-islamic-insert-monthly-entry
diary-islamic-insert-yearly-entry
diary-bahai-insert-entry
diary-bahai-insert-monthly-entry
diary-bahai-insert-yearly-entry
diary-chinese-insert-entry
diary-chinese-insert-monthly-entry
diary-chinese-insert-yearly-entry
diary-chinese-insert-anniversary-entry
これらのコマンドは、通常のダイアリーエントリーの対応するコマンドに似ています。これらはカレンダーウィンドウのポイント位置の日付に適用され、これらのコマンドが行なうのはダイアリーファイルの最後にダイアリーエントリーの日付部分を挿入することだけです。その後、ダイアリーエントリーの残りを挿入しなければなりません。特定の非グレゴリオ日付のエントリーを追加する基本的なコマンドとして、与えられた非グレゴリオ日を各月に追加する‘`monthly`’コマンド、与えられた非グレゴリオの月日を各年に追加する‘`yearly`’コマンドがあります。

### ダイアリーの表示

diary-display-function
diary-simple-display
diary-fancy-display
diary buffer
ダイアリーの表示は、ダイアリーエントリーのリストを準備して、変数`diary-display-function`で指定された関数を実行することにより機能します。デフォルト値の`diary-fancy-display`は、ダイアリーエントリーを表示するためだけに存在する特別なバッファーにコピーして、ダイアリーエントリーと休日を表示します。ダイアリーエントリーを別のバッファーにコピーすることにより、表示されるテキストの見栄えをよくする機会 — たとえばダイアリーエントリーに適用される日付順にソートするなど — が提供されます。

diary-list-include-blanks
通常、fancy diary(装飾的なダイアリー)バッファーは、たとえその日が休日であっても、ダイアリーエントリーがない日は表示しません。そのような日をfancy diaryバッファーに表示したいときは、変数`diary-list-include-blanks`を`t`にセットします。

fancy diaryバッファーはViewモードを有効にします ([View Mode](#View-Mode)を参照してください)。

他の表示方法の`diary-simple-display`は、実際のダイアリーバッファーを表示して、適合しないエントリーを隠すために非表示のテキストを使います。休日はモードラインに表示されます。この方法の有利な点は、ダイアリーファイルを直接編集して、変更を保存できることです。しかし、この方法はfancy方式のように柔軟ではありません。たとえば、これはエントリーのソートはできません。他の不利な点としては、非表示のテキストが混乱の元となることがある点です。たとえば、他の場所に張り付けるためにリージョンのテキストをコピーした場合、非表示のテキストも含まれます。同様に、目に見えるダイアリーバッファーは一種の幻影なので、単にバッファーを印刷しても、スクリーンで表示されているものが印刷されるわけではありません。

diary-print-entries-hook
diary-print-entries
この理由により、ダイアリーバッファーのハードコピーを*見た通りに*印刷する特別なコマンド`M-x
diary-print-entries`があります。これは、どちらの表示方式でも機能します(たとえfancy displayバッファーが他のバッファーと同じようにプリントできるとしても)。週の各曜日のハードコピーを印刷するには、ポイントを週の初めの曜日に移動して`7
d`とタイプし、それから`M-x
diary-print-entries`を実行します。通常のように、休日が含まれる場合、表示は若干遅くなります。変数`diary-show-holidays-flag`を`nil`にセットすることにより、速度を改善することができます。

このコマンドは、ダイアリーバッファーで現在可視なダイアリーエントリーだけを含んだ一時的なバッファーを作成します。単なる表示とは異なり、他の無関係なエントリーは隠されるだけではなく、まったく含まれません。バッファーを作成したら、フック`diary-print-entries-hook`が実行されます。このフックのデフォルト値はコマンド`lpr-buffer`で、これはデータを直接プリンターに送信します ([Printing](#Printing)を参照してください)。 違うコマンドを印刷に使いたい場合は、単にこのフックの値を変更するだけです。他のコマンドには、たとえば行を日付と時刻順に再配置することなどが含まれるかもしれません。

simpleダイアリーウィンドウで表示されているときと同じように、ダイアリーエントリーを編集できますが、表示されているバッファーには、表示から隠されている部分が含まれていることを覚えておくのは重要です。これは、たとえば`C-f` (`forward-char`)は表示されている最後の行にポイントを移動できますが、実際は隠されている行の途中かもしれないことを意味します。

*simple表示でダイアリーエントリーを編集するときは注意してください。*表示されている行の途中での行の追加、文字の追加や削除は問題になりませんが、行の最後で編集する場合は、意図した通りにはならないでしょう。行の削除は、それに続く他の非表示のエントリーを削除するかもしれません。simple diaryバッファーで編集する前に、`s` (`diary-show-all-entries`)でファイル全体を表示するのが最善です。

### Fancy Diary表示

以下の機能は、fancy diary表示だけで機能します。

sorting diary entries
ノーマルフック`diary-list-entries-hook`を使用して、各曜日のダイアリーエントリーを日時順でソートできます。以下はその方法です:

diary-sort-entries
    (add-hook 'diary-list-entries-hook 'diary-sort-entries t)

これは各曜日にたいして、認識可能は日時で始まるダイアリーエントリーをソートします。時刻がないダイアリーエントリーは、各曜日の最初に配置されます。ソートコマンドがフックリストの最後に配置されているわけに注意してください。リストの最初の方に配置されている場合、これはダイアリーエントリーの順序を変更したり、アイテムを追加します。

diary-comment-start
コメント区切りとなる文字列を`diary-comment-start`と`diary-comment-end`にセットすることにより、ダイアリーエントリーに‘`コメント`’を記述できます。fancy表示はコメントを印刷しません。他のパッケージ(たとえばappointmentパッケージ。 [Appointments](#Appointments)を参照してください) で使用するメタデータをコメント内に記述したいと思うかもしれません。

diary-include-string
メインとなるダイアリーファイルに、他のファイルをインクルードできます。これにより、グループのメンバー全員に適用されるイベント用のダイアリーファイルを、共有することができます。ダイアリーファイルで、`diary-include-string`で開始される行:

    #include "filename"

は、ファイルfilenameからダイアリーエントリーをfancy diaryバッファーにインクルードします。インクルードの仕組みは再帰的なので、インクルードされたファイルは他のファイルをインクルードできます(もちろん循環的なインクルードについては注意しなければなりません)。インクルード機能を有効にするには、以下のようにします:

diary-list-entries-hook
diary-mark-entries-hook
diary-include-other-diary-files
diary-mark-included-diary-files
    (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
    (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)

インクルード機能はfancy diaryだけで機能します。なぜならsimple diary表示は、エントリーをダイアリーファイルから直接表示するからです。

### sexpエントリーとFancy Diary表示

sexp diary entries
diary-sexp-entry-symbol
sexp( s-expression: S式)ダイアリーエントリーにより、どのダイアリーエントリーに適用するか、複雑な条件判定以上のことができます。sexpエントリーは、ダイアリーファイルで`diary-sexp-entry-symbol`(デフォルトは‘`%%`’)が前置されている行です。fancy diary表示では、sexpエントリーはエントリーの日付に応じて、エントリーのテキストを生成できます。

たとえば記念日のダイアリーエントリーでは、記念日から経過した年数をダイアリーエントリーのテキストに挿入できます。したがって、以下のダイアリーエントリーの‘`%d`’:

diary-anniversary, and sexp diary entries
    %%(diary-anniversary 10 31 1948) Arthur's birthday (%d years old)

は年齢に置換されるので、1990年10月31日のfancy diaryバッファーでは、以下のように表示されます:

    Arthur's birthday (42 years old)

かわりに、ダイアリーファイルに以下のようなエントリーが含まれている場合:

    %%(diary-anniversary 10 31 1948) Arthur's %d%s birthday

は1990年10月31日のfancy diaryバッファーで、以下のように表示されます:

    Arthur's 42nd birthday

同様に、周期的なダイアリーエントリーは、それが繰り返し発生した回数を挿入できます:

diary-cyclic, and sexp diary entries
    %%(diary-cyclic 50 1 1 2012) Renew medication (%d%s time)

これは以下のように表示されます:

    Renew medication (5th time)

これは2012年9月7日のfancy diary表示です。

発生する日付だけでなく、それより前のダイアリーエントリーを含めるための、事前リマインダー(early-reminder)となるsexpダイアリーエントリーもあります。たとえば記念日の1週間前にリマインダーが欲しいときは、以下を使用します

diary-remind
    %%(diary-remind '(diary-anniversary 12 22 1968) 7) Ed's anniversary

これにより、fancy diaryは12月15日と12月22日に、‘`Ed's anniversary`’を表示します。

diary-date
関数`diary-date`は、整数または`t`(すべての値を意味します)からなるmonth、day、yearの組み合わせで日付を指定します。たとえば、

    %%(diary-date '(10 11 12) 22 t) Rake leaves

これによりfancy diaryは

    Rake leaves

を毎年10月22日、11月22日、12月22日に表示します。

diary-float, and sexp diary entries
関数`diary-float`を使って、11月の第3金曜日や、4月の最後の火曜日といった日付をダイアリーエントリーに記述することができます。パラメーターはmonth、dayname、およびインデックスnです。エントリーはmonthの最初の日の後のn番目の曜日daynameに表示されます。ここでdayname=0は日曜日、1は月曜日、…です。nが負の場合、monthの最後から後方に数えます。monthの値に指定できるのは、月のリスト、単一の月、`t`の場合はすべての月を意味します。オプションのパラメーターdayを使用して、monthのday日目の後または前の、n番目の曜日daynameを指定することもできます。dayのデフォルト値は、nが正のときは1で、nが負のときはと気はの最後の日です。たとえば、

    %%(diary-float t 1 -1) Pay rent

これによりfancy diaryは

    Pay rent

を毎月最後の月曜日に表示します。

sexpダイアリーエントリーの一般性により、アルゴリズム的に記述したダイアリーエントリーを指定できます。sexpダイアリーエントリーには、任意の与えられた日付にたいして、エントリーを適用するかどうかを計算する式が含まれます。値が非`nil`の場合はその日付にエントリーが適用され、そうでない場合は適用されません。式では判定する日付を変数`date`で使用することができます。この変数の値は、グレゴリオ暦を参照するリスト(month day year)です。

sexpダイアリーエントリーは、式の値が非`nil`のときはその日付に適用されますが、いくつかの値は特別な意味をもちます。値が文字列の場合、その文字列はその日に発生するイベントを説明する文字列です。値は`(mark
.
string)`という形式をもつこともできます。markは、カレンダーでその日をどのようにマークするかを指定し、stringはそのイベントの説明です。markが1文字の文字列の場合、その文字はカレンダーの日付の隣に表示されます。markがフェイス名の場合、その日はそのフェイスで表示されます。markが`nil`の場合、その日を特にハイライト表示しません。

21日がウィークデイのときは21日、21日が週末のときは前の日の金曜日に給料が支払われるとしましょう。以下はそのような日付にマッチするsexpダイアリーエントリーです:

    &%%(let ((dayname (calendar-day-of-week date))
             (day (cadr date)))
          (or (and (= day 21) (memq dayname '(1 2 3 4 5)))
              (and (memq day '(19 20)) (= dayname 5)))
             ) Pay check deposited

以下のsexpダイアリーエントリーは、(fancy diary表示において)日付により異なるテキストをもつダイアリーエントリーを作成することができます:

diary-sunrise-sunset
diary-lunar-phases
diary-day-of-year
diary-iso-date
diary-julian-date
diary-astro-day-number
diary-bahai-date
diary-chinese-date
diary-coptic-date
diary-ethiopic-date
diary-hebrew-date
diary-islamic-date
diary-french-date
diary-mayan-date
diary-persian-date
`%%(diary-sunrise-sunset)`  
地方時で、今日の日の出と日の入りの時刻のダイアリーエントリーを作成します。

`%%(diary-lunar-phases)`  
月の位相にたいするダイアリーエントリーを作成します。

`%%(diary-day-of-year)`  
その年での通算日数と、その年の残り日数でダイアリーエントリーを作成します。

`%%(diary-iso-date)`  
今日と等価な、ISO商用日付のダイアリーエントリーを作成します。

`%%(diary-julian-date)`  
今日と等価な、ユリウス暦日のダイアリーエントリーを作成します。

`%%(diary-astro-day-number)`  
今日と等価な、天文日(ユリウス日)のダイアリーエントリーを作成します。

`%%(diary-bahai-date)`  
今日と等価な、Bahá’í暦日のダイアリーエントリーを作成します。

`%%(diary-chinese-date)`  
今日と等価な、旧暦日のダイアリーエントリーを作成します。

`%%(diary-coptic-date)`  
今日と等価な、Copticカレンダー日のダイアリーエントリーを作成します。

`%%(diary-ethiopic-date)`  
今日と等価な、エチオピア暦日のダイアリーエントリーを作成します。

`%%(diary-french-date)`  
今日と等価な、フランス革命暦の日付のダイアリーエントリーを作成します。

`%%(diary-hebrew-date)`  
今日と等価な、ヘブライ暦の日付のダイアリーエントリーを作成します。

`%%(diary-islamic-date)`  
今日と等価な、イスラム暦の非助のダイアリーエントリーを作成します。

`%%(diary-mayan-date)`  
今日と等価な、マヤ暦の日付のダイアリーエントリーを作成します。

`%%(diary-persian-date)`  
今日と等価な、Persian calendarの日付のダイアリーエントリーを作成します。

例えば、以下のようなダイアリーエントリーを含めると

    &%%(diary-hebrew-date)

fancy diary表示を使用している場合は、毎日のダイアリー表示に、その日に対応するヘブライ暦の日付が含まれるようになります(simple diary表示を使用している場合は、任意の日付のダイアリーにリテラル行‘`&%%(diary-hebrew-date)`’が表示されます)。

以下の関数は、特定の標準的なヘブライsexpダイアリーエントリーを構築するために使用されます:

rosh hodesh
diary-hebrew-rosh-hodesh
parasha, weekly
diary-hebrew-parasha
candle lighting times
diary-hebrew-sabbath-candles
omer count
diary-hebrew-omer
yahrzeits, and sexp diary entries
diary-hebrew-yahrzeit
diary-hebrew-birthday
`%%(diary-hebrew-rosh-hodesh)`  
新しいヘブライ月にたいして、礼拝の発生と告知を告げるダイアリーエントリーを作成します。

`%%(diary-hebrew-parasha)`  
毎週のシナゴーグ経典(synagogue scripture)の読書会を告げる、土曜日のダイアリーエントリーを作成します。

`%%(diary-hebrew-sabbath-candles)`  
安息日のキャンドルライトを告げる、*地方時*のダイアリーエントリーを作成します。

`%%(diary-hebrew-omer)`  
適切な場合は、omerを数えるダイアリーエントリーを作成します。

`%%(diary-hebrew-yahrzeit month day year) name`  
命日をマークするダイアリーエントリーを作成します。命日の日付はグレゴリオ暦の日付です。ダイアリーエントリーは適切なヘブライ暦の命日、およびその前日に表示されます(カレンダーの日付様式に対応してパラメーターの順序は変化します。たとえばヨーロッパ標識ではday、month、yearの順です)。

`%%(diary-hebrew-birthday month day year)`  
ヘブライ暦での誕生日のダイアリーエントリーを作成します。

上記でドキュメントされたすべての関数は、オプションの引数markを受け取ります。これはカレンダー表示で、その日をどのようにマークするかを指定します。上記の関数の1つが特定の日付に適用されると決定された場合、上述したようにmarkを含んだ値を戻します。

メールの送信
============

sending mail
mail
email
message
C-x m
compose-mail
Emacsから電子メールのメッセージを送信するには、`C-x
m`とタイプします。これはメッセージのテキストとヘッダーを編集できる、`*unsent
mail*`という名前のバッファーに切り替えます。編集が終了したら`C-c C-s`または`C-c
C-c`とタイプして、それを送信します。

`C-x m`  
メールの作成を開始します(`compose-mail`)。

`C-x 4 m`  
同様ですが、他のウィンドウで行ないます(`compose-mail-other-window`)。

`C-x 5 m`  
同様ですが、新しいフレームで行ないます(`compose-mail-other-frame`)。

`C-c C-s`  
メールバッファーでは、メッセージを送信します(`message-send`)。

`C-c C-c`  
メールバッファーでは、メッセージを送信して、そのバッファーを隠し(bury)ます(`message-send-and-exit`)。

メールバッファーは通常のEmacsバッファーなので、メールの作成中に他のバッファーに切り替えることができます。現在のメールを終了する前に他のメールを送信したい場合は、再度`C-x
m`とタイプして新しいメールバッファーを開きます、このバッファーは異なる数字が後ろについた名前をもちます([Misc Buffer](#Misc-Buffer)を参照してください)。`C-u C-x
m`のように、プレフィクス引数を指定してコマンドを呼び出した場合、Emacsは最後のメールバッファーに戻って、そのバッファーのメッセージを削除したいか尋ねます。これにnoと答えると、中止した場所から編集を再開できます。

C-x 4 m
compose-mail-other-window
C-x 5 m
compose-mail-other-frame
コマンド`C-x 4 m` (`compose-mail-other-window`)は、`C-x
m`と同じことを行ないますが、これはメールバッファーを別のウィンドウに表示します。コマンド`C-x 5 m` (`compose-mail-other-frame`)は、新しいフレームでこれを行ないます。

`C-c C-c`または`C-c C-s`とタイプしてメールを送信するとき、Emacsはどのようにしてメールを送信するべきか — SMTPを通じて直接送信するか、またはほかの方法を使うか — を尋ねます。詳細は、[Mail Sending](#Mail-Sending)を参照してください。

メールバッファーのフォーマット
------------------------------

以下はメールバッファーの内容の例です(訳注: 出典はコナン・ザ・グレートらしいです):

    To: subotai@example.org
    Cc: mongol.soldier@example.net, rms@gnu.org
    Subject: Re: What is best in life?
    From: conan@example.org
    --text follows this line--
    To crush your enemies, see them driven before you, and to
    hear the lamentation of their women.

メールバッファーのトップは、一連のヘッダーフィールド(header fields)です。これは電子メールの受取人、subject(題目)などに関する情報を指定するのに使用されます。上記のバッファー例には‘`To`’、‘`CC`’、‘`Subject`’、‘`From`’のヘッダーフィールドが含まれています。いくつかのヘッダーフィールドは、それが適切なときは、事前に自動的に初期化されます。

‘`--text follows this
line--`’という行は、ヘッダーフィールドとメッセージのbody(本文、またはtext)を分割します。この行の上にあるすべては、ヘッダーの一部として扱われます。下にあるすべては、bodyとして扱われます。区切り行自体は、実際に送信されるメッセージには含まれません。

通常の編集コマンドで、ヘッダーフィールドの挿入と編集ができます。ヘッダーフィールドを編集するための特定のコマンドについては、[Header Editing](#Header-Editing)を参照してください。‘`Date`’や‘`Message-Id`’のような特定のヘッダーは、通常はメールバッファーでは省略され、メッセージを送信するとき自動的に作成されます。

メールヘッダーフィールド
------------------------

headers (of mail message)
メールバッファーのヘッダーフィールドは、行の最初がフィールド名で始まります。フィールド名はコロンで終端されます。フィールド名で大文字小文字は区別されません。コロンとオプションの空白文字の後に、フィールドの内容を記述します。

好きな名前のヘッダーフィールドを使用できますが、多くの人は通常、一般に認められた意味をもつは、標準的なフィールド名だけを使用します。

user-full-name
user-mail-address
ヘッダーフィールド‘`From`’は、電子メールを送信した人(あとえばあなた)を識別します。これは有効なメールアドレスである必要があります。なぜなら、通常はそのアドレスに返信されるからです。このヘッダーフィールドのデフォルトの内容は、変数`user-full-name`(あなたのフルネームを指定します)と`user-mail-address`(あなたの電子メールアドレス)から計算されます。いくつかのオペレーティングシステムでは、Emacsはこの2つの変数を環境変数から初期化します([General Variables](#General-Variables)を参照してください)。この情報が利用不可能か間違っている場合、変数を自分でカスタマイズする必要があります([Easy Customization](#Easy-Customization)を参照してください)。

mail-from-style
変数`mail-from-style`の値は、‘`From`’フィールドの内容をどのようにフォーマットするかを指定します:

`nil`  
‘`king@grassland.com`’のように、アドレスだけを使用します。

`parens`  
‘`king@grassland.com (Elvis Parsley)`’のように、アドレスとフルネームの両方を使用します。

`angles`  
‘`Elvis Parsley <king@grassland.com>`’のように、アドレスとフルネームの両方を使用します。

any other value  
通常は`angles`を使用します。しかし`angles`では、構文的に有効にするためにアドレスをクォートしなければならないときは、かわりに`parens`を使用します。これがデフォルトです。

以下は‘`From`’以外の、一般的に使用されるフィールドの表です:

‘`To`’  
メッセージを送信するメールアドレスです。複数のアドレスを記述するには、それらを区切るのにカンマを使用します。

‘`Subject`’  
メッセージのsubjectです。

‘`CC`’  
メッセージを送信する追加のメールアドレスです。これは‘`To`’と似ていますが、受取人はそのメッセージが自分宛だと思うべきではありません。

‘`BCC`’  
実際に送信するメッセージのヘッダーには現れない、追加のメッセージ送信先のメールアドレスです。‘`BCC`’はblind carbon copiesが由来です。

‘`FCC`’  
送信されたメッセージのコピーが追加されるべき、ファイルの名前です。ファイルがBabyl形式(Emacs23以前のRmailで使用されていました)の場合、EmacsはBabyl形式で書き込み、それ以外はmbox形式で書き込みます。Rmailバッファーがそのファイルをvisitしている場合、Emacsはそれに合わせて更新します。複数のファイルを指定するには、複数の‘`FCC`’フィールドを使用して、各フィールドに1つのファイル名を記述します。

‘`Reply-to`’  
‘`From`’のかわりとなる、返信が送信されるべきアドレスです。これは何らかの理由により、‘`From`’のアドレスが返信を受け取れないときに使用します。

‘`Mail-reply-to`’  
このフィールドは‘`Reply-to`’より優先されます。メーリングリストの中には、‘`Reply-to`’を独自の目的(問題の多い、何らかの方法)のために使用しているものがあるため、これが使用されます。

‘`Mail-Followup-To`’  
follow-upメッセージのための、デフォルトの受取人のために使用する1つ以上のアドレスです。これは通常、登録しているメーリングリストからメッセージを受信するとき、余分なコピーを送らせないようにしたいときに使用します。

‘`In-reply-to`’  
返信するメッセージのための識別子です。ほとんどのメールリーダーは、関連するメッセージをまとめてグループ化するためにこの情報を使用します。このヘッダーは通常、Emacsに組み込まれた任意のメールプログラムでメッセージに返信するとき、自動的に充填されます。

‘`References`’  
以前の関連するメッセージのための識別子です。‘`In-reply-to`’と同じように、これは通常、自動的に充填されます。

‘`To`’、‘`CC`’、‘`BCC`’のフィールドは何回記述してもよく、また各フィールドにはカンマで括って複数のアドレスを含めることができます。この方法により、メッセージを送信する複数の場所を指定できます。これらのフィールドには継続行も使用できます。フィールドの開始行に続く、空白文字で始まる1行以上の行は、そのフィールドの一部とみなされます。以下は継続行を使用した‘`To`’フィールドの例です:

    To: foo@example.net, this@example.net,
      bob@example.com

mail-default-headers
変数`mail-default-headers`に文字列をセットすることにより、特定のデフォルトヘッダーを挿入するよう、Emacsに指示できます。これにより`C-x
m`でメッセージヘッダーにその文字列が挿入されます。たとえば以下は、各メッセージにヘッダー‘`Reply-to`’と‘`FCC`’を追加する例です:

    (setq mail-default-headers
          "Reply-to: foo@example.com\nFCC: ~/Mail/sent")

デフォルトのヘッダーフィールドが、特定のメッセージにたいして適切でない場合、メッセージを送信する前にそれらを編集する必要があります。

メールエイリアス
----------------

mail aliases
.mailrc
file
mailrc file
mail-personal-alias-file
メールエイリアス(mail aliases)を定義することができます。これは1つ以上のメールアドレスを意味する短い呼び名です。デフォルトでは、メールエイリアスはファイル`~/.mailrc`で定義されます。変数`mail-personal-alias-file`をセットすることにより、異なるファイル名を指定できます。

`~/.mailrc`でエイリアスを定義するには、以下のように記述します:

    alias nick fulladdresses

これはnickがfulladdressesに展開されるという意味で、fulladdressesは単一のアドレス、またはスペースで区切られた複数のアドレスです。たとえば`maingnu`が、`gnu@gnu.org`とあなた自身のローカルのアドレスを意味するよう定義するには、以下の行を記述します:

    alias maingnu gnu@gnu.org local-gnu

アドレスにスペースが含まれる場合は、以下のようにダブルクォートでアドレス全体をクォートします:

    alias jsmith "John Q. Smith <none@example.com>"

その人の名前の部分などのような、アドレスの特定の部分をダブルクォートで括る必要はないことに注意してください。Emacsは必要に応じてそれらを挿入します。たとえば上記のアドレスは‘`"John
Q. Smith" <none@example.com>`’のように挿入されます。

Emacsは、`~/.mailrc`でのincludeコマンドも識別します。これらは以下のようなものです:

    source filename

ファイル`~/.mailrc`は、Emacsだけのものではありません。他の多くのメールを閲覧するプログラムが、メールアドレスのためにこれを使用し、他にもさまざまなコマンドが含まれます。しかしEmacsは、エイリアスの定義とインクルードコマンド以外のすべてを無視します。

mail-abbrev-insert-alias
メールエイリアスはabbrevのように — つまり、エイリアスの後で単語区切り文字をタイプするとすぐに — 展開されます。この展開はヘッダーフィールド‘`To`’、‘`From`’、‘`CC`’、‘`BCC`’、‘`Reply-to`’(およびそれらの‘`Resent-`’の変種)だけで展開されます。‘`Subject`’のような、他のヘッダーフィールドでは展開されません。

コマンド`M-x
mail-abbrev-insert-alias`を使って、エイリアスされたアドレスを直接挿入することもできます。これは補完つきでエイリアス名を読み取り、ポイント位置にそれの定義を挿入します。

メールコマンド
--------------

Message mode
mode, Message
`*mail*`バッファーのデフォルトのメジャーモードは、Messageモードと呼ばれます。これはTextモードのように振る舞いますが、メッセージをより快適に編集するために、`C-c`プレフィクスを伴う、追加のコマンドをいくつか提供します。

このセクションでは、Messageモードで利用可能な、もっとも一般的に使用されるコマンドを説明します。 Messageモードにはそれ自身のマニュアルがあり、その機能についてより詳細に説明されています。section “Message” in Messageを参照してください。

### メールの送信

`C-c C-c`  
そのメッセージを送信して、メールバッファーを隠し(bury)ます(`message-send-and-exit`)。

`C-c C-s`  
そのメッセージを送信して、メールバッファーを選択されたまま残します(`message-send`)。

C-c C-s (Message mode)
C-c C-c (Message mode)
message-send
message-kill-buffer-on-exit
メッセージを送信するために通常使用されるコマンドは、`C-c C-c` (`mail-send-and-exit`)です。これはメッセージを送信して、メールバッファーを隠す(bury) — つまりバッファーを再選択するときもっとも低い優先順位になるようにします。かわりにメールバッファーをkillしたい場合は、変数`message-kill-buffer-on-exit`を`t`に変更してください。

message-send-and-exit
コマンド`C-c C-s` (`message-send`)はメッセージを送信して、そのバッファーを選択されたまま残します。(たとえば新しい送信先のために)メッセージを変更して、再度送信したい場合に、このコマンドを使用します。

message-send-hook
メッセージの送信により、フック`message-send-hook`が実行されます。メールバッファーがファイルをvisitしているバッファーの場合をのぞき、送信によりメールバッファーは変更なし(unmodified)とマークされます(ファイルをvisitしている場合は、そのファイルを保存したときだけ変更なしとマークされます。このため、同じメッセージを2回送信しても警告はされません)。

SMTP
Feedmail
Sendmail
Mailclient
send-mail-function
変数`send-mail-function`は、メッセージの配送方法を制御します。値には、以下の関数のどれか1つを指定します:

`sendmail-query-once`  
配送方法(このリストの他の項目のうちの1つ)を尋ね、このメッセージにその方法を使用します。`smtpmail-send-it`を通じてすでにメールの配送方法を変数にセットしていない場合(以下参照)、これがデフォルトです。

`smtpmail-send-it`  
インターネットサービスプロバイダーの対外SMTPメールサーバーのような、外部のメールホストを通じてメールを送信します。そのSMTPサーバーに接続する方法をEmacsに指示していない場合、コマンドはこの情報の入力を求め、それは変数`smtpmail-smtp-server`と、ファイル`~/.authinfo`に保存されます。section “Emacs SMTP Library” in Sending mail via SMTPを参照してください。

`sendmail-send-it`  
システムのデフォルトの`sendmail`プログラム、またはそれと等価なプログラムを使用してメールを送信します。これは、そのシステムがSMTPで直接メールを配送できるように、セットアップされている必要があります。

`mailclient-send-it`  
メールバッファーを、システムで指定されたメールクライアントに渡します。詳細はファイル`mailclient.el`の、コメントセクションを参照してください。

`feedmail-send-it`  
これは`sendmail-send-it`と同様ですが、後で送信するためにメッセージをキューできます。詳細は、ファイル`feedmail.el`の、コメントセクションを参照してください。

非ASCII文字を含むメッセージを送信する場合、それらはコーディングシステムでエンコードされる必要があります。コーディングシステムは通常、選択された言語環境([Language Environments](#Language-Environments)を参照してください)により、自動的に指定されます。変数`sendmail-coding-system`をセットすることにより、対外に送信するメールのコーディングシステムを明示的に指定することができます([Recognize Coding](#Recognize-Coding)を参照してください)。そのようにして決定されたコーディングシステムで扱えない文字が、特定のメッセージに含まれる場合、Emacsは利用可能なコーディングシステムのリストを表示して、使用するコーディングシステムの選択を求めます。[Output Coding](#Output-Coding)を参照してください。

### メールヘッダーの編集

Messageモードは、特定のヘッダーフィールドに移動したり、ヘッダーのアドレスを補完する、以下の特別なコマンドを提供します。

`C-c C-f C-t`  
‘`To`’ヘッダーに移動します(`message-goto-to`)。

`C-c C-f C-s`  
‘`Subject`’ヘッダーに移動します(`message-goto-subject`)。

`C-c C-f C-c`  
‘`CC`’ヘッダーに移動します(`message-goto-cc`)。

`C-c C-f C-b`  
‘`BCC`’ヘッダーに移動します(`message-goto-bcc`)。

`C-c C-f C-r`  
‘`Reply-to`’ヘッダーに移動します(`message-goto-reply-to`)。

`C-c C-f C-f`  
‘`Mail-Followup-To`’ヘッダーフィールドに移動します(`message-goto-followup-to`)。

`C-c C-f C-w`  
ファイル名の補完つきで、新しい‘`FCC`’ヘッダーフィールドを追加します(`message-goto-fcc`)。

`C-c C-b`  
メッセージ本文の先頭に移動します(`message-goto-body`)。

`TAB`  
メールアドレスを補完します(`message-tab`)。

C-c C-f C-t (Message mode)
message-goto-to
C-c C-f C-s (Message mode)
message-goto-subject
C-c C-f C-c (Message mode)
message-goto-cc
C-c C-f C-b (Message mode)
message-goto-bcc
C-c C-f C-r (Message mode)
goto-reply-to
C-c C-f C-f (Message mode)
goto-followup-to
C-c C-f C-w (Message mode)
message-goto-fcc
特定のヘッダーフィールドにポイントを移動するコマンドは、すべて`C-c
C-f`というプレフィクスを指定します(‘`C-f`’は“field”が由来です)。指定したフィールドが存在しない場合、コマンドは新たにそれを作成します(例外は`mail-fcc`で、これは毎回新たなフィールドを作成します)。

C-c C-b (Message mode)
mail-text
コマンド`C-c C-b` (`message-goto-body`)は、ポイントをヘッダー区切り行の下 — つまり本文の先頭にポイントを移動します。

message-tab
TAB (Message mode)
‘`To:`’、‘`CC:`’、‘`BCC:`’のようなアドレスを含むヘッダーフィールドを編集しているときは、TAB (`message-tab`)をタイプすることにより、アドレスを補完できます。これは2つの方法にもとづいて、そのアドレスにタイプするフルネームを挿入しようと試みます。まず複数のディレクトリーサーバープロトコルを認識するEUDCライブラリーを試み(section “EUDC” in The Emacs Unified Directory Clientを参照してください)、それに失敗したときはメールエイリアスによりアドレスの展開を試みます([Mail Aliases](#Mail-Aliases)を参照してください)。メール本文のような、アドレスを要求しないヘッダーフィールドにポイントがあるとき、TABはタブ文字を挿入するだけです。

### メールの引用

citing mail
`C-c C-y`  
選択されたメッセージを、引用のためにメールリーダーからyankします(`message-yank-original`)。

`C-c C-q`  
他のメッセージから引用された各パラグラフをフィルします(`message-fill-yanked-message`)。

C-c C-y (Message mode)
message-yank-original
message-yank-prefix
`C-c C-y` (`message-yank-original`)を使用して、返信するメッセージから“引用(cite)”することができます。これは、そのメッセージのテキストをメールバッファーに挿入します。このコマンドは、Rmailのように、Emacsから実行されるメールリーダーから呼び出されたときだけ機能します。

デフォルトでは、Emacsは引用されたテキストの各行の前に、文字列‘`>`’を挿入します。このプレフィクス文字列は、変数`message-yank-prefix`で指定されます。プレフィクス引数を指定して`message-yank-original`を呼び出した場合、引用のためのプレフィクスは挿入されません。

C-c C-q (Message mode)
mail-fill-yanked-message
`C-c C-y`を使用した後で、`C-c C-q` (`message-fill-yanked-message`)とタイプして、引用されたメッセージのパラグラフをフィルできます。`C-c
C-q`の1つの使い方としては、そのようなパラグラフのすべてを個別にフィルすることです。クォートされたメッセージの1つのパラグラフをフィルするには、`M-q`を使います。フィルが、あなたが使用している引用プレフィクスを自動的に処理しない場合は、フィルプレフィクスを明示的にセットしてみてください。[Filling](#Filling)を参照してください。

mail-citation-hook
フック`mail-citation-hook`を通じて、メールの引用をカスタマイズできます。たとえば、より柔軟な引用を提供するSuperciteパッケージを使うことができます(section “Introduction” in Superciteを参照してください)。

### メール、その他

C-c C-a (Message mode)
mml-attach-file
MIME
Multipurpose Internet Mail Extensions
メールバッファーで`C-c C-a` (`mml-attach-file`)とタイプすることにより、送信するメッセージに、ファイルを添付(attach)できます。添付は、MIME(Multipurpose Internet Mail Extensions)標準を使って行なわれます。

`mml-attach-file`コマンドはファイル名と、添付ファイルのcontent type(内容のタイプ)、description(説明)、disposition(性質)の入力を求めます。通常content typeは自動的に検知されます。単にRETとタイプすると、そのデフォルトが適用されます。descriptionは1行のテキストで、そのメールの受取人には添付ファイルの隣に表示されます。これは空にすることもできます。dispositionは‘`inline`’、または‘`attachment`’のどちらかです。‘`inline`’の場合、メッセージ本文に添付ファイルへのリンクが表示され、‘`attachment`’の場合は、本文とは別にリンクが表示されます。

mail-add-attachment
`mml-attach-file`コマンドは、Messageモードに特有なコマンドです。Mailモードではかわりに、`mail-add-attachment`を使用します。これはファイル名の入力だけを求め、content typeとdispositionは自動的に決定されます。添付ファイルの説明を含めたい場合は、それをメッセージの本文にタイプしてください。

添付ファイルの実際の内容は、メールバッファーには挿入されません。かわりに、以下のような代替テキストがメールバッファーに挿入されます:

    <#part type="text/plain" filename="~/foo.txt" disposition=inline>
    <#/part>

`C-c C-c`または`C-c C-s`でメッセージを送信するとき、それと一緒に添付ファイルも送信されます。

ispell-message
メッセージを作成しているとき、`M-x
ispell-message`とタイプして、メッセージテキストのスペル訂正を行なうことができます。受信メッセージから送信用の下書きにyankした場合、このコマンドはyankされたテキストをスキップして、あなた自身が挿入したテキストだけをチェックします(このコマンドはインデント、またはあなたの入力と引用された行を区別する`mail-yank-prefix`を調べます)。[Spelling](#Spelling)を参照してください。

message-mode-hook
message-setup-hook
Messageモードをオンに切り替えると(`C-x
m`は自動的にこれを行ないます)、ノーマルフックの`text-mode-hook`と`message-mode-hook`が自動的に実行されます。新しい送信メッセージの初期化では、ノーマルフック`message-setup-hook`が実行されます。メールバッファーの外観を変更したい場合は、このフックを使うことができます。[Hooks](#Hooks)を参照してください。

これらのフックの主な違いは、それらが呼び出されるタイミングだけです。`C-x m`, `message-mode-hook`とタイプしたときは、メールバッファーが作成された直後に`message-mode-hook`が実行されます。その後`message-setup`関数がそのバッファーのデフォルトの内容を挿入します。これらのデフォルトの内容が挿入された後に、`message-setup-hook`が実行されます。

既存のメッセージにたいして、`C-x
m`で作成を継続する場合、そのメールバッファーに切り替えた直後に、`message-mode-hook`が実行されます。バッファーが変更されていない場合、またはそれを削除して新たに作成を開始する場合には、デフォルトの内容が挿入された後に、`message-setup-hook`が実行されます。

メール署名
----------

mail signature
message-signature-file
message-signature
各メッセージの最後に標準的なテキストの断片 — メール署名(mail signature) — を追加できます。この署名には、あなたの電話番号や住所などの情報を含めることができます。変数`message-signature`は、Emacsがメール署名を扱う方法を決定します。

`message-signature`のデフォルト値は`t`です。これはメール署名をファイル`~/.signature`から探すことを意味します。ファイルが存在する場合、そのファイルの内容がメールバッファーの最後に自動的に挿入されます。変数`message-signature-file`を通じて署名ファイルを変更できます。

`message-signature`を文字列に変更すると、それは署名のテキストを直接指定することになります。

C-c C-w (Message mode)
message-insert-signature
`message-signature`を`nil`に変更した場合、Emacsはメール署名を自動的に挿入しません。メールバッファーで`C-c
C-w` (`message-insert-signature`)とタイプすることにより、メール署名を挿入できます。この場合も、Emacsは署名ファイルから署名を探します。

mail-signature-file
mail-signature
メールを作成するのにMessageモードではなくMailモードを使用する場合、どのようにして署名を送るか決定する変数は、`mail-signature`と`mail-signature-file`になります。

慣例により、メール署名は行の内容が‘`--
`’であることによりマークされるべきです。署名にこのプレフィクスがない場合、このプレフィクスが追加されます。署名は4行を超えないようにするべきです。

アミューズメント
----------------

spook
NSA
`M-x
spook`は、送信するメールメッセージに、ランダムに選択されたキーワードの行を追加します。これらのキーワードは、あなたが何らかの破壊活動を企てていると思わせるような単語のリストから選択されます。

この機能の背後にあるアイデアは、NSA[16]や他の情報機関が、かれらが関心をもつキーワードを含むすべてのインターネットメールのメッセージを監視しているという疑惑です(そのような政府機関は、“やっていない”と言いますが、もちろんかれらはそう言うでしょう)。このアイデアは、もし多くの人々がメッセージに不審な単語を含めれば、政府機関は不審な入力で手一杯になり、やがて最後はそれらを読むのを止めるだろうというものです。これが本当かどうかはわかりませんが、少なくとも人々を楽しませることができます。

fortune-to-signature
fortune cookies
`fortune`プログラムを使用して、送信メールにフォーチューンクッキー(fortune cookie)メッセージを追加できます。これを行なうには`mail-setup-hook`に`fortune-to-signature`を追加してください。

    (add-hook 'mail-setup-hook 'fortune-to-signature)

多分、これを使う前に変数`fortune-file`をセットする必要があるでしょう。

メール作成方法
--------------

mail-composition methods
Mail mode
mode, Mail
MH mail interface
Message mode for sending mail
このチャプターでは、メールを編集したり送信する通常のEmacsモードである、Messageモードを説明してきました。これは、いくつかの利用可能なモードのうちの1つに過ぎません。Emacs23.2以前では、デフォルトのモードはMailモードで、これは多くの点でMessageモードに似ていますが、MIMEサポートのような機能がありません。その他の利用可能なモードはMH-Eです(section “MH-E” in The Emacs Interface to MHを参照してください)。

mail-user-agent
これらのメールユーザーエージェント(mail user agents)から、メールを編集したり送信するための、好みの方法を選択できます。コマンド`C-x m`、`C-x 4
m`、`C-x 5
m`は指定されたエージェントを使用するので、Emacsでメールを送信する他の様々な部分(たとえばバグリポーターなど、[Bugs](#Bugs)を参照してください)もこれを行ないます。メールユーザーエージェントを指定するには、変数`mail-user-agent`をカスタマイズします。現在のところ、正式な値には`message-user-agent`(Messageモード)、`sendmail-user-agent`(Mailモード)、`gnus-user-agent`、`mh-e-user-agent`が含まれます。

他のメール作成方法を選択した場合、メールバッファーとMessageモードに関するこのチャプターの情報は適用できません。他の方法は違うバッファーで異なるフォーマットのテキストを使用し、コマンドも異なります。

read-mail-command
同様に、メールを読むための好みの方法を指定するには、変数`read-mail-command`をカスタマイズします。デフォルトは`rmail`です([Rmail](#Rmail)を参照してください)。

Rmailでメールを読む
===================

Rmail
reading mail
rmail
rmail-mode
rmail-mode-hook
Rmailは、メールを閲覧したり処理するための、Emacsのサブシステムです。Rmailは、Rmailファイルを呼ばれるファイルに、メールメッセージを保存します。Rmailファイルの中のメッセージの閲覧は、Rmailモードという特別なメジャーモードで行なわれます。このモードはメールを管理するために実行するコマンドのために、多くの文字を再定義します。

Emacsには、より複雑かつ柔軟なGnusと呼ばれるメールを読むためのサブシステムが同梱されています。Gnusは巨大なパッケージなので、独自のマニュアルThe Gnus Newsreaderで説明されているので、それを参照してください。

Rmailの基本的な概念
-------------------

primary Rmail file
rmail-file-name
もっとも簡単な方法でRmailを使用するには、メールが保存される`~/RMAIL`というRmailファイルを使用します。これはプライマリーRmailファイル(primary Rmail file)と呼ばれます。コマンド`M-x
rmail`はプライマリーRmailファイルを読み込み、inbox(受信箱)から新しいメールをマージして、未読の最初のメッセージを表示して、それを閲覧出きるようにします。変数`rmail-file-name`はプライマリーRmailファイルの名前を指定します。

current message (Rmail)
Rmailは、Rmailファイルのメッセージを、1度に1つだけ表示します。表示されているメッセージは、カレントメッセージ(current message: 現在のメッセージ)と呼ばれます。Rmailモードの特別なコマンドは、カレントメッセージの削除、他のファイルへのコピー、返信、他のメッセージへの移動を行なうことができます。複数のRmailファイル([Files](#Files)を参照)を作成して、それらの間でメッセージの移動をするのに、Rmailを使用することができます([Rmail Output](#Rmail-Output)を参照)。

message number (Rmail)
Rmailファイルでは通常、メッセージは受信した順になっています。それらをソートする他の方法を指定できます([Rmail Sorting](#Rmail-Sorting)を参照してください)。メッセージは連続する整数で識別され、それはメッセージナンバー(message numbers)と呼ばれます。カレントメッセージのナンバーはRmailのモードラインに表示され、その後にはファイル内のメッセージの総数が続きます。`j`でメッセージナンバーを指定して、そのメッセージに移動できます([Rmail Motion](#Rmail-Motion)を参照してください)。

s (Rmail)
rmail-expunge-and-save
通常のEmacsの慣例にしたがい、Rmailでの変更は、そのファイルを保存したときだけ永続化されます。`s` (`rmail-expunge-and-save`)で、ファイルを保存することができます、これは最初に削除されたメッセージをファイルから完全に削除します([Rmail Deletion](#Rmail-Deletion)を参照してください)。完全な削除を行なわずにファイルを保存するには、`C-x
C-s`を使用します。Rmailは、inboxファイルから新しいメールをマージした後に、自動的にRmailファイルを保存します。

q (Rmail)
rmail-quit
b (Rmail)
rmail-bury
Rmailをexitするには、`q` (`rmail-quit`)を使用します。これはRmailにたいして完全な削除と保存を行い、Rmailバッファーと、(表示されていれば)サマリーバッファーを隠します([Rmail Summary](#Rmail-Summary)を参照してください)。しかし正式にexitする必要はありません。Rmailから他のバッファーを編集するために切り替えて、2度とRmailに戻らなければ、それはexitしたことになります。(他の変更したファイルと同様に)最終的にRmailファイルを確実に保存することだけが重要です。これを行なうには`C-x
s`が適しています([Save Commands](#Save-Commands)を参照してください)。Rmailコマンドの`b` `rmail-bury`は、Rmailファイルにたいする完全な削除と保存を行なわずに、Rmailバッファーとサマリーを隠します。

メッセージのスクロール
----------------------

Rmailが画面に収まらないメッセージを表示しているときは、残りを読むためにスクロールしなければなりません。通常のスクロールコマンド`C-v`、`M-v`、`M-<` ([Scrolling](#Scrolling)を参照)などでこれを行なうことができますが、Rmailでのスクロールは頻繁に行なわれるので、簡単に行なえるようにする価値があります。

`SPC`  
前方にスクロールします(`scroll-up-command`)。

`DEL`; `S-SPC`  
後方にスクロールします(`scroll-down-command`)。

`.`  
メッセージの最初にスクロールします(`rmail-beginning-of-message`)。

`/`  
メッセージの最後にスクロールします(`rmail-end-of-message`)。

SPC (Rmail)
DEL (Rmail)
S-SPC (Rmail)
メッセージを読むときにもっとも一般的に行なうのは、画面単位でメッセージをスクロールすることなので、RmailはSPCとDEL(または`S-SPC`)で、`C-v` (`scroll-up-command`)と`M-v` (`scroll-down-command`)と同じことを行なうようにしています。

. (Rmail)
/ (Rmail)
rmail-beginning-of-message
rmail-end-of-message
コマンド`.` (`rmail-beginning-of-message`)は、選択されたメッセージの最初に、後方へスクロールします。これは`M-<`とまったく同じではありません。このコマンドはマークをセットしません。他にも、カレントメッセージのバッファー境界を変更していた場合(たとえば編集により。[Rmail Editing](#Rmail-Editing)を参照されたい)は、それをリセットします。同様に、コマンド`/` (`rmail-end-of-message`)は、選択されたメッセージの最後に、前方へスクロールします。

メッセージ間の移動
------------------

メッセージにたいして行なうもっとも基本的なことは、それを読むことです。Rmailでこれを行なうために、そのメッセージをカレントにします。通常の方法はファイルを、受信したメッセージ順に移動していく方法です(その最初のメッセージは‘`unseen`’(未読)の属性をもちます。[Rmail Attributes](#Rmail-Attributes)を参照してください)。他の新しいメッセージを読むには、前方に移動します。古いメッセージを再読するには後方に移動します。

`n`  
間にある削除されたメッセージをスキップして、次の削除されていないメッセージに移動します(`rmail-next-undeleted-message`)。

`p`  
前の削除されていないメッセージに移動します(`rmail-previous-undeleted-message`)。

`M-n`  
削除されたメッセージも含めて、次のメッセージに移動します(`rmail-next-message`)。

`M-p`  
削除されたメッセージも含めて、前のメッセージに移動します(`rmail-previous-message`)。

`C-c C-n`  
カレントメッセージと同じsubjectの、次のメッセージに移動します(`rmail-next-same-subject`)。

`C-c C-p`  
カレントメッセージと同じsubjectの、前のメッセージに移動します(`rmail-previous-same-subject`)。

`j`  
最初のメッセージに移動します。引数nを指定すると、n番目のメッセージに移動します(`rmail-show-message`)。

`>`  
最後のメッセージに移動します(`rmail-last-message`)。

`<`  
最初のメッセージに移動します(`rmail-first-message`)。

`M-s regexp RET`  
regexpへのマッチを含む、次のメッセージに移動します(`rmail-search`)。

`- M-s regexp RET`  
regexpへのマッチを含む、前のメッセージに移動します(これは負の引数による`M-s`である)。

n (Rmail)
p (Rmail)
M-n (Rmail)
M-p (Rmail)
rmail-next-undeleted-message
rmail-previous-undeleted-message
rmail-next-message
rmail-previous-message
`n`と`p`は、Rmailでメッセージを移動する通常の方法です。これらは、(通常そうしたいように)削除されたメッセージをスキップして、メッセージを順番に移動していきます。これらのコマンドの定義には、`rmail-next-undeleted-message`および`rmail-previous-undeleted-message`という名前がつけられています。削除されたメッセージをスキップしたくない場合 — たとえばメッセージの削除を取り消すために — は、変種の`M-n`と`M-p`(`rmail-next-message`と`rmail-previous-message`)を使います。これらのコマンドへの数引数は、繰り返し回数を指定します。

Rmailでは数引数の指定は、単に数字をタイプして行なうことができます。最初に`C-u`をタイプする必要はありません。単に`-`とタイプして、負の引数を指定することもできます。

M-s (Rmail)
rmail-search
searching in Rmail
`M-s` (`rmail-search`)は、Rmail版の検索コマンドです。通常のインクリメンタル検索`C-s`は機能しますが、これはカレントメッセージだけを検索します。`M-s`の目的は、他のメッセージにたいする検索です。これは非インクリメンタルに正規表現([Regexps](#Regexps)を参照してください)を読み取り、後続のメッセージの先頭から検索を開始して、見つかったらそのメッセージを選択します。regexpが空の場合、`M-s`は前回使用したregexpを再使用します。

ファイルの中の他のメッセージにたいして後方に検索するには、`M-s`に負の引数を与えます。Rmailでは`-
M-s`でこれを行なうことができます。これは前のメッセージの最後から検索を開始します。

ラベルにもとづく検索も可能です。[Rmail Labels](#Rmail-Labels)を参照してください。

C-c C-n (Rmail)
C-c C-p (Rmail)
rmail-next-same-subject
rmail-previous-same-subject
`C-c C-n` (`rmail-next-same-subject`)コマンドは、カレントメッセージと同じsubjectをもつ、次のメッセージに移動します。プレフィクス引数は繰り返し回数として使用されます。負の引数を指定すると、`C-c
C-p` (`rmail-previous-same-subject`)のように、後方に移動します。subjectを比較するとき、subjectへの返信に通常付加されるようなプレフィクスは無視します。これらのコマンドは、同じsubjectに関するすべてのメッセージ、いわゆるthreadを読むときに有用です。

j (Rmail)
&gt; (Rmail)
&lt; (Rmail)
rmail-show-message
rmail-last-message
rmail-first-message
メッセージの絶対番号を指定してメッセージに移動するには、メッセージ番号を引数として、`j` (`rmail-show-message`)を使用します。引数を与えない場合、`j`は最初のメッセージに移動します。`<` (`rmail-first-message`)も最初のメッセージを選択します。`>` (`rmail-last-message`)は最後のメッセージを選択します。

メッセージの削除
----------------

deletion (Rmail)
メッセージを残す必要がなくなったとき、それを削除(delete)できます。これはそのメッセージを無視するフラグをつけ、いくつかのRmailコマンドは、そのメッセージが存在しないかのように振る舞います。しかし、そのメッセージはまだRmailファイルの中にあり、メッセージ番号ももっています。

expunging (Rmail)
Rmailファイルにたいして完全な削除(expunging)を行なうことにより、削除されたメッセージを実際に消去します。残ったメッセージには新たに連番が振られます。

`d`  
カレントメッセージを削除して、次の削除されていないメッセージに移動します(`rmail-delete-forward`)。

`C-d`  
カレントメッセージを削除して、前の削除されていないメッセージに移動します(`rmail-delete-backward`)。

`u`  
カレントメッセージの削除を取り消すか、前の削除されたメッセージに後方へ移動して、そのメッセージの削除を取り消します(`rmail-undelete-previous-message`)。

`x`  
Rmailファイルにたいして完全な削除を行ないます(`rmail-expunge`)。

d (Rmail)
C-d (Rmail)
rmail-delete-forward
rmail-delete-backward
Rmailには、メッセージを削除するためのコマンドが2つあります。両方ともカレントメッセージを削除して、他のメッセージを選択します。`d` (`rmail-delete-forward`)は、すでに削除されたメッセージをスキップして次のメッセージに移動し、`C-d` (`rmail-delete-backward`)は、前の削除されていないメッセージに移動します。指定方向に、移動先となる削除されていないメッセージが存在しない場合は、単にそのメッセージを削除するだけで、カレントメッセージはそのメッセージのままです。数引数は繰り返し回数を指定します。これにより1つのコマンドで複数のメッセージを削除できます。負の引数は`d`と`C-d`の意味を逆転します。

rmail-delete-message-hook
Rmailがメッセージを削除するときは、フック`rmail-delete-message-hook`が実行されます。フック関数が呼び出されるとき、そのメッセージは削除とマークされますが、そのメッセージがRmailバッファーのカレントメッセージのままです。

undeletion (Rmail)
x (Rmail)
rmail-expunge
u (Rmail)
rmail-undelete-previous-message
すべての削除されたメッセージを最終的にRmailファイルから消すには、`x` (`rmail-expunge`)とタイプします。これを行なうまでは、削除されたメッセージの削除を取り消す(undelete)ことができます。削除の取り消しコマンド`u` (`rmail-undelete-previous-message`)は、ほとんどのケースにおいて`d`コマンドの効果を取り消すようにデザインされています。カレントメッセージが削除されている場合は、カレントメッセージの削除を取り消します。そうでない場合は、削除されたメッセージが見つかるまで後方に移動して、そのメッセージの削除を取り消します。数引数は繰り返し回数を指定します。これにより1つのコマンドで複数のメッセージ削除を取り消すことができます。。

通常、`d`を`u`で取り消すことができます。なぜなら`u`は後方に移動して、`d`で削除されたメッセージの削除を取り消すからです。しかしこれは、削除するメッセージの前にすでに削除されたメッセージがある場合、`d`はこれらのメッセージをスキップするのでうまく機能しません。その後で`u`コマンドを実行すると、スキップされた最後のメッセージの削除を取り消すからです。この問題を避ける明解な方法はありません。しかし`u`コマンドを繰り返すことにより、削除を取り消したいメッセージに戻ることができます。`M-p`コマンドで特定の削除されたメッセージを選択してから、`u`をタイプして削除を取り消すこともできます。

削除されたメッセージは‘`deleted`’の属性をもち、結果として、カレントメッセージが削除されている場合はモードラインに‘`deleted`’が表示されます。実際のところ、メッセージの削除と削除の取り消しは、この属性の追加または削除に過ぎません。[Rmail Attributes](#Rmail-Attributes)を参照してください。

Rmailファイルとinbox
--------------------

inbox file
ローカルでメールを受信したとき、オペレーティングシステムは受信メールを、私たちがinboxと呼ぶファイルに配します。Rmailを開始したとき、`movemail`と呼ばれるCプログラムを実行して、inboxから新しいメッセージを、RmailセッションのRmailファイルにコピーします。このRmailファイルには、以前のRmailセッションの他のメッセージも含まれています。Rmailで実際に読むメールは、このファイルの中にあります。この操作は新しいメールの取得(getting new mail)と呼ばれます。`g`とタイプすることにより、いつでも新しいメールを取得できます。

rmail-primary-inbox-list
MAIL
environment variable
変数`rmail-primary-inbox-list`は、プライマリーRmailファイルにたいするinboxファイルのリストを含みます。この変数を明示的にセットしない場合、Rmailは環境変数MAILを使用するか、最後の手段として`rmail-spool-directory`にもとづく、デフォルトのinboxを使用します。デフォルトのinboxはオペレーティングシステムに依存し、それは`/var/mail/username`、`/var/spool/mail/username`、`/usr/spool/mail/username`などです。

コマンド`set-rmail-inbox-list`で、カレントセッションでの任意のRmailファイルにたいするinboxファイルを指定できます。[Rmail Files](#Rmail-Files)を参照してください。

inboxとは別にRmailファイルをもつべき理由が2つあります。

1.  inboxファイルのフォーマットは、オペレーティングシステムと、それを使用する他のメールソフトによりさまざまです。Rmailの一部だけがそれらの候補を理解していればよく、それらすべてをRmail自身のフォーマットに変換する方法だけを理解すればよいからです。

2.  メールを紛失せずにinboxにアクセスするのは厄介です。なぜならそれはメール配信とインターロック(連動)する必要があるからです。さらにオペレーティングシステムごとに、異なるインターロック技術が使用されています。inboxから別のRmailファイルに1度メールを移動する方法により、Rmailの残りのすべてがインターロックの必要性を無視できます。なぜならRmailはRmailファイルだけを操作すればよいからです。

mbox files
rmail-mbox-format
Rmailは、Rmailファイルの内部フォーマットとして、UnixおよびGNUシステムに取り入れられた、標準的な‘`mbox`’フォーマットを使用します(実際のところ、mboxフォーマットとは若干の違いがあります。その違いは重要ではありませんが、変数`rmail-mbox-format`をセットすることにより、あなたのシステムが使用するフォーマットをRmailに指定できます。詳細は、変数のドキュメントを参照してください)。

rmail-preserve-inbox
新しいメールを受信したとき、Rmailは最初にその新しいメールをinboxファイルからRmailファイルにコピーします。それからRmailファイルを保存して、その後でinboxファイルからそれをクリアーします。この方法では、システムのクラッシュにより、inboxとRmailファイルの間でメールの重複は発生するかもしれませんが、メールを失うことはあり得ません。`rmail-preserve-inbox`が非`nil`の場合、Rmailは新しいメールを受信したときにinboxファイルをクリアーしません。旅行の際など、携帯用のコンピューターでPOPを通じてメールをチェックするときは、この変数をセットすれば、メールはサーバーに残るので、後であなたがメインに使用するワークステーションのデスクトップに保存することができます。

Rmailがinboxファイルから間接的に新しいメールをコピーするケースがあります。最初に`movemail`プログラムを実行してinboxから、Rmailファイルと同じディレクトリーにある、`.newmail-inboxname`と呼ばれる中間ファイルにメールを移動します。その後、Rmailは、そのファイルから新しいメールをマージして、Rmailファイルを保存し、中間ファイルの削除はその後にだけ行なわれます。悪いタイミングでクラッシュが発生した場合、中間ファイルは残っているので、Rmailは次にinboxファイルから新しいメールを取得するとき、それを再使用します。

Rmailが`.newmail-inboxname`の中のデータをmbox形式に変換できない場合、ファイルを`RMAILOSE.n`(nはファイル名を一意にするために選ばれます)にリネームするので、Rmailはそのデータで再度問題を起こすことはなくなります。メッセージの何がRmailを混乱させたか調べて、それを削除すべきです(大抵は8進コード037のcontrol-underscoreがメッセージに含まれている場合です)。その後、修正されたファイルから`1
g`を使って新しいメールを取得できます。

複数のRmailファイル
-------------------

Rmailはデフォルトで、あなたのプライマリーRmailファイル(primary Rmail file)を操作します。これは`~/RMAIL`というファイルで、inboxファイルからメールを受け取ります。しかし他のRmailファイルを所有して。Rmailでそれを編集することができます。これらのファイルは、それら自身のinboxからメールを受け取ったり、明示的なRmailコマンドでメッセージを移動することができます([Rmail Output](#Rmail-Output)を参照してください)。

`i file RET`  
fileをEmacsに読み込んで、それにたいしてRmailを実行します(`rmail-input`)。

`g`  
カレントRmailファイルのinboxから、新しいメールをマージします(`rmail-get-new-mail`)。

`C-u g file RET`  
inboxファイルfileから新しいメールをマージします。

i (Rmail)
rmail-input
プライマリーRmailファイル以外のファイルでRmailを実行するために、Rmailで`i` (`rmail-input`)コマンドを使用できます。これは、そのファイルをRmailモードでvisitします。Rmailの外からでも`M-x
rmail-input`を使用することができますが、同じことを行なう`C-u M-x rmail`の方が簡単にタイプできます。

通常`i`で読み込むファイルは、有効なmboxファイルであるべきです。そうでない場合、Rmailはそのファイルのテキストをmbox形式に変換しようと試み、そのバッファーで変換されたテキストをvisitします。バッファーを保存すると、そのファイルが変換されます。

存在しないファイル名を指定した場合、`i`は新しいRmailファイルを作成するために、新しいバッファーを初期化します。

rmail-secondary-file-directory
rmail-secondary-file-regexp
メニューからRmailファイルを選択することもできます。メニューClassifyの、アイテムInput Rmail Fileを選択して、Rmailファイルを選択します。変数`rmail-secondary-file-directory`および`rmail-secondary-file-regexp`は、メニューがどのファイルを表示するかを指定します。最初の変数はファイルを探すディレクトリーを指定し、2番目の変数はそのディレクトリーのどのファイル(正規表現にマッチするファイルすべて)を表示するかを指定します。マッチするファイルがない場合、このメニューアイテムは選択できません。これらの変数は、出力するファイルの選択にも適用されます([Rmail Output](#Rmail-Output)を参照してください)。

rmail-inbox-list
使用するinboxファイルは変数`rmail-inbox-list`により指定され、これはRmailモードではバッファーローカルな変数です。特別な例外として、プライマリーRmailファイルにinboxを指定していない場合、これは環境変数MAIL、またはシステム標準のinboxを使用します。

g (Rmail)
rmail-get-new-mail
`g` (`rmail-get-new-mail`)コマンドは、inboxのメールを、カレントRmailファイルにマージします。Rmailファイルにinboxがない場合、`g`は何もしません。コマンド`M-x
rmail`も、新しいメールをプライマリーRmailファイルにマージします。

merge mail from file (Rmail)
通常のinboxではないファイルからメールをマージするには、`C-u
g`のように`g`キーに数引数を与えます。するとファイル名を読み取り、そのファイルからメールをマージします。引数を使用して`g`を使用しても、inboxファイルの削除・変更はされません。したがって、これはあるファイルのメッセージを、他のファイルにマージする一般的な方法です。

外部ファイルへのメッセージのコピー
----------------------------------

以下はRmailファイルから他のファイルにメッセージをコピーするコマンドです。

`o file RET`  
カレントメッセージの完全なコピーを、ファイルfileに追加します(`rmail-output`)。

`C-o file RET`  
カレントメッセージの表示にしたがい、ファイルfileに追加します(`rmail-output-as-seen`)。

`w file RET`  
メッセージの本文だけをファイルfileに出力します。デフォルトのファイル名は、そのメッセージの‘`Subject`’ヘッダーからとられます。

o (Rmail)
rmail-output
C-o (Rmail)
rmail-output-as-seen
コマンド`o`および`C-o`は、カレントメッセージのコピーを指定したファイルの最後に追加します。2つのコマンドの主な違いは、どれだけコピーするかです。`C-o`が現在表示されているヘッダーだけをコピーするのにたいし、`o`はヘッダーがすべて表示されていなくても、メッセージヘッダーを完全にコピーします。[Rmail Display](#Rmail-Display)を参照してください。加えて、ファイルがBabylフォーマットのとき、`o`はメッセージをBabylフォーマットに変換しますが、`C-o`はBabylファイルを出力できません。

Emacsバッファーで出力ファイルをvisitしていた場合、出力コマンドはメッセージをそのバッファーに追加します。最終的にそのバッファーをファイルに保存するかは、あなた次第です。

w (Rmail)
rmail-output-body-to-file
本文にファイル内容がそのまま記載されているようなメッセージを受信することがあるかもしれません。そのような場合、`w` (`rmail-output-body-to-file`)コマンドで、本文を(メッセージヘッダーを除いて)ファイルに保存できます。そのようなメッセージは‘`Subject`’フィールドにファイル名を意図した内容を含んでいる場合があるので、`w`コマンドは(ファイル名に可搬的に使用できないいくつかの文字を置換した後)デフォルトの出力ファイル名に‘`Subject`’フィールドを使用します。しかし、ファイル名はミニバッファーを使って読み取られるので、異なる名前を指定できます。

メニューからRmailファイルを選択して、メッセージを出力することもできます。メニューClassifyの、メニューアイテムOutput Rmail Fileを選択して、出力したいRmailファイルを選択します。これは`o`コマンドのように、カレントメッセージをそのファイルに出力します。変数`rmail-secondary-file-directory`および`rmail-secondary-file-regexp`は、メニューがどのファイルを表示するかを指定します。最初の変数はファイルを探すディレクトリーを指定し、2番目の変数はそのディレクトリーのどのファイル(正規表現にマッチするファイルすべて)を表示するかを指定します。マッチするファイルがない場合、このメニューアイテムは選択できません。

rmail-delete-after-output
`o`または`C-o`でメッセージをコピーすることにより、メッセージのオリジナルコピーには属性‘`filed`’が与えられるので、そのメッセージがカレントのときは、モードラインに‘`filed`’が表示されます。

各メールメッセージにたいして1つのコピーを保持したい場合は、変数`rmail-delete-after-output`に`t`をセットします。その場合、コマンド`o`、`C-o`および`w`は、コピー後にオリジナルのメッセージを削除します(望むなら後で削除を取り消すことができる。[Rmail Deletion](#Rmail-Deletion)を参照されたい)。

rmail-output-file-alist
変数`rmail-output-file-alist`は、カレントメッセージの内容にもとづいて、理にかなったデフォルトの出力ファイルを指定できます。値は以下の形式をもつ要素のリストです:

    (regexp . name-exp)

カレントメッセージにregexpにたいするマッチが存在する場合、デフォルトの出力ファイルはname-expになります。複数の要素がそのメッセージにマッチする場合、最初にマッチした要素がデフォルトのファイル名を決定します。式name-expは使用するファイル名を与える文字列定数、またはより一般的に、ファイル名を文字列として取得する任意のLisp式を指定できます。`rmail-output-file-alist`は、`o`と`C-o`の両方に適用されます。

rmail-automatic-folder-directives
Rmailは、(`rmail-file-name`で指定される)プライマリーRmailファイルから、(変数`rmail-automatic-folder-directives`の値にもとづいて)他のファイルにメッセージを自動的に保存できます。この変数は、どのメッセージをどこに保存するかを指定する要素(‘`directives`’)のリストです。各directiveは出力ファイルからなるリストで、ヘッダー名と正規表現の組が1つ以上後に続きます。メッセージのヘッダーが指定された正規表現にマッチする場合、そのメッセージは与えられたファイルに保存されます。directiveが複数のヘッダーエントリーをもつ場合、それらすべてがマッチしなければなりません。Rmailはファイル`rmail-file-name`からメッセージを表示するときdirectiveをチェックして、(もしあれば)最初のマッチに適用します。出力ファイルが`nil`の場合、そのメッセージは削除され、保存されません。たとえば特定のアドレスや、特定のsubjectのメッセージを保存するのに、この機能を使用することができます。

ラベル
------

label (Rmail)
attribute (Rmail)
各メッセージは、分類(classification)のために割り当てられる、さまざまなラベル(labels)をもつことができます。各ラベルは名前をもち、名前が異なると違うラベルになります。任意のラベルは、特定のメッセージにたいして、付いているか付いていないかのどちらかです。標準的な意味をもつラベル名がいくつかあり、それが適切なときは、Rmailにより自動的にメッセージに付与されます。これらの特別なラベルは、属性(attribute)と呼ばれます ([Rmail Attributes](#Rmail-Attributes)を参照してください)。 それ以外のすべてのラベルは、ユーザーにより付与されます。

`a label RET`  
カレントメッセージに、ラベルlabelを割り当てます(`rmail-add-label`)。

`k label RET`  
カレントメッセージから、ラベルlabelを外します(`rmail-kill-label`)。

`C-M-n labels RET`  
複数のラベルlabelsのどれか1つをもつ、次のメッセージに移動します(`rmail-next-labeled-message`)。

`C-M-p labels RET`  
複数のラベルlabelsのどれか1つをもつ、前のメッセージに移動します(`rmail-previous-labeled-message`)。

`l labels RET`; `C-M-l labels RET`  
複数のラベルlabelsのどれかを含む、すべてのメッセージのサマリーを作成します(`rmail-summary-by-labels`)。

a (Rmail)
k (Rmail)
rmail-add-label
rmail-kill-label
コマンド`a` (`rmail-add-label`)および`k` (`rmail-kill-label`)で、カレントメッセージにたいして任意のラベルを割り当てたり、外すことができます。引数labelが空の場合、もっとも最近割り当てられた(または外された)ラベルを割り当てる(または外す)ことを意味します。

メッセージを分類するためにラベルを割り当てた後、ラベルを使用する3つの方法 — 移動、サマリー、ソート — があります。

C-M-n (Rmail)
C-M-p (Rmail)
rmail-next-labeled-message
rmail-previous-labeled-message
`C-M-n labels RET` (`rmail-next-labeled-message`)は、複数のラベルlabelsのうちどれか1つをもつ、次のメッセージに移動します。引数labelsには、カンマで区切られた1つ以上のラベル名を指定します。`C-M-p` (`rmail-previous-labeled-message`)も同様ですが、前のメッセージに後方へ移動します。どちらのコマンドも、数引数は繰り返し回数を指定します。

コマンド`C-M-l labels RET` (`rmail-summary-by-labels`)は、指定された複数のラベルのうち、少なくとも1つをもつメッセージだけを含むサマリーを表示します。引数labelsはカンマで区切られた1つ以上のラベル名です。サマリーについての詳細は、[Rmail Summary](#Rmail-Summary)を参照してください。

`C-M-n`、`C-M-p`、`C-M-l`にたいして引数labelsが空の場合は、それらのコマンドにたいして、もっとも最近に指定されたlabelsを使うことを意味します。

ラベルでメッセージをソートする情報については、[Rmail Sorting](#Rmail-Sorting)を参照してください。

Rmailの属性
-----------

‘`deleted`’や‘`filed`’のようないくつかのラベルはビルトインの意味をもち、Rmailは適切なときに、それらをメッセージに割り当てます。これらのラベルは属性(attributes)と呼ばれます。以下はRmailの属性のリストです:

‘`unseen`’  
そのメッセージが1度もカレントになっていないことを意味します。inboxからメッセージが到着したとき割り当てられ、そのメッセージがカレントになったときに外されます。Rmailを開始したとき、この属性をもつメッセージを最初に表示します。

‘`deleted`’  
メッセージが削除されたことを意味します。削除コマンドにより割り当てられ、削除を取り消すコマンドで外されます([Rmail Deletion](#Rmail-Deletion)を参照してください)。

‘`filed`’  
そのメッセージが他のファイルにコピーされたことを意味します。ファイル出力コマンド`o`および`C-o`により割り当てられます([Rmail Output](#Rmail-Output)を参照してください)。

‘`answered`’  
メッセージへの返信をメールしたことを意味します。`r` (`rmail-reply`)コマンドにより割り当てられます。[Rmail Reply](#Rmail-Reply)を参照してください。

‘`forwarded`’  
メッセージを転送したことを意味します。`f` (`rmail-forward`)コマンドにより割り当てられます。[Rmail Reply](#Rmail-Reply)を参照してください。

‘`edited`’  
メッセージのテキストをRmailで編集したことを意味します。[Rmail Editing](#Rmail-Editing)を参照してください。

‘`resent`’  
メッセージを再送したことを意味します。コマンド`M-x rmail-resend`により割り当てられます。[Rmail Reply](#Rmail-Reply)を参照してください。

‘`retried`’  
送信に失敗したメッセージを再試行したことを意味します。コマンド`M-x
rmail-retry-failure`により割り当てられます。[Rmail Reply](#Rmail-Reply)を参照してください。

これ以外のすべてのラベルは、ユーザーだけが割り当てたり外すことができ、それらのラベルは標準的な意味をもちません。

返信の送信
----------

Rmailには、送信メールを送るための複数のコマンドがあります。Messageモードの使い方(Rmailでも動作する特別な機能を含む)に関する情報は、[Sending Mail](#Sending-Mail)を参照してください。このセクションでは、送信メッセージ作成に使用する、mailバッファーに入るエンターするためのRmailの特別なコマンドを説明します。メールを送信するための通常のキー — `C-x m`、`C-x 4 m`、`C-x 5 m` — は、Rmailモードでも通常どおり機能することに注意してください。

`m`  
メッセージを送信します(`rmail-mail`)。

`c`  
すでに編集を開始した送信メッセージの編集を続けます(`rmail-continue`)。

`r`  
カレントRmailメッセージにたいする返信を送信します(`rmail-reply`)。

`f`  
カレントメッセージを他のユーザーに転送します(`rmail-forward`)。

`C-u f`  
カレントメッセージを他のユーザーに再送します(`rmail-resend`)。

`M-m`  
送信に失敗して戻ってきたメッセージにたいして、2回目の送信を試みます(`rmail-retry-failure`)。

r (Rmail)
rmail-reply
reply to a message
Rmailにいるときにメッセージを送信する理由でもっとも一般的なのは、読んでいるメールに返信するときでしょう。これを行なうには、`r` (`rmail-reply`)とタイプします。これは`C-x 4
m`のように、別ウィンドウにメール作成バッファーを表示しますが、ヘッダーフィールド‘`Subject`’、‘`To`’、‘`CC`’、‘`In-reply-to`’、‘`References`’は、返信するメッセージにもとづいて、事前に初期化されています。‘`To`’フィールドには、返信するメッセージを送信した人のアドレスがセットされ、‘`CC`’にはそのメッセージを受け取った、他のすべての人のアドレスがセットされます。

mail-dont-reply-to-names
変数`mail-dont-reply-to-names`を使用して、自動的に返信に含まれる受信者から、特定の受信者を除外することができます。この変数の値には正規表現を指定します。正規表現にマッチする受信者は、‘`CC`’フィールドから除外されます。その受信者を除外することにより‘`To`’フィールドが空になる場合を除き、‘`To`’フィールドからも除外されます。この変数が`nil`の場合、最初に返信を作成するときに、あなた自身のアドレスにマッチするデフォルト値に初期化されます。

元メッセージの送信者だけにリプライするには、`C-u r`または`1
r`のように、数引数とともに返信コマンドをエンターします。特定の返信にたいして‘`CC`’フィールドを完全に省略するには、返信コマンドに数引数を指定します。これは、元のメッセージを送信した人だけに返信することを意味します。

1度メール作成バッファーが初期化されると、後は通常どおりメールの編集と送信を行なうことができます([Sending Mail](#Sending-Mail)を参照してください)。事前にセットされたヘッダーフィールドが適切でない場合は、それを編集することができます。`C-c
C-y`のようなコマンドを使うこともできます。これは返信するメッセージをyankします([Mail Commands](#Mail-Commands)を参照してください)。Rmailバッファーに切り替えて、異なるメッセージを選択してから、また戻って新しいカレントメッセージにyankすることもできます。

M-m (Rmail)
rmail-retry-failure
retrying a failed message
rmail-retry-ignored-headers
メッセージが送信先に届かないこともあります。そのような場合メーラーは通常、失敗メッセージ(failure message)をあなたに返信します。Rmailコマンドの`M-m` (`rmail-retry-failure`)は、同じメッセージの2回目の送信を準備をします。これは前と同じテキストとヘッダーフィールドで、メール作成バッファーをセットアップします。そこですぐに`C-c
C-c`をタイプすると、初回とまったく同じメッセージを再送します。テキストやヘッダーを編集してから送信することもできます。変数`rmail-retry-ignored-headers`は、失敗したメッセージを再試行するとき除外するヘッダーを制御し、フォーマットは`rmail-ignored-headers` ([Rmail Display](#Rmail-Display)を参照してください)と同じです。

f (Rmail)
rmail-forward
forwarding a message
Rmailからメールを送信する他のよくある理由に、カレントメッセージを他のユーザーに転送(forward)することです。`f` (`rmail-forward`)は、メール作成バッファーのテキストとsubjectを、カレントメッセージで事前に初期化することにより、これを簡単に行なえるようにします。subjectは`[from:
subject]`という形式で初期化されます。fromとsubjectには、元のメッセージの送信者とsubjectが入ります。あなたが行なう必要があるのは、送信先を記述して、それを送信することだけです。メッセージを転送するとき、受信者が受け取るメッセージのfromはあなたになり、メールの内容は元のメッセージと同じになります。

rmail-enable-mime-composing
unforward-rmail-message
Rmailは転送メッセージにたいして2つのフォーマットを提供します。デフォルトはMIMEフォーマットを使用します([Rmail Display](#Rmail-Display)を参照してください)。これは元のメッセージを別の部分に含めます。変数`rmail-enable-mime-composing`を`nil`にセットすることにより、もっと簡単なフォーマットを使うこともできます。この場合、Rmailは元のメッセージを2つの区切り行で囲むだけです。これは各行の行頭に‘`-
`’を挿入することにより、各行の変更も行ないます。このフォーマットによる転送メッセージを受信した場合、それに普通のテキスト以外の何か — たとえばプログラムのソースコード — が含まれている場合、この変更を取り消せたら便利だと思うかもしれません。これを行なうには、転送されたメッセージを選択して、`M-x
unforward-rmail-message`とタイプします。このコマンドは、挿入された文字列‘`-
`’を削除して、転送されたメッセージのオリジナルを抽出し、カレントメッセージの直後に、別のメッセージとしてRmailファイルに挿入します。

rmail-resend
再送(Resending)は、転送と似た別の方法です。違いは、再送により送信されるメッセージは、あなたが受け取ったときのように、元の送信者がfromになり、追加のヘッダーフィールド(‘`Resent-From`’と‘`Resent-To`’)により、それがあなたを通じて送られたことを示すことです。Rmailでメッセージを再送するには、`C-u
f`を使用します(`f`は`rmail-forward`を実行し、数引数を指定すると`rmail-resend`を呼び出します)。

m (Rmail)
rmail-mail
`m` (`rmail-mail`)を使用することにより、返信ではない送信用のメールの編集を開始します。これはヘッダーフィールドを空のままにします。`C-x
4 m`との違いは、`r`のように`C-c C-y`でRmailにアクセスできることです。

c (Rmail)
rmail-continue
`c` (`rmail-continue`)コマンドは、既に編集を開始した送信用メッセージの編集を終えるために、または送信したメッセージを変更するために、メール作成バッファーでの編集を再開します。

rmail-mail-new-frame
変数`rmail-mail-new-frame`を非`nil`にセットした場合、メッセージの送信を開始するすべてのコマンドは、それを編集するために新しいフレームを作成します。このフレームは、そのメッセージを送信すると削除されます。

メッセージを送信するすべてのRmailコマンドは、選択されたメール作成方法を使用します([Mail Methods](#Mail-Methods)を参照してください)。

サマリー
--------

summary (Rmail)
サマリー(summary)は、Rmailファイルのメールを概観するために、メッセージごとに1つの行を含むバッファーです。各行にはメッセージ番号、日付、送信者、行数、ラベル、subjectが表示されます。サマリーバッファーでポイントを移動することにより、そのサマリー行のメッセージを選択することができます。ほとんどのRmailコマンドはサマリーバッファーでも有効です。それらのコマンドを使うと、サマリーのカレント行に記述されているメッセージに適用されます。

サマリーバッファーは、1つのRmailファイルだけに適用されます。複数のRmailファイルを編集している場合、それぞれが自身のサマリーバッファーをもつことができます。サマリーバッファーの名前は、Rmailバッファーの名前に‘`-summary`’を追加して作成されます。通常は1度に1つだけのサマリーバッファーが表示されます。

### サマリーの作成

以下は、カレントRmailバッファーでサマリーを作成するコマンドです。Rmailバッファーが1度サマリーされると、Rmailバッファーでの変更(メッセージの削除や完全な削除、新しいメールの受信など)により、サマリーも自動的に更新されます。

`h`; `C-M-h`  
すべてのメッセージをサマリーします(`rmail-summary`)。

`l labels RET`; `C-M-l labels RET`  
1つ以上の指定したラベルをもつメッセージをサマリーします(`rmail-summary-by-labels`)。

`C-M-r rcpts RET`  
指定した受信者にマッチするメッセージをサマリーします(`rmail-summary-by-recipients`)。

`C-M-t topic RET`  
指定した正規表現topicにマッチするsubjectをもつメッセージをサマリーします(`rmail-summary-by-topic`)。

`C-M-s regexp RET`  
指定した正規表現regexpにマッチするヘッダーをもつメッセージをサマリーします(`rmail-summary-by-regexp`)。

`C-M-f senders RET`  
指定した送信者にマッチするメッセージをサマリーします(`rmail-summary-by-senders`)。

h (Rmail)
rmail-summary
コマンド`h`または`C-M-h` (`rmail-summary`)は、カレントRmailバッファーにたいする、すべてのメッセージのサマリーを、サマリーバッファーに表示します。その後、別のウィンドウにサマリーバッファーを表示して、それを選択します。

l (Rmail)
C-M-l (Rmail)
rmail-summary-by-labels
`C-M-l labels RET` (`rmail-summary-by-labels`)は、1つ以上のラベルlabelsをもつメッセージの、部分的なサマリーを作成します。labelsには、カンマで区切られたラベル名を指定します。

C-M-r (Rmail)
rmail-summary-by-recipients
`C-M-r rcpts RET` (`rmail-summary-by-recipients`)は、正規表現rcptsにマッチする、1つ以上の受信者をもつメッセージのサマリーを作成します。これはヘッダー‘`To`’、‘`From`’、‘`CC`’にたいしてマッチを行ないます(プレフィクス引数を与えた場合は‘`CC`’ヘッダーを除外する)。

C-M-t (Rmail)
rmail-summary-by-topic
`C-M-t topic RET` (`rmail-summary-by-topic`)は、正規表現topicにマッチするsubjectをもつメッセージの、部分的なサマリーを作成します。プレフィクス引数を指定した場合、subjectだけでなく、メッセージ全体にたいしてマッチを行ないます。

C-M-s (Rmail)
rmail-summary-by-regexp
`C-M-s regexp RET` (`rmail-summary-by-regexp`)は、正規表現regexpにマッチするヘッダー(日付とsubject行を含む)をもつメッセージの、部分的なサマリーを作成します。

C-M-f (Rmail)
rmail-summary-by-senders
`C-M-f senders RET` (`rmail-summary-by-senders`)は、正規表現sendersにマッチする‘`From`’フィールドをもつメッセージの、部分的なサマリーを作成します。

1つのRmailバッファーにたいして、1つのサマリーしか存在しないことに注意してください。他の種類のサマリーを作成すると、以前のサマリーは破棄されます。

rmail-summary-window-size
rmail-summary-line-count-flag
変数`rmail-summary-window-size`は、サマリーウィンドウに何行使用するかを指定します。変数`rmail-summary-line-count-flag`は、メッセージのサマリー行に、メッセージの総行数を含めるかを制御します。このオプションに`nil`をセットすると、サマリーの生成が速くなるかもしれません。

### サマリーでの編集

Rmailバッファーで行なえることのほとんどは、Rmailサマリーバッファーでも使用できます。実際、1度サマリーバッファーを作成すれば、Rmailバッファーに戻る必要はありません。

サマリーバッファーで異なる行にポイントを移動するだけで、サマリーバッファーからメッセージを選択して、Rmailバッファーに表示することができます。ポイントを移動するEmacsコマンドが何であるかは問題になりません。コマンドの最後でポイントのある行のメッセージが、Rmailバッファーに表示されます。

rmail-summary-scroll-between-messages
ほとんどのRmailコマンドは、Rmailバッファーと同様に機能します。したがって、サマリーバッファーでは、`d`がカレントメッセージの削除、`u`は削除の取り消し、`x`で完全に削除します(しかし、サマリーバッファーでは関連する方向に削除されていないメッセージが存在しない場合、削除コマンドはカレントメッセージに留まるのではなく、最初または最後のメッセージに移動します)。`o`と`C-o`は、カレントメッセージをファイルに出力します。他にも、`r`はそれにたいする返信を開始する、などです。サマリーバッファーでSPCとDELを使用することにより、カレントメッセージをスクロールできます。しかし、サマリーバッファーでSPCまたはDELにより、メッセージの終端または先頭を超えてスクロールすると、削除されていない次または前のメッセージに移動します。`rmail-summary-scroll-between-messages`オプションを`nil`にカスタマイズすれば、次または前のメッセージへのスクロールが無効になります。

rmail-summary-undelete-many
`M-u` (`rmail-summary-undelete-many`)は、サマリーで削除されたすべてのメッセージの削除を取り消します。プレフィクス引数を指定した場合、以前に削除された、指定した数のメッセージの削除を取り消すことを意味します。

メッセージ間を移動するRmailコマンドはサマリーバッファーでも機能しますが、動作が少し異なります。これらのコマンドはサマリーに含まれる一連のメッセージ間を移動します。これらのコマンドは、常にRmailバッファーがスクリーンに表示されるようにします(カーソル移動コマンドはRmailバッファーの内容を更新しますが、これらのコマンドはウィンドウにすでにそれが表示されているのでなければ、表示しません)。以下はそれらのコマンドのリストです:

`n`  
“deleted”の行をスキップして次の行に移動し、その行のメッセージを選択します(`rmail-summary-next-msg`)。

`p`  
“deleted”の行をスキップして前の行に移動し、その行のメッセージを選択します(`rmail-summary-previous-msg`)。

`M-n`  
次の行に移動して、その行のメッセージを選択します(`rmail-summary-next-all`)。

`M-p`  
前の行に移動して、その行のメッセージを選択します(`rmail-summary-previous-all`)。

`>`  
最後の行に移動して、その行のメッセージを選択します(`rmail-summary-last-message`)。

`<`  
最初の行に移動して、その行のメッセージを選択します(`rmail-summary-first-message`)。

`j`; `RET`  
(Rmailバッファーがスクリーンに確実に表示されるようにして)カレント行のメッセージを選択します(`rmail-summary-goto-msg`)。引数nを指定した場合、メッセージ番号nのメッセージを選択し、サマリーバッファーのそのメッセージの行に移動します。そのメッセージがサマリーバッファーにリストされていない場合は、エラーをシグナルします。

`M-s pattern RET`  
メッセージからpatternを検索します。検索はカレントメッセージから開始されます。マッチが見つかったらそのメッセージを選択して、サマリーバッファーのそのメッセージの行にポイントを移動します(`rmail-summary-search`)。プレフィクス引数は繰り返し回数として機能します。負の引数は後方に検索を行なうことを意味します(`rmail-summary-search-backward`と等価です)。

`C-M-n labels RET`  
指定した1つ以上のラベルのうち、少なくとも1つをもつ次のメッセージに移動します(`rmail-summary-next-labeled-message`)。labelsはカンマで区切られたラベルのリストです。プレフィクス引数は繰り返し回数として機能します。

`C-M-p labels RET`  
指定した1つ以上のラベルのうち、少なくとも1つをもつ前のメッセージに移動します(`rmail-summary-previous-labeled-message`)。

`C-c C-n RET`  
カレントメッセージと同じsubjectをもつ、次のメッセージに移動します(`rmail-summary-next-same-subject`)。プレフィクス引数は繰り返し回数として機能します。

`C-c C-p RET`  
カレントメッセージと同じsubjectをもつ、前のメッセージに移動します(`rmail-summary-previous-same-subject`)。

rmail-redisplay-summary
削除、削除の取り消し、新しいメールの取得はもちろん、異なるメッセージの選択でも、それらの操作をRmailバッファーで行なったとき、サマリーバッファーは更新されます。変数`rmail-redisplay-summary`が非`nil`の場合、これらの操作はサマリーバッファーをスクリーンに表示します。

Q (Rmail summary)
rmail-summary-wipe
q (Rmail summary)
rmail-summary-quit
b (Rmail summary)
rmail-summary-bury
サマリーの使用を終了するときは、`Q` (`rmail-summary-wipe`)とタイプして、サマリーバッファーのウィンドウを削除します。サマリーからRmailを終了することもできます。`q` (`rmail-summary-quit`)はサマリーウィンドウを削除して、Rmailファイルを保存してからRmailを終了してから、他のバッファーに切り替えます。かわりに`b` (`rmail-summary-bury`)とタイプすると、単にRmailとRmailサマリーバッファーを隠し(bury)ます。

Rmailファイルのソート
---------------------

sorting Rmail file
Rmail file sorting
`C-c C-s C-d`; `M-x rmail-sort-by-date`  
カレントRmailバッファーのメッセージを、日付順にソートします。

rmail-sort-by-subject

`C-c C-s C-s`; `M-x rmail-sort-by-subject`  
カレントRmailバッファーのメッセージを、subject順にソートします。

rmail-sort-by-author

`C-c C-s C-a`; `M-x rmail-sort-by-author`  
カレントRmailバッファーのメッセージを、送信者順にソートします。

rmail-sort-by-recipient

`C-c C-s C-r`; `M-x rmail-sort-by-recipient`  
カレントRmailバッファーのメッセージを、受信者の名前順にソートします。

rmail-sort-by-correspondent

`C-c C-s C-c`; `M-x rmail-sort-by-correspondent`  
カレントRmailバッファーのメッセージを、他の受信者名順にソートします。

rmail-sort-by-lines

`C-c C-s C-l`; `M-x rmail-sort-by-lines`  
カレントRmailバッファーのメッセージを、行数順にソートします。

rmail-sort-by-labels

`C-c C-s C-k RET labels RET`; `M-x rmail-sort-by-labels RET labels RET`  
カレントRmailバッファーのメッセージを、ラベル順にソートします。引数labelsは、カンマで区切られたラベルのリストです。ラベルの順序は、メッセージの順序を指定します。最初のラベルをもつメッセージが最初に、2番目のラベルをもつメッセージが次に、というようになります。ラベルをもたないメッセージは最後になります。

Rmailのソートコマンドは*安定ソート(stable sort)*を行ないます。2つのメッセージのどちらを先にするか特に理由がない場合、メッセージの順序は変更されません。これを使用して複数のソート条件を使用できます。たとえば、`rmail-sort-by-date`の後に`rmail-sort-by-author`を使用すれば、メッセージは作者ごとに日付順にソートされます。

プレフィクス引数を指定した場合、これらのコマンドは逆順で比較をします。これはメッセージが新しいものから古いものへ、大きいものから小さいものへ、アルファベットの逆順でソートされることを意味します。

同じキーをサマリーバッファーで使うと、似た関数が実行されます。たとえば`C-c C-s
C-l`は、`rmail-summary-sort-by-lines`を実行します。これらのコマンドは、たとえサマリーがメッセージの一部しか表示していなくても、Rmailバッファー全体をソートします。

ソートのアンドゥはできないことに注意してください。そのため、ソートをする前にRmailバッファーを保存したいと思うかもしれません。

メッセージの表示
----------------

このセクションではRmailが、メールヘッダー、MIMEのセクションと添付、URL、暗号化されたメッセージを表示する方法を説明します。

`t`  
ヘッダーの完全表示を切り替えます(`rmail-toggle-header`)。

t (Rmail)
rmail-toggle-header
各メッセージを最初に表示する前に、Rmailは余分な物を減らすために、重要でないヘッダーを隠して、メッセージのヘッダーを再フォーマットします。`t` (`rmail-toggle-header`)コマンドは、これを切り替えます。つまり再フォーマットされたヘッダーフィールドと、完全な元のヘッダーの間で、表示を切り替えます。正の引数を指定した場合、このコマンドは再フォーマットされたヘッダーを表示します。0または負の引数を指定した場合、完全なヘッダーを表示します。メッセージを再選択することにより、必要な場合は再フォーマットします。

rmail-ignored-headers
rmail-displayed-headers
rmail-nonignored-headers
変数`rmail-ignored-headers`は、隠すべきヘッダーフィールドを指定する正規表現を保持します。これにマッチするヘッダー行は隠されます。変数`rmail-nonignored-headers`は、これをオーバーライドします。この変数の正規表現にマッチするヘッダーフィールドは、たとえそれが`rmail-ignored-headers`にマッチしても、表示されます。変数`rmail-displayed-headers`は、これら2つの変数のかわりに使用されます。非`nil`の場合、その値には表示するヘッダーを指定する正規表現を指定します(デフォルトは`nil`です)。

rmail-highlighted-headers
Rmailは特に重要なヘッダーフィールド — デフォルトでは‘`From`’と‘`Subject`’フィールドをハイライトします。ハイライトには`rmail-highlight`フェイスが使用されます。変数`rmail-highlighted-headers`は、ハイライトするヘッダーフィールドを指定する正規表現を保持します。これがヘッダーフィールドの先頭にマッチした場合、フィールド全体がハイライトされます。この機能を無効にするには、`rmail-highlighted-headers`に`nil`をセットしてください。

MIME messages (Rmail)
rmail-enable-mime
メッセージがMIME(Multipurpose Internet Mail Extensions)形式で、複数パート(MIMEエンティティー)が含まれている場合、Rmailは各パートにタグライン(tagline)を表示します。タグラインはそのパートのインデックス、サイズ、コンテントタイプを要約します。コンテントタイプに依存して、1つ以上のボタンが含まれる場合があります。これらのボタンは、そのパートをファイルに保存する、などの処理を行ないます。

`RET`  
ポイント位置のMIMEパートを隠す、または表示します(`rmail-mime-toggle-hidden`)。

rmail-mime-next-item

`TAB`  
次のMIMEタグラインのボタンにポイントを移動します(`rmail-mime-next-item`)。

rmail-mime-previous-item

`S-TAB`  
前のMIMEパートにポイントを移動します(`rmail-mime-previous-item`)。

rmail-mime

`v`  
v (Rmail)

MIME表示とrawメッセージの表示を切り替えます(`rmail-mime`)。

プレーンテキストのMIMEパートは、最初タグラインの直後に表示され、Rmailバッファーの他のタイプのMIMEパートは、Rmailバッファーの一部としてタグラインだけが表示され(メッセージがHTMLパートをもたない場合。以下参照)、実際のコンテンツは隠されています。どちらの場合も、MIMEパートのどこか、またはそれのタグラインでRETをタイプすることにより、表示と非表示を切り替えることができます(他の処理を行なうボタンがある場合を除きます)。RETとタイプするかマウスでクリックすることにより、タグラインボタンをアクティブにでき、TABでタグラインのボタンにたいして循環的にポイントを移動できます。

`v` (`rmail-mime`)コマンドは、上記で説明したデフォルトのMIME表示と、MIMEでデコードされていないrawデータの表示を切り替えます。プレフィクス引数を指定した場合は、ポイント位置にあるものの表示だけを切り替えます。

rmail-mime-prefer-html
メッセージにHTMLのMIMEパートがあり、EmacsがHTMLを表示できる場合、Rmailはそれをplain-textパートより優先して表示します[17]。これを抑制してかわりにplain-textパートを表示するには、変数`rmail-mime-prefer-html`を`nil`にカスタマイズしてください。

RmailからMIMEでデコードされたメッセージの処理を抑止するには、変数`rmail-enable-mime`を`nil`に変更します。この場合、`v` (`rmail-mime`)は、カレントMIMEメッセージを表示するために、一時的なバッファーを作成します。

rmail-epa-decrypt
encrypted mails (reading in Rmail)
カレントメッセージが暗号化されている場合、復号化するために`M-x
rmail-epa-decrypt`を使用します。これはEasyPGライブラリーを使用します(section “EasyPG” in EasyPG Assistant User’s Manualを参照してください)。

RmailバッファーでGoto Addressモードを使用して、URLのハイライトとアクティブ化ができます:

    (add-hook 'rmail-show-message-hook 'goto-address-mode)

このモードを使用すると、そのURLを`mouse-2`でクリック(または`mouse-1`で素早くクリック)するか、ポイントをそこに移動して`C-c
RET`とタイプすることにより、それらのURLをブラウズできます。[Activating URLs](#Goto-Address-mode)を参照してください。

Rmailとコーディングシステム
---------------------------

decoding mail messages (Rmail)
Rmailは、Emacsがファイルをvisitしたりサブプロセスの出力にたいして行なうように、非ASCII文字を含むメッセージを自動的にデコードします。Rmailはメッセージで標準の‘`charset=charset`’ヘッダーを使用し、もしそれがあれば、送信者によりメッセージがどのようにエンコードされたか決定します。これはcharsetを、対応するEmacsコーディングシステム([Coding Systems](#Coding-Systems)を参照してください)にマップして、メッセージテキストをデコードするために、そのコーディングシステムを使います。メッセージヘッダーに‘`charset`’指定がない場合、またはcharsetが認識されなかった場合、Rmailは通常のEmacsの経験則とデフォルトに則ったコーディングシステムを選択します([Recognize Coding](#Recognize-Coding)を参照してください)。

fixing incorrectly decoded mail messages
メッセージが間違ってデコードされることもあります。これは‘`charset`’指定がないためにEmacsが間違ったコーディングシステムを推測したか、そもそも指定が間違っているかです。たとえば間違って設定されたメーラーが、メッセージが実際には`koi8-r`でエンコードされているのに、‘`charset=iso-8859-1`’というヘッダーでメッセージを送るかもしれません。メッセージテキストが文字化けしていたり、文字が16進コードや空ボックスで表示されているときは、おそらくこれが発生しています。

rmail-redecode-body
正しいコーディングシステムを解決または推測できる場合、正しいコーディングシステムを使ってメッセージを再デコードすることにより、問題を訂正することができます。これを行なうには`M-x
rmail-redecode-body`コマンドを呼び出します。これはコーディングシステムの名前を読み取り、指定したコーディングシステムを使って、メッセージを再デコードします。正しいコーディングシステムを指定した場合、デコード結果は読めるようになるでしょう。

rmail-file-coding-system
Rmailで新しいメールを受信したとき、各メッセージは、それらがあたかも個別のファイルであるかのように、それぞれが記述されたコーディングシステムに自動的に変換されます。これは指定されたコーディングシステムの優先順を使用します。MIMEメッセージが文字セットを指定している場合、Rmailはその指定にしたがいます。Rmailファイルの読み込みと保存にたいして、Emacsは、変数`rmail-file-coding-system`で指定されたコーディングシステムを使用します。デフォルト値は`nil`で、これはRmailファイルが変換されないことを意味します(これらはEmacsの内部文字セットで読み書きされます)。

メッセージの編集
----------------

通常のEmacsのキーバインドのほとんどはRmailモードで利用可能ですが、`C-M-n`や`C-M-h`のように、他の目的のためにRmailにより再定義されているものもあります。しかしRmailバッファーは通常読み取り専用で、ほとんどの文字はRmailコマンドに再定義されています。メッセージのテキストを編集したい場合、Rmailの`e`コマンドを使わなければなりません。

`e`  
カレントメッセージを通常のテキストとして編集します。

e (Rmail)
rmail-edit-current-message
`e` command (`rmail-edit-current-message`)は、Rmailモードから、Rmail Editモードという、Textモードと類似した、別のメジャーモードに切り替えます。メジャーモードの変更はモードラインに示されます。

rmail-cease-edit
rmail-abort-edit
Rmail Editモードでは、文字は通常どおり文字自身を挿入し、Rmailコマンドは利用できません。メッセージの本文とヘッダーフィールドを編集することができます。メッセージの編集を終えたら、`C-c
C-c` (`rmail-cease-edit`)でRmailモードに戻ります。かわりに`C-c C-]` (`rmail-abort-edit`)とタイプすれば、編集をキャンセルしてRmailモードに戻ることができます。

rmail-edit-mode-hook
Rmail Editモードに入ることにより、フック`text-mode-hook`、その後にフック`rmail-edit-mode-hook`が実行されます([Hooks](#Hooks)を参照してください)。通常のRmailモードにもどると、メッセージを変更した場合には、そのメッセージに属性‘`edited`’が追加されます([Rmail Attributes](#Rmail-Attributes)を参照)。

ダイジェストメッセージ
----------------------

digest message
undigestify
ダイジェストメッセージ(digest message)は、複数の他のメッセージを含み、それを運ぶために存在するメッセージです。ダイジェストは、いくつかのメーリングリストで使用されています。1日というような一定の期間の間にメーリングリストに到着したすべてのメッセージが、1つのダイジェストにまとめられて、メーリングリストに登録した人に送られます。1つのダイジェストを送信するのにかかるコンピューター時間は、たとえ合計サイズが同じでも個別にメッセージを送信するより短くなります。なぜならネットワークでのメール送信において、メッセージ単位のオーバーヘッドがあるからです。

undigestify-rmail-message
ダイジェストメッセージを受信したとき、それを読むもっとも便利な方法は、それを非ダイジェスト化(undigestify)することです。これはダイジェストを複数のメッセージに戻します。それから個別にメッセージを読んだり削除できます。これを行なうにはダイジェストメッセージを選択して、コマンド`M-x
undigestify-rmail-message`をタイプします。これはダイジェストに含まれるメッセージを個別のRmailメッセージに抽出し、ダイジェストの後に挿入します。ダイジェストメッセージ自身には、削除のフラグがつけられます。

Rot13メッセージを読む
---------------------

rot13 code
読む人を怒らせたり不快にするかもしれないメーリングリストのメッセージは、rot13と呼ばれる単純なコードでエンコードされているときがあります。この名前は、エンコードの方法がアルファベットを13文字分巡回させることに由来します。このコードに機密性はなく、それを提供もしません。むしろ、実際のテキストを見るのを避けたいと思う人のためのものです。たとえばビデオの講評などでは、重要なあらすじを隠すためにrot13を使います。

rot13-other-window
rot13を使ったバッファーを閲覧するには、コマンド`M-x
rot13-other-window`を使用します。これはカレントバッファーを他のウィンドウで表示します。このウィンドウではテキストを表示するときこのコードを適用します。

`movemail` program
------------------

movemail
program
Rmailは、inboxからRmailファイルにメールを移動するために、`movemail`プログラムを使用します。最初にロードされたとき、Rmailは`movemail`プログラムを探して、そのバージョンを判断します。`movemail`プログラムには2つのバージョンがあります。それはGNU Mailutilsバージョン(section “movemail” in GNU mailutilsを参照)と、`--with-mailutils`でEmacsをconfigureしたときにインストールされるEmacs固有バージョンです。これらのコマンドは、同じコマンドラインシンタックスをもち、同じ基本的なサブセットオプションをもちます。しかしMailutilsバージョンは、追加の機能を提供します。

Emacsバージョンの`movemail`は、通常のUnix mailbox形式のmailboxからメールを取得することができます。**警告**: これはPOP3プロトコルの使用も可能ですが、暗号化されたTLSチャンネルを通じたPOP3をサポートしないので、推奨しません。

Mailutilsバージョンは、プレーンUnix mailbox、`maildir`および`MH`のメールボックスなどの、より広範なmailbox形式を処理することができます。これはPOP3またはIMAP4プロトコルを使用してリモートのmailboxにアクセスでき、TLS暗号化チャンネル(TLS encrypted channel)を使用してメールを取得できます。これはURL形式でのmailbox引数を受けとることもできます。mailboix URLの詳細な説明は、section “URL” in Mailbox URL Formatsで見ることができます。短く言うと、URLは以下のようなものです:

    proto://[user[:password]@]host-or-file-name[:port]

角カッコ(bracket)はオプションの要素を意味します。

proto  
mailboxプロトコル、または使用するフォーマットを指定します。URLの残りの要素の正確な意味は、protoの実際の値に依存します(以下参照)。

user  
リモートmailboxにアクセスするためのユーザー名です。

password  
リモートmailboxにアクセスするためのユーザーパスワードです。

host-or-file-name  
リモートmailboxのリモートサーバーのホスト名、またはローカルmailboxのファイル名です。

port  
そのプロトコルのデフォルト以外のポート番号をオプションで指定します。

protoには以下の1つを指定します:

`mbox`  
通常のUnix mailbox形式です。この場合user、pass、portは使用せず、host-or-file-nameはmailboxファイルのファイル名を意味します(例: `mbox:///var/spool/mail/smith`)。

`mh`  
MH形式のローカルmailboxです。user、pass、portは使用せず、host-or-file-nameはMHフォルダーのファイル名を意味します(例: `mh:///Mail/inbox`)。

`maildir`  
maildir形式のローカルmailboxです。user、pass、portは使用せず、host-or-file-nameは`maildir` mailboxの名前を意味します(例: `maildir:///mail/inbox`)。

`file`  
mailbox形式の任意のローカルファイルです。実際の形式は`movemail`により自動的に決定されます。

`pop`; `pops`  
POP3プロトコルを通じてアクセスされるリモートmailboxです。userは使用するリモートのユーザー名を指定し、passはユーザーパスワードを指定するのに使用され、host-or-file-nameは接続するリモートメールサーバーのホスト名かIPアドレス、portはポート番号です(例: `pop://smith:guessme@remote.server.net:995`)。サーバーがサポートする場合、`movemail`は暗号化された接続 — 暗号化接続に要求される‘`pops`’の使用を試みます。

`imap`; `imaps`  
IMAP4プロトコルを通じてアクセスされるリモートmailboxです。userは使用するリモートのユーザー名を指定し、passはユーザーパスワードを指定するのに使用され、host-or-file-nameは接続するリモートメールサーバーのホスト名かIPアドレス、portはポート番号です(例: `imap://smith:guessme@remote.server.net:993`)。サーバーがサポートする場合、`movemail`は暗号化された接続 — 暗号化接続に要求される‘`imaps`’の使用を試みます。"

かわりに、使用するmailboxのファイル名を指定できます。これはプロトコルに‘`file`’を指定するのと等価です:

    /var/spool/mail/user ≡ file:///var/spool/mail/user

rmail-movemail-program
rmail-movemail-search-path
変数`rmail-movemail-program`は、どのバージョンの`movemail`を使用するかを制御します。文字列の場合、それは`movemail`実行ファイルの絶対ファイル名を指定します。`nil`の場合、Rmailは`rmail-movemail-search-path`、`exec-path`([Shell](#Shell)を参照してください)、`exec-directory`の順で、これらの変数にリストされたディレクトリーから、`movemail`を検索します。

リモートmailboxからのメールの取得
---------------------------------

movemail
inboxファイルにデータを格納するかわりに、POP3と呼ばれる手法を使用してユーザーのinboxデータにアクセスするサイトがいくつかあります。Mailutilsの`movemail`は、デフォルトでTLS暗号化されたPOP3をサポートします。**警告:** たとえ`Emacs
movemail`がPOP3をサポートしていても、Mailutilsバージョンがサポートする暗号化された接続をサポートしないので、これを使用することは推奨しません。どちらのバージョンの`movemail`も、POP3にたいしてだけ機能し、POPの古いバージョンにたいしては機能しません。

MAILHOST
environment variable
POP3 mailboxes
どちらの`movemail`を使用するかにかかわらず、POP3 URL(see [Movemail](#Movemail))を使用してPOP3 inboxを指定できます。POP3 URLは、‘`pop://username@hostname:port`’という形式で、hostnameとportはリモートメールサーバーのホスト名(またはIPアドレス)とポート番号、usernameはそのサーバーでのユーザー名です。これに加えて‘`pop://username:password@hostname:port`’のようなmailbox URLでパスワードを指定することもできます。この場合、passwordは`rmail-remote-password` (以下参照)で指定された値より優先されます。これは複数のリモートメールサーバーで異なるパスワードを指定するとき、特に便利です。

後方互換のため、RmailはリモートのPOP3 mailboxを指定する他の方法もサポートします。‘`po:username:hostname:port`’によるinbox名の指定は、‘`pop://username@hostname:port`’と等価です。:hostnameの部分を省略した場合は、環境変数MAILHOSTで、どのマシンのPOP3サーバーを探すか指定します。

IMAP mailboxes
リモートmailboxesにアクセスする他の方法に、IMAPがあります。この方法はMailutils `movemail`だけでサポートされます。inboxリストでIMAP mailboxを指定するには、‘`imap://username[:password]@hostname:port`’の形式のmailbox URLを使用します。上記で説明したように、passwordの部分はオプションです。‘`imap`’の箇所に‘`imaps`’を使用したいと思うかもしれません。

rmail-remote-password
rmail-remote-password-required
リモートmailboxへのアクセスにはパスワードが要求されます。これを取得するためにRmailは以下のアルゴリズムを使います:

1.  mailbox URL(上記参照)でpasswordが与えられた場合はそれを使います。

2.  変数`rmail-remote-password-required`が`nil`の場合、Rmailはパスワードが要求されないと想定します。

3.  変数`rmail-remote-password`が非`nil`の場合はその値を使います。

4.  上記以外の場合、Rmailはパスワードの入力を求めます。

rmail-movemail-flags
追加のコマンドラインフラグを`movemail`に渡す必要がある場合は、使いたいフラグのリストを変数`rmail-movemail-flags`にセットします。inboxの内容を保持するために。この変数を使ってフラグ‘`-p`’を渡さないでください。かわりに`rmail-preserve-inbox`を使用してください。

Kerberos POP3 authentication
あなたのサイトにインストールされた`movemail`プログラムは、ケルベロス認証(Kerberos authentication)をサポートするでしょう。もしサポートされている場合、`rmail-remote-password`および`rmail-remote-password-required`がセットされていないときに、POP3メールの取得を試みたときは、デフォルトでケルベロス認証を使います。

reverse order in POP3 inboxes
メッセージを逆順に保存するPOP3サーバーもあります。あなたのサーバーがこれを行なっている場合、到着した順にメールを読みたいときは、`rmail-movemail-flags`に‘`-r`’フラグを追加することにより、逆順でメッセージをダウンロードするよう、`movemail`に指示できます。

TLS encryption (Rmail)
Mailutils `movemail`は、TLS暗号化(TLS encryption)をサポートします。これを使いたい場合は、`rmail-movemail-flags`に‘`--tls`’フラグをセットしてください。

さまざまな形式のローカルmailboxからのメールの取得
-------------------------------------------------

受信したメールがローカルマシンのUnix mailbox以外の形式に保存される場合、これを取得するためにMailutils `movemail`を使う必要があるでしょう。`movemail`のバージョンについての詳細な説明は、[Movemail](#Movemail)を参照してください。たとえば`/var/spool/mail/in`にある`maildir`形式のinboxのメールにアクセスするには、Rmailのinboxリストに以下を含める必要があるでしょう:

    maildir:///var/spool/mail/in

GnusによるEメールとUsenetニュース
=================================

Gnus
Usenet news
newsreader
Gnusは、主にUsenetニュースを読んだりポストするためにデザインされた、Emacsパッケージです。これはいくつかの異なるソース — 電子メール、リモートディレクトリー、ダイジェスト、などを読んだり、メッセージを返すためにも使うことができます。以下はGnusの紹介と、いくつかの基本的な機能の説明です。 完全な詳細に付いては、section “Gnus” in The Gnus Manualを参照してください。

Gnusバッファー
--------------

Gnusは、情報を表示したり返信コマンドのために、複数のバッファーを使用します。もっとも一般的に使用される3つのGnusバッファーはグループバッファー(group buffer)、サマリーバッファー(summary buffer)、アーティクルバッファー(article buffer)です。

グループバッファーは、アーティクルソースのリスト(たとえばニュースグループや電子メールのinbox)を含んでおり、それらはグループとして参照されます。これはGnusを開始したときに最初に表示されるバッファーです。これは通常、あなたが登録したグループと、未読のアーティクルだけを表示します。このバッファーから、読みたいグループを選択できます。

サマリーバッファーは1つのグループのアーティクルをリストし、1行に1つのアーティクルを表示します。デフォルトでは、アーティクルの作者、subject、 行数が表示されますが、これはカスタマイズできます。section “Summary Buffer Format” in The Gnus Manualを参照してください。 サマリーバッファーは、グループバッファーでグループを選択すると作成され、グループを抜けるとkillされます。

サマリーバッファーから、閲覧するアーティクルを選択できます。アーティクルはアーティクルバッファーで表示されます。通常のGnusの使い方では、このバッファーを閲覧はしますが選択はしません — すべての便利なGnusコマンドはサマリーバッファーから呼び出すことができます。しかし望むなら、アーティクルバッファーを選択して、そこからGnusコマンドを実行することもできます。

Gnusを起動したとき
------------------

gnus
.newsrc
file
あなたのシステムがUsenetニュースをよむためにセットアップされていれば、Gnusを始めるのは簡単です — `M-x
gnus`とタイプするだけです。

起動時に、Gnusはホームディレクトリーにある`.newsrc`という名前のニュース初期化ファイル(news initialization file)を読み込みます。これにはあなたのUsenetニュースグループと購読状況がリストされています(これはGnus固有のファイルではありません。他の多くのニュースリーダープログラムにより使用されています)。その後システムのデフォルトのニュースサーバーへの接続を試みます。これは通常、環境変数NNTPSERVERにより指定されます。

あなたのシステムがデフォルトのニュースサーバーをもっていない場合、または電子メールを読むためにGnusを使いたい場合は、`M-x
gnus`を呼び出す前に、どこでニュースおよび/またはメールを取得するか、Gnusに指示する必要があります。これを行なうには、変数`gnus-select-method`および/または`gnus-secondary-select-methods`をカスタマイズします。 section “Finding the News” in The Gnus Manualを参照してください。

1度Gnusを開始すると、グループバッファーを表示します。デフォルトでは少数のsubscribedグループ(subscribed groups: 登録されたグループ)だけが表示されます。他の状態 — unsubscribed、killed、zombie — のグループは表示されません。最初にGnusを開始したとき、登録していないグループはkilledグループになります。その後にニュースサーバーに現れたグループはzombieグループになります。

先に進むには、グループバッファーでグループを選択して、そのグループのサマリーバッファーを開かなければなりません。その後サマリーバッファーのアーティクルを選択して、別のウィンドウでアーティクルバッファーを閲覧します。以下のセクションでは、これを行なうための、グループバッファーとサマリーバッファーの使用について説明します。

Gnusを終了するには、グループバッファーで`q`とタイプします。これは自動的にグループの状態をファイル`.newsrc`ト`.newsrc.eld`に記録するので、その後のGnusセッションでも効果があります。

Gnus Groupバッファーの使用
--------------------------

以下のコマンドは、Gnusグループバッファーで利用可能です:

`SPC`  
カレント行のグループの、サマリーバッファーに切り替えます(`gnus-group-read-group`)。

l (Gnus Group mode)

A s (Gnus Group mode)

gnus-group-list-groups

`l`; `A s`  
eグループバッファーでは、未読のアーティクルを含む登録したグループだけをリストします(`gnus-group-list-groups`。これはデフォルトの一覧方法である)。

L (Gnus Group mode)

A u (Gnus Group mode)

gnus-group-list-all-groups

`L`; `A u`  
すべてのsubscribed(登録)およびunsubscribed(未登録)のグループをリストしますが、killedまたはzombieのグループは表示しません(`gnus-group-list-all-groups`)。

A k (Gnus Group mode)

gnus-group-list-killed

`A k`  
killされたグループをリストします(`gnus-group-list-killed`)。

A z (Gnus Group mode)

gnus-group-list-zombies

`A z`  
ゾンビ状態のグループをリストします(`gnus-group-list-zombies`)。

u (Gnus Group mode)

gnus-group-unsubscribe-current-group

subscribe groups

unsubscribe groups

`u`  
カレント行のグループの登録状態を切り替えます((`gnus-group-unsubscribe-current-group`。たとえばsubscribedグループをunsubscribedグループにしたり、その逆を行なう)。killedまたはzombieのグループにたいしてこれを呼び出すと、そのグループをunsubscribedグループにします。

C-k (Gnus Group mode)

gnus-group-kill-group

`C-k`  
カレント行のグループをkillします(`gnus-group-kill-group`)。killedとなったグループは`.newsrc`ファイルに記録され、`l`または`L`のリストには表示されなくなります。

DEL (Gnus Group mode)

`DEL`  
未読アーティクルを含む、前のグループにポイントを移動します(`gnus-group-prev-unread-group`)。

n (Gnus Group mode)

gnus-group-next-unread-group

`n`  
次の未読グループにポイントを移動します(`gnus-group-next-unread-group`)。

p (Gnus Group mode)

gnus-group-prev-unread-group

`p`  
前の未読グループにポイントを移動します(`gnus-group-prev-unread-group`)。

q (Gnus Group mode)

gnus-group-exit

`q`  
Gnusのセッティングを更新してGnusを終了します(`gnus-group-exit`)。

Gnus Summaryバッファーの使用
----------------------------

以下のコマンドは、Gnusサマリーバッファーで利用可能です:

`SPC`  
選択されたアーティクルがない場合、カレント行のアーティクルを選択して、それをアーティクルバッファーに表示します。そうでない場合、選択されたアーティクルバッファーのウィンドウでスクロールを試みます。バッファーの最後に到達した場合、次の未読アーティクルを選択します(`gnus-summary-next-page`)。

したがって、繰り返しSPCをタイプすることにより、すべてのアーティクルを読むことができます。

DEL (Gnus Summary mode)

gnus-summary-prev-page

`DEL`  
アーティクルのテキストを後方にスクロールします(`gnus-summary-prev-page`)。

n (Gnus Summary mode)

gnus-summary-next-unread-article

`n`  
次の未読アーティクルを選択します(`gnus-summary-next-unread-article`)。

p (Gnus Summary mode)

gnus-summary-prev-unread-article

`p`  
前の未読アーティクルを選択します(`gnus-summary-prev-unread-article`)。

s (Gnus Summary mode)

gnus-summary-isearch-article

`s`  
選択されたアーティクルバッファーで、あたかもそのバッファーに切り替えて`C-s`([Incremental Search](#Incremental-Search)を参照してください)とタイプしたかのように、インクリメンタル検索を行ないます(`gnus-summary-isearch-article`)。

M-s (Gnus Summary mode)

gnus-summary-search-article-forward

`M-s regexp RET`  
regexpへのマッチを含むアーティクルを、前方に検索します(`gnus-summary-search-article-forward`)。

M-r (Gnus Summary mode)

gnus-summary-search-article-backward

`M-r regexp RET`  
regexpへのマッチを含むアーティクルを、後方に検索します(`gnus-summary-search-article-backward`)。

q (Gnus Summary mode)

`q`  
サマリーバッファーをexitして、グループバッファーに戻ります(`gnus-summary-exit`)。

ホストのセキュリティ
====================

security
EmacsはGNU/Linuxのようなオペレーティングシステムの内部で実行され、ファイルアクセスのようなセキュリティー制限のチェックはオペレーティングシステムに依存します。Emacsのデフォルトセッティングは、通常の使用のためにデザインされています。通常よりセキュリティーが重要な場合、または重要でない環境では、何らかの調整が必要になるでしょう。たとえばファイルローカル変数(file-local variables)が危険な場合もあるので、変数`enable-local-variables`に`:safe`や、(より安全に)`nil`をセットできます。ファイルがすべて信用でき、それらの変数にたいするデフォルトのチェックが煩わしいときには、`enable-local-variables`に`:all`をセットできます。[Safe File Variables](#Safe-File-Variables)を参照してください。

大きなアプリケーションの一部としてEmacsを使用する場合の、セキュリティー考慮についての情報は、section “Security Considerations” in The Emacs Lisp Reference Manualを参照してください。

ネットワークのセキュリティ
==========================

network security manager
NSM
encryption
SSL
TLS
Transport Layer Security
STARTTLS
Emacsがネットワーク接続を確立するときは、常にその確立された接続をNSM(Network Security Manager)に渡します。NSMは、あなたのコントロールのもとにセットワークセキュリティーを実施する責任があります。現在のところ、これはTLS(Transport Layer Security)の機能を使用して動作します。

network-security-level
変数`network-security-level`は、NSMが実施するセキュリティーレベルを決定します。変数の値が`low`の場合、セキュリティーのチェックは行なわれません。

この変数が`medium`(デフォルト)の場合、いくつかのチェックが行なわれます。チェックの結果、NSMがそのネットワーク接続を信頼できないと判断した場合は、それを知らせて、そのネットワーク接続にたいして何を行なうか尋ねます。

証明されていない接続(unverified connection)にたいして、永続的なセキュリティー例外(security exception)を登録したり、一時的な例外(temporary exception)とするか、接続を完全に拒絶することができます。

以下は`medium`で行なわれるチェックのリストです。

TLS認証が検証できない(unable to verify a TLS certificate)  
その接続がTLS、SSL、STARTTLS接続の場合、NSMは接続しようとしているサーバーの同一性(identity)を証明するために使用される認証が、検証できるかどうかチェックします。

無効な認証が懸念される場合(Man-in-the-Middleによりネットワーク接続がハイジャックて、あなたのパスワードが盗まれるかもしれません)や、とにかく接続を行なう正当な理由があるかもしれません。たとえばサーバーが自己署名された認証(self-signed certificate)を使用していたり、認証の期限が切れている場合もあるでしょう。接続の継続を容認するかどうかの決定は、あなたに任されています。

自己署名された認証が変更されている(a self-signed certificate has changed)  
以前自己署名された認証を許容したが、今回はそれが変更されていて、それはそのサーバーが単に認証を変更しただけかもしれませんが、ネットワーク接続がハイジャックされている可能性もあります。

以前は暗号化されていた接続が、暗号化されていない(previously encrypted connection now unencrypted)  
接続が暗号化されていないが、以前のセッションでは暗号化されていた場合、あなたとそのサーバーの間にSTARTTLSアナウンス(STARTTLS announcements)を剥奪して、接続を非暗号化するプロキシーがあることを意味するかもしれません。これは通常とても疑わしいです。

パスワードを送信するとき暗号化されていないサービスと通信する(talking to an unencrypted service when sending a password)  
IMAPやPOP3のサーバーに接続するとき、ネットワーク越しにパスワードを送信するのが一般的なので、接続は通常暗号化されています。同様に、パスワードを要求するSMTPを通じてemailを送信する場合は通常、その接続が暗号化されていることを望むでしょう。その接続が暗号化されていない場合、NSMは警告します。

`network-security-level`が`high`の場合、上記に加えて以下のチェックが行なわれます:

有効な認証がパブリックキーを変更した(a validated certificate changes the public key)  
サーバーはキーを変更するときがあり、通常それは心配することはありません。しかし、サードパーティーのサービスにたいして新しい認証を発行する、偽装しやすい証明期間(pliable Certificate Authorities)へのアクセスをもつエージェントにより、ネットワーク接続がハイジャックされているか心配なときは、これらの変更を追跡したいと思うかもしれません。

Diffie-Hellmanロープライムビット(Diffie-Hellman low prime bits)  
パグリックキーの交換を行なう際、そのチャンネルが第三者により盗聴できないことを確実にするために、プライムビット(prime bits)の数は高くあるべきです。この数があまりに低い(low)場合は、警告されるでしょう。

RC4ストリーム暗号(RC4 stream cipher)  
RC4ストリーム暗号は低品質とされており、第三者による盗聴を許すかもしれません。

SSL1、SSL2、SSL3  
TLS1.0より古いプロトコルは、様々な攻撃にたいして脆弱とされており、あなたが行なうことがより高いセキュリティーを要する場合は、使用を避けたいと思うかもしれません。

最後に、`network-security-level`が`paranoid`の場合は、最初にNSMが新たな認証に遭遇したときに、それが通知されます。これによりEmacsによるすべての接続のすべての認証を検証することができるでしょう。

以下の追加の変数は、NSM操作の詳細を制御するために使用できます。

`nsm-settings-file`  
nsm-settings-file

これはNSMが接続の詳細を保存するファイルです。デフォルトは`~/.emacs.d/network-security.data`です。

`nsm-save-host-names`  
nsm-save-host-names

デフォルトでは、非`STARTTLS`接続ではホスト名は保存されません。接続の識別には、かわりにホストとポートによるハッシュ値(host/port hash)が使用されます。ユーザーがどのサーバーに接続しているか確認するために、誰かが気軽に設定ファイルを読めないことを意味します。この変数が`t`の場合、NSMは`nsm-settings-file`にもホスト名を保存します。

ドキュメントの閲覧
==================

DVI file
PDF file
PS file
PostScript file
OpenDocument file
Microsoft Office file
DocView mode
mode, DocView
document viewer (DocView)
doc-view-mode
DocViewモードは、DVI、PostScript(PS)、PDF、OpenDocument、Microsoft Officeドキュメントを閲覧するためのメジャーモードです。このモードはスライス、ズーム、ドキュメント内の検索などの機能を提供します。これは、`gs`(GhostScript)、または`mudraw`/`pdfdraw`(MuPDF)、およびその他の外部ツール[18]を使用して、ドキュメントを一連のイメージに変換し、それらのイメージを表示することにより機能します

doc-view-toggle-display
doc-view-minor-mode
DocViewモードで表示可能なドキュメントをvisitすると、Emacsは自動的にそのモードを使用します[19]。例外として、PostScriptファイルをvisitしたとき、EmacsはPostScriptファイルをテキストとして編集するためのメジャーモードの、PSモードに切り替わります。しかし、これはDocView minorモードも有効にするので、`C-c
C-c`とタイプして、そのドキュメントを閲覧することができます。DocViewモードまたはDocView minorモードでは、`C-c
C-c` (`doc-view-toggle-display`)を繰り返すことにより、DocViewとその背後にあるファイル内容を切り替えることができます。

doc-view-open-text
いくつかの要件が満たされないとき(たとえばテキスト端末のフレームを操作していたり、そのEmacsはPNGをサポートしないときなど)に、通常DocViewモードで処理されるファイルをvisitした場合は、そのドキュメントの内容をプレーンテキストとして閲覧したいか問い合わせます。これに同意すると、そのバッファーはtextモードとなり、DocView minorモードがアクティブになります。したがって`C-c
C-c`とタイプすることにより、fallbackモードに切り替わります。もう1度`C-c
C-c`とタイプすると、DocViewモードに戻ります。DocViewモードで`C-c C-t` (`doc-view-open-text`)とタイプすることにより、プレーンテキストで内容を表示することもできます。

コマンド`M-x doc-view-mode`で、DocViewモードを明示的に有効にすることができます。また、`M-x
doc-view-minor-mode`で、DocView minorモードに切り替えることができます。

DocViewモードを開始したときは、ウェルカム画面を表示して、そのファイルを1ページずつフォーマットしていきます。最初のページがフォーマットされると、そのページを表示します。

DocViewバッファーをkillするには、`k` (`doc-view-kill-proc-and-buffer`)とタイプします。バッファーを隠す(bury)には、`q` (`quit-window`)とタイプします。

DocViewの操作
-------------

DocViewモードでは通常のEmacs移動キー、つまり`C-p`、`C-n`、`C-b`、`C-f`、および矢印キーを使って、ページをスクロールできます。

doc-view-continuous
デフォルトでは、行移動キーの`C-p`と`C-n`は、カレントページの先頭または最後でスクロールを止めます。しかし、変数`doc-view-continuous`を非`nil`値に変更した場合、カレントページの先頭で`C-p`とタイプすると前のページを表示し、カレントページの最後で`C-n`とタイプすると次のページを表示します。

doc-view-next-page
doc-view-previous-page
n (DocView mode)
p (DocView mode)
PageDown (DocView mode)
PageUp (DocView mode)
next (DocView mode)
prior (DocView mode)
C-x \] (DocView mode)
C-x \[ (DocView mode)
`n`、PageDown、next、`C-x
]`をタイプすることにより、次のページを表示することもできます(`doc-view-next-page`)。前のページを表示するには、`p`、PageUp、prior、`C-x
[`をタイプします(`doc-view-previous-page`)。

doc-view-scroll-up-or-next-page
doc-view-scroll-down-or-previous-page
SPC (DocView mode)
DEL (DocView mode)
SPC (`doc-view-scroll-up-or-next-page`)は、ドキュメントを順に読んでいくのに便利な方法です。これはカレントページをスクロールするか、次のページに移動します。DEL (`doc-view-scroll-down-or-previous-page`)は、同様の方法で後方に移動します。

doc-view-first-page
doc-view-last-page
doc-view-goto-page
M-&lt; (DocView mode)
M-&gt; (DocView mode)
最初のページに移動するには、`M-<` (`doc-view-first-page`)とタイプします。最後のページに移動するには、`M->` (`doc-view-last-page`)とタイプします。ページ番号を指定して移動するには、`M-g M-g`または`M-g
g` (`doc-view-goto-page`)とタイプしてください。

doc-view-enlarge
doc-view-shrink
doc-view-resolution
+ (DocView mode)
- (DocView mode)
`+` (`doc-view-enlarge`)と`-` (`doc-view-shrink`)で、ドキュメントを拡大したり縮小することができます。これらのコマンドはドキュメントを新しいサイズに再変換することにより機能します。DocViewにたいするデフォルトサイズを指定するには、変数`doc-view-resolution`をカスタマイズしてください。

DocViewの検索
-------------

DocViewモードでは、ファイルのテキストにたいして正規表現の検索を行なうことができます([Regexps](#Regexps)を参照してください)。検索のインターフェースは`isearch`が元になっています([Incremental Search](#Incremental-Search)を参照してください)。

doc-view-search
doc-view-search-backward
doc-view-show-tooltip
検索を開始するには、`C-s` (`doc-view-search`)または`C-r` (`doc-view-search-backward`)とタイプします。これはミニバッファーを使用して正規表現を読み取り、そのドキュメントでマッチした数をエコーします。`C-s`または`C-r`とタイプすることにより、マッチ間を前方または後方に移動できます。DocViewモードはページイメージの中でマッチを表示できません。かわりに、カレントページのマッチするすべての行を一覧するツールチップを、(マウス位置に)表示します。このツールチップを強制的に表示するには`C-t` (`doc-view-show-tooltip`)とタイプしてください。

新しい検索を開始するには、たとえば前方検索では`C-u C-s`、後方検索では`C-u
C-r`のように、検索コマンドにプレフィクス引数を使用します。

DocViewのスライス
-----------------

印刷のために広い余白をもつドキュメントもあります。これらはスクリーンでドキュメントを読むとき邪魔になることがあります。なぜならこれらは画面スペースを消費して、スクロールが不便になるからです。

doc-view-set-slice
doc-view-set-slice-using-mouse
DocViewでは、表示するページのスライス(slice)を選択することにより、これらの余白を隠すことができます。スライスはページ内の矩形領域です。DocViewで1度スライスを指定すると、閲覧するすべてのページに適用されます。

数値でスライスを指定するには、`s s` (`doc-view-set-slice`)とタイプします。その後、スライスの左上のピクセル位置(pixel position)と、スライスの幅(width)と高さ(height)を入力します。

スライスを指定するための、もっと便利でグラフィカルな方法は、`s m` (`doc-view-set-slice-using-mouse`)で、スライスの選択にマウスを使う方法です。これは単に、スライスにしたいリージョンの左上隅で左マウスボタンを押して、そのまま右下隅にマウスポインターを移動してマウスボタンを離します。

最適なスライスをセットする一番簡単な方法は、`s b` (`doc-view-set-slice-from-bounding-box`)とタイプすることにより、そのドキュメントから自動的に判断されるBoundingBox情報を使う方法です。

doc-view-reset-slice
選択されたスライスを取り消すには、`s r` (`doc-view-reset-slice`)とタイプします。するとDocViewは、余白全体を含めたページ全体を表示します。

DocViewの変換
-------------

doc-view-cache-directory
doc-view-clear-cache
効率のために、DocViewは`gs`により生成されたイメージをキャッシュします。イメージをキャッシュするディレクトリーの名前は、変数`doc-view-cache-directory`により与えられます。`M-x
doc-view-clear-cache`とタイプすることにより、キャッシュディレクトリーをクリアーできます。

doc-view-kill-proc
doc-view-kill-proc-and-buffer
現在閲覧中のドキュメントを強制的に再変換するには、type `r`または`g` (`revert-buffer`)とタイプします。カレントバッファーに関連付けられた変換プロセスをkillするには、`K` (`doc-view-kill-proc`)とタイプします。コマンド`k` (`doc-view-kill-proc-and-buffer`)は、変換プロセスとDocViewバッファーをkillします。

Emacsからのシェルコマンドの実行
===============================

subshell
shell commands
Emacsには、シェルサブプロセスに1つのコマンドラインを渡したり、入出力にEmacsバッファーを使用して対話的にシェルを実行するコマンドや、端末エミュレーターウィンドウでシェルを実行するコマンドがあります。

`M-! cmd RET`  
シェルコマンドcmdを実行して、出力を表示します(`shell-command`)。

`M-| cmd RET`  
リージョンの内容を入力としてシェルコマンドcmdを実行します。オプションでリージョンを出力で置き換えます(`shell-command-on-region`)。

`M-& cmd RET`  
シェルコマンドcmdを非同期で実行し、出力を表示します(`async-shell-command`)。

`M-x shell`  
Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その後で、コマンドを対話的に与えることができます。

`M-x term`  
Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その後でコマンドを対話的に与えることができます。完全な端末エミュレーションが利用できます。

exec-path
(上記のコマンドのcmd引数、または他のコンテキストにおいて)実行可能プログラムとして相対ファイル名を指定したときは、Emacsは変数`exec-path`により指定されるディレクトリーのプログラムを検索します。この変数の値は、ディレクトリーのリストでなければなりません。デフォルト値は、Emacsが開始されたときの環境変数PATHにより初期化されます([General Variables](#General-Variables)を参照してください)。

`M-x
eshell`は、Emacsで完全に実装されたシェルを呼び出します。eshellについては、自身のマニュアルにドキュメントされています。 section “Eshell” in Eshell: The Emacs Shellを参照してください。

単一のシェルコマンド
--------------------

M-!
shell-command
`M-!` (`shell-command`)は、ミニバッファーを使って1行のテキストを読み取り、それをシェルコマンドとして、そのコマンドのためだけに作成されたサブシェルで実行します。そのコマンドの標準入力はnullデバイスです。シェルコマンドが出力を生成する場合、その出力はエコーエリア(出力が短い場合)、または別のウィンドウの`*Shell
Command
Output*`という名前のEmacsバッファー(出力が長い場合)に表示されます。変数`resize-mini-windows`と`max-mini-window-height`は、出力がエコーエリアにたいして長過ぎるとEmacsが判断した場合に、ウィンドウのサイズ変更を制御します([Minibuffer Edit](#Minibuffer-Edit)を参照)。

たとえば`foo.gz`という名前のファイルを解凍する1つの方法は、`M-! gunzip foo.gz
RET`とタイプすることです。このシェルコマンドは通常、ファイル`foo`を作成して、端末出力を生成しません。

たとえば`M-1
M-!`のように`shell-command`に数引数を指定した場合、別のバッファーではなく、カレントバッファーに端末出力を挿入します。これはポイントを出力の前に配し、出力の後にマークを配します。たとえば`M-1
M-! gunzip < foo.gz RET`は、カレントバッファーにファイル`foo.gz`の解凍された内容を挿入します。

最後が‘`&`’でないシェルコマンドを指定した場合、コマンドは同期(synchronously)で実行され、Emacsを継続して使用するには、コマンドがexitするのを待たなければなりません。待つのを中止するには、`C-g`とタイプします。これはシェルコマンドを終了するために、シグナル`SIGINT`を送ります(これは通常、シェルで`C-c`とタイプしたときに生成されるのと同じシグナルです)。その後、Emacsはコマンドが実際に終了するまで待ちます。シェルコマンドが終了しない場合(そのコマンドがシグナル`SIGINT`を無視する場合)は、再度`C-g`とタイプします。これは　そのコマンドにたいして、無視することが不可能なシグナル`SIGKILL`を送ります。

M-&
async-shell-command
‘`&`’で終わるシェルコマンドは非同期(asynchronously)で実行され、それを実行した後でも、継続してEmacsを使用できます。シェルコマンドを非同期で実行する前に、`M-&` (`async-shell-command`)とタイプすることもできます。これは最後の‘`&`’が必要ない点を除き、最後に‘`&`’を指定して`M-!`を呼び出すことと同じです。非同期シェルコマンドにたいするデフォルトの出力バッファーは、‘`*Async
Shell
Command*`’という名前のバッファーです。このバッファーがウィンドウに表示されているかに関わらず、Emacsは出力をこのバッファーに挿入します。

async-shell-command-buffer
同時に複数の非同期シェルコマンドを実行した場合、出力バッファーが競合します。この場合どのようにするか — たとえば既存の出力バッファーをリネームしたり、新しいコマンドに異なるバッファーを使用する — を、オプション`async-shell-command-buffer`で指定できます。他の可能なオプションについては、この変数のドキュメントを参照してください。

async-shell-command-display-buffer
非同期シェルコマンドが出力を生成したときだけ出力バッファーが表示されるようにしたい場合は、`async-shell-command-display-buffer`を`nil`にセットしてください。

M-|
shell-command-on-region
`M-|` (`shell-command-on-region`)は`M-!`と同様ですが、入力を与えないかわりに、リージョンの内容をシェルコマンドの標準入力として渡します。数引数を指定した場合、古いリージョンの内容を、シェルコマンドの出力で置き換えます。

たとえば`M-|`で`gpg`プログラムを使用して、そのバッファーのキーが何かを見ることができます。そのバッファーがGnuPGキーを含む場合、`C-x
h M-| gpg
RET`とタイプして、バッファー全体の内容を`gpg`に送ることができます。これはキーのリストを、`*Shell
Command Output*`バッファーに出力します。

shell-file-name
上記のコマンドは、変数`shell-file-name`で指定されたシェルを使用します。この変数のデフォルト値は、Emacsが開始されたときの環境変数SHELLにより決定されます。相対ファイル名の場合、Emacsは`exec-path`にリストされたディレクトリーを検索します([Shell](#Shell)を参照してください)。

`M-!`または`M-|`にたいするコーディングシステムを指定するには、あらかじめコマンド`C-x RET
c`を使用します。[Communication Coding](#Communication-Coding)を参照してください。

shell-command-default-error-buffer
デフォルトでは、出力バッファーではエラー出力と標準出力が混ざって出力されます。しかし変数`shell-command-default-error-buffer`の値を文字列に変更すると、エラー出力はその名前のバッファーに出力されます。

shell-command-dont-erase-buffer
デフォルトでは、出力バッファーはシェルコマンドとシェルコマンドの間に消去されます。変数`shell-command-dont-erase-buffer`の値を非`nil`値に変更した場合、出力バッファーは消去されません。この変数は、コマンドが完了したとき、ポイントを出力バッファーのどこに配すかも制御します。詳細は変数のドキュメントを参照してください。

対話的なサブシェル
------------------

shell
対話的にサブシェルを実行するには、`M-x
shell`とタイプします。これは`*shell*`という名前のバッファーを作成(または再使用)して、そのバッファーにたいして入出力を行なう、シェルのサブプロセスを実行します。つまりサブシェルからの端末出力はポイントの後に挿入されてポイントを進め、サブシェルにたいする端末入力はそのバッファーのテキストになります。サブシェルにたいして入力を与えるには、バッファーの最後に移動して入力をタイプし、RETで終了します。

デフォルトでは、サブシェルが対話的に呼び出された際、カレントウィンドウですでに`*shell*`バッファーを表示していない場合は、新たなウィンドウに`*shell*`バッファーが表示されます。この動作は`display-buffer-alist`([Window Choice](#Window-Choice)を参照)を通じてカスタマイズできます。

サブシェルがコマンドの実行を待つ間、ウィンドウまたはバッファーを切り替えてEmacsで他の編集を行なうことができます。Emacsはそれを処理するときがきたら(たとえばキーボード入力待ちになったとき)、サブシェルからの出力をShellバッファーに挿入します。

comint-highlight-input
face
comint-highlight-prompt
face
Shellバッファーでは、プロンプトはフェイス`comint-highlight-prompt`で表示され、サブミットされた入力行はフェイス`comint-highlight-input`で表示されます。これにより入力行とシェル出力を容易に区別することができます。[Faces](#Faces)を参照してください。

複数のサブシェルを作成するには、(`C-u M-x shell`)のように)プレフィクス引数を指定して`M-x
shell`を呼び出します。その後、このコマンドはバッファー名を読み取り、そのバッファーでサブシェルを作成(または再使用)します。`M-x
rename-uniquely`を使用して`*shell*`バッファーをリネームしてから、`M-x
shell`で新しい`*shell*`バッファーを作成することもできます。異なるバッファーのサブシェルは、並行して独立に実行されます。

explicit-shell-file-name
environment variables for subshells
ESHELL
environment variable
SHELL
environment variable
`M-x
shell`によりシェルファイル名を指定するには、変数`explicit-shell-file-name`をカスタマイズします。これが`nil`(デフォルト)の場合、もし存在すればEmacsは環境変数ESHELLを使用します。そうでない場合は通常、変数`shell-file-name`を使用します([Single Shell](#Single-Shell)を参照してください)。しかしデフォルトディレクトリーがリモートの場合([Remote Files](#Remote-Files)を参照してください)、シェルファイル名の入力を求めます。リモートファイル名を正しくタイプする方法に関するヒントは、[Minibuffer File](#Minibuffer-File)を参照してください。

Emacsは新しいシェルにたいする入力として、もしそれが存在すればファイル`~/.emacs_shellname`の内容を送ります。ここでshellnameは、そのシェルがロードされたファイルの名前です。たとえばbashを使う場合、送られるファイルは`~/.emacs_bash`になります。ファイルが見つからない場合、Emacsは`~/.emacs.d/init_shellname.sh`の使用を試みます。

シェルにたいしてコーディングシステムを指定するには、`M-x shell`の直前にコマンド`C-x RET
c`を使用します。`C-x RET
p`とタイプすることにより、実行されているサブシェルにたいするコーディングシステムを変更することもできます。[Communication Coding](#Communication-Coding)を参照してください。

INSIDE\_EMACS
environment variable
サブシェルでは、Emacsは環境変数INSIDE\_EMACSに‘`version,comint`’をセットします。ここでversionは、Emacsのバージョン(たとえば‘`24.1`’)です。プログラムはこの変数をチェックして、Emacsの内部で実行されているかを判断することができます。

Shellモード
-----------

Shell mode
mode, Shell
ShellバッファーのためのメジャーモードはShellモードです。このモードの特別なコマンドは`C-c`プレフィクスにバインドされており、最初に`C-c`をタイプしなければならない点を除けば、通常のシェルでの編集やジョブ制御文字と共通点があります。以下はShellモードのコマンドのリストです:

`RET`  
RET (Shell mode)

comint-send-input

サブシェルの入力にカレント行を送ります(`comint-send-input`)。行頭のシェルプロンプトは省略されます([Shell Prompts](#Shell-Prompts)を参照してください)。ポイントがバッファーの最後にある場合、これは通常の対話的なシェルにおいてコマンド行をサブミットするのに似ています。しかし、シェルバッファーの他の場所でも、RETを呼び出してカレント行を入力としてサブミットできます。

`TAB`  
TAB (Shell mode)

completion-at-point, in Shell Mode

shell completion

シェルバッファーのポイントの前のコマンド名、またはファイル名を補完します(`completion-at-point`)。これは通常のEmacs補完ルールを使用します([Completion](#Completion)を参照してください)。ファイル名、環境変数名、シェルコマンドヒストリー、ヒストリー参照が補完候補になります([History References](#History-References)を参照してください)。補完を制御するオプションについては、[Shell Options](#Shell-Options)を参照してください。

`M-?`  
M-? (Shell mode)

comint-dynamic-list-filename…

ポイントの前のファイル名にたいして、可能性のある補完リストを一時的に表示します(`comint-dynamic-list-filename-completions`)。

`C-d`  
C-d (Shell mode)

comint-delchar-or-maybe-eof

delete文字、またはEOF文字を送ります(`comint-delchar-or-maybe-eof`)。シェルバッファーの最後でこれをタイプすると、サブシェルにEOFが送られます。バッファーの他の場所でタイプすると、通常どおり文字を削除します。

`C-c C-a`  
C-c C-a (Shell mode)

comint-bol-or-process-mark

行の先頭に移動しますが、プロンプトがある場合はプロンプトの後に移動します(`comint-bol-or-process-mark`)。このコマンドを連続して繰り返すと、2回目はプロセスマーク(process mark)に戻ります。これはサブシェルにまだ送信されていない入力の開始位置のことです(通常これは同じ場所 — その行のプロンプトの最後 — ですが、`C-c SPC`の後では、プロセスマークは前の行にあるかもしれません)。

`C-c SPC`  
複数行の入力を累積して、それらを合わせて送ります(`comint-accumulate`)。このコマンドはポイントの前に改行を挿入しますが、その前のテキストをサブシェルの入力として — 少なくともその時点では — 送りません。改行の前後の行は両方、(それらを分割する改行も含めて)RETをタイプしたとき一緒に送られます。

`C-c C-u`  
C-c C-u (Shell mode)

comint-kill-input

まだ入力として送られていない、バッファーの最後のすべてのテキストをkillします(`comint-kill-input`)。ポイントがバッファーの最後にない場合、これはポイントの前のテキストだけをkillします。

`C-c C-w`  
C-c C-w (Shell mode)

ポイントの前の単語をkillします(`backward-kill-word`)。

`C-c C-c`  
C-c C-c (Shell mode)

comint-interrupt-subjob

シェルまたは(もしあれば)カレントのサブジョブに割り込み(interrupt)ます(`comint-interrupt-subjob`)。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。

`C-c C-z`  
C-c C-z (Shell mode)

comint-stop-subjob

シェルまたは(もしあれば)カレントのサブジョブを停止(stop)します。(`comint-stop-subjob`)。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。

`C-c C-\`  
comint-quit-subjob

C-c C-\\ (Shell mode)

シェルまたは(もしあれば)カレントのサブジョブに、シグナルQUITを送ります(`comint-quit-subjob`)。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。

`C-c C-o`  
C-c C-o (Shell mode)

comint-delete-output

前のシェルコマンドからの出力の一群を削除します(`comint-delete-output`)。これはシェルコマンドが大量の出力を吐くときに便利です。

`C-c C-s`  
C-c C-s (Shell mode)

comint-write-output

前のシェルコマンドからの出力の一群をファイルに書き込みます(`comint-write-output`)。プレフィクス引数を指定した場合は、ファイルに追加で書き込みます。出力の最後のプロンプトは書き込まれません。

`C-c C-r`; `C-M-l`  
C-c C-r (Shell mode)

C-M-l (Shell mode)

comint-show-output

前の一群の出力の最初がウィンドウの最上部になるようにスクロールし、カーソルもそこに移動します(`comint-show-output`)。

`C-c C-e`  
C-c C-e (Shell mode)

comint-show-maximum-output

バッファーの最後の行がウィンドウの最下部になるようにスクロールします(`comint-show-maximum-output`)。

`C-c C-f`  
C-c C-f (Shell mode)

shell-forward-command

shell-command-regexp

シェルコマンド1つ分、前方に移動しますが、カレント行を超えては移動しません(`shell-forward-command`)。変数`shell-command-regexp`は、コマンドの最後を認識する方法を指定します。

`C-c C-b`  
C-c C-b (Shell mode)

shell-backward-command

シェルコマンド1つ分、後方に移動しますが、カレント行を超えて移動はしません(`shell-backward-command`)。

`M-x dirs`  
シェルに作業ディレクトリーを尋ね、Shellバッファーのデフォルトディレクトリーを更新します。[Directory Tracking](#Directory-Tracking)を参照してください。

`M-x send-invisible RET text RET`  
send-invisible

エコーなしでtextを読み取った後、それをシェルの入力として送ります。これはシェルコマンドでパスワードを尋ねるプログラムを実行するとき便利です。

デフォルトではEmacsはパスワードをエコーしないことに注意してください。もし本当にエコーさせたいときは、以下のLisp式を評価します([Lisp Eval](#Lisp-Eval)を参照してください):

    (remove-hook 'comint-output-filter-functions
                 'comint-watch-for-password-prompt)

`M-x comint-continue-subjob`  
comint-continue-subjob

シェルプロセスを継続します。これは間違ってシェルプロセスをサスペンドしてしまったときなどに便利です。[20]

`M-x comint-strip-ctrl-m`  
comint-strip-ctrl-m

シェル出力のカレントグループから、すべてのcontrol-M文字を破棄します。このコマンドを使うもっとも便利な方法は、サブシェルからの出力を受け取ったときに自動的に実行されるようにする方法です。これを行なうには、以下のLisp式を評価します:

    (add-hook 'comint-output-filter-functions
              'comint-strip-ctrl-m)

`M-x comint-truncate-buffer`  
comint-truncate-buffer

このコマンドはシェルバッファーを、変数`comint-buffer-maximum-size`により指定される、特定の最大行数に切り詰めます。以下は、サブシェルから出力を受けとるとき、毎回自動的にこれを行なう方法です:

    (add-hook 'comint-output-filter-functions
              'comint-truncate-buffer)

Comint mode
mode, Comint
Shellモードは、サブプロセスと対話的に通信を行なう一般的な用途向けのComintモードから派生したモードです。上記のコマンド名からも判るとおり、Shellモードのほとんどの機能は、実際にはComintモードが由来です。Shellモードの特別な機能には、ディレクトリー追跡機能、およびいくつかのユーザーコマンドが含まれます。

Comintモードの変種を使う他のEmacs機能には、GUD ([Debuggers](#Debuggers)を参照してください)や、`M-x
run-lisp` ([External Lisp](#External-Lisp)を参照してください)が含まれます。

comint-run
サブプロセスとして選択した任意のプログラムを実行するために、Shellモードに特化しない未修正のComintモードを使用するには、`M-x
comint-run`を使用することができます。

Shellプロンプト
---------------

prompt, shell
プロンプトとは、新しいユーザー入力を受け取る準備ができたことを表す、プログラムによるテキスト出力のことです。Comintモード(したがってShellモードも)は通常、サブプロセスからの出力にもとづいて、バッファーの一部をプロンプトとして自動的に判断します(具体的には、改行で終端されていない任意の出力行を受け取ったときは、プロンプトとみなします)。

Comintモードは、バッファーを2つのタイプのフィールド(fields)に分けます。1つは入力フィールド(ユーザーの入力がタイプされるところ)で、もう1つは出力フィールド(入力フィールド以外)です。プロンプトは出力フィールドの一部です。ほとんどのEmacs移動コマンドは、そのコマンドが複数行を移動しない限り、フィールド境界を超えることはありません。たとえば、ポイントがシェルコマンドの入力フィールドにある場合、`C-a`はポイントを入力フィールドの先頭、プロンプトの後に配します。内部的には、フィールドはテキストプロパティー`field`を使って実装されています(section “Text Properties” in the Emacs Lisp Reference Manualを参照してください)。

comint-use-prompt-regexp
shell-prompt-pattern
変数`comint-use-prompt-regexp`を非`nil`値に変更した場合、Comintモードは正規表現を使ってプロンプトを認識します([Regexps](#Regexps)を参照してください)。Shellモードでは、その正規表現は変数`shell-prompt-pattern`により指定されます。`comint-use-prompt-regexp`のデフォルト値は`nil`です。なぜならプロンプト認識のためのこの方法は信頼性が低いためです。しかし特殊な状況では、これを非`nil`値にセットしたいと思うこともあるでしょう。そのような場合、EmacsはComintバッファーをフィールドに分割しないので、一般的な移動コマンドは、テキストプロパティーを使用せず、それらのコマンドがバッファーで通常行なうように振る舞います。しかし、バッファーを便利に操作するために、パラグラフ移動コマンドを使うことができます([Paragraphs](#Paragraphs)を参照してください)。Shellモードでは、Emacsはパラグラフ境界に`shell-prompt-pattern`を使用します。

Shellコマンドヒストリー
-----------------------

Shellバッファーは、以前のコマンドを繰り返す3つの方法をサポートします。1つ目はミニバッファーヒストリーにたいして使うのと同じようなキーを使う方法です。つまり、これらはミニバッファーで行なうのと同じように、前のコマンドからテキストを挿入して、ポイントを常にバッファーの最後に保ちます。2つ目は、バッファーを移動して元の場所から前の入力を取得して、それらを再実行したり、バッファーの最後にコピーする方法です。3つ目は‘`!`’スタイルのヒストリー参照を使う方法です。

### Shellヒストリーリング

`M-p`; `C-UP`  
以前のシェルコマンドから、次に古いコマンドを取り出します(`comint-previous-input`)。

M-n (Shell mode)

comint-next-input

`M-n`; `C-DOWN`  
以前のシェルコマンドから、次に新しいコマンドを取り出します(`comint-next-input`)。

M-r (Shell mode)

comint-history-isearch-backward-regexp

`M-r`  
以前のシェルコマンドにたいして、インクリメンタルregexp検索を開始します(`comint-history-isearch-backward-regexp`)。

`C-c C-x`  
C-c C-x (Shell mode)

comint-get-next-from-history

ヒストリーから次のコマンドを取り出します(`comint-get-next-from-history`)。

`C-c .`  
C-c . (Shell mode)

comint-input-previous-argument

以前のシェルコマンドから引数を1つ取り出します(`comint-input-previous-argument`)。

`C-c C-l`  
C-c C-l (Shell mode)

comint-dynamic-list-input-ring

そのバッファーのシェルコマンドのヒストリーを、別のウィンドウに表示します(`comint-dynamic-list-input-ring`)。

Shellバッファーは、以前に入力したシェルコマンドのヒストリーを提供します。ヒストリーからシェルコマンドを再利用するには、編集コマンド`M-p`、`M-n`、`M-r`を使用します。これらは、ミニバッファーではなくShellバッファーを操作する点を除き、ミニバッファーヒストリーコマンド([Minibuffer History](#Minibuffer-History)を参照してください)と同じように機能します。またShellバッファー内での`M-r`は、シェルコマンドヒストリーにたいするインクリメンタル検索を呼び出します。

`M-p`は、シェルバッファーの最後から以前のシェルコマンドを取り出します。連続して`M-p`を使用すると、古いシェルコマンドを連続して取り出し、その度にシェル入力の候補として表示されているテキストを置き換えます。`M-n`も同様に機能しますが、これはバッファーから、より新しいシェルコマンドを連続して探します。`C-UP`は`M-p`と同様に機能し、`C-DOWN`は`M-n`と同様に機能します。

ヒストリー検索コマンド`M-r`は、以前のシェルコマンドにたいしてインクリメンタル正規表現検索を開始します。`M-r`とタイプした後に、検索したい文字列か正規表現のタイプを開始します。するとマッチする最後のシェルコマンドがカレント行に表示されます。インクリメンタル検索コマンドは通常の効果をもちます — たとえば`C-s`および`C-r`は前方または後方に、次のマッチを検索します([Incremental Search](#Incremental-Search)を参照してください)。探している入力が見つかったら、検索を終了するためにRETをタイプします。これにより、入力がコマンドラインに配されます。ヒストリーリストを操作する前にタイプしていた入力の一部は、ヒストリーリングの先頭または最後に達したときに復元されます。

以前に実行した一連のシェルコマンドを、同じ順番で再実行できたら便利なこともあります。これを行なうには、最初に順番に再実行する1番目のコマンドを検索します。その後`C-c
C-x`とタイプします。これは次のコマンド — つまり再実行したコマンドの次のコマンドを取り出します。それからRETでそのコマンドを実行します。`C-c C-x
RET`を繰り返しタイプすることにより、連続する複数のコマンドを再実行することができます。

コマンド`C-c .` (`comint-input-previous-argument`)は、Bashの`ESC
.`のように、以前のコマンドから個別に引数をコピーします。一番簡単な使い方は、以前のシェルコマンドから最後の引数をコピーする方法です。プレフィクス引数nを指定すると、n番目の引数をコピーします。繰り返し`C-c
.`とタイプすることにより、さらに古いシェルコマンドからコピーします。この場合、常に同じnの値を使用します(`C-c
.`を繰り返すときは、プレフィクス引数を与えないでください)。

これらのコマンドは、以前のシェルコマンドのテキストを、シェルバッファー自身からではなく、特別なヒストリーリストから取得します。したがってシェルバッファーを編集したり、広い範囲をkillしても、これらのコマンドがアクセスするヒストリーに影響はありません。

shell-input-ring-file-name
シェルの中には、コマンドヒストリーをファイルに保存して、以前のシェルセッションからコマンドを参照できるようにするものがあります。Emacsは選択されたシェルにたいして、コマンドヒストリーを初期化するために、コマンドヒストリーファイルを読み込みます。ヒストリーファイル名は、bashでは`~/.bash_history`、kshでは`~/.sh_history`、他のシェルでは`~/.history`です。

### Shellヒストリーのコピー

`C-c C-p`  
前のプロンプトにポイントを移動します(`comint-previous-prompt`)。

C-c C-n (Shell mode)

comint-next-prompt

`C-c C-n`  
次のプロンプトにポイントを移動します(`comint-next-prompt`)。

C-c RET (Shell mode)

comint-copy-old-input

`C-c RET`  
ポイント位置の入力コマンドをコピーして、そのコピーをバッファーの最後に挿入します(`comint-copy-old-input`)。これは以前のコマンドにポイントを移動したときに便利です。コマンドをコピーした後、RETでそのコピーを入力として実行することができます。再実行する前に、そのコピーを編集することもできます。このコマンドを出力行で使用した場合、その行をバッファーの最後にコピーします。

`mouse-2`  
`comint-use-prompt-regexp`が`nil`(デフォルト)の場合、クリックした以前の入力コマンドをコピーして、そのコピーをバッファーの最後に挿入します(`comint-insert-input`)。`comint-use-prompt-regexp`が非`nil`、または以前の入力以外の場所をクリックしたときは、通常のようにyankします。

以前の入力に移動して、`C-c
RET`または`mouse-2`でコピーすることは、`M-p`を充分な回数使用して、ヒストリーリングから以前の入力を取り出したときと同じ結果 — つまり同じバッファー内容 — を生成します。しかし`C-c
RET`は、バッファーからテキストをコピーするので、入力をシェルに送信した後に入力テキストを編集していた場合は、ヒストリーリストと異なります。

### Shellヒストリーの参照

history reference
cshやbashを含むさまざまなシェルは、‘`!`’や‘`^`’で始まるヒストリー参照(history references)をサポートします。Shellモードはこれらを認識して、ヒストリーの置き換える処理をします。

ヒストリー参照を挿入してTABとタイプすると、これは入力ヒストリーからマッチするコマンドを検索して、必要なら置換を行い、結果をバッファー内のヒストリー参照の場所に配します。たとえば、一番最近の‘`mv`’で始まるコマンドを取り出すには、`!
m v TAB`とタイプします。必要ならコマンドを編集して、RETでシェルにたいしてコマンドを再実行できます。

comint-input-autoexpand
comint-magic-space
Shellモードはヒストリー参照をシェルに送るとき、オプションでヒストリー参照を展開できます。これを行なうには、変数`comint-input-autoexpand`を`input`にセットします。SPCを`comint-magic-space`にバインドすれば、SPCでヒストリー参照を展開できます。[Rebinding](#Rebinding)を参照してください。

Shellモードは、ヒストリー参照がプロンプトの後にあればヒストリー参照を認識します。Shellモードがプロンプトを認識する方法については、[Shell Prompts](#Shell-Prompts)を参照してください。

ディレクトリーの追跡
--------------------

directory tracking
shell-pushd-regexp
shell-popd-regexp
shell-cd-regexp
Shellモードは、Shellバッファーのデフォルトディレクトリー([File Names](#File-Names)を参照してください)をシェルの作業ディレクトリーと同一に保つために、サブシェルに与えられる‘`cd`’、‘`pushd`’、‘`popd`’のコマンドを追跡します。これは、送信する入力行を調べることにより認識されます。

これらのコマンドにたいしてエイリアスを使用する場合、変数`shell-pushd-regexp`、`shell-popd-regexp`、`shell-cd-regexp`に適切な正規表現([Regexps](#Regexps)を参照してください)をセットすることにより、それらも認識するようEmacsに指示できます。たとえば、`shell-pushd-regexp`がシェルコマンドラインの先頭にマッチした場合、その行は`pushd`コマンドとして記録されます。これらのコマンドは、シェルコマンドラインの先頭だけで認識されます。

dirs
Emacsが作業ディレクトリーの変更に際して混乱した場合は、`M-x
dirs`を試してください。このコマンドはシェルに作業ディレクトリーを尋ねて、それに対応してデフォルトディレクリーを更新します。これは、一般的なコマンド構文のほとんどをサポートするシェルでは機能しますが、特殊なシェルでは機能しないかもしれません。

dirtrack-mode
Dirtrack mode
mode, Dirtrack
dirtrack-list
シェルの作業ディレクトリーを追跡する他の方法を実装した、バッファーローカルなマイナーモードの、Dirtrackモードを使うこともできます。この方法を使うには、シェルプロンプトに常に作業ディレクトリーが含まれていなければならず、プロンプトのどの部分が作業ディレクトリーを含むか認識するための正規表現を与えなければなりません。詳細は、変数`dirtrack-list`のドキュメントを参照してください。Dirtrackモードを使用するには、Shellバッファーで`M-x
dirtrack-mode`とタイプするか、`shell-mode-hook`に`dirtrack-mode`を追加します([Hooks](#Hooks)を参照してください)。

Shellモードのオプション
-----------------------

comint-scroll-to-bottom-on-input
変数`comint-scroll-to-bottom-on-input`が非`nil`の場合、挿入およびyankコマンドは、挿入する前に選択されたウィンドウを、バッファーの最後までスクロールします。デフォルトは`nil`です。

comint-scroll-show-maximum-output
`comint-scroll-show-maximum-output`が非`nil`の場合、ポイントが最後にあるとき到着した出力は、可能な限り有用なテキストを表示するために、テキストの最後の行がウィンドウの一番下になるようなスクロールを試みます(これはほとんどの端末のスクロール動作を真似た動作です)。デフォルトは`t`です。

comint-move-point-for-output
`comint-move-point-for-output`をセットすることにより、出力が到着したときにバッファーの最後にポイントをジャンプさせることができます — その前にポイントがバッファーのどこにあろうと関係ありません。値が`this`の場合、選択されたウィンドウ内でポイントがジャンプします。値が`all`の場合、Comintバッファーを表示するすべてのウィンドウでポイントがジャンプします。値が`other`の場合、カレントバッファーを表示する、選択されていないすべてのウィンドウでポイントがジャンプします。デフォルト値は`nil`で、これはポイントが最後にジャンプしないことを意味します。

comint-prompt-read-only
`comint-prompt-read-only`をセットした場合、Comintバッファーのプロンプトは読み取り専用になります。

comint-input-ignoredups
変数`comint-input-ignoredups`は、連続する同じ入力を入力ヒストリーに保存するかを制御します。非`nil`値は、入力が前の入力と同じ場合は省略することを意味します。デフォルトは`nil`で、これは入力が前の入力と同じでも保存することを意味します。

comint-completion-addsuffix
comint-completion-recexact
comint-completion-autolist
ファイル名の補完をカスタマイズする3つの変数があります。変数`comint-completion-addsuffix`は、完全に補完されたファイル名またはディレクトリー名の最後にスペースまたはスラッシュを挿入するかを制御します(非`nil`は、スペースまたはスラッシュを挿入することを意味します)。`comint-completion-recexact`が非`nil`の場合、通常のEmacs補完アルゴリズムが1文字も追加できないようなときは、TABで一番短い利用可能な補完を選択するよう指示します。`comint-completion-autolist`が非`nil`の場合、補完が完全でないときは、利用可能なすべての候補をリストするよう指示します。

shell-completion-execonly
コマンド補完は通常、実行可能ファイルだけを考慮します。`shell-completion-execonly`を`nil`にセットした場合は、実行可能ファイル以外も同様に考慮します。

shell-completion-fignore
comint-completion-fignore
変数`shell-completion-fignore`は、Shellモードで無視するファイル名の拡張子のリストを指定します。デフォルトは`nil`ですが、‘`~`’、‘`#`’、‘`%`’で終わるファイル名を無視するために`("~"
"#"
"%")`をセットするユーザーもいます。他のComintモードに関連するモードは、かわりに変数`comint-completion-fignore`を使用します。

shell-dynamic-complete-command
シェルコマンド補完の実装の詳細は、`shell-dynamic-complete-command`関数のlispドキュメントで見ることもできます。

shell-pushd-tohome
shell-pushd-dextract
shell-pushd-dunique
‘`pushd`’の動作を設定することができます。`shell-pushd-tohome`は、引数を与えない場合に‘`pushd`’が‘`cd`’のように振る舞うかを制御します。`shell-pushd-dextract`は、数引数を与えたときローテートするのではなくpopするかを制御します。`shell-pushd-dunique`は、ディレクトリースタックにディレクトリーがない場合だけ追加するかを制御します。もちろん選択する値は背後のシェルに適合する必要があります。

comint-terminfo-terminal
TERM, environment variable, in sub-shell
Comintモードは、環境変数TERMの値を安全なデフォルト値にセットしますが、この値はいくつかの有用な機能を無効にします。たとえば、カラーがサポートされているかの判断にTERMを使用するため、アプリケーションではカラーが無効になっています。したがって、Emacsはオプション`comint-terminfo-terminal`を提供します。そのため、その端末の高度な機能を利用するために、システムのterminfoデータベースにより提供される端末にセットできます。

Emacsの端末エミュレーター
-------------------------

term
テキスト端末エミュレーターでサブシェルを実行するには、`M-x
term`を使用します。これは`*terminal*`という名前のバッファーを作成(または再利用)して、キーボードを入力とするサブシェルを実行し、出力はそのバッファーになります。

line mode (terminal emulator)
char mode (terminal emulator)
端末エミュレーターは、2つの入力モードをもつTermモードを使用します。lineモード(line mode)では、Termは基本的にShellモードのように振る舞います([Shell Mode](#Shell-Mode)を参照してください)。charモード(char mode)では、文字は端末入力として直接サブシェルに送られます。唯一の例外は端末エスケープ文字で、デフォルトは`C-c`です([Term Mode](#Term-Mode)を参照してください)。入力をエコーするのはサブシェルの役目です。サブシェルからの端末出力は、バッファーのポイントの後に送られます。

(Emacsのような)いくつかのプログラムでは、端末スクリーンで詳細に外観を制御する必要があります。これらのプログラムは特別な制御コードを送ることによりこれを行ないます。Termモードは、`xterm`を含むほとんどの現代的な端末で使用できる、ANSI標準のVT100スタイルのエスケープシーケンスを認識・処理します(したがって、実際にEmacsのTermウィンドウ内でEmacsを実行することもできます)。

`term`フェイスは、端末エミュレーターのテキストのデフォルトの外観を指定します(デフォルトは`default`フェイスと同じ外観です)。端末の制御コードがテキストの外観を変更するために使用される場合、これらは端末エミュレーター内で、フェイス`term-color-black`、`term-color-red`、`term-color-green`、`term-color-yellow`、`term-color-blue`、`term-color-magenta`、`term-color-cyan`、`term-color-white`、`term-color-underline`、`term-color-bold`で表示されます。[Faces](#Faces)を参照してください。

シリアルポートに接続されたデバイスと通信するために、Termモードを使うこともできます。[Serial Terminal](#Serial-Terminal)を参照してください。

サブシェルをロードするために使用されるファイル名は、Shellモードと同じ方法で決定されます。複数の端末エミュレーターを作成するには、Shellモードと同じように、`M-x
rename-uniquely`を使って、バッファー`*terminal*`を違う名前にリネームします。

Shellモードとは異なり、Termモードは入力を調べてカレントディレクトリーを追跡することはしません。しかし、いくつかのシェルはカレントディレクトリーをTermに告げることができます。これは`bash`のバージョン1.15以降では自動的に行なわれます。

Termモード
----------

Term mode
mode, Term
Termモードでlineモードとcharモードを切り替えるには、以下のコマンドを使用します:

`C-c C-j`  
lineモードに切り替えます(`term-line-mode`)。すでにlineモードのときは何もしません。

C-c C-k (Term mode)

term-char-mode

`C-c C-k`  
charモードに切り替えます(`term-char-mode`)。すでにcharモードのときは何もしません。

以下のコマンドはcharモードだけで利用可能です:

`C-c C-c`  
サブシェルに、リテラルの`C-c`を送ります(`term-interrupt-subjob`)。

`C-c char`  
これは通常のEmacsでの`C-x char`と等価です。たとえば`C-c o`は、通常`C-x
o`にグローバルにバインドされている‘`other-window`’を呼び出します。

paging in Term mode
Termモードにはpage-at-a-time(1度に1ページ)機能があります。これが有効な場合、出力の画面の最後で一時停止します。

`C-c C-q`  
page-at-a-time機能を切り替えます(`term-pager-toggle`)。このコマンドはlineモードとcharモードの両方で機能します。この機能が有効な場合、モードラインには単語‘`page`’が表示され、Termが1画面に収まらない出力を受け取ったときは、一時停止してモードラインに‘`**MORE**`’を表示します。SPCとタイプすると次の1画面分の出力を表示し、`?`でオプションを見ることができます。このインターフェースは、`more`プログラムと同様です。

リモートホストのシェル
----------------------

remote host
connecting to remote host
Telnet
Rlogin
Termウィンドウから、通常の端末から使うコマンド(たとえば`ssh`、`telnet`、`rlogin`)で、リモートコンピューターにログインすることができます。

パスワードを尋ねるようなプログラムは、通常パスワードをエコーしないので、パスワードはバッファーにも表示されません。バッファーがcharモードの場合、実際の端末で使用しているのと同じ動作になります。lineモードの場合、パスワードは一時的に表示されますが、リターンをタイプするとパスワードは消去されます(これは自動的に行なわれます。特別なパスワード処理は行なっていません)。

別のマシンにログインしているときは、リモートログインコマンドのために、環境変数TERMをセットすることにより、端末タイプを指定する必要があります(bashを使用している場合、リモートログインコマンドの前に、カンマで区切らず値割り当てを記述することにより、これを行なうことができます)。端末タイプ‘`ansi`’または‘`vt100`’は、ほとんどのシステムで動作するでしょう。

シリアル端末
------------

terminal, serial
serial-term
コンピューターに、シリアルポートに接続されたデバイスがあるとき、`M-x
serial-term`とタイプすることにより、デバイスと通信することができます。このコマンドは新しいTermモードのバッファーのために、ポート番号、スピード、スイッチを尋ねます。Emacsは、通常のTermモードの端末で行なうのと同じように、このバッファーを通じてシリアルデバイスと通信します。

シリアルポートのスピードはビット毎秒で計ります。もっとも一般的なスピードは9600ビット毎秒です。モードラインをクリックすることにより、このスピードを対話的に変更できます。

シリアルポートはモードラインの‘`8N1`’をクリックしても設定できます。デフォルトでは、シリアルポートは‘`8N1`’に設定されており、これは各バイトは8ビットからなり、パリティービットチェックなし、ストップビットが1であることを意味します。

スピードや設定が間違っている場合、デバイスと通信できず、おそらくウィンドウにはゴミが出力されるでしょう。

サーバーとしてのEmacsの使用
===========================

emacsclient
Emacs as a server
server, using Emacs as
EDITOR
environment variable
さまざまなプログラムが、特定のテキスト断片を編集するために、あなたが選択したエディターを呼び出すことができます。たとえば、バージョンコントロールシステム([Version Control](#Version-Control)を参照してください)は、バージョンコントロールログを入力するためのエディターを呼び出し、Unixの`mail`ユーティリティーは送信メッセージの入力にエディターを呼び出します。慣例により、選択するエディターは、環境変数EDITORで指定されます。しかしEDITORを‘`emacs`’にセットした場合、Emacsが呼び出されますが、これは便利な方法ではありません — なぜなら新しいEmacsプロセスが開始されるからです。なぜこれが不便かというと、新たなEmacsプロセスは、既存のEmacsプロセスのバッファー、コマンドヒストリー、その他の情報を共有しないからです。

Emacsをedit server(編集サーバー)としてセットアップして、Emacsが外部からの編集リクエストを“listen”し、それに応じて動作させることにより、この問題を解決できます。Emacsサーバーを開始するにはさまざまな方法があります:

-   server-start
    `M-x server-start`とタイプするか、initファイル([Init File](#Init-File)を参照してください)に式`(server-start)`を記述して、既存のEmacsプロセスでコマンド`server-start`を実行します。既存のEmacsプロセスがサーバーになり、Emacsを終了すると、サーバーはそのEmacsプロセスとともに終了します。

-   daemon, Emacs
    コマンドラインオプション‘`--daemon`’のいずれか1つを使用して、Emacsをdaemonとして実行します。[Initial Options](#Initial-Options)を参照してください。Emacsがこの方法で開始された場合、初期化の後に`server-start`を呼び出して、初期フレームを開きません。その後クライアントからの編集リクエストをwaitします。

-   systemd unit file
    オペレーティングシステムがスタートアップ管理に`systemd`を使用する場合、提供されるsystemdユニットファイル(systemd unit file)を使用して、ログイン時に自動的にデーモンモードのEmacsを開始できます。これをアクティブにするには:

        systemctl --user enable emacs

    (Emacsが標準的な場所にインストールされていない場合は、`~/.config/systemd/user/`のような標準的なディレクトリーに`emacs.service`をコピーする必要があるかもしれません。)

-   socket activation, systemd, Emacs
    指定されたソケットに接続イベントが発生したとき、外部プロセスはEmacsサーバーを呼び出して、そのソケットを新たなEmacsサーバーのプロセスに渡すことができます。このインスタンスは`systemd`のソケット機能です。`systemd`サービスはソケットを作成して、そのソケットへの接続をlistenします。`emacsclient`が最初にこれに接続したとき、`emacsclient`による接続のために、`systemd`はEmacsサーバーを起動して、そのソケットを渡すことができます。`emacsclient`が最初にこれに接続したとき、`emacsclient`による接続のために、`systemd`はEmacsサーバーを起動して、そのソケットを渡すことができます。この機能を使用するためのセットアップは:

    `~/.config/systemd/user/emacs.socket`:

        [Socket]
        ListenStream=/path/to/.emacs.socket

        [Install]
        WantedBy=sockets.target

    (上述のファイル`emacs.service`もインストールされていなければなりません。)

    パス`ListenStream`は、Emacsが`emacsclient`からの接続をlistenするパスです。これは、あなたが選択するファイルです。

TEXEDIT
environment variable
Emacsサーバーを一度開始すると、`emacsclient`というシェルコマンドを使用してEmacsに接続して、ファイルをvisitするよう指示できます。環境変数EDITORに‘`emacsclient`’をセットすれば、外部プログラムは編集のために既存のEmacsプロセスを使用できます。[21]

server-name
変数`server-name`を使って、一意なサーバー名を与えることにより、同一マシン上で複数のEmacsサーバーを実行することができます。たとえば`M-x
set-variable RET server-name RET "foo"
RET`は、サーバー名を‘`foo`’にセットします。`emacsclient`プログラムはTCPソケット使用の有無に応じて‘`-s`’オプション、または‘`-f`’オプション([emacsclient Options](#emacsclient-Options)を参照)で、名前によりサーバーを指定できます([emacsclient Options](#emacsclient-Options)を参照)。

複数のEmacsデーモン([Initial Options](#Initial-Options)をい参照してください)を実行したい場合、以下のようにデーモンごとにそれぞれ、独自のサーバー名を与えることができます:

      emacs --daemon=foo

server-eval-at
一意なサーバー名によりサーバーを定義した場合、他のEmacsインスタンスからそのサーバーに接続し、`server-eval-at`関数を使用して、そのサーバーでLisp式を評価できます。たとえば`(server-eval-at
"foo" '(+ 1 2))`は、式`(+ 1
2)`をサーバー‘`foo`’で評価して、`3`を返します(そのような名前のサーバーが存在しない場合はエラーをシグナルします)。現在のところ、これは主に開発者に有用な機能です。

TCP Emacs server
----------------

TCP Emacs server
server-use-tcp
Emacsサーバーは通常、接続にたいしてローカルのUnixドメインソケットをlistenします。 MS-Windowsのようないくつかのオペレーティングシステムは、ローカルソケットをサポートしません。そのような場合、サーバーはかわりにTCPソケットをlistenします。ローカルソケットがサポートされている場合でも、サーバーにTCPソケットをlistenさせるほうが便利な場合があります(たとえばリモートマシンからEmacsサーバーに接続する必要がある場合)。ローカルソケットのかわりにTCPソケットをEmacsにlistenさせる場合は、`server-use-tcp`に非`nil`をセットできます。これはOSがローカルソケットをサポートしない場合は、デフォルトです。

server-host
server-port
EmacsサーバーがTCPを使うように設定されている場合は、デフォルトではlocalhostインターフェイスのランダムなポートをlistenします。`server-host`と`server-port`を使用して、これを他のインターフェイス、および/または固定されたポートに変更できます。

server-auth-key
TCPソケットは、ファイルシステムのパーミッションの対象ではありません。TCPソケットを通じて、誰がEmacsサーバーと通信できるか何らかの制御を得るには、`emacsclient`プログラムがサーバーに認証キーを送信しなければなりません。このキーは通常、Emacsサーバーによりランダムに生成されます。これが推奨されるモードです。

server-generate-key
必要なら、`server-auth-key`変数をセットすることにより、認証キーに静的な値をセットできます。このキーは、スペースを除くプリント可能な64文字のASCII文字(これは‘`!`’から‘`~`’、10進コードの33から126を意味します)から構成されなければなりません。ランダムキーを得るために、`M-x
server-generate-key`を使用できます。

server-auth-dir
server file
TCP Emacsサーバーを開始したとき、Emacsは`emacsclient`がサーバーに接続するために使用する、TCP情報を含むサーバーファイル(server file)を作成します。変数`server-auth-dir`は、サーバーファイルを含むデフォルトディレクトリーを指定します。デフォルトでは、これは`~/.emacs.d/server/`です。アクセス権限(file permission)をもつlocalソケットが存在しない場合は、このディレクトリーのパーミッションにより、どのユーザーの`emacsclient`プロセスがEmacsサーバーと対話(talk)できるか判断されます。`server-name`がー絶対ファイル名なら、サーバーファイルはそのファイル名で作成されます。

EMACS\_SERVER\_FILE, environment variable
特定のserverファイルによりTCPサーバーに接続するよう`emacsclient`に指示するには、オプション‘`-f`’または‘`--server-file`’を使用するか、環境変数EMACS\_SERVER\_FILEをセットします([emacsclient Options](#emacsclient-Options)を参照)。`server-auth-dir`が非標準的な値にセットされていたり、`server-name`に絶対ファイル名がセットされていると、デフォルトの`server-auth-dir`は、相対ファイル名を解決するために使用するディレクトリーとして、`emacsclient`内にハードコーディングされているため、serverファイルにたいする絶対ファイル名が必要になります。

`emacsclient`の呼び出し
-----------------------

emacsclient
invocation
`emacsclient`プログラムを使う一番簡単な方法は、シェルコマンド‘`emacsclient
file`’を実行する方法です。ここでfileはファイル名です。これはEmacsサーバーに接続して、Emacsプロセスの既存のフレームの1つ — グラフィカルなフレーム、またはテキスト端末のフレーム([Frames](#Frames)を参照してください) — でfileをvisitするよう指示します。それから、そのフレームを選択して編集を開始できます。

Emacsサーバーが存在しない場合、`emacsclient`はエラーメッセージと共に終了します(このハプニングによるエラー終了は、`emacsclient`にたいして‘`--alternate-editor=\"\"`’オプションを使用して回避できる。[emacsclient Options](#emacsclient-Options)を参照されたい)。Emacsプロセスに既存のフレームがない場合 — これはサーバーがデーモン([Emacs Server](#Emacs-Server)を参照してください)として開始されたときに発生し得ます — は、`emacsclient`を呼び出した端末でEmacsフレームをオープンします。

オプション‘`-c`’でグラフィカルなディスプレー、‘`-t`’を使用しテキスト端末で新しいフレームを開くように、`emacsclient`に強制することもできます。[emacsclient Options](#emacsclient-Options)を参照してください。

単一のテキスト端末で実行している場合、`emacsclient`のシェルとEmacsサーバーを、次の2つの方法で切り替えることができます。1つ目は、Emacsサーバーと、別の仮想端末で`emacsclient`を実行して、`emacsclient`を呼び出した後にEmacsサーバーの仮想端末に切り替える方法です。2つ目は、Emacsサーバー自身からShellモード([Interactive Shell](#Interactive-Shell)を参照してください)、またはTermモード([Term Mode](#Term-Mode)を参照してください)を使って`emacsclient`を呼び出す方法です。`emacsclient`は、Emacs配下のサブシェルのときだけブロックするので、依然としてファイルの編集にEmacsを使用できます。

C-x \#
server-edit
Emacsサーバーでfileの編集を終えたら、そのバッファーで`C-x #` (`server-edit`)とタイプします。これはファイルを保存して、`emacsclient`プログラムに終了を告げるメッセージを送り返します。通常、EDITORを使うプログラムは、何か他のことを行なう前にエディター — この場合は`emacsclient` — の終了を待ちます。

複数のファイル名を引数にして`emacsclient`を呼び出すこともできます。‘`emacsclient
file1 file2
...`’は、Emacsサーバーにfile1、file2、...をvisitするよう指示します。Emacsはfile1をvisitしているバッファーを選択して、他のバッファーをバッファーリストの最後に隠します([Buffers](#Buffers)を参照してください)。指定されたすべてのファイルを終了したら(たとえば各サーバーバッファーで`C-x
#`をタイプしたら)、`emacsclient`プログラムは終了します。

server-kill-new-buffers
server-temp-file-regexp
サーバーバッファーを終了すると、そのバッファーがサーバーバッファーを作成する前から存在していたバッファーでないかぎり、そのバッファーもkillされます。しかし`server-kill-new-buffers`を`nil`にセットした場合、別の基準が使用されます。この場合、サーバーバッファーの終了は、ファイル名が正規表現`server-temp-file-regexp`にマッチするときは、バッファーをkillします。これはある種の一時ファイルを区別するための仕組みです。

各`C-x
#`は、さまざまなファイルを編集する、保留されている外部要求が他にないかチェックして、次のそのようなファイルを選択します。サーバーバッファーに辿り着くのに、`C-x
#`だけを使わなければならない訳ではありません。サーバーバッファーに手動で切り替えることもできます。しかし`C-x
#`は、`emacsclient`に終了したことを告げる方法なのです。

server-window
変数`server-window`の値をウィンドウやフレームにした場合、`C-x
#`は常に次のサーバーバッファーを、そのウィンドウまたはそのフレームに表示します。

`emacsclient`のオプション
-------------------------

emacsclient
options
以下のようなオプション引数を`emacsclient`プログラムに渡すことができます:

    emacsclient -c +12 file1 +4:3 file2

引数‘`+line`’および‘`+line:column`’は、その後に続くファイルの行番号、または行番号と列番号を指定します。これらはEmacs自身に対するコマンドライン引数と同じように機能します。 [Action Arguments](#Action-Arguments)を参照してください。

その他の`emacsclient`により認識されるオプション引数を以下にリストします:

‘`-a command`’; ‘`--alternate-editor=command`’  
`emacsclient`が、Emacsとの接続に失敗したとき実行するシェルコマンドを指定します。これはスクリプト内で`emacsclient`を実行するとき便利です。このコマンドには、\\"like this\\"のようにクォートされた引数が含まれるかもしれません。現在のところ、クォートのエスケープはサポートされていません。

特別な例外として、commandが空文字列の場合、接続に失敗したら`emacsclient`は(‘`emacs
--daemon`’のように)Emacsをデーモンモードで開始して、再度接続を試みます。

ALTERNATE\_EDITOR

environment variable

環境変数ALTERNATE\_EDITORは、‘`-a`’オプションと同じ効果をもちます。両方が指定された場合は、後者のオプションが優先されます。

client frame

‘`-c`’; ‘`--create-frame`’  
既存のEmacsフレームを使うかわりに、新しいグラフィカルなクライアントフレーム(client frame)を作成します。クライアントフレームでの、`C-x
C-c`の特別な振る舞いについては、以下を参照してください。(Xサーバーに接続できない等で)新たにグラフィカルなフレームを作成しない場合、あたかも‘`-t`’オプションが指定されたかのように、テキスト端末でクライアントフレームの作成を試みます。

MS-Windowsでは、単一のEmacsセッションがグラフィカルなフレームとテキスト端末のフレームの両方を表示することはできず、複数のテキスト端末のフレームを表示することもできません。したがってEmacsサーバーがテキスト端末で実行されている場合、‘`-c`’オプションは‘`-t`’オプションのように、サーバーのカレントテキスト端末で新たなフレームを作成します。[Windows Startup](#Windows-Startup)を参照してください。

‘`-c`’オプションを指定するときに、ファイル名の引数を省略した場合、新しいフレームはデフォルトで`*scratch*`バッファーを表示します。変数`initial-buffer-choice`でこの振る舞いをカスタマイズできます([Entering Emacs](#Entering-Emacs)を参照してください)。

‘`-F alist`’; ‘`--frame-parameters=alist`’  
新たに作成される、グラフィカルなフレームのパラメーターをセットします([Frame Parameters](#Frame-Parameters)を参照してください)。

‘`-d display`’; ‘`--display=display`’  
与えられたファイルを、(複数のXディスプレーがあることを想定して)Xディスプレーdisplayで開くようEmacsに指示します。

‘`-e`’; ‘`--eval`’  
ファイルをvisitするかわりに、Emacs Lispコードを評価するようEmacsに指示します。このオプションが与えられた場合、`emacsclient`は引数をvisitするファイルではなく、式のリストと解釈します。

‘`-f server-file`’; ‘`--server-file=server-file`’  
TCPを通じてEmacsサーバーに接続するためのserverファイル([TCP Emacs server](#TCP-Emacs-server)を参照)を指定します。かわりにserverファイルを示すように、環境変数EMACS\_SERVER\_FILEをセットできます(コマンドラインオプションは、環境変数をオーバーライドする)。

Emacsサーバーは通常は接続にたいしてローカルソケットをlistenしますが、TCPを通じた接続もサポートします。TCPによりEmacsサーバーに接続するためには、`emacsclient`がEmacsサーバーへの接続に関する詳細を含むserverファイル(server file)を読み込む必要があります。このオプションでserverファイル名を指定します。これは`~/.emacs.d/server`からの相対ファイル名か、絶対ファイル名です。[TCP Emacs server](#TCP-Emacs-server)を参照してください。

‘`-n`’; ‘`--no-wait`’  
すべてのサーバーバッファーが終了するのを待つかわりに、`emacsclient`が即座に終了するようにします。Emacsのサーバーバッファーで編集したいときに、このオプションを指定します。`C-x
#`をタイプしても、これらはkillされません。

‘`--parent-id id`’  
XEmbedプロトコルを通じて、IDがidの親Xウィンドウでクライアントフレームとして、`emacsclient`フレームをオープンします。現在のところ、これは主に開発者に有用なオプションです。

‘`-q`’; ‘`--quiet`’  
`emacsclient`がEmacsを待つメッセージ、またはリモートのサーバーソケットに接続するメッセージを表示しないようにします。

‘`-u`’; ‘`--suppress-output`’  
サーバーからリターンされた結果を、`emacsclient`が表示しないようにします。これは主に‘`-e`’と併用し、評価が結果ではなく副作用を目的としているとき有用です。

‘`-s server-name`’; ‘`--socket-name=server-name`’  
名前がserver-nameのEmacsサーバーに接続します(このオプションはMS-Windowsではサポートされない)。サーバー名は、Emacsサーバー上の変数`server-name`により与えられます。このオプションが省略された場合、`emacsclient`は見つかったサーバーに接続します。Emacsサーバーの`server-name`に絶対ファイル名をセットした場合は、`emacsclient`がそのサーバーに接続するよう指示するために、server-nameに同じ絶対ファイル名を与えてください。

‘`-t`’; ‘`--tty`’; ‘`-nw`’  
既存のEmacsフレームを使うかわりに、カレントテキスト端末に新たなクライアントフレームを作成します。これはテキスト端末のフレームを作成する点を除き、上記で説明した‘`-c`’と同じように振る舞います([Non-Window Terminals](#Non_002dWindow-Terminals)を参照してください)。

MS-Windowsでは、Emacsサーバーがグラフィカルなディスプレーを使っている場合は‘`-c`’のように振る舞いますが、Emacsサーバーがテキスト端末で実行されている場合は、カレントテキスト端末に新たなフレームを作成します。

‘`-T tramp-prefix`’; ‘`--tramp-prefix=tramp-prefix`’  
EmacsがTRAMP (section “The Tramp Manual” in The Tramp Manualを参照)を使用してリモートマシンにファイルを配すとき([Remote Files](#Remote-Files)を参照)、ファイル名に追加されるプレフィクスをセットします。これは主に、TCP上でのEmacsサーバーの使用と併用すると有用です([TCP Emacs server](#TCP-Emacs-server)を参照)。listenするポートをsshフォワードして、リモートマシンでserver-fileを利用可能にすることにより、リモートマシン上のプログラムはEDITOR、および同種の環境変数にたいする値に`emacsclient`を使用できますが、リモートマシンからEmacsサーバーと通信するかわりに、そのファイルはTRAMPを使用してローカルのEmacsセッションによりvisitされます。

EMACSCLIENT\_TRAMP, environment variable

環境変数EMACSCLIENT\_TRAMPは、‘`-T`’オプションと同じ効果をもちます。両方が指定された場合は、コマンドラインのオプションが優先されます。

たとえば２つのホスト‘`local`’および‘`remote`’があり、ローカルのEmacsはTCPポート12345をlistenしているとします。さらに`/home`が共有ファイルシステム上にあるとすると、serverファイル`~/.emacs.d/server/server`は両方のホストから読み込めることになります。

    local$ ssh -R12345:localhost:12345 remote
    remote$ export EDITOR="emacsclient \
            --server-file=server \
            --tramp=/ssh:remote:"
    remote$ $EDITOR /tmp/foo.txt #Should open in local emacs.

オプション‘`-c`’または‘`-t`’で作成された、グラフィカルなフレームおよびテキスト端末のフレームは、クライアントフレーム(client frames)とみなされます。クライアントフレームから作成した新たなフレームも、クライアントフレームとみなされます。クライアントフレームで`C-x
C-c` (`save-buffers-kill-terminal`)とタイプした場合、それが通常行なうようなEmacsセッションのkill([Exiting](#Exiting)を参照してください)は行なわれません。かわりにEmacsはクライアントフレームを削除します。さらに、制御を取り戻すために待っている`emacsclient`をクライアントフレームがもつ場合(たとえば‘`-n`’オプションを与えなかった場合)、Emacsは同じくクライアントの他のすべてのフレームを削除し、(それらすべてにたいして`C-x
#`をタイプしたかのように)クライアントのサーバーバッファーが終了したとマークします。クライアントフレームが削除された後、残ったフレームが存在しない場合、Emacsセッションは終了します。

例外として、Emacsがデーモンとして開始された場合、すべてのフレームはクライアントフレームとみなされ、`C-x
C-c`がEmacsをkillすることはありません。デーモンセッションを終了するには、`M-x kill-emacs`とタイプします。

‘`-t`’と‘`-n`’は、矛盾するオプションであることに注意してください。‘`-t`’はカレントテキスト端末に新たにクライアントフレームを作成して制御することを指示し、‘`-n`’はテキスト端末で制御を行なわないことを指示するからです。両方のオプションを与えた場合、‘`-t`’の効果は打ち消されて、Emacsは新たにフレームを作成せず、既存のフレームで指定されたファイルをvisitします。

ハードコピーの印刷
==================

hardcopy
printing
Emacsは、バッファーの全体、または一部のハードコピーを印刷するコマンドを提供します。以下で詳しく述べるとおり、直接印刷コマンドを呼び出したり、メニューバーの‘`File`’メニューを使うことができます。

htmlfontify-buffer
このセクションで説明するコマンドとは別に、Dired([Operating on Files](#Operating-on-Files)を参照してください)からハードコピーを印刷したり、ダイアリー([Displaying the Diary](#Displaying-the-Diary)を参照してください)から印刷することもできます。コマンド`M-x
htmlfontify-buffer`で、EmacsバッファーをHTMLに“印刷”することもできます。これはEmacsのフェイスをCSSベースのマークアップに置換して、カレントバッファーをHTMLに変換します。さらにOrgモード([Org Mode](#Org-Mode)を参照してください)では、OrgファイルをPDFのような様々なフォーマットに印刷できます。

`M-x print-buffer`  
ファイル名を含むページヘッダーとともに、カレントバッファーのハードコピーを印刷します。

`M-x lpr-buffer`  
ページヘッダーなしで、カレントバッファーのハードコピーを印刷します。

`M-x print-region`  
`print-buffer`と同様ですが、カレントリージョンだけを印刷します。

`M-x lpr-region`  
`lpr-buffer`と同様ですが、カレントリージョンだけを印刷します。

print-buffer
print-region
lpr-buffer
lpr-region
lpr-switches
lpr-commands
ほとんどのオペレーティングシステムでは、上記のハードコピーコマンドは、`lpr`プログラムを呼び出して、印刷のためにファイルをサブミットします。印刷プログラムを変更するには、変数`lpr-command`をカスタマイズします。追加のスイッチを指定して、印刷プログラムにに与えるには、リスト変数`lpr-switches`をカスタマイズします。この変数の値はオプション文字列のリストで、それぞれが‘`-`’で始まります(たとえばオプション文字列`"-w80"`は1行に80列を指定します)。デフォルトは、空リスト`nil`です。

printer-name
lpr-printer-switch
使用するプリンターを指定するには、変数`printer-name`をセットします。デフォルトは`nil`で、これはデフォルトプリンターを指定します。これにプリンター名(文字列)をセットした場合、その名前は‘`-P`’スイッチとともに`lpr`に渡されます。`lpr`コマンドを使用しない場合は、スイッチを`lpr-printer-switch`で指定する必要があります。

lpr-headers-switches
lpr-add-switches
同様に変数`lpr-headers-switches`は、ページヘッダーを作成するために使用する追加のスイッチを指定します。変数`lpr-add-switches`は、印刷プログラムに‘`-T`’および‘`-J`’オプション(`lpr`向きのオプションです)を渡すかどうかを制御します。`nil`は、これらを追加しないことを意味します(印刷プログラムが`lpr`)互換でない場合は、この値を使用するべきです)。

PostScriptのハードコピー
------------------------

これらのコマンドはバッファーの内容をPostScriptに変換して、それを印刷または別のEmacsバッファーに出力します。

`M-x ps-print-buffer`  
PostScript形式で、カレントバッファーのハードコピーを印刷します。

`M-x ps-print-region`  
PostScript形式で、カレントリージョンのハードコピーを印刷します。

`M-x ps-print-buffer-with-faces`  
PostScript形式で、カレントバッファーのハードコピーを印刷し、テキストで使用されているフェイスはPostScript機能により表示します。

`M-x ps-print-region-with-faces`  
PostScript形式で、カレントリージョンのハードコピーを印刷し、テキストで使用されているフェイスで表示します。

`M-x ps-spool-buffer`  
カレントバッファーのテキストにたいするPostScriptイメージを生成およびスプールします。

`M-x ps-spool-region`  
カレントリージョンにたいするPostScriptイメージを生成およびスプールします。

`M-x ps-spool-buffer-with-faces`  
カレントバッファーにたいするPostScriptイメージを生成およびスプールし、使用されているフェイスで表示します。

`M-x ps-spool-region-with-faces`  
カレントリージョンにたいするPostScriptイメージを生成およびスプールし、使用されているフェイスで表示します。

`M-x ps-despool`  
Send the spooled PostScript to the printer.

`M-x handwrite`  
カレントバッファーにたいして、手書きされたようなPostScriptを生成・印刷します。

ps-print-region
ps-print-buffer
ps-print-region-with-faces
ps-print-buffer-with-faces
`ps-print-buffer`および`ps-print-region`コマンドは、バッファーの内容をPostScript形式で印刷します。一方はバッファー全体を印刷し、もう一方はリージョンだけを印刷します。コマンド`ps-print-buffer-with-faces`および`ps-print-region-with-faces`も同様に振る舞いますが、バッファーテキストのフェイス(フォントとカラー)を表示するためにPostScript機能を使用します。

プレフィクス引数(`C-u`)を使用した場合、これらのコマンドは対話的にユーザーにファイル名の入力を求め、PostScriptイメージをプリンターに送るかわりに、そのファイルに保存します。

ps-spool-region
ps-spool-buffer
ps-spool-region-with-faces
ps-spool-buffer-with-faces
‘`print`’のかわりに‘`spool`’が名前につくコマンドは、PostScript出力をプリンターに送るかわりに、Emacsバッファーに出力することを意味します。

ps-despool
コマンド`ps-despool`を使用して、スプールされたイメージをプリンターに送ります。このコマンドは‘`-spool-`’コマンド(上記コマンド参照)により生成されたPostScriptをプリンターに送ります。プレフィクス引数(`C-u`)を指定した場合は、ファイル名の入力を求め、スプールされたPostScriptイメージをプリンターに送るかわりに、そのファイルに保存します。

handwrite
handwriting
`M-x
handwrite`はもっと他愛ない機能です。これはカレントバッファーのPostScript表現を、草書体の手書きドキュメントのように生成します。これはグループ`handwrite`でカスタマイズできます。この関数はISO 8859-1文字だけサポートします。

PostScriptハードコピーにたいする変数
------------------------------------

ps-lpr-command
ps-lpr-switches
ps-printer-name
すべてのPostScriptハードコピーコマンドは、どのように出力を印刷するかの指定に、変数`ps-lpr-command`と`ps-lpr-switches`を使用します。`ps-lpr-command`は実行するコマンド名、`ps-lpr-switches`は使用するコマンドラインオプション、`ps-printer-name`はプリンターを指定します。最初の2つの変数をセットしない場合、変数の初期値を`lpr-command`と`lpr-switches`から取得します。`ps-printer-name`が`nil`の場合、`printer-name`が使用されます。

ps-print-header
変数`ps-print-header`は、これらのコマンドが各ページにヘッダー行を追加するかを制御します。これを`nil`にセットするとヘッダーはオフになります。

color emulation on black-and-white printers
ps-print-color-p
プリンターがカラーをサポートしない場合は、`ps-print-color-p`を`nil`にセットして、カラー処理をオフにするべきです。デフォルトでは、ディスプレーがカラーをサポートしていれば、Emacsはカラー情報をもったハードコピー出力を生成します。モノクロプリンターでは、カラーはグレーの濃淡でエミュレートされます。スクリーンカラーがグレーの濃淡だけしか使用していなくても、これは読みにくい出力を生成するかもしれません。

かわりに`ps-print-color-p`を`black-white`にセットして、モノクロプリンターで印刷する色をセットできます。

ps-use-face-background
デフォルトでは、変数`ps-use-face-background`が非`nil`でなければ、PostScript印刷はフェイスのバックグラウンドカラーは無視します。これは望ましくないゼブラストライプや、バックグラウンドイメージとテキストの干渉を避けるためです。

ps-paper-type
ps-page-dimensions-database
変数`ps-paper-type`は、フォーマットする用紙サイズを指定します。妥当な値には`a4`、`a3`、`a4small`、`b4`、`b5`、`executive`、`ledger`、`legal`、`letter`、`letter-small`、`statement`、`tabloid`が含まれます。デフォルトは`letter`です。変数`ps-page-dimensions-database`を変更することにより、追加の用紙サイズを定義できます。

ps-landscape-mode
変数`ps-landscape-mode`は、ページの印刷向きを指定します。デフォルトは`nil`で、これは縦向き印刷モード(portrait mode)を意味します。非`nil`値は横向き印刷モード(landscape mode)を指定します。

ps-number-of-columns
変数は列番号を指定します。この変数は横向きモードと縦向きモードの両方で効果をもちます。デフォルトは1です。

ps-font-family
ps-font-size
ps-font-info-database
変数`ps-font-family`は、通常のテキストを印刷するために使用するフォントファミリーを指定します。妥当な値には、`Courier`、`Helvetica`、`NewCenturySchlbk`、`Palatino`、`Times`が含まれます。変数`ps-font-size`は、通常のテキストのためのフォントサイズを指定し、デフォルトは8.5ポイントです。`ps-font-size`の値には、2つの浮動小数点によるコンスでも指定できます。その場合、1つは縦向き印刷モード、もう一方は横向き印刷モードでの指定です。

ps-multibyte-buffer
Intlfonts for PostScript printing
fonts for PostScript printing
Emacsは、通常のPostScriptプリンターより多くのスクリプトと文字をサポートします。したがってバッファーのいくつかの文字は、プリンターに組み込まれたフォントを使って印刷できないかもしれません。プリンターが提供するフォントをGNU Intlfontsパッケージのフォントで増強したり、EmacsにIntlfontsフォントだけを使うように命令できます。変数`ps-multibyte-buffer`がこれを制御します。デフォルト値の`nil`は、ASCIIおよびLatin-1文字を印刷するのに適しています。`non-latin-printer`は、プリンターにASCII、Latin-1、Japanese、Korean文字にたいするフォントが組み込まれている場合の値です。*すべて*の文字にたいして使用される、IntlfontsパッケージのBDFフォントのための値が`bdf-font`です。最後に値`bdf-font-except-latin`は、ASCIIおよびLatin-1文字にたいしては組み込みフォントを使用し、それ以外の文字にたいしてはIntlfontsのBDFフォントを使用するよう指示します。

bdf-directory-list
BDFフォントを使えるようにするには、それをどこで見つけることができるかを、Emacsが知る必要があります。変数`bdf-directory-list`は、Emacsがこれらのフォントを探すべきディレクトリーのリストを保持します。デフォルト値には、1つのディレクトリー`/usr/local/share/emacs/fonts/bdf`が含まれます。

これらのコマンドに対する、その他多くのカスタマイズ変数は、Lispファイル`ps-print.el`および`ps-mule.el`で定義・説明されています。

印刷のためのパッケージ
----------------------

Printing package
ハードコピーを印刷するためのEmacsの基本的な機能は、Printingパッケージを使って拡張できます。これは何を印刷するかの選択、印刷前のPostScriptファイルのプレビュー、プリントヘッダーなどのさまざまな印刷オプションの設定、横向きモードや縦向きモード、duplexモードにたいする使いやすいインターフェースを提供します。GNU/LinuxシステムまたはUnixシステムでは、Printingパッケージは、GhostScriptプログラムの一部として配布される、`gs`および`gv`ユーティリティーに依存しています。MS-Windowsでは、Ghostscriptのポート版の`gstools`が使用されます。

pr-interface
Printingパッケージを使用するには、initファイル([Init File](#Init-File)を参照してください)に`(require
'printing)`を追加して、その後に`(pr-update-menus)`と記述します。この関数はメニューバーの通常の印刷コマンドを、さまざまな印刷オプションを含む‘`Printing`’サブメニューに置き換えます。`M-x
pr-interface RET`とタイプすることもできます。これはカスタマイズバッファーに似た`*Printing
Interface*`バッファーを作成し、そこで印刷オプションをセットできます。何をどのようにして印刷するかセットした後、‘`Print`’ボタン(それを`mouse-2`でクリックするか、その上にポイントを移動してRETをタイプします)で印刷ジョブを開始します。さまざまなオプションについての詳細は、‘`Interface
Help`’ボタンを使用してください。

テキストのソート
================

sorting
Emacsは、バッファーのテキストをソートするためのコマンドをいくつか提供しています。これらはすべて、リージョンの内容にたいして処理を行ないます。これらのコマンドはリージョンのテキストを、多数のソートレコード(sort records)に分割し、各レコードをソートキー(sort key)で識別した後、ソートキーにより決定される順序にレコードを並び替えます。レコードは並び替えられ、レコードのキーはアルファベット順、または数値ソートでは数値順になります。アルファベット順のソートでは、ASCII文字順にしたがい、‘`A`’から‘`Z`’のすべての大文字は、小文字の‘`a`’の前になります。(しかし、以下で説明する`sort-fold-case`はこれを変更する)。

種々のソートコマンドは、テキストをどのようにソートレコードに分割するか、そして各レコードのどの部分がソートキーとして使用されるかという点で異なります。ほとんどのコマンドは行ごとにソートレコードを分割しますが、ソートレコードとしてパラグラフやページを使うコマンドもあります。ほとんどのソートコマンドは、ソートレコード全体をソートキーとして使用しますが、レコードの一部をソートキーとして使用するものもあります。

sort-lines
sort-paragraphs
sort-pages
sort-fields
sort-numeric-fields
sort-numeric-base
`M-x sort-lines`  
リージョンを行に分割して、行のテキスト全体を比較してソートします。数引数は降順でソートすることを意味します。

`M-x sort-paragraphs`  
リージョンをパラグラフに分割して、パラグラフのテキスト全体(先頭の空行は除く)を比較してソートします。数引数は降順にソートすることを意味します。

`M-x sort-pages`  
リージョンをページに分割して、ページのテキスト全体(先頭の空行は除く)を比較してソートします。数引数は降順にソートすることを意味します。

`M-x sort-fields`  
リージョンを行に分割して、各行のあるフィールドの内容を比較することによりソートします。フィールドは空白で区切ることにより定義されるので、ある行の最初の連続する非空白文字がフィールド1を構成し、2番目のそのような文字構成がフィールド2、...となります。

どのフィールドでソートするかは数引数で指定します。1はフィールド1、2はフィールド2、...となります。デフォルトは1です。負の引数はフィールドを左からではなく右から数えることを意味します。したがって、-1は最後のフィールドでソートするという意味です。ソートされるフィールドの内容が同じ行が複数存在する場合、バッファーの元の並び順が維持されます。

`M-x sort-numeric-fields`  
`M-x
sort-fields`と同様ですが、各行の指定されたフィールドを整数に変換して、その数字を比較します。テキストとして比較したとき‘`10`’は‘`2`’の前になりますが、数字として比較すると‘`2`’の後になります。デフォルトでは、数字は`sort-numeric-base`により解釈されますが、‘`0x`’または‘`0`’で始まる数字は16進および8進で解釈されます。

`M-x sort-columns`  
`M-x
sort-fields`と同様ですが、各行で比較に使用されるテキストは固定長の列範囲です。プレフィクス引数を指定した場合は、逆順でソートします。このコマンドの詳細は以下を参照してください。

reverse-region

`M-x reverse-region`  
リージョンの行を逆順にソートします。フィールドでソートするコマンドは降順でソートする機能がないので、フィールドまたは列で降順にソートできるのは便利です。

たとえば、以下のようなバッファー内容のとき:

    On systems where clash detection (locking of files being edited) is
    implemented, Emacs also checks the first time you modify a buffer
    whether the file has changed on disk since it was last visited or
    saved.  If it has, you are asked to confirm that you want to change
    the buffer.

バッファー全体に`M-x sort-lines`を適用すると以下のようになります:

    On systems where clash detection (locking of files being edited) is
    implemented, Emacs also checks the first time you modify a buffer
    saved.  If it has, you are asked to confirm that you want to change
    the buffer.
    whether the file has changed on disk since it was last visited or

大文字の‘`O`’はすべての小文字の前にソートされます。かわりに`C-u 2 M-x
sort-fields`を使用すると、以下が得られます:

    implemented, Emacs also checks the first time you modify a buffer
    saved.  If it has, you are asked to confirm that you want to change
    the buffer.
    On systems where clash detection (locking of files being edited) is
    whether the file has changed on disk since it was last visited or

ここで、ソートキーは‘`Emacs`’、‘`If`’、‘`buffer`’、‘`systems`’、‘`the`’です。

sort-columns
`M-x
sort-columns`は説明が必要でしょう。ある列にポイントを配し、別の列をマークして、ソート列を指定します。ソートしたいテキストの最初の行の先頭にポイントまたはマークを配すことはできないので、このコマンドは特殊な“リージョン”の定義を使用します。ポイントがある行はすべてリージョンの一部と判断されます。マークがある行もすべてリージョンの一部と判断されます。同様にその間にあるすべての行もリージョンの一部となります。

たとえば、10列目から15列目までの情報でテーブルをソートするには、テーブルの最初の行の10列目にマークを置き、最後の行の15列目にポイントを置いて、`sort-columns`を実行します。最初の行の15列目にマークを置き、最後の行の10列目にポイントを置いても、同じように実行できます。

これはポイントとマークで指定された矩形領域をソートすると考えることができます。1つ違うのは、各行の矩形領域の左右にあるテキストも、矩形領域内のテキストとともに移動するという点です。[Rectangles](#Rectangles)を参照してください。

sort-fold-case
`sort-fold-case`が非`nil`の場合、多くのソートコマンドは比較時の大文字小文字の違いを無視します。

ピクチャーの編集
================

pictures
making pictures out of text characters
picture-mode
テキスト文字で作られたピクチャー(たとえばプログラムのコメントにあるような、レジスターをフィールドに分割したピクチャーなど)を編集するには、コマンド`M-x
picture-mode`を使用してPictureモードに入ります。

Pictureモードでは、編集はテキストのquarter-plane(1/4平面)モデルにもとづき、テキスト文字は、右方および下方に無限に広がる領域に点在します。このモデルには、行の終端という概念は存在しません。せいぜい言えるのは、その行の空白でない最後の文字がどこにあるかぐらいです。

もちろん、実際にはEmacsはテキストを文字シーケンスとして考え、行は終端をもちます。しかしPictureモードは、もっともよく使われるコマンドを、テキストのquarter-planeモデルをシミュレートする変種に置き換えます。これらのコマンドはスペースの挿入、またはタブをスペースに置き換えることにより、これを行ないます。

Emacsのほとんどの基本的な編集コマンドは、本質的には同等なことをquarter-planeの方法で行なうように、Pictureモードにより再定義されます。それに加えてPictureモードは、`C-c`プレフィクスで始まる、特別なピクチャー編集コマンドを実行する、さまざまなキーを定義します。

これらのキーのうち特に重要なのは`C-c
C-c`です。ピクチャーが、通常は他のメジャーモードで編集する、大きなファイルの一部ということもあります。Pictureモードは以前のメジャーモードを記録するので、後で`C-c
C-c` (`picture-mode-exit`)コマンドでそのモードに戻ることができます。`C-c
C-c`は数引数を与えなければ、行末のスペースの削除も行ないます。

Pictureモードの特別なコマンドのすべては、(`picture`ライブラリーがロードされていれば)他のモードでも機能しますが、Pictureモード以外ではキーにバインドされません。以下の説明では、“1列”移動...のような言い方をしますが、通常の同等なコマンドと同じように、Pictureモードのコマンドは数引数を扱うことができます。

picture-mode-hook
Pictureモードをオンにすることにより、フック`picture-mode-hook`が実行されます。Pictureモードにたいする追加の拡張は、`artist.el`で見ることができます。

Pictureモードでの基本的な編集
-----------------------------

picture-forward-column
picture-backward-column
picture-move-down
picture-move-up
editing in Picture mode
ほとんどのキーは、Pictureモードでも通常と同じことを、quarter-planeスタイルで行ないます。たとえば`C-f`は、`picture-forward-column`を実行するようにリバインドされます。これはポイントを1列右に移動します。必要ならスペースを挿入するので実際の行末は関係ありません。`C-b`は、`picture-backward-column`を実行するようにリバインドされます。必要ならタブを複数のスペースに変換して、常に1列ポイントを左に移動します。`C-n`と`C-p`は、`picture-move-down`と`picture-move-up`を実行するようにリバインドされ、どちらもポイントが同じ列に留まるように、必要に応じてスペースの挿入とタブの変換を行ないます。`C-e`は、`picture-end-of-line`を実行します。これは、その行の最後の非空白文字の後に移動します。`C-a`は、`picture-beginning-of-line`を実行します(スクリーンモデルの選択は行の開始に影響を与えません。このコマンドが行なう追加事項は、カレントピクチャー列を0に更新することです)。

picture-newline
テキストの挿入は、Overwriteモードを通じてquarter-planeモデルに適合されます ([Minor Modes](#Minor-Modes)を参照してください)。 自己挿入文字は既存のテキストを右にずらすのではなく、列ごとに既存のテキストを置き換えます。RETは`picture-newline`を実行し、これは単に次の行の先頭に移動するので、新しいテキストでその行を置き換えることができます。

picture-backward-clear-column
picture-clear-column
picture-clear-line
Pictureモードでは、通常は削除やkillを行なうコマンドは、かわりにテキストを消去(スペースで置き換え)します。DEL (`picture-backward-clear-column`)は、前の文字を削除するのではなく、スペースで置き換えます。これはポイントを後方に移動します。`C-d` (`picture-clear-column`)は、次の文字をスペースで置き換えますが、ポイントは移動しません(文字をクリアーして前方に移動したいときはSPCを使用します)。`C-k` (`picture-clear-line`)は、実際に行の内容をkillしますが、バッファーから改行は削除しません。

picture-open-line
実際に挿入を行なうには、特別なコマンドを使わなければなりません。`C-o` (`picture-open-line`)は、カレント行の後に空行を作成します。行の分割はしません。Pictureモードでも`C-M-o` (`split-line`)は意味があるので、変更されていません。`C-j` (`picture-duplicate-line`)は、カレント行の下に同じ内容の行を挿入します。

C-c C-d (Picture mode)
Pictureモードで実際の削除を行なうには、`C-w`、`C-c
C-d`(これは他のモードでは`C-d`にバインドされている`delete-char`にバインドされています)、またはピクチャー矩形コマンドの1つを使用します([Rectangles in Picture](#Rectangles-in-Picture)を参照してください)。

挿入後の移動の制御
------------------

picture-movement-up
picture-movement-down
picture-movement-left
picture-movement-right
picture-movement-nw
picture-movement-ne
picture-movement-sw
picture-movement-se
C-c &lt; (Picture mode)
C-c LEFT (Picture mode)
C-c &gt; (Picture mode)
C-c RIGHT (Picture mode)
C-c ^ (Picture mode)
C-c UP (Picture mode)
C-c . (Picture mode)
C-c DOWN (Picture mode)
C-c ‘ (Picture mode)
C-c Home (Picture mode)
C-c ’ (Picture mode)
C-c PageUp (Picture mode)
C-c prior (Picture mode)
C-c / (Picture mode)
C-c End (Picture mode)
C-c \\ (Picture mode)
C-c PageDown (Picture mode)
C-c next (Picture mode)
Pictureモードでは、自己挿入文字(self-inserting characters)は上書きとポイント移動を行なうので、ポイントを移動する方法に、本質的に制限はありません。ポイントは通常右に移動しますが、自己挿入文字の後に移動する方向は、直行方向と対角方向の8つのうちから任意の方向を指定できます。これはバッファーに線を描くとき便利です。

`C-c <`; `C-c LEFT`  
挿入の後、左に移動します(`picture-movement-left`)。

`C-c >`; `C-c RIGHT`  
挿入の後、右に移動します(`picture-movement-right`)。

`C-c ^`; `C-c UP`  
挿入の後、上に移動します(`picture-movement-up`)。

`C-c .`; `C-c DOWN`  
挿入の後、下に移動します(`picture-movement-down`)。

`` C-c ` ``; `C-c Home`  
挿入の後、左上(“北西”)に移動します(`picture-movement-nw`)。

`C-c '`; `C-c PageUp`; `C-c prior`  
挿入の後、右上(“北東”)に移動します(`picture-movement-ne`)。

`C-c /`; `C-c End`  
挿入の後、左下(“南西”)に移動します(`picture-movement-sw`)。

`C-c \`; `C-c PageDown`; `C-c next`  
挿入の後、右下(“南東”)に移動します(`picture-movement-se`)。

C-c C-f (Picture mode)
C-c C-b (Picture mode)
picture-motion
picture-motion-reverse
カレントPicture挿入方向にもとづき移動を行なうコマンドは2つです。1つはコマンド`C-c C-f` (`picture-motion`)で、その時点で挿入後に移動すると定められた方向と同じ方向に移動するのが`C-c C-f` (`picture-motion`)で、逆方向へは`C-c C-b` (`picture-motion-reverse`)です。

Pictureモードでのタブ
---------------------

M-TAB (Picture mode)
picture-tab-search
picture-tab-chars
Pictureモードでは、タブのような動作が2つ提供されます。コンテキストベースのタブ動作には、`M-TAB` (`picture-tab-search`)を使用します。引数を与えないと、前の空でない行で、空白の後の次の“意味をもつ”文字の下にポイントを移動します。ここで“次”とは、“開始した位置から水平方向に大な位置”という意味です。`C-u
M-TAB`のようにプレフィックス引数を指定した場合、このコマンドはカレント行で次の意味のある文字に移動します。`M-TAB`はテキストを変更せず、ポイントだけを移動します。“意味のある”文字は変数`picture-tab-chars`により定義され、これは一連の文字で定義されます。この変数の構文は正規表現での‘`[…]`’の内側で使用される構文と似ていますが、‘`[`’と‘`]`’はありません。デフォルト値は`"!-~"`です。

picture-tab
TABは`picture-tab`を実行し、これはカレントのタブストップの設定にもとづき動作します。Pictureモードでは`tab-to-tab-stop`と等価です。通常はポイントを移動するだけですが、数引数を指定した場合は、移動先までのテキストをクリアーします。

C-c TAB (Picture mode)
picture-set-tab-stops
コンテキストベースとタブストップベースのタブ動作形式は、`C-c TAB` (`picture-set-tab-stops`)で合わせることができます。このコマンドは、カレント行にたいして、`M-TAB`が意味をもつと判断するであろう位置に、タブストップをセットします。このコマンドの使い方としては、TABと合わせて、コンテキストベースの効果を得ることができます。しかし`M-TAB`で充分な場合は、そちらのほうが便利です。

ピクチャー内では、実際のタブ文字を抑止するほうが便利かもしれません。たとえば、これにより`C-x
TAB`がピクチャーをめちゃくちゃにするのを防ぐことができます。変数`indent-tabs-mode`を`nil`にセットすることにより、これを行なうことができます。

Pictureモードの矩形領域コマンド
-------------------------------

rectangles and Picture mode
Picture mode and rectangles
Pictureモードは、quarter-planeモデルに適合する方法で、テキストの矩形部分に作用するコマンドを定義します。標準の矩形領域コマンドも便利でしょう [Rectangles](#Rectangles)を参照してください。

`C-c C-k`  
矩形領域をスペースでクリアーします(`picture-clear-rectangle`)。プレフィクス引数を指定した場合、テキストを削除します。

`C-c C-w r`  
同様ですが、最初にレジスターrに矩形領域の内容を保存します(`picture-clear-rectangle-to-register`)。 [Registers](#Registers)を参照してください。

`C-c C-y`  
ポイント位置を左上隅として、最後にkillされた矩形領域をバッファーに上書きコピーします。引数を指定した場合は、上書きではなく挿入します。

`C-c C-x r`  
同様ですが、レジスターrの矩形領域を使用します(`picture-yank-rectangle-from-register`)。

C-c C-k (Picture mode)
C-c C-w (Picture mode)
picture-clear-rectangle
picture-clear-rectangle-to-register
ピクチャー矩形領域コマンドの`C-c C-k` (`picture-clear-rectangle`)と`C-c C-w` (`picture-clear-rectangle-to-register`)が、標準の矩形領域コマンドと異なる点は、通常は矩形領域を削除するかわりにクリアーすることです。これはPictureモードで`C-d`が変更された方法と類似しています。

しかしPictureモードで矩形領域を削除するのが便利なときもあるかもしれないので、これらのコマンドは数引数を与えたときは矩形領域を削除します。数引数の指定の有無に関わらず、`C-c
C-k`は`C-c C-y`のために矩形領域を保存します。

C-c C-y (Picture mode)
C-c C-x (Picture mode)
picture-yank-rectangle
picture-yank-rectangle-from-register
矩形領域をyankするPictureモードのコマンドは、挿入ではなく上書きするという点で、標準の矩形領域コマンドと異なります。これはPictureモードでのテキストの挿入方法が他のモードと異なるのと同じです。`C-c
C-y` (`picture-yank-rectangle`)は、一番最近killされた矩形領域を(上書きにより)挿入し、`C-c
C-x` (`picture-yank-rectangle-from-register`)は、指定されたレジスターの矩形領域で同様のことを行ないます。

バイナリーファイルの編集
========================

Hexl mode
mode, Hexl
editing binary files
hex editing
バイナリーファイルを編集する特別なメジャーモードに、Hexlモードがあります。これを使用するには、ファイルをvisitするのに。`C-x
C-f`のかわりに`M-x
hexl-find-file`を使用します。このコマンドはファイル内容を16進に変換して、その変換結果を編集できるようにします。ファイルを保存するときは、自動的にバイナリーに変換されます。

既存のバッファーをhexに変換するために、`M-x
hexl-mode`を使用することもできます。これは普通にファイルをvisitしてから、それがバイナリーファイルだと気づいた場合などに便利です。

Hexlモードでは通常のテキスト文字は上書きです。これはファイル内のデータのアラインメントを意図せず壊してしまう危険を減らすためです。挿入のためには特別なコマンドがあります。以下はHexlモードのコマンドのリストです:

`C-M-d`  
10進でタイプされたバイトコードを挿入します。

`C-M-o`  
8進でタイプされたバイトコードを挿入します。

`C-M-x`  
16進でタイプされたバイトコードを挿入します。

`C-x [`  
1Kバイトページの先頭に移動します。

`C-x ]`  
1Kバイトページの最後に移動します。

`M-g`  
16進で指定されたアドレスに移動します。

`M-j`  
10進で指定されたアドレスに移動します。

`C-c C-c`  
Hexlモードを抜けて、`hexl-mode`モードを呼び出す前の、このバッファーのメジャーモードに戻ります。

他のHexlコマンドには、バイナリーバイトの文字列(シーケンス)の挿入、`short`、`int`単位での移動などがあります。詳細については、`C-h
a hexl-RET`とタイプしてください。

Emacsセッションの保存
=====================

saving sessions
restore session
remember editing session
reload files
desktop
desktop-restore-frames
Emacsの状態を1つのセッションから別のセッションのために保存するためには、desktopライブラリーを使用します。1度Emacsのデスクトップ(desktop) — バッファーと、それらのファイル名、メジャーモード、バッファーでの位置など — を保存すると、後のEmacsセッションで、保存されたデスクトップをリロードできます。デフォルトでは、デスクトップはフレームとウィンドウ設定も保存しようと試みます。これを無効にするには、`desktop-restore-frames`を`nil`にセットします(この振る舞いを調整するためにマスタマイズできる関連オプションについては、変数のドキュメントを参照してください)。

desktop-files-not-to-save
デフォルトでは、リモートファイルをvisitしているバッファーに関する情報は保存されません。変数`desktop-files-not-to-save`をカスタマイズして、これを変更することができます。

frameset-filter-alist
desktopがフレームとウィンドウの設定えおリストアするときは、フレームパラメーターの記録された値を使用し、initファイル([Init File](#Init-File)を参照)でそれらのパラメーターに何をセットしていても無視されます。これは、リストアされたフレームにたいするフォントやフェイスのようなフレームパラメーターは、前のEmacsセッションを終了したときに保存されたdesktopファイルから取得され、initファイルでのそれらのパラメーターにたいするセッティングは無視されることを意味します。これを無効にするには、リストアしたくないフレームパラメーターを除外するように、`frameset-filter-alist`の値をカスタマイズしてください。

desktop-save
desktop-save-mode
コマンド`M-x
desktop-save`で、デスクトップを手動で保存できます。Emacs終了時のデスクトップの自動保存を有効にすることもできます。またEmacs開始時に最後に保存されたデスクトップを自動的に復元することもできます。将来のセッションのためには、Customizationバッファー([Easy Customization](#Easy-Customization)を参照してください)を使用して、`desktop-save-mode`を`t`にセットするか、initファイル([Init File](#Init-File)を参照してください)に以下の行を追加します:

    (desktop-save-mode 1)

desktop-change-dir
desktop-revert
desktop-path
initファイルで`desktop-save-mode`をオンにした場合、Emacsはカレントディレクトリーで保存されたデスクトップを探します(より正確には、`desktop-path`で指定されたディレクトリーを探して、最初に見つかったデスクトップを使用します)。したがって異なるディレクトリーに別のデスクトップを保存でき、開始ディレクトリーによりEmacsがリロードするデスクトップを決定できます。`M-x
desktop-change-dir`とタイプすることにより、カレントデスクトップを保存して、他のディレクトリーに保存されたデスクトップをリロードできます。`M-x
desktop-revert`とタイプすることにより、前にリロードされたデスクトップをリバートできます。

保存されたデスクトップをリロードしたくないときは、コマンドラインでオプション‘`--no-desktop`’を指定します。これはカレントセッションにたいして、`desktop-save-mode`をオフにします。‘`--no-init-file`’オプションを指定してEmacsを開始することにより、通常`desktop-save-mode`をオンにしているinitファイルをバイパスして、デスクトップのリロードを無効にすることもできます。

desktop-restore-eager
デフォルトでは、デスクトップのすべてのバッファーは1度に復元されます。しかし、デスクトップにたくさんのバッファーがあるときは遅くなるかもしれません。変数`desktop-restore-eager`で、即座に復元するバッファーの最大数を指定できます。残りのバッファーはEmacsのアイドル時に、ゆっくり(lazily)と復元されます。

desktop-clear
desktop-globals-to-clear
desktop-clear-preserve-buffers-regexp
Emacsのデスクトップを空にするには、`M-x
desktop-clear`とタイプします。これは内部バッファーを除いてすべてのバッファーをkillし、`desktop-globals-to-clear`にリストされたグローバル変数をクリアーします。特定のバッファーを残したい場合は、変数`desktop-clear-preserve-buffers-regexp`をカスタマイズします。この変数の値には、killしないバッファーの名前にマッチする正規表現を指定します。

あるセッションから別のセッションへ、ミニバッファーのヒストリーを保存したい場合は、`savehist`ライブラリーを使用してください。

desktop-auto-save-timeout
`desktop-save-mode`がオンの状態でEmacsが実行されているとき、デフォルトでは何らかの変更があった際は、常にデスクトップを自動保存します。変数`desktop-auto-save-timeout`は、デスクトップ変更をEmacsがチェックする頻度を決定します。

desktop-load-locked-desktop
Emacsがデスクトップを保存するファイルは、他のEmacsセッションによる不意の上書きを防ぐために、そのセッションの実行中はロックされます。このロックは、通常はEmacsのexit時に解除されますが、Emacsまたはシステムがクラッシュした場合、そのロックは残り、Emacsを再スタートする際に、デフォルトではロックされたデスクトップファイルのどちらを使用するか尋ねます。この質問は、変数`desktop-load-locked-desktop`を`nil`(その場合はデスクトップをロードしない)、または`t`(確認なしでデスクトップをロードする)のいずれかにカスタマイズすることにより、抑止することができます。

desktop restore in daemon mode
Emacsがデーモンモードで起動する際はユーザーに質問することができないので、ロックされたデスクトップが見つかった場合は、`desktop-load-locked-desktop`が`t`以外であれば、それをロードしません。デーモンモードでのデスクトップのリストアは、その他の理由により問題になりがちなことに注意してください。たとえば、デーモンはGUI機能を使用できないので、フレーム位置やサイズ、装飾のようなパラメーターはリストアできません。この理由により、デスクトップのリストアを、`after-make-frame-functions`にフック関数`desktop-read`を追加して、それが呼び出されることにより、最初のクライアントが接続するまで、遅延させたいと思うかもしれません(section “Creating Frames” in The Emacs Lisp Reference Manualを参照)。

再帰編集レベル
==============

recursive editing level
editing level, recursive
再帰編集(recursive edit)とは、あるEmacsコマンドの途中で、別のEmacsコマンドを使用して自由に編集を行なうような状況を指します。たとえば`query-replace`の途中で`C-r`をタイプすると、カレントバッファーを変更することができる再帰編集に入ります。再帰編集から抜けると、`query-replace`に戻ります。[Query Replace](#Query-Replace)を参照してください。

C-M-c
exit-recursive-edit
exiting recursive edit
再帰編集を抜ける(exit)とは、実行を継続中の、終了していないコマンドに戻ることを意味します。再帰編集を抜けるコマンドは`C-M-c` (`exit-recursive-edit`)です。

再帰編集を中断(abort)することもできます。これはexitと似ていますが、終了していないコマンドも即座に終了します。これを行なうには、コマンド`C-]` (`abort-recursive-edit`)を使用します。[Quitting](#Quitting)を参照してください

モードラインで常にメジャーモードとマイナーモードの周りを囲む丸カッコ(parentheses)を、さらに角カッコ(square brackets)で囲んで表示することにより、再帰編集中であることが示されます。再帰編集は特定のウィンドウやバッファーにたいするものではなく、Emacs全体が再帰編集中であるため、すべてのウィンドウのモードラインは同じように表示されます。

再帰編集中に、さらに再帰編集に入ることも可能です。たとえば`query-replace`の途中で`C-r`とタイプした後、デバッガーに入るコマンドをタイプしたとします。これは`C-r`にたいする再帰編集レベルから、デバッガーにたいする再帰編集を開始します。モードラインには、現在進行中の再帰編集レベルが角カッコのペアで表示されます。

(デバッガーでの`c`コマンドのように)内側の再帰編集を抜けると、次に上のレベルのコマンドの実行が再開されます。コマンドが終了したら、他の再帰編集レベルに抜けるために`C-M-c`を使用することができます。exitは最内レベルだけに適用されます。abortも1レベルの再帰編集だけを抜けて、前の再帰編集レベルのコマンドに即座に戻ります。もし望むなら次の再帰編集レベルもabortできます。

かわりにコマンド`M-x
top-level`は、すべてのレベルの再帰編集をabortして、即座にトップレベルのコマンドリーダーに戻ります。ミニバッファーがアクティブなときは、ミニバッファーも抜けます。

再帰編集の中で編集されるテキストは、トップレベルで編集しているテキストと同じである必要はありません。これは、何にたいしての再帰編集かに依存します。再帰編集を呼び出したコマンドが最初に別のバッファーを選択する場合、そのバッファーが再帰編集を行なうバッファーになります。どんな場合でも再帰編集中に、(バッファーを切り替えるキーがリバインドされていないかぎり)通常の方法でバッファーを切り替えることができます。再帰編集の中で、ファイルをvisitしたりその他のことを行ない、残りのすべての編集を行なうことも、おそらく可能です。しかしこれは、(スタックオーバーフローのような)驚くべき効果をもたらすことがあります。そのため必要なくなったときは、再帰編集をexitまたはabortすることを忘れないでください。

一般的に、わたしたちはGNU Emacsでは再帰編集レベルを最小限にしようと努めています。これは、特定の順 — 最内のレベルからトップレベルに向かって — で戻ることをあなたに強いるからです。可能な場合は、異なる作業には別のバッファーを供し、それらを切り替えられるようにします。いくつかのコマンドは、元のメジャーモードに戻るコマンドを提供する、新しいメジャーモードに切り替えます。これらの試みは、あなたの選択にしたがい、まだ終了していないタスクにもどる、柔軟性を与えます。

ハイパーリンクとWebナビゲーション機能
=====================================

以下のサブセクションでは、URLや、Emacsバッファーのテキスト内にある他の種類のリンクを扱う便利な機能を説明します。

EWWによるウェブブラウズ
-----------------------

eww
eww-open-file
EWW(Emacs Web Wowser)は、Emacs用のウェブブラウザーのパッケージです。これはEmacsバッファーでURLブラウズすることを可能にします。コマンド`M-x
eww`により、URLを開いたり、ウェブを検索します。コマンド`M-x
eww-open-file`を使用して、ファイルを開くことができます。`browse-url`にたいするウェブブラウザーとして。EWWを使うことができます([Browse-URL](#Browse_002dURL)を参照してください)。完全な詳細に付いては、section “EWW” in The Emacs Web Wowser Manualを参照してください。

埋め込みWebKitウィジェット
--------------------------

xwidget
webkit widgets
embedded widgets
xwidget-webkit-browse-url
xwidget-webkit-mode
Xwidget-WebKit mode
Emacsが適切なサポートパッケージとともにコンパイルされている場合、Emacsのバッファーにブラウザーウィジェット(browser widgets)を表示できます。コマンド`M-x
xwidget-webkit-browse-url`は、ブラウザーウィジェットに表示するURLを尋ねます。通常はポイント位置、またはポイント位置の前にあるURLがデフォルトのURLになります。しかしアクティブなリージョン([Mark](#Mark)を参照してください)がある場合は、余分な空白文字を削除してから、そのリージョンからデフォルトのURLを取得します。コマンドはその後、指定されたURLを表示するめ込みブラウザー(embedded browser)をもつ、新しいバッファーを作成します。このパッファーはXwidget-WebKitモード(Imageモードと似ています。[File Conveniences](#File-Conveniences)を参照してください)で、ウィジェットのスクロール、サイズ変更、リロードを1-keyで行なうコマンドを提供します。キーバインドを確認するには、そのバッファーで`C-h
b`とタイプしてください。

URLのフォロー
-------------

World Wide Web
Web
browse-url
browse-url-at-point
browse-url-at-mouse
Browse-URL
URLs
`M-x browse-url RET url RET`  
ウェブブラウザーへのURLのロード。

Browse-URLパッケージは、Emacsで簡単にURLをフォロー(辿る)することを可能にします。ほとんどのURLは、ウェブブラウザーを呼び出すことによりフォローされます。‘`mailto:`’のURLは、指定されたアドレスにメールを送るために、Emacsコマンドの`compose-mail`でフォローされます。

コマンド`M-x
browse-url`は、URLの入力を求め、それをフォローします。ポイントがURLのようなテキストの近くにある場合、そのURLがデフォルトとして提示されます。Browse-URLパッケージは、`browse-url-at-point`や`browse-url-at-mouse`のような、キーにバインドしたいと思うような、他のコマンドも提供します。

browse-url-mailto-function
browse-url-browser-function
Customizeグループ`browse-url`の、さまざまなオプションを通じて、Browse-URLの振る舞いをカスタマイズできます。特に、オプション`browse-url-mailto-function`では‘`mailto:`’のURL、`browse-url-browser-function`ではそれ以外のタイプのURLにたいして、どのような方法でフォローするか定義することができます。詳細は、`C-h
P browse-url RET`とタイプすることにより表示される、パッケージのコメントを参照してください。

URLのアクティブ化
-----------------

goto-address-mode
mode, Goto Address
Goto Address mode
URLs, activating
`M-x goto-address-mode`  
カレントバッファーのURLとメールアドレスをアクティブにします。

C-c RET (Goto Address mode)
goto-address-at-point
`M-x
goto-address-mode`とタイプすることにより、EmacsにカレントバッファーのURLを特別にマークさせることができます。このバッファーローカルなマイナーモードが有効な場合、バッファーのすべてのURLを探して、それらをハイライトするとともに、クリックできるボタンに変更します。そのようなテキストの上にポイントを移動して`C-c
RET` (`goto-address-at-point`)とタイプするか、`mouse-2`をクリック、または`mouse-1`を素早くクリックすることにより([Mouse References](#Mouse-References)を参照してください)、そのURLをフォローできます。URLのフォローは、`browse-url`をサブルーチンとして呼び出すことにより行なわれます([Browse-URL](#Browse_002dURL)を参照してください)。

モードフックや受信メッセージを表示するフック(たとえばRmailの`rmail-show-message-hook`や、MH-Eの`mh-show-mode-hook`)に`goto-address-mode`を追加するのは便利かもしれません。Gnusには類似の機能があるので必要ありません。

ポイント位置のファイルやURLを開く
---------------------------------

find-file-at-point
ffap
dired-at-point
ffap-next
ffap-menu
finding file at point
FFAPパッケージは、`C-x
C-f`のようなファイルを探すためのキーにバインドされているコマンドを、より直感的なデフォルトを提供するコマンドに置き換えます。これらのコマンドにプレフィクス引数を与えたときは、通常のコマンドと同様に振る舞います。それ以外の場合、ポイント周辺のテキストからデフォルトのファイル名を取得します。バッファーから見つかったのがファイル名ではなくURLの場合、このコマンドはそれを閲覧するために`browse-url`を使用します([Browse-URL](#Browse_002dURL)を参照してください)。

この機能は、メールバッファーやニュースバッファー内の参照、`README`ファイル、`MANIFEST`ファイルなどをフォローするのに便利です。詳細については、`C-h
P ffap RET`とタイプして、パッケージのコメントを参照してください。

FFAP minor mode
ffap-mode
FFAPを有効にするには、`M-x
ffap-bindings`とタイプします。これにより、以下のキーバインドが作成され、Rmail、Gnus、VMアーティクルバッファーでの、追加FFAP機能にたいするフックもインストールされます。

`C-x C-f filename RET`  
C-x C-f (FFAP)

filenameを検索します(`find-file-at-point`)。デフォルトのファイル名は、ポイント周辺のテキストから推測します。

`C-x C-r filename RET`  
C-x C-r (FFAP)

`ffap-read-only`。`find-file-read-only`に相当します。

`C-x C-v filename RET`  
C-x C-v (FFAP)

`ffap-alternate-file`。`find-alternate-file`に相当します。

`C-x d directory RET`  
C-x d (FFAP)

ポイント位置のディレクトリーをデフォルトとして、directoryでDiredを開始します(`dired-at-point`)。

`C-x C-d directory RET`  
`ffap-list-directory`。`list-directory`に相当します。

`C-x 4 f filename RET`  
C-x 4 f (FFAP)

`ffap-other-window`。`find-file-other-window`に相当します。

`C-x 4 r filename RET`  
`ffap-read-only-other-window`。`find-file-read-only-other-window`に相当します。

`C-x 4 d directory RET`  
`ffap-dired-other-window`。`dired-other-window`と同様です。

`C-x 5 f filename RET`  
C-x 5 f (FFAP)

`ffap-other-frame`。`find-file-other-frame`に相当します。

`C-x 5 r filename RET`  
`ffap-read-only-other-frame`。`find-file-read-only-other-frame`に相当します。

`C-x 5 d directory RET`  
`ffap-dired-other-frame`。`dired-other-frame`に相当します。

`M-x ffap-next`  
バッファーから次のファイル名またはURLを検索して、そのファイルまたはURLを開きます。

`S-mouse-3`  
S-mouse-3 (FFAP)

`ffap-at-mouse`は、マウスがクリックされた周辺のテキストから推測されたファイルを開きます。

`C-S-mouse-3`  
C-S-mouse-3 (FFAP)

カレントバッファーに記述されたファイルとURLのメニューを表示して、選択されたものを開きます(`ffap-menu`)。

ゲーム、その他の娯楽
====================

boredom
games
animate-birthday-present
animate
`animate`パッケージは、テキストをダンスさせます(たとえば`M-x animate-birthday-present`)。

blackbox
mpuz
5x5
puzzles
`M-x blackbox`、`M-x mpuz`、`M-x
5x5`はパズルです。`blackbox`はボックス内のボールの位置を、トモグラフィー(断層撮影)により当てるパズルです。`mpuz`は掛け算パズルを表示します。掛け算の中の英字が何の数字かを当てなければなりません。数字を入力するには、英字をタイプしてから、その数字をタイプします。`5x5`の目標は、すべてのマスを埋めることです。

bubbles
bubbles
`M-x bubbles`は、より少ない回数の移動で、多くのbubble(シャボン玉)を取り除くゲームです。

decipher
ciphers
cryptanalysis
`M-x decipher`は、単純なアルファベット置換で暗号化されたバッファーを解読するのに役立ちます。

dissociated-press
`M-x
dissociated-press`は、Emacsのカレントバッファーのテキストをスクランブルします。スクランブルは単語単位または文字単位で行なわれ、`*Dissociation*`という名前のバッファーに出力されます。正の引数は文字単位での操作を指定し、数にはオーバーラップする文字数を指定します。負の引数は単語単位での操作を指定し、数にはオーバーラップする単語数を指定します。Dissociated Pressはマルコフ連鎖と酷似した結果を生成しますが、それとは独自のigオリジナルな創案です。手法としては、単語または文字の後ろにランダムにジャンプするマルコフ連鎖とは異なり、ランダムなジャンプの間にあるサンプルから、連続する複数の文字をコピーします。ユーザーに受け入れられ、正確でありたいなら、ドキュメントにはdissociwordsを使用しないでください。

dunnet
dunnet
`M-x dunnet`は、テキストベースのアドベンチャーゲームを開始します。

gomoku
Go Moku
個人的な満足感を得たいなら、`M-x gomoku`に挑戦してみてください。これはあなたと五目並べゲームを対戦します。

tower of Hanoi
hanoi
少し退屈していたら`M-x
hanoi`に挑戦してみてください。かなり退屈しているなら、数引数を指定します。とてもとても退屈なら、引数9に挑戦してみましょう。さあ、座って眺めましょう。

life
Life
`M-x life`は、ConwayのLife cellular automatonを実行します。

morse-region
unmorse-region
nato-region
Morse code
–/—/.-./.../.
`M-x morse-region`は、リージョンのテキストをモールス信号に変換し、`M-x
unmorse-region`で元に戻します。`M-x nato-region`は、リージョンのテキストをNATO発音記号(NATO phonetic alphabet)に変換し、`M-x denato-region`で元に戻します。

pong
Pong game
tetris
Tetris
snake
Snake
`M-x pong`、`M-x snake`、`M-x tetris`は、有名なPong、Snake、Tetrisの実装です。

solitaire
solitaire
`M-x solitaire`はソリティアーゲームをプレーします。これはピンを他のピンを超えてジャンプさせるゲームです。

zone
zone
`M-x zone`は、Emacsがアイドル時にプレーするゲームです。

butterfly
butterfly
円盤状記憶媒体のビットのフリップにbutterflies(蝶々)を使用する“真のプログラマー”は、`M-x
butterfly`をデプロイします。<https://xkcd.com/378>を参照してください。

doctor
Eliza
最後に、もし不満を感じているときは、有名な精神分析医のElizaに問題の説明を試みてください。これは`M-x
doctor`とタイプするだけです。各入力の最後には、RETを2回タイプしてください。

Emacs Lispパッケージ
====================

Package
Emacs Lisp package archive
Package archive
Emacsには、追加の機能を実装するパッケージ(packages)を、簡単にダウンロードしてインストールする機能が含まれています。それぞれのパッケージは個別のEmacs Lispプログラムで、Infoマニュアルのような他の構成要素が含まれているときもあります。

`M-x
list-packages`により、すべてのパッケージのリストを含む、`*Packages*`という名前のバッファーが表示されます。このバッファーを通じてパッケージをインストールしたりアンインストールできます。[Package Menu](#Package-Menu)を参照してください。

コマンド`C-h P` (`describe-package`)はパッケージ名の入力を求め、そのパッケージの属性や、実装する機能を説明するヘルプバッファーを表示します。

デフォルトでは、Emacsはemacs開発者により保守されGNUプロジェクトによりホスティングされる、パッケージアーカイブ(package archive)からパッケージをダウンロードします。オプションでサードパーティーにより保守されるアーカイブから、パッケージをダウンロードすることもできます。[Package Installation](#Package-Installation)を参照してください。

Emacs Lispのプログラムをインストール可能なパッケージに変更する情報に関しては、section “Packaging” in The Emacs Lisp Reference Manualを参照してください。

Package Menuバッファー
----------------------

package menu
built-in package
list-packages
コマンド`M-x list-packages`は、パッケージメニュー(package menu)を立ち上げます。これはEmacsが把握するすべてのパッケージをリストするバッファーです。リストの各行には以下の情報が表示されます:

-   パッケージ名(例: ‘`auctex`’)。

-   パッケージのバージョン番号(例: ‘`11.86`’)。

-   パッケージの状態(state)は通常、‘`available`’(パッケージアーカイブからダウンロード可能)、‘`installed`’、‘`built-in`’(デフォルトでEmacsに含まれる)のうちの1つです。‘`external`’(外部)という状態は、そのパッケージがビルトイン(組み込み)ではなく、`package-user-dir`([Package Files](#Package-Files)を参照してください)で指定されたディレクトリーのものでもないことを意味します。外部パッケージはビルトインのパッケージと同様に扱われます。これらのパッケージはパッケージメニューから削除できず、更新も考慮されません。

    ステータスが‘`new`’のこともあります。これは‘`available`’と同じですが、最後に`M-x
    list-packages`を呼び出した後に、そのパッケージがパッケージアーカイブで新たに利用可能になったことを意味します。他にもパッケージは‘`held`’、‘`disabled`’、‘`obsolete`’のステータスをもつかもしれません。[Package Installation](#Package-Installation)を参照してください。

-   パッケージの短い説明。

`list-packages`は、パッケージアーカイブサーバーから利用可能なパッケージのリストを取得するために、ネットワークにアクセスします。ネットワークが利用できない場合、一番最近取得したリストにフォールバックします。

パッケージメニューでは、以下のコマンドが利用可能です:

`h`  
パッケージメニューの使い方を要約した短いメッセージを表示します(`package-menu-quick-help`)。

`?`; `RET`  
カレント行のパッケージにたいして、`C-h
P`コマンド([Packages](#Packages)を参照してください)により表示されるヘルプウィンドウと同様の、ヘルプバッファーを表示します(`package-menu-describe-package`)。

`i`  
カレント行のパッケージをインストールのためにマークします(`package-menu-mark-install`)。パッケージのステータスが‘`available`’の場合、行の先頭に文字‘`I`’を追加します。`x`とタイプすると、パッケージをダウンロードしてインストールします(以下参照)。

`d`  
カレント行のパッケージを削除のためにマークします(`package-menu-mark-delete`)。パッケージのステータスが‘`installed`’の場合、行の先頭に文字‘`D`’を追加します。`x`とタイプすると、パッケージを削除します(以下参照)。パッケージ削除の結果、何が起こるかについての情報は、[Package Files](#Package-Files)を参照してください。

`~`  
削除のためにすべての時代遅れのパッケージobsolete packagesをマークします(`package-menu-mark-obsolete-for-deletion`)。これは状態が‘`obsolete`’の、すべてのパッケージを削除のためにマークします。

`u`; `DEL`  
`i`や`d`コマンドにより、でカレント行に追加された、以前のインストールまたは削除のマークを外します。

`U`  
新たに利用可能になったすべてのパッケージを、更新のためにマークします(`package-menu-mark-upgrades`)。これは新たに利用可能になったバージョンにインストールのマークをつけ、インストール済みの古いバージョンに削除のマークをつけます。

`x`  
package-menu-async

`i`でマークされたすべてのパッケージをダウンロードしてインストールするとともに、`d`でマークされたすべてのパッケージを削除します(`package-menu-execute`)。これによりマークは削除されます。

`r`  
パッケージリストを更新します(`package-menu-refresh`)。これは再度パッケージアーカイブから利用可能なパッケージのリストを取得して、パッケージリストを再計算します。

`f`  
パッケージリストをフィルターします(`package-menu-filter`)。これはキーワード(例: ‘`games`’)の入力を求め、そのキーワードに関連するパッケージだけを表示します。完全なパッケージリストを復元するには、`q`をタイプします。

`H`  
regexpにマッチするパッケージを永久に隠します(`package-menu-hide-package`)。

`(`  
古いバージョンのパッケージ、および優先度低のアーカイブから取得したバージョンの可視性を切り替えます(`package-menu-toggle-hiding`)。

たとえばパッケージをインストールするには、そのパッケージの行で`i`をタイプしてから、`x`をタイプします。

パッケージのインストール
------------------------

package-install
パッケージを一番便利にインストールするのはパッケージメニューを使う方法([Package Menu](#Package-Menu)を参照してください)ですが、コマンド`M-x
package-install`を使用することもできます。これはステータスが‘`available`’のパッケージ名の入力を求め、それをダウンロードしてインストールします。

package requirements
他のパッケージが提供する機能に依存するために、それらのパッケージがインストール済みであることを必要(require)とするパッケージもあるでしょう。Emacsがそのようなパッケージをインストールするときは、必要なパッケージがインストールされていなければ、それらのパッケージのダウンロードとインストールも自動に行ないます(必要なパッケージが何らかの理由で利用できない場合、Emacsはエラーをシグナルしてインストールを中止します)。パッケージの必要条件リスト(requirements list)は、そのパッケージのヘルプバッファーに表示されます。

package-archives
デフォルトでは、パッケージはEmacs開発者により保守される単一のパッケージアーカイブからダウンロードされます。これは変数`package-archives`により制御されます。この変数の値は、Emacsが認識するパッケージアーカイブのリストです。リストの各要素は`(id
.
location)`という形式でなければなりません。ここで、idはパッケージアーカイブの名前、locationはパッケージアーカイブディレクトリーのHTTPアドレスか名前です。サードパーティーのアーカイブを使用したい場合はこのリストを変更できます — が、自己責任で行い、信用できるサードパーティーだけを使用してください!

package security
package signing
パッケージアーカイブのメンテナーは、パッケージにサイン(signing)を付して、信頼度を増すことができます。これらはプライベートとパブリックのペアーからなる暗号化キーにより生成されます。プライベートキーは各パッケージにたいする署名ファイル(signature file)を作成するのに使用されます。パブリックキーにより、署名ファイルを使用してそのパッケージ作成者と、それが改ざんされていないかを確認できます。署名の検証は、EasyPGインターフェイス(section “EasyPG” in Emacs EasyPG Assistant Manualを参照)を通じて[the GnuPG package](https://www.gnupg.org/)を使用します(section “EasyPG” in Emacs EasyPG Assistant Manualを参照)。有効な署名であっても、それが悪意がないパッケージであることを厳正に保証する訳ではなく、用心するべきです。パッケージアーカイブは、パブリックキーの入手方法について、説明を提供するべきです。<http://pgp.mit.edu/>のようなサーバーからキーをダウンロードするのも1つの方法です。Emacsにキーをインポートするには、`M-x
package-import-keyring`を使用します。Emacsは変数`package-user-dir`で指定されるディレクトリー(デフォルトは`package-gnupghome-dir`のサブディレクトリー`gnupg`)にパッケージキーを格納します。これにより、Emacsが署名を検証する際に、オプション`gnupg`でGnuPGを呼び出すようになります。`package-gnupghome-dir`が`nil`,の場合は、GnuPGのオプション‘`--homedir`’は省略します。GNUパッケージアーカイブにたいするパブリックキーはEmacsと共に配布され、`etc/package-keyring.gpg`にあります。Emacsはこれを自動的に使用します。

package-check-signature
package-unsigned-archives
ユーザーオプション`package-check-signature`が非`nil`の場合、Emacsはパッケージのインストール時に書名の検証を試みます。このオプションが値`allow-unsigned`をもつ場合、サインされていないパッケージのインストールができます。パッケージにサインしないアーカイブを使用する場合、それらを`package-unsigned-archives`に追加できます。

暗号化キーとサインについての詳細は、section “GnuPG” in The GNU Privacy Guard Manualを参照してください。EmacsのGNU Privacy Guardにたいするインターフェースについては、section “EasyPG” in Emacs EasyPG Assistant Manualを参照してください。

package-pinned-packages
複数のパッケージアーカイブが有効で、同じパッケージにたいして異なるバージョンを提供する場合は、オプション`package-pinned-packages`が便利かもしれません。指定したパッケージが指定されたアーカイブだけからダウンロードされるように、このリストにパッケージとアーカイブのペアーを追加できます。

package-archive-priorities
package-menu-hide-low-priority
複数の有効なパッケージアーカイブがあるときに便利な他のオプションとして、`package-archive-priorities`があります。これは各アーカイブにたいして、優先度(高い数字は高い優先度のアーカイブを指定します)を指定します。このオプションにより指定されない限り、アーカイブの優先度はデフォルトの0です。優先度高のアーカイブのパッケージが利用可能な場合、優先度低のアーカイブのパッケージはメニューに表示されません(これは`package-menu-hide-low-priority`の値により制御されます)。

1度パッケージをダウンロードしてインストールすると、そのパッケージはカレントEmacsセッションにロードされます。パッケージのロードは、Lispライブラリーのロード([Lisp Libraries](#Lisp-Libraries)を参照してください)とまったく同一ではありません。パッケージをロードすることにより、パッケージのディレクトリーを`load-path`に追加して、パッケージのautoloadをロードします。パッケージのautoloadの効果はパッケージごとにさまざまです。ほとんどのパッケージは、いくつかの新たなコマンドを利用可能にするだけですが、Emacsセッションにたいして広範な影響を及ぼすものもあります。この種の情報については、パッケージのヘルプバッファーを参照してください。

デフォルトでは、インストールされたパッケージは、Emacsその後のはセッションで、自動的にロードされます。これはEmacs開始時、initファイル処理後([Init File](#Init-File)を参照してください)に行なわれます。例外として、‘`-q`’または‘`--no-init-file`’オプション([Initial Options](#Initial-Options)を参照してください)で呼び出されたときは、Emacs開始時のパッケージのロードは行なわれません。

package-enable-at-startup
自動的なパッケージのロードを無効にするには、変数`package-enable-at-startup`を`nil`に変更してください。

package-initialize
自動的なパッケージのロードがinitファイルのロード後である理由は、(パッケージシステムに影響するものも含む)ユーザーオプションが、カスタマイズされた値を受けとるのがinitファイルのロード後だからです。initファイルの中で明示的にパッケージをロードしたい状況があるかもしれません(たいていは、initファイルの他のコードが、あるパッケージに依存する等の理由により)。そのような場合、initファイルで関数`package-initialize`を呼び出す必要があります。`package-initialize`の呼び出しの前に、`package-load-list`(以下参照)などの関連するユーザーオプションをセットアップするのは、あなたの責任です。initファイルを処理した後に、これにより、パッケージを重複してロードするのを避けるために、自動的に`package-enable-at-startup`が`nil`にセットされます。かわりに、開始時にパッケージのロードを完全に抑止して、後でコマンド`M-x
package-initialize`を呼び出して手動でパッケージをロードする方法を選択したいと思うかもしれません。

package-load-list
パッケージのロードをより精密に制御するために、変数`package-load-list`を使用することができます。この変数の値にはリストを指定します。リストの要素は`(name
version)`という形式で、これはEmacsにパッケージ名nameのバージョンversionをロードするよう指示します。ここで、versionには、(そのパッケージの特定のバージョンに対応する)バージョン文字列か、`t`(これは任意のインストール済みのバージョンを意味します)、または`nil`(これはバージョンを意味しません。パッケージがロードされるのを防いで、そのパッケージを無効にします)を指定します。リストの要素にはシンボル`all`も指定でき、これは他のリスト要素で名前指定されていない、任意のパッケージのインストール済みバージョンをロードすることを意味します。デフォルト値は、単に`'(all)`となっています。

たとえば`package-load-list`を`'((muse "3.20")
all)`にセットした場合、Emacsは‘`muse`’のバージョン3.20と、‘`muse`’以外のパッケージのインストール済みの任意のバージョンをロードします。‘`muse`’の他のバージョンがインストールされていたとしても、それらは無視されます。‘`muse`’パッケージは、‘`held`’というステータスでパッケージメニューにリストされるはずです。

パッケージのファイルとディレクトリー
------------------------------------

package directory
package file
package-install-file
各パッケージはパッケージアーカイブから単一ファイル形式 －－－ 1つのEmacs Lispソースファイル、または複数のEmacs Lispソースと他のファイルを含むtarファイル — でダウンロードされます。パッケージファイルは、パッケージをインストールするEmacsコマンドにより自動的に取得、処理、配置されます。パッケージを作成する(section “Packaging” in The Emacs Lisp Reference Manualを参照してください)のでない限り、通常これらを直接扱う必要はないでしょう。パッケージファイルから直接パッケージをインストールする必要があるときは、コマンド`M-x
package-install-file`を使用してください。

package-user-dir
1度インストールされると、パッケージの内容はそのサブディレクトリーに配置されます(変数`package-user-dir`を変更することにより、ディレクトリーの名前を変更できます)。パッケージのサブディレクトリーは`name-version`という名前で、nameはパッケージ名、versionはバージョン文字列です。

system-wide packages
package-directory-list
`package-user-dir`に加えて、Emacsは`package-directory-list`にリストされたディレクトリーからインストール済みパッケージを探します。これらのディレクトリーはシステム管理者のためのディレクトリーで、Emacsパッケージをシステムワイドに利用可能にするためのものです。Emacs自身がこれらのディレクトリーにパッケージをインストールすることはありません。`package-directory-list`にたいするパッケージのサブディレクトリーは、`package-user-dir`と同じ方法で配置されます。

パッケージの削除([Package Menu](#Package-Menu)を参照してください)は、対応するパッケージのサブディレクトリーを削除します。これは`package-user-dir`にインストールされたパッケージだけに機能します。システムワイドなパッケージディレクトリーにたいして呼び出された場合、削除コマンドはエラーをシグナルします。

カスタマイズ
============

customization
このチャプターでは、Emacsの振る舞いをカスタマイズするシンプルな方法をいくつか説明します。

ここで説明する方法とは別に、EmacsをカスタマイズするためにX resourcesを使用する情報については[X Resources](#X-Resources)、キーボードマクロの記録と再生については[Keyboard Macros](#Keyboard-Macros)を参照してください。より広範で制限のない変更を行なうには、Emacs Lispコードを記述する必要があります。 section “Emacs Lisp” in The Emacs Lisp Reference Manualを参照してください。

Easy Customizationインターフェース
----------------------------------

settings
user option
customizable variable
Emacsには変更できる多くのセッティング(settings)があります。ほとんどのセッティングはカスタマイズ可能な変数(customizable variables。[Variables](#Variables)を参照してください)で、これらはユーザーオプション(user options)とも呼ばれます。非常にたくさんのカスタマイズ可能な変数があり、それらはEmacsの振る舞いを数々の側面から制御します。このマニュアルにドキュメントされている変数は、[Variable Index](#Variable-Index)にリストされています。セッティングの別のクラスにはフェイス(faces)があり、これはフォント、カラー、その他のテキスト属性を決定します([Faces](#Faces)を参照してください)。

customize
customization buffer
セッティング(変数およびフェイスの両方)を閲覧したり変更するには、`M-x
customize`とタイプします。これは論理的に組織化されたセッティングのリストの操作、値の編集とセット、永続的な保存を行なうことができる、カスタマイズバッファー(customization buffer)を作成します。

### カスタマイズグループ

customization groups
カスタマイズセッティングは、カスタマイズグループ(customization groups)に組織化されています。これらのグループはより大きなグループに集められ、最終的に`Emacs`と呼ばれるマスターグループに集約されます。

`M-x
customize`は、トップレベルの`Emacs`グループを表示するカスタマイズバッファーを作成します。これは、部分的には以下のようなものです:

    For help using this buffer, see [Easy Customization] in the [Emacs manual].

    ________________________________________ [ Search ]

     Operate on all settings in this buffer:
     [ Revert... ] [ Apply ] [ Apply and Save ]


    Emacs group: Customization of the One True Editor.
          [State]: visible group members are all at standard values.
          See also [Manual].

    [Editing]      Basic text editing facilities.
    [Convenience]  Convenience features for faster editing.

    ...more second-level groups...

このバッファーも表示されている主要な部分は‘`Emacs`’カスタマイズグループで、これはいくつかの他のグループ(‘`Editing`’、‘`Convenience`’など)を含みます。これらのグループの内容はここではリストされず、それぞれにたいして1行のドキュメントだけが表示されています。

グループのstate(ステート、状態)には、そのグループ内のセッティングが、編集されているか(edited)、セットされているか(set)、保存されているか(saved)が示されます。[Changing a Variable](#Changing-a-Variable)を参照してください。

editable fields (customization buffer)
buttons (customization buffer)
links (customization buffer)
カスタマイズバッファーのほとんどは読み取り専用ですが、編集できるいくつかの編集可能フィールド(editable fields)が含まれています。たとえばカスタマイズバッファーの最上部にある編集可能フィールドは、セッティングを検索するためのものです([Browsing Custom](#Browsing-Custom)を参照してください)。マウスでクリック、またはポイントをそこに移動して`RET`をタイプすることによりアクティブにできる、ボタン(buttons)やリンク(links)もあります。たとえば‘`[Editing]`’のようなグループ名はリンクで、これらのリンクをアクティブにすることにより、そのグループにたいするカスタマイズバッファーが立ち上がります。

TAB (customization buffer)
S-TAB (customization buffer)
widget-forward
widget-backward
カスタマイズバッファーでは、`TAB` (`widget-forward`)とタイプすると、次のボタンまたは編集可能フィールドに前方へ移動します。`S-TAB` (`widget-backward`)は、前のボタンまたは編集可能フィールドに後方へ移動します。

### セッティングのブラウズと検索

customize-browse
`M-x
customize`により作成されたトップレベルのカスタマイズバッファーから、カスタマイズグループ‘`Emacs`’のサブグループへのリンクをフォローできます。これらのサブグループは、カスタマイズするためのセッティングを含んでいるでしょう。また、これらのサブグループには、Emacsのより特化したサブシステムを扱うサブグループが、さらに含まれているかもしれません。カスタマイズグループの階層を移動していけば、カスタマイズしたい、いくつかのセッティングが見つかるでしょう。

特定のセッティングまたはカスタマイズグループのカスタマイズに興味がある場合は、コマンド`M-x
customize-option`、`M-x customize-face`、`M-x
customize-group`で直接移動することもできます。[Specific Customization](#Specific-Customization)を参照してください。

custom-search-field
どのグループまたはセッティングをカスタマイズしたいか確信がもてない場合、各カスタマイズバッファーの上部にある、編集可能なサーチフィールドを使用して、それらを検索できます。このフィールドで検索条件 — 1つの単語またはスペースで区切られた複数の単語、または正規表現([Regexps](#Regexps)を参照してください) — をタイプできます。それからそのフィールドで`RET`をタイプするか、となりの‘`Search`’ボタンをアクティブにすることにより、その条件にマッチするグループとセッティングを含むカスタマイズバッファーに切り替わります。しかし、この機能はカレントEmacsセッションにロードされたグループ、またはセッティングだけを探すことに注意してください。

カスタマイズバッファーにサーチフィールドを表示したくない場合は、変数`custom-search-field`を`nil`に変更してください。

コマンド`M-x
customize-apropos`は、同じようにサーチフィールドを使用しますが、これはミニバッファーを使用して検索条件を読み取ります。[Specific Customization](#Specific-Customization)を参照してください。

`M-x
customize-browse`は、利用可能なセッティングをブラウズする別の方法です。このコマンドは、グループまたはセッティングの名前だけを、構造化されたレイアウトで表示する、特別なカスタマイズバッファーを作成します。グループ名のとなりの‘`[+]`’ボタンを呼び出すことにより、同じバッファーでグループの内容を表示できます。グループの内容が表示されている場合、ボタンは‘`[-]`’に変化し、それを呼び出すことにより、再びグループ内容を隠すことができます。このバッファーのグループまたはセッティングには、それぞれ‘`[Group]`’、‘`[Option]`’、‘`[Face]`’というリンクがあります。このリンクを呼び出すことにより、そのグループ、オプション、フェイスだけを表示する、通常のカスタマイズバッファーが作成されます。`M-x
customize-browse`では、この方法によりセッティングを変更します。

### 変数の変更

以下は変数またはユーザーオプションが、カスタマイズバッファーではどのように表示されるかの例です:

    [Hide] Kill Ring Max: 60
       [State]: STANDARD.
       Maximum length of kill ring before oldest elements are thrown away.

最初の行には、この変数の名前が`kill-ring-max`であることが、見やすいよう‘`Kill Ring
Max`’のようにフォーマットされてに表示されています。この変数の値は‘`60`’です。‘`[Hide]`’というラベルのボタンは、アクティブにした場合は、この変数の値とステートを隠します。これは、変数がもし非常に長い値をもつ場合、カスタマイズバッファーが見にくくなるのを避けるために便利です(この理由により、非常に長い値をもつ変数は、最初は隠されています)。‘`[Hide]`’ボタンを使用すると、ボタンは‘`[Show
Value]`’に変化し、これをアクティブにすると値とステートが表示されます。グラフィカルなディスプレーでは、‘`[Hide]`’と‘`[Show
Value]`’ボタンは、下向きまたは右向きのグラフィカルな三角形で置き換えられます。

変数名の次の行は、変数のカスタマイズ状態(customization state)を示します。この例では‘`STANDARD`’で、これは変数を変更していないので、値はデフォルトのままだということを意味します。‘`[State]`’ボタンは、変数をカスタマイズするためのオペレーションメニューを提供します。

カスタマイズのステートの下は、変数のドキュメントです。これは`C-h
v`コマンド([Examining](#Examining)を参照してください)で表示されるのと同じドキュメントです。ドキュメントが複数行の場合、1行だけが表示されます。この場合、その行の最後に‘`[More]`’ボタンが表示されるので、これをアクティブにすれば完全なドキュメントを表示できます。

user options, changing
customizing variables
variables, changing
‘`Kill Ring
Max`’に新しい値を入力するには、値にポイントを移動してそれを編集するだけです。たとえば`M-d`とタイプして‘`60`’を削除して、別の値をタイプします。テキストの変更を開始すると、‘`[State]`’行が変化します:

    [State]: EDITED, shown value does not take effect until you
             set or save it.

値を編集してもすぐに変更は反映されません。変更を反映するには、‘`[State]`’をアクティブにして、‘`Set for Current
Session`’を選択することにより、変数をセット(set)しなければなりません。すると変数のステートは以下のようになります:

    [State]: SET for current session only.

無効な値を指定してしまうことを心配する必要はありません。‘`Set for Current
Session`’オペレーションは正当性をチェックして、不当な値はインストールしません。

M-TAB (customization buffer)
C-M-i (customization buffer)
widget-complete
ファイル名、ディレクトリー名、Emacsコマンドのようなタイプの値を編集するときは、`C-M-i` (`widget-complete`)、または等価なキー`M-TAB`、`ESC
TAB`で補完を行なうことができます。これはミニバッファーでの補完と同じように振る舞います([Completion](#Completion)を参照してください)。

編集可能な値フィールドで`RET`とタイプすることにより、`TAB`のように、次のフィールドまたはボタンに移動できます。したがってフィールドの編集を終えたら`RET`とタイプして、次のボタンまたはフィールドに移動できます。編集可能なフィールドに改行を挿入するには、`C-o`または`C-q
C-j`を使用します。

あらかじめ決められた値しかセットできず、値を直接編集することができない変数もいくつかあります。そのような変数の値の前には、かわりに‘`[Value
Menu]`’ボタンが表示されます。このボタンをアクティブにすると、値の選択肢が表示されます。“onかoff”のブーリーン値にたいしては、‘`[Toggle]`’ボタンが表示され、このボタンにより値のオンとオフを切り替えることができます。‘`[Value
Menu]`’ボタンや‘`[Toggle]`’ボタンを使用した後は、変数をセットして、選択した値を反映するために、再度値をセットしなければなりません。

複雑な構造の値をもつ変数もいくつか存在します。たとえば、`minibuffer-frame-alist`の値は連想配列(association list、alist)です。これはカスタマイズバッファーでは、以下のように表示されます:

    [Hide] Minibuffer Frame Alist:
    [INS] [DEL] Parameter: width
                Value: 80
    [INS] [DEL] Parameter: height
                Value: 2
    [INS]
       [ State ]: STANDARD.
       Alist of parameters for the initial minibuffer frame. [Hide]
       […more lines of documentation…]

この場合、リストの各association要素は2つのアイテムからなり、1つは‘`Parameter`’というラベルがつき、もう1つは‘`Value`’というラベルがつき、両方とも編集可能フィールドです。となりにある‘`[DEL]`’ボタンでリストからassociationを削除できます。associationを追加するには、挿入したい位置の‘`[INS]`’ボタンを使用します。一番最後の‘`[INS]`’ボタンはリストの最後に挿入します。

saving a setting
settings, how to save
変数をセットした場合、新しい値はカレントEmacsセッションでだけ効果があります。将来のセッションのために値を保存(save)するには、‘`[State]`’ボタンを使用して、‘`Save
for Future Sessions`’オペレーションを選択します。[Saving Customizations](#Saving-Customizations)を参照してください。

‘`[State]`’ボタンを使用して‘`Erase
Customization`’オペレーションを選択することにより、変数の値をその変数の標準値に復元することもできます。実際には4つのリセットオペレーションがあります:

‘`Undo Edits`’  
値を変更したが、まだ変数をセットしていない場合は、実際の値にマッチするようにバッファーのテキストを復元します。

‘`Revert This Session's Customizations`’  
これは、変更された変数がある場合は、変数の値を最後に保存された値に復元し、それ以外は標準の値に復元します。テキストも復元された変数に合わせて更新します。

‘`Erase Customization`’  
これは変数をその変数の標準値にセットします。保存した値も削除します。

‘`Set to Backup Value`’  
これはこのセッションでカスタマイズバッファーでセットされる前の値に、変数をリセットします。変数をカスタマイズしてからリセットすると、これはカスタマイズした値を破棄するので、このオペレーションにより、破棄した値に戻すことができます。

comments on customized settings
特定のカスタマイズにたいして、コメントを記録できれば便利なこともあります。コメントを入力するフィールドを作成するには、‘`[State]`’メニューの‘`Add
Comment`’アイテムを使用します。

カスタマイズバッファーの上部には2行のボタン行があります:

     Operate on all settings in this buffer:
     [Revert...] [Apply] [Apply and Save]

‘`[Revert...]`’ボタンは、上述で説明したうち、最初の3つのリセット操作をドロップダウンします。‘`[Apply]`’ボタンは、カレントセッションにセッティングを適用します。‘`[Apply
and
Save]`’ボタンはセッティングを適用して、将来のセッションのためにそれらのセッティングを保存します。このボタンは、Emacsが`-q`または`-Q`のオプションで開始された場合は表示されません([Initial Options](#Initial-Options)を参照)。

C-c C-c (customization buffer)
C-x C-c (customization buffer)
Custom-set
Custom-save
コマンド`C-c C-c` (`Custom-set`)は、‘`[Set for Current
Session]`’ボタンを使用するのと等価です。コマンド`C-x C-s` (`Custom-save`)は、‘`[Save
for Future Sessions]`’ボタンを使用するのと同様です。

custom-buffer-done-kill
‘`[Exit]`’ボタンはカスタマイズバッファーを、バッファーリストの最後のバッファーに隠し(bury)ます。カスタマイズバッファーをkillさせるようにするには、変数`custom-buffer-done-kill`を`t`に変更します。

### カスタマイズの保存

カスタマイズバッファーでは、カスタマイズしたセッティングの‘`[State]`’ボタンで‘`Save for Future
Sessions`’を選択することにより、それを保存(save)できます。`C-x C-s` (`Custom-save`)コマンド、またはカスタマイズバッファーのトップにある‘`[Apply and
Save]`’ボタンで、そのバッファー内で適用可能なすべてのセッティングが保存されます。

ファイル(通常は初期化ファイル。[Init File](#Init-File)を参照してください)にコードを書き込むことにより保存は機能します。将来のEmacsセッションは、開始時に自動的にこのファイルを読み込んで、カスタマイズを再びセットします。

custom-file
初期化ファイル以外の他のファイルにカスタマイズを保存する選択もできます。これが機能するには、変数`custom-file`に保存したいファイル名をセットして、そのファイルをロードするコード行を追加しなければなりません。たとえば:

    (setq custom-file "~/.emacs-custom.el")
    (load custom-file)

以下のようにして、Emacsのバージョンごとに違うカスタマイズファイルを指定することさえ可能です:

    (cond ((< emacs-major-version 22)
           ;; Emacs 21 customization.
           (setq custom-file "~/.custom-21.el"))
          ((and (= emacs-major-version 22)
                (< emacs-minor-version 3))
           ;; Emacs 22 customization, before version 22.3.
           (setq custom-file "~/.custom-22.el"))
          (t
           ;; Emacs version 22.3 or later.
           (setq custom-file "~/.emacs-custom.el")))

    (load custom-file)

Emacsが`-q`または`--no-init-file`オプションで呼び出されたときは、カスタマイズを初期化ファイルに保存しません。なぜならそのようなセッションからカスタマイズを保存することにより、初期化ファイルに記述されていた他のすべてのカスタマイズが消されてしまうからです。

unsaved customizations, reminder to save
custom-prompt-customize-unsaved-options
将来のセッションのために保存することを選択しなかった場合、そのカスタマイズはEmacsの終了とともに失われてしまうことに注意してください。終了時に保存されていないカスタマイズにたいするメッセージを表示させたい場合は、初期化ファイルに以下を追加してください:

    (add-hook 'kill-emacs-query-functions
              'custom-prompt-customize-unsaved-options)

### フェイスのカスタマイズ

customizing faces
faces, customizing
fonts and faces
フェイス([Faces](#Faces)を参照してください)をカスタマイズできます。フェイスは、異なる種類のテキストをEmacsがどのように表示するか決定します。カスタマイズグループは、変数とフェイスの両方を含むことができます。

たとえばプログラミング言語のモードでは、ソースコードのコメントはフェイス`font-lock-comment-face`で表示されます([Font Lock](#Font-Lock)を参照してください)。カスタマイズバッファーでは、‘`[Show All
Attributes]`’リンクをクリックした後は、このフェイスについて以下のように表示されます:

    [Hide] Font Lock Comment Face:[sample]
       [State] : STANDARD.
       Font Lock mode face used to highlight comments.
       [ ] Font Family: --
       [ ] Font Foundry: --
       [ ] Width: --
       [ ] Height: --
       [ ] Weight: --
       [ ] Slant: --
       [ ] Underline: --
       [ ] Overline: --
       [ ] Strike-through: --
       [ ] Box around text: --
       [ ] Inverse-video: --
       [X] Foreground: Firebrick     [Choose]  (sample)
       [ ] Background: --
       [ ] Stipple: --
       [ ] Inherit: --
       [Hide Unused Attributes]

最初の3行にはフェイス名、‘`[State]`’ボタン、そのフェイスにたいするドキュメントが表示されます。その下は、フェイス属性(face attributes)のリストです。それぞれの属性の前にはチェックボックスがあります。チェックされているチェックボックスは‘`[X]`’と表示され、このフェイスがその属性に値を指定していることを意味します。空のチェックボックスは‘`[
]`’と表示され、このフェイスがその属性に特に値を指定していないことを意味します。チェックボックスをアクティブにすることにより、その属性を指定または未指定にできます。

フェイスにすべての属性を指定する必要はありません。実際のところ、ほとんどのフェイスは少しの属性しか指定していません。上記の例では、`font-lock-comment-face`はフォアグラウンドカラーだけを指定しています。未指定の属性にたいしては、すべての属性が指定された特別なフェイス`default`の属性が使用されます。`default`フェイスは、明示的にフェイスが割り当てられていない任意のテキストを表示するために使用されるフェイスです。さらに、このフェイスのバックグラウンドカラー属性には、フレームのバックグラウンドカラーが使用されます。

属性リストの最後にある‘`[Hide Unused
Attributes]`’ボタンは、このフェイスの未指定の属性を隠します。隠された属性があるとき、ボタンは‘`[Show All
Attributes]`’に変化し、これはすべての属性リストを表示します。カスタマイズバッファーは、インターフェースが見にくくなるのを避けるため、未指定の属性が隠された状態で開始されるでしょう。

属性を指定するときは、通常の方法で値を変更できます。

フォアグラウンドカラーとバックグラウンドカラーは、カラーネームとRGBトリプレットの両方を使用して指定できます([Colors](#Colors)を参照してください)。カラーネームのリストに切り替えるために、‘`[Choose]`’ボタンも使用できます。そのバッファーで`RET`でカラーを選択すると、値フィールドにそのカラーネームが入ります。

フェイスのセット・保存。リセットは、変数にたいする操作と同様に機能します([Changing a Variable](#Changing-a-Variable)を参照してください)。

フェイスは、異なるタイプのディスプレーにたいして、違う外観を指定できます。たとえば、カラーディスプレーではテキストを赤にして、モノクロディスプレーでは太字フォントを使うようにフェイスを設定できます。フェイスにたいして複数の外観を指定するには、‘`[State]`’で呼び出されるメニューで‘`For
All Kinds of Displays`’を選択してください。

### 特定のアイテムのカスタマイズ

`M-x customize-option RET option RET`; `M-x customize-variable RET option RET`  
1つのユーザーオプションoptionにたいするカスタマイズバッファーをセットアップします。

`M-x customize-face RET face RET`  
1つのフェイスfaceにたいするカスタマイズバッファーをセットアップします。

`M-x customize-group RET group RET`  
1つのグループgroupにたいするカスタマイズバッファーをセットアップします。

`M-x customize-apropos RET regexp RET`  
regexpにマッチする、すべてのセッティングとグループにたいするカスタマイズバッファーをセットアップします。

`M-x customize-changed RET version RET`  
Emacsのバージョンversionから意味が変更された、すべてのセッティングとグループでカスタマイズバッファーをセットアップします。

`M-x customize-changed-options RET version RET`  
Emacsのバージョンversionから意味、またはデフォルト値が変更された、すべてのセッティングとグループのオプションでカスタマイズバッファーをセットアップします。

`M-x customize-saved`  
カスタマイズバッファーを使って保存された、すべてのセッティングを含むカスタマイズバッファーをセットアップします。

`M-x customize-unsaved`  
セットしたが保存していない、すべてのセッティングを含むカスタマイズバッファーをセットアップします。

customize-option
特定のユーザーオプションをカスタマイズしたい場合は、`M-x
customize-option`とタイプします。これは変数名を読み取り、そのユーザーオプション1つだけのためのカスタマイズバッファーをセットアップします。ミニバッファーから変数名を入力するときは、補完が利用可能ですが、Emacsにロードされた変数名だけが補完されます。

customize-face
customize-group
同様に`M-x customize-face`を使用して、特定のフェイスをカスタマイズできます。`M-x
customize-group`を使用して、特定のカスタマイズグループにたいするカスタマイズバッファーをセットアップできます。

customize-apropos
`M-x customize-apropos`は検索条件 — 1つの単語か、スペースで区切られた複数の単語、または正規表現 — の入力を求め、名前がそれにマッチする、*ロードされた*すべてのセッティングとグループにたいするカスタマイズバッファーをセットアップします。これはカスタマイズバッファーのトップにあるサーチフィールドを使用するのと同様です([Customization Groups](#Customization-Groups)を参照してください)。

customize-changed
新しいバージョンのEmacsにアップグレードしたとき、新しいセッティングをカスタマイズしたり、意味やデフォルト値が変更されたものをセッティングしたいと思うかもしれません。これを行なうには`M-x
customize-changed`を使用して、ミニバッファーから以前のEmacsのバージョンを指定します。これは指定されたバージョンから変更されたすべてのセッティングとグループを表示するカスタマイズバッファーを作成し、必要ならそれらをロードします。

customize-saved
customize-unsaved
セッティングを変更した後、その変更が間違いだと気づいたときは、変更を戻すために2つのコマンドを使用できます。保存されたカスタマイズのセッティングには、`M-x
customize-saved`を使用します。セットしたが保存していないカスタマイズのセッティングには、`M-x
customize-unsaved`を使用します。

### カスタムテーマ

custom themes
カスタムテーマ(Custom themes)は、1つの単位として有効または無効にできる、セッティングのコレクションです。カスタムテーマを使用して、さまざまなセッティングコレクション間を簡単に切り替えることができ、あるコンピューターから別のコンピューターへそのようなコレクションを持ち運ぶことができます。

カスタムテーマは、Emacs Lispソースファイルとして保存されています。カスタムテーマの名前がnameなら、そのテーマのファイル名は`name-theme.el`です。テーマファイルのフォーマットと、それを作成する方法については、[Creating Custom Themes](#Creating-Custom-Themes)を参照してください。

customize-themes
custom-theme-directory
color scheme
`M-x customize-themes`とタイプすると、Emacsが認識するカスタムテーマをリストする、`*Custom
Themes*`という名前のバッファーに切り替わります。デフォルトでは、Emacsは2つの場所からテーマファイルを探します。1つは`custom-theme-directory`により指定されるディレクトリー(デフォルトは`~/.emacs.d/`))で、もう1つはEmacsがインストールされた場所(変数`data-directory`を参照してください)の`etc/themes`というディレクトリーです。後者にはEmacsと共に配布されるいくつかのカスタムテーマが含まれており、これらはさまざまなカラースキーム(color schemes)に適合するように、Emacsフェイスをカスタマイズします(しかし、カスタムテーマの目的はこれだけに制限される必要はなく、変数をカスタマイズするのにも使用できることに注意してください)。

custom-theme-load-path
Emacsに他の場所からカスタムテーマを探させたい場合は、リスト変数`custom-theme-load-path`にディレクトリーを追加します。この変数のデフォルト値は`(custom-theme-directory
t)`です。ここでシンボル`custom-theme-directory`は、変数`custom-theme-directory`の値を指定するという特別な意味をもち、`t`はビルトインのテーマディレクトリー`etc/themes`を意味します。`custom-theme-load-path`で指定されるディレクトリーにあるテーマが、`*Custom
Themes*`バッファーにリストされます。

C-x C-s (Custom Themes buffer)
`*Custom
Themes*`バッファーでは、カスタムテーマの隣のチェックボックスをアクティブにすることにより、カレントEmacsセッションで、そのテーマを有効または無効にできます。カスタムテーマが有効な場合、そのテーマのすべてのセッティング(変数とフェイス)がEmacsセッションで効果をもちます。選択したテーマを将来のEmacsセッションに適用するには、`C-x
C-s` (`custom-theme-save`)とタイプするか、‘`[Save Theme
Settings]`’ボタンを使用してください。

custom-safe-themes
最初にカスタムテーマを有効にするとき、Emacsはテーマファイルの内容を表示して、本当にロードするか確認を求めます。これはカスタムテーマのロードにより不定なLispコードが実行されるからで、テーマが安全だと判っているときだけyesと答えるべきです。この場合、Emacsは将来のセッションのために、そのテーマが安全だということを記憶するか尋ねます(これは変数`custom-safe-themes`にテーマファイルのSHA-256ハッシュ値を保存することにより行なわれます)。すべてのテーマを安全なものとして扱いたい場合は、変数の値を`t`)に変更します。(ディレクトリー`etc/themes`の)Emacsと共に配布されるテーマは、このチェックから除外されていて、常に安全だと判断されます。

custom-enabled-themes
カスタムテーマのセッティングと保存は、変数`custom-enabled-themes`をカスタマイズすることにより機能します。この変数の値は、カスタムテーマ名(`tango`のようなLispシンボル)のリストです。`custom-enabled-themes`のセットに`*Custom
Themes*`バッファーを使用するかわりに、たとえば`M-x
customize-option`のような通常のカスタマイズインターフェースを使用して、変数をカスタマイズできます。カスタムテーマ自身では、`custom-enabled-themes`をセットできないことに注意してください。

カスタマイズバッファーを通じて行なう任意のカスタマイズは、テーマのセッティングより優先されます。これによりテーマのセッティングを簡単にオーバーライドできます。2つの異なるテーマのセッティングがオーバーラップする場合には、`custom-enabled-themes`で先に指定されたテーマが優先されます。カスタマイズバッファーでは、カスタムテーマによりセッティングがデフォルトから変更されているときは、‘`State`’には‘`STANDARD`’ではなく‘`THEMED`’が表示されます。

load-theme
enable-theme
disable-theme
`M-x
load-theme`とタイプすることにより、カレントEmacsセッションで特定のカスタムテーマを有効にできます。これはテーマ名の入力を求め、テーマファイルからテーマをロードし、それを有効にします。すでにテーマファイルがロードされているときは、`M-x
enable-theme`とタイプすることにより、ファイルをロードせずにテーマを有効にできます。カスタムテーマを無効にするには、`M-x
disable-theme`とタイプしてください。

describe-theme
カスタムテーマの説明を見るには、`*Custom
Themes*`バッファーのその行で、`?`とタイプするか、Emacsの任意のバッファーで`M-x
describe-theme`とタイプしてテーマ名を入力してください。

### カスタムテーマの作成

custom themes, creating
customize-create-theme
`M-x
customize-create-theme`とタイプすることにより、カスタマイズバッファーと似たインターフェースを使用して、カスタムテーマを定義できます。これは`*Custom
Theme*`という名前のバッファーに切り替えます。これは、一般的なEmacsフェイスをそのテーマに挿入するかも尋ねます(カスタムテーマは、フェイスをカスタマイズするのに使用される場合があるので便利です)。これにnoと答えると、そのテーマには最初は何もセッティングが含まれません。

`*Custom
Theme*`バッファーの上部には、テーマ名と説明を入力できる、編集可能フィールドがあります。‘`user`’を除く任意の名前を指定できます。説明は、テーマにたいして`M-x
describe-theme`を呼び出したときに表示される文です。最初の行は1センテンスの概要であるべきです。`M-x
customize-themes`により作成されたバッファーでは、このセンテンスがテーマ名のとなりに表示されます。

テーマに新しいセッティングを追加するには、‘`[Insert Additional Face]`’ボタンか、‘`[Insert
Additional
Variable]`’ボタンを使用します。これらのボタンはミニバッファーを使用して、補完つきでフェイス名または変数名を読み取り、そのフェイスまたは変数にたいするカスタマイズエントリーを挿入します。通常のカスタマイズバッファーと同じ方法で、変数の値またはフェイスの属性を編集できます。テーマからフェイスまたは変数を削除するには、名前の横のチェックボックスのチェックを外してください。

custom-theme-directory, saving theme files
カスタムテーマのフェイスや変数を指定した後は、`C-x C-s` (`custom-theme-write`)とタイプするか、そのバッファーの‘`[Save
Theme]`’ボタンを使用します。これは`custom-theme-directory`のディレクトリーに、`name-theme.el`(nameはテーマ名)という名前で、テーマファイルを保存します。

`*Custom Theme*`バッファーから、‘`[Visit
Theme]`’ボタンをアクティブにしてテーマ名を指定することにより、既存のカスタムテーマの閲覧と編集ができます。‘`[Merge
Theme]`’ボタンを使用して、他のテーマのセッティングをバッファーに追加することもできます。‘`[Merge
Theme]`’ボタンを使用して、‘`user`’という名前の特別なテーマ名を指定することにより、非テーマセッティングをカスタムテーマにインポートできます。

テーマファイルは単なるEmacs Lispソースファイルで、カスタムテーマのロードはLispファイルをロードすることにより機能します。したがって`*Custom
Theme*`バッファーを使用するかわりに、テーマファイルを直接編集することもできます。詳細は、section “Custom Themes” in The Emacs Lisp Reference Manualを参照してください。

変数
----

variable
変数(variable)とは、値をもつLipシンボルです。このようなシンボルの名前は、変数名(variable name)とも呼ばれます。変数名には、ファイルに記述できる任意の文字を含めることもできますが、ほとんどの変数名は通常の単語をハイフンで区切って構成されます。

変数の名前には、その変数の役割を簡単に説明する役目があります。ほとんどの変数はドキュメント文字列(documentation string)ももっていて、これは変数の目的、どのような種類の値をもつべきか、値がどのように使用されるかを説明します。ヘルプコマンド`C-h
v` (`describe-variable`)を使用して、このドキュメントを閲覧できます。[Examining](#Examining)を参照してください。

Emacsは内部の記録維持のために多くのLisp変数を使用しますが、非プログラマーに一番興味があるのはユーザーが変更することを意図したLisp変数であり、これらはカスタマイズ可能変数(customizable variables)やユーザーオプション(user options)と呼ばれます([Easy Customization](#Easy-Customization)を参照してください)。以下のセクションでは、カスタマイズのためのインターフェース以外から変数をセットする方法など、他の観点からEmacs変数を説明します。

(少数の例外を除き)Emacs Lispでは、任意の変数は任意のタイプの値をもつことができます。しかし多くの変数は、特定のタイプの値を割り当てられた場合だけ意味をもちます。たとえばkillリングの最大長さを指定する`kill-ring-max`の値としては、数字だけが意味をもちます。`kill-ring-max`の値として文字列を与えた場合、`C-y` (`yank`)のようなコマンドはエラーをシグナルするでしょう。一方、タイプを気にしない変数もあります。たとえば、変数の値が`nil`のときはある効果をもたらし、非`nil`のときは別の効果をもたらす場合、シンボル`nil`以外の任意の値は、そのタイプに関わらず2番目の効果をもたらします(慣例により、非`nil`値を指定するために、通常は値`t` — これは“true”が由来です — を使用します)。カスタマイズバッファーを使用して変数をセットする場合、無効なタイプを与えてしまう心配はありません。カスタマイズバッファーでは通常、意味のある値しか入力できないからです。判別がつかないときは、その変数が期待する値の種類を見るために、`C-h
v` (`describe-variable`)を使用して、変数のドキュメント文字列をチェックしてください([Examining](#Examining)を参照してください)。

### 変数の確認とセット

setting variables
`C-h v var RET`  
変数varの値とドキュメントを表示します(`describe-variable`)。

`M-x set-variable RET var RET value RET`  
変数varの値をvalueに変更します。

変数の値を調べるには、`C-h v` (`describe-variable`)を使用します。これはミニバッファーを使用して補完つきで変数名を読み取り、、変数の値とドキュメントの両方を表示します。たとえば、

    C-h v fill-column RET

これは以下のような出力を表示します:

    fill-column is a variable defined in ‘C source code’.
    Its value is 70

      Automatically becomes buffer-local when set.
      This variable is safe as a file local variable if its value
      satisfies the predicate ‘integerp’.

    Documentation:
    Column beyond which automatic line-wrapping should happen.
    Interactively, you can set the buffer local value using C-x f.

    You can customize this variable.

‘`You can customize the variable`’の行は、この変数がユーザーオプションであることを示します。`C-h
v`はユーザーオプションだけに制限されません。これはカスタマイズ可能でない変数にも使用できます。

set-variable
特定のカスタマイズ可能な変数をセットする一番簡単な方法は、`M-x
set-variable`です。これはミニバッファーで変数名を読み取り(補完つき)、次にミニバッファーを使用して新しい値にたいするLisp式を読み取ります(`M-n`を使用してミニバッファーで編集するために、古い値を挿入することができます)。たとえば、

    M-x set-variable RET fill-column RET 75 RET

これは`fill-column`を75にセットします。

`M-x set-variable`はカスタマイズ可能な変数に制限されていますが、以下のようなLisp式で任意の変数をセットできます:

    (setq fill-column 75)

このような式を実行するには、`M-:` (`eval-expression`)とタイプして、ミニバッファーで式を入力します([Lisp Eval](#Lisp-Eval)を参照してください)。かわりに`*scratch*`バッファーに移動して、式をタイプしてから`C-j`とタイプすることもできます([Lisp Interaction](#Lisp-Interaction)を参照してください)。

変数のセットは、Emacsのカスタマイズと同様、特に明記しない限りは、カレントEmacsセッションだけに影響します。将来のセッションのために変数を変更する唯一の方法は、初期化ファイルにそれを記述することです([Init File](#Init-File)を参照してください)。

### フック

hook
running a hook
フック(hook)とは、Emacsをカスタマイズするための重要な仕組みです。フックは関数のリストを保持するLisp変数で、これらの関数は、ある定められたタイミングで呼び出されます(これは、フックを実行する(running the hook))、と呼ばれます)。リストの中の個別の関数は、そのフックのフック関数(hook functions)と呼ばれます。たとえばフック`kill-emacs-hook`は、Emacsを終了する直前に実行されます([Exiting](#Exiting)を参照してください)。

normal hook
ほとんどのフックはノーマルフック(normal hooks)です。これは、Emacsがフックを実行するとき、フック関数が引数なしで順に呼び出します。わたしたちは、ほとんどのフックをノーマルフックに保つために努力しているので、あなたはこれらのフックを一貫した方法で使用することができます。変数名の最後が‘`-hook`’の変数は、ノーマルフックです。

abnormal hook
多くはありませんが、アブノーマルフック(abnormal hooks)もあります。アブノーマルフックは、名前の最後が‘`-hook`’ではなく‘`-functions`’です(古いコードの中には時代遅れのサフィックス‘`-hooks`’を使うものもあります)。これらのフックがアブノーマルな理由は、関数が呼び出される方法にあります — もしかしたら引数が与えられているかもしれず、ことによると関数が返す値が何かに使用されるかもしれません。たとえば`find-file-not-found-functions`はアブノーマルです。なぜならフック関数のうちの1つが非`nil`値を返した場合、残りの関数は呼び出されないからです([Visiting](#Visiting)を参照してください)。アブノーマルフック変数のドキュメントには、フック関数がどのように使用されるかの説明があります。

add-hook
他のLisp変数と同じように、`setq`でフック変数をセットすることもできますが、フック(ノーマルとアブノーマルの両方)に関数を追加するための推奨される方法は、以下の例で示されるような、`add-hook`を使う方法です。詳細は、section “Hooks” in The Emacs Lisp Reference Manualを参照してください。

ほとんどのメジャーモードは初期化の最終ステップで、1つ以上のモードフック(mode hooks)を実行します。モードフックは個々のモードの振る舞いをカスタマイズするための便利な方法で、常にノーマルフックです。たとえば、以下はTextモードと、Textモードを基礎とする他のモードで、Auto Fillモードをオンにするフックをセットアップする方法です:

    (add-hook 'text-mode-hook 'auto-fill-mode)

これは、引数を与えられない場合にマイナーモードを有効にする`auto-fill-mode`を呼び出すことにより機能します([Minor Modes](#Minor-Modes)を参照してください)。次に、Textモードを基礎とするLATEXモードではAuto Fillモードをオンにしたくない場合、以下の行を追加してこれを行なうことができます:

    (add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))

ここでは、無名関数(anonymous function。section “Lambda Expressions” in The Emacs Lisp Reference Manualを参照してください)を構築するために、特別なマクロ`lambda`を使用しており、`auto-fill-mode`に`-1`を与えて呼び出すことにより、マイナーモードを無効にしています。LATEXモードは、`text-mode-hook`を実行した後に、`latex-mode-hook`モードを実行するので、その結果Auto Fillモードが無効になります。

以下はもっと複雑な例で、Cコードのインデントをカスタマイズするのにフックを使う方法です:

    (setq my-c-style
      '((c-comment-only-line-offset . 4)

        (c-cleanup-list . (scope-operator
                           empty-defun-braces
                           defun-close-semi))))

    (add-hook 'c-mode-common-hook
      (lambda () (c-add-style "my-style" my-c-style t)))

Prog mode
modes for editing programs
メジャーモードフックは、それを元のモードとして派生された(derived)他のメジャーモードにも適用されます(section “Derived Modes” in The Emacs Lisp Reference Manualを参照してください)。たとえばHTMLモード([HTML Mode](#HTML-Mode)を参照してください)はTextモードから派生しており、HTMLモードが有効になるときは、`html-mode-hook`を実行する前に`text-mode-hook`が実行されます。これは1つのフックを複数の関連するモードに作用させるための便利な方法を提供します。特に任意のプログラミング言語にたいしてフック関数を適用したい場合は、それを`prog-mode-hook`モードに追加します。Progモードは、それを継承する他のメジャーモードと比較すると、ほとんど何も行なわないメジャーモードで、まさにこの目的のために存在します。

実行される順番に依存しないようにフック関数をデザインするのがベストです。実行順への依存はトラブルを招きます。しかし実行順は予測可能です。フック関数はフックに登録された順に実行されます。

remove-hook
何度も`add-hook`を呼び出すことにより、さまざまな異なるバージョンのフック関数を追加した場合、追加されたすべてのバージョンのフック関数がフック変数に残ることを忘れないでください。`remove-hook`を呼び出すことにより関数を個別にクリアーするか、`(setq
hook-variable nil)`ですべてのフック関数を削除できます。

buffer-local hooks
フック変数がバッファーローカルな場合、グローバル変数のかわりにバッファーローカル変数が使用されます。しかしバッファーローカル変数が要素`t`を含む場合は、グローバル変数も同様に実行されます。

### ローカル変数

`M-x make-local-variable RET var RET`  
変数varが、カレントバッファーでローカル値をもつようにします。

`M-x kill-local-variable RET var RET`  
変数varが、カレントバッファーでグローバル値を使うようにします。

`M-x make-variable-buffer-local RET var RET`  
変数varがセットされた時点で、カレントバッファーにたいしてローカルになるようマークします。

local variables
ほとんどの変数は、特定のEmacsバッファーにたいしてローカル(local)にすることができます。これは、そのバッファーでの変数の値が、他のバッファーでの変数の値とは、独立していることを意味します。多くはありませんが、常にバッファーごとにローカルな変数もあります。他のすべてのEmacs変数は、バッファーで変数をローカルにしていないかぎりは、すべてのバッファーに効果を及ぼすグローバル(global)な値をもちます。

make-local-variable
`M-x
make-local-variable`は変数名を読み取り、それをカレントバッファーにたいしてローカルにします。その後、このバッファーで変数の値を変更しても他のバッファーには影響せず、変数のグローバル値を変更してもこのバッファーには影響しなくなります。

make-variable-buffer-local
per-buffer variables
`M-x
make-variable-buffer-local`は、変数がセットされたとき自動的にローカルになるように、変数をマークします。より正確には、1度この方法で変数がマークされると、通常の方法による変数のセットは、最初に自動的に`make-local-variable`を呼び出します。このような変数をパーバッファー(per-buffer: バッファーごと)変数と呼びます。Emacsの多くの変数は、通常はパーバッファーです。変数のドキュメント文字列には、いつこれを行なうかが記述されています。パーバッファー変数のグローバル値は、通常は任意のバッファーには影響しませんが、それでもまだ意味があります。グローバル値は、新しいバッファーにたいする、この変数の初期値として使用されます。

メジャーモード([Major Modes](#Major-Modes)を参照してください)は常に変数をセットする前に、変数をローカルにします。あるバッファーでメジャーモードを変更しても、他のバッファーに影響がないのは、これが理由です。マイナーモードは変数をセットすることにより機能します — 通常、各マイナーモードは1つの制御変数(controlling variable)をもっていて、この変数が非`nil`の場合はモードが有効になります([Minor Modes](#Minor-Modes)を参照してください)。多くのマイナーモードにたいして制御変数はパーバッファーであり、したがって常にバッファーローカルです。そうでない場合、他の変数と同様に特定のバッファーで変数をローカルにできます。

多くはありませんが、バッファーでローカルにできない(かわりに各ディスプレーにたいして常にローカル。[Multiple Displays](#Multiple-Displays)を参照してください)変数も存在します。そのような変数をバッファーローカルにしようとすると、エラーメッセージが表示されます。

kill-local-variable
`M-x
kill-local-variable`は、指定された変数が、カレントバッファーにたいしてローカルであることを終了させます。その後は、そのバッファーにたいして、その変数のグローバル値が効力をもちます。メジャーモードのセットにより、数少ないパーマネントローカル(permanent locals: 永久にローカル)な変数を除いて、そのバッファーのすべてのローカル変数はkillされます。

setq-default
変数がカレントバッファーでローカル値をもつかに関わらず、変数にグローバル値をセットするには、Lispコンストラクト`setq-default`を使用することができます。このコンストラクトは`setq`と同じように使用されますが、(もしあれば)ローカル値のかわりにグローバル値をセットします。カレントバッファーがローカル値をもつ場合、新しいグローバル値は他のバッファーに切り替えるまで見えないでしょう。以下は例です:

    (setq-default fill-column 75)

`setq-default`は、`make-variable-buffer-local`でマークされた変数のグローバル値をセットする唯一の方法です。

default-value
Lispプログラムは変数のデフォルト値を得るために、`default-value`を使用することができます。この関数はシンボルを引数として受け取り、それのデフォルト値を返します。引数は評価されるので、通常は明示的にクォートする必要があります。たとえば、以下は`fill-column`のデフォルト値を得る方法です:

    (default-value 'fill-column)

### ファイル内のローカル変数

local variables in files
file local variables
ファイルに、Emacsでそのファイルを編集するときに使用するローカル変数の値を指定できます。ファイルをvisitするか、メジャーモードをセットすることにより、Emacsはローカル変数指定をチェックします。これは自動的にこれらの変数をバッファーにたいしてローカルにし、ファイルで指定された値にセットします。

あるファイルのディレクトリーにたいしてディレクトリーローカル変数([Directory Variables](#Directory-Variables)を参照)が指定されている場合、ファイルローカル変数はそれをオーバーライドします。

#### ファイル変数の指定

ファイルローカル変数を指定するには2つの方法があります。1つは最初の行に記述する方法で、もう1つはローカル変数リストを使用する方法です。以下は最初の行でこれらを指定する方法の例です:

    -*- mode: modename; var: value; … -*-

この方法により、任意の数の変数/値(variable/value)ペアーを指定できます。各ペアーはコロンとセミコロンで区切ります。特別な変数/値ペアー`mode:
modename;`が与えられた場合、これはメジャーモードを指定します。valueは文字列として使用され、評価はされません。

add-file-local-variable-prop-line
delete-file-local-variable-prop-line
copy-dir-locals-to-file-locals-prop-line
手作業でエントリーを追加するかわりに、`M-x
add-file-local-variable-prop-line`を使用することができます。このコマンドは変数と値の入力を求め、適切な方法で最初の行にこれらを追加します。`M-x
delete-file-local-variable-prop-line`は変数の入力を求め、最初の行から変数のエントリーを削除します。コマンド`M-x
copy-dir-locals-to-file-locals-prop-line`は、カレントのディレクトリーローカル変数を最初の行にコピーします([Directory Variables](#Directory-Variables)を参照してください)。

以下は、最初の行でLispモードを指定して、2つの変数に数値をセットする例です:

    ;; -*- mode: Lisp; fill-column: 75; comment-column: 50; -*-

`mode`の他に、ファイル変数として特別な意味をもつキーワードは`coding`、`unibyte`、`eval`です。これらは以下で説明します。

shell scripts, and local file variables
man pages, and local file variables
シェルスクリプトでは、最初の行はスクリプトのインタープリターの識別に使用されるので、ローカル変数をそこに置くことはできません。これに対処するために、Emacsは最初の行がインタープリターを指定しているときは、*2行目*からローカル変数指定を探します。man pagesにも同じことが言えます。man pagesはtroffプリプロセッサーのリストを指定するマジック文字列‘`'\"`’で始まるからです(しかし、すべてがこれを行なう訳ではありません)。

‘`-*-`’行を使用するのではなく、ファイルの終端付近でローカル変数リスト(local variables list)を使用することにより、ファイルローカル変数を定義することもできます。ローカル変数リストは、ファイル終端から3000文字以内で開始され、ファイルがページに分かれているときは最後のページになければなりません。

ファイルにローカル変数リストと‘`-*-`’の両方がある場合、Emacsは最初に‘`-*-`’行の*すべて*を処理してから、ローカル変数リストの*すべて*を処理します。例外はメジャーモード指定です。Emacsはメジャーモード指定がどこにあろうと、まずそれを適用します。なぜならほとんどのメジャーモードは、初期化部分ですべてのローカル変数をkillするからです。

ローカル変数リストは、文字列‘`Local
Variables:`’を含む行で開始され、文字列‘`End:`’を含む行で終了します。この間には、以下のように1行に変数名と値のペアーが記述されます:

    /* Local Variables:  */
    /* mode: c           */
    /* comment-column: 0 */
    /* End:              */

この例では、各行はプレフィクス‘`/*`’で始まり、サフィックス‘`*/`’で終了します。Emacsは、リストの最初の行のマジック文字列‘`Local
Variables:`’を囲む文字列から、プレフィクスとサフィックスを識別します。その後はリストの他の行で自動的にこれらを破棄します。プレフィクスおよび/またはサフィックスを使用する通常の理由は、そのファイルが意図する他のプログラムが混乱しないように、ローカル変数をコメントに埋め込むためです。上記は、コメントが‘`/*`’で始まり‘`*/`’で終わるCプログラミング言語での例です。

Emacsのローカル変数リストではないが、そのように見えるテキストがある場合は、そのテキストの後にフォームフィード文字(ページ区切りです。[Pages](#Pages)を参照してください)を挿入して、それを取り消すことができます。Emacsはファイルの最後のページ(つまり最後のページ区切りの後)にあるファイルローカル変数だけを調べます。

add-file-local-variable
delete-file-local-variable
copy-dir-locals-to-file-locals
ローカル変数を直接タイプするかわりに、コマンド`M-x
add-file-local-variable`を使用することができます。これは変数と値の入力を求め、それらをリストに追加し、‘`Local
Variables:`’と、必要なら開始・終了マーカーも追加します。コマンド`M-x
delete-file-local-variable`は、リストから変数を削除します。`M-x
copy-dir-locals-to-file-locals`は、ディレクトリーローカル変数をリストにコピーします([Directory Variables](#Directory-Variables)を参照してください)。

‘`-*-`’行と同じように、ローカル変数リストの変数は文字列として使用され、最初に評価されることはありません。長い文字列値をファイル内で複数行に分割したい場合、改行とバックスラッシュを使用できます(Lisp文字列定数では無視されます)。各行には、プレフィクスとサフィックスを記述するべきです。たとえ行がその文字列で開始または終了していても、それらはリストを処理するとき取り除かれます。以下は例です:

    # Local Variables:
    # compile-command: "cc foo.c -Dfoo=bar -Dhack=whatever \
    #   -Dmumble=blaah"
    # End:

いくつかの名前は、ローカル変数リスト内で特別な意味をもちます:

-   `mode`は、指定されたメジャーモードを有効にします。

-   `eval`は、指定されたLisp式を評価します(式が返す値は無視されます)。

-   `coding`は、このファイルでの文字コード変換にたいするコーディングシステムを指定します。[Coding Systems](#Coding-Systems)を参照してください。

-   `unibyte`の値が`t`の場合、Emacs Lispのロードとコンパイルをunibyteモードで行ないます。section “Disabling Multibyte Characters” in GNU Emacs Lisp Reference Manualを参照してください。

これら4つのキーワードは、実際には変数ではありません。他のコンテキストでこれらをセットしても、特別な意味はありません。

マイナーモードにたいして`mode`キーワードを使用しないでください。ローカル変数リストでマイナーモードを有効または無効にするには、`eval`でモードコマンドを実行するLisp式を指定します([Minor Modes](#Minor-Modes)を参照してください)。たとえば以下のローカル変数リストは、引数なし(引数に1を指定しても同じことを行ないます)で`eldoc-mode`を呼び出すことにより、Eldocモード([Lisp Doc](#Lisp-Doc)を参照してください)を有効にし、引数−1で`font-lock-mode`([Font Lock](#Font-Lock)を参照してください)を呼び出すことにより、Font Lockモードを無効にする例です。

    ;; Local Variables:
    ;; eval: (eldoc-mode)
    ;; eval: (font-lock-mode -1)
    ;; End:

しかしこの方法でマイナーモードを指定するのは、間違っている場合もあることに注意してください。マイナーモードは個人の好みを表しており、そのファイルを編集するユーザーにあなたの好みを強制するのは、不適切かもしれません。状況に依存して自動的にマイナーモードを有効または無効にしたい場合は、たいていメジャーモードフックでこれを行なう方がよいのです([Hooks](#Hooks)を参照してください)。

ローカル変数と、ファイル名とファイル内容にしたがったバッファーのメジャーモード(もしあればローカル変数リストも)をリセットするには、コマンド`M-x
normal-mode`を使用します。[Choosing Modes](#Choosing-Modes)を参照してください。

#### 安全なファイル変数

ファイルローカル変数が危険な場合もあります。他の誰かのファイルをvisitするとき、そのファイルのローカル変数リストがEmacsに何を行なうか、告げるものはありません。`eval` “variable”や、その他の`load-path`などにたいする不正な値は、実行する意図がないLispコードを実行するかもしれません。

したがって、安全と判っていないファイルローカル変数を発見した場合、Emacsはファイルのローカル変数リスト全体を表示して、それらをセットする前に継続するか尋ねます。`y`またはSPCをタイプすると、ローカル変数リストは効果をもち、`n`の場合は無視します。Emacsがバッチモード([Initial Options](#Initial-Options)を参照してください)で実行されている場合、Emacsは確認することができないので、`n`と応えられたとみなします。

Emacsは通常、特定の変数/値ペアーが安全だと認識できます。たとえば`comment-column`や`fill-column`には、任意の整数値を与えても安全です。ファイルが安全だと判っている変数/値ペアーだけを指定する場合、Emacsはそれらをセットする前に確認を求めません。そうでない場合、確認プロンプトで`!`とタイプすることにより、このファイル内のすべての変数/値ペアーが安全なことを記録するようEmacsに指示できます。その後、Emacsが同じファイルまたは別のファイルで、これらの変数/値ペアーに出会うと、これらを安全だとみなします。

safe-local-variable-values
risky variable
`load-path`のようないくつかの変数は、特に危険だと判断されます。これらをローカル変数として指定すべき理由はほとんどなく、それらを変更するのは危険です。ファイルに危険なローカル変数だけが含まれる場合、Emacsは確認プロンプトで`!`の選択肢を提示することも、それを受け入れることもしません。ファイル内のいくつかのローカル変数が危険で、いくつかの変数は潜在的に安全ではない場合は、プロンプトで`!`を入力できます。これはすべての変数に適用されますが、危険ではない変数だけを将来のセッションのために安全とマークします。もし危険な変数を安全な値として記録したいと本当に望むなら、‘`safe-local-variable-values`’をカスタマイズすることによりこれを行ないます([Easy Customization](#Easy-Customization)を参照してください)。

enable-local-variables
変数`enable-local-variables`により、Emacsがローカル変数を処理する方法を変更できます。デフォルト値は`t`で、これは上述の振る舞いを指定します。`nil`の場合、Emacsは単にすべてのファイルローカル変数を無視します。`:safe`は安全な値だけを使用して、残りは無視します。他の値の場合、安全と判っている値かどうかの決定を試みずに、ローカル変数をもつ各ファイルごとに尋ねます。

enable-local-eval
safe-local-eval-forms
変数`enable-local-eval`は、Emacsが`eval`変数を処理するかどうかを制御します。`enable-local-variables`のように、変数に対する可能な値は3つで、`t`、`nil`、およびそれ以外です。デフォルトは、`t`や`nil`ではない`maybe`で、通常Emacsは`eval`変数を処理するときに確認を求めます。

例外として、評価する任意の`eval`形式が、変数`safe-local-eval-forms`で指定された形式の場合、Emacsは確認を求めません。

### ディレクトリーごとのローカル変数

local variables, for all files in a directory
directory-local variables
per-directory local variables
大きなソフトウェアプロジェクトでのディレクトリーツリーのような、特定のディレクトリーや、それのサブディレクトリーのすべてのファイルにたいして、同じローカル変数を定義したいことがあるかもしれません。これはディレクトリーローカル変数(directory-local variables)で行なうことができます。ファイルローカル変数はディレクトリーローカル変数をオーバーライドするので、あるディレクトリー内のファイルに特別なセッティングが必要な場合は、ディレクトリー変数でそのディレクトリー内の大多数にたいするセッティングを指定してから、ファイルローカル変数により、少数のファイルにたいしてオーバーライドを要する一般的なセッティングを定義できます。

.dir-locals.el
file
ディレクトリーローカル変数を定義する通常の方法は、そのディレクトリーに`.dir-locals.el`[22]を配す方法です。そのディレクトリー、またはそれのサブディレクトリーの任意のファイルをEmacsがvisitするとき、`.dir-locals.el`で指定されたディレクトリーローカル変数が、あたかもそのファイルのファイルローカル変数([File Variables](#File-Variables)を参照してください)として定義されたかのように、ファイルに適用されます。Emacsはvisitされたファイルのディレクトリーから、ディレクトリーツリーを上に移動しながら`.dir-locals.el`を検索します。スローダウンを避けるために、検索はリモートファイルをスキップします。必要なら、変数`enable-remote-dir-locals`を`t`にセットして、検索範囲をリモートファイルに広げることができます。

Emacsが追加でロードする`.dir-locals-2.el`が存在する場合は、それを使用することもできます。これは`.dir-locals.el`がバージョンコントロールの共有ディレクトリー配下にあり、個人的なカスタマイズに使用できないときに有用です。

`.dir-locals.el`は、特別な構成のリストをもちます。これはモード名(シンボルで指定)をalist(Association Lists: 連想リスト。section “Association Lists” in The Emacs Lisp Reference Manualを参照してください)にマップします。各alistエントリーは、変数名と、指定されたメジャーモードが有効なときに、その変数に割り当てるディレクトリーローカル値からなります。モード名のかわりに‘`nil`’を指定でき、これはalistが任意のモードで適用されることを意味します。サブディレクトリー(文字列で指定)を指定することもできます。この場合、そのサブディレクトリーのすべてのファイルにalistが適用されます。

以下は、`.dir-locals.el`ファイルの例です:

    ((nil . ((indent-tabs-mode . t)
             (fill-column . 80)))
     (c-mode . ((c-file-style . "BSD")
                (subdirs . nil)))
     ("src/imported"
      . ((nil . ((change-log-default-name
                  . "ChangeLog.local"))))))

これはディレクトリーツリーの任意のファイルにたいして、‘`indent-tabs-mode`’と`fill-column`をセットし、任意のCソースファイルにたいしてインデントスタイルをセットします。特別な要素`subdirs`は変数ではありません。これは特別なキーワードで、Cモードのセッティングがカレントディレクトリーだけに適用され、任意のサブディレクトリーには適用されないことを示します。最後に、これは`src/imported`サブディレクトリー内の任意のファイルにたいして、違う`ChangeLog`ファイル名を指定します。

`.dir-locals.el`内では`mode`、`eval`、`unibyte`を指定できます。これらの変数は、ファイルローカル変数のときとオ同じ意味をもちます。`coding`は、ディレクトリーローカル変数としては指定できません。[File Variables](#File-Variables)を参照してください。

add-dir-local-variable
delete-dir-local-variable
copy-file-locals-to-dir-locals
`.dir-locals.el`ファイルを手で編集するかわりに、コマンド`M-x
add-dir-local-variable`を使用できます。これはモード名またはサブディレクトリー、および変数名と値の入力を求め、ディレクトリーローカル変数を定義するエントリーを追加します。`M-x
delete-dir-local-variable`は、エントリーを削除します。`M-x
copy-file-locals-to-dir-locals`は、カレントファイル内のファイルローカル変数を、`.dir-locals.el`にコピーします。

dir-locals-set-class-variables
dir-locals-set-directory-class
ディレクトリーローカル変数を指定する他の方法は、`dir-locals-set-class-variables`関数を使用して、ディレクトリークラス(directory class)の中に、変数/値ペアーのグループを定義する方法です。その後、`dir-locals-set-directory-class`関数を使用して、そのクラスに対応するディレクトリーをEmacsに指示します。これらの関数呼び出しは通常、初期化ファイルで行なわれます([Init File](#Init-File)を参照してください)。この方法は、何らかの理由でディレクトリーに`.dir-locals.el`を置けないときに便利です。たとえば、この方法で書き込み不可なディレクトリーにセッティングを適用できます:

    (dir-locals-set-class-variables 'unwritable-directory
       '((nil . ((some-useful-setting . value)))))

    (dir-locals-set-directory-class
       "/usr/include/" 'unwritable-directory)

変数にたいしてディレクトリーローカル値とファイルローカル値の両方が指定された場合、ファイルローカル値が効果をもちます。安全ではないディレクトリーローカル値は、安全でないファイルローカル値と同じ方法で扱われます([Safe File Variables](#Safe-File-Variables)を参照してください)。

ディレクトリーローカル変数は、Diredバッファー([Dired](#Dired)を参照してください)のような、ファイルを直接visitしていないが、ディレクトリーで処理を行なうバッファーにたいしても効果があります。

キーバインディングのカスタマイズ
--------------------------------

key bindings
このセクションでは、キーをコマンドにマップするキーバインド(key bindings)と、そのキーバインドを記録するキーマップ(keymaps)を説明します。それにinitファイルを編集して、キーバインドをカスタマイズする方法も説明します([Init Rebinding](#Init-Rebinding)を参照してください)。

reserved key bindings
keys, reserved
ほとんどのモードは自身のキーバインディングを定義するので、モードをアクティブにすることにより、あなたのカスタムキーバインディングがオーバーライドされるかもしれません。いくつかのキーはユーザー定義バインディングのために予約されており、モードはそれらを使用してはならないので、これらのキーはこの問題にたいして安全です。予約済みのキーは、`C-c`と英字(大文字と小文字の両方)、修飾キーなし([Modifier Keys](#Modifier-Keys)を参照)のファンクションキーのF5からF9です。

### キーマップ

keymap
[Commands](#Commands)で説明されているように、各Emacsコマンドは、対話的に使用することを条件として定義されたLisp関数です。すべてのLisp関数と同様に、コマンドは小文字とハイフンからなる関数名をもちます。

キーシーケンス(key sequence) — 短くはキー(key) — とは、1つの単位として意味をもつ、連続する入力イベント(input events)のことです。入力イベントとは文字、ファンクションキー、マウスボタン — つまりコンピューターに送ることができるすべての入力のことです。キーシーケンスは、それが何のコマンドを実行するかを指示するバインディング(binding)により、意味をもちます。

キーシーケンスとコマンド関数との間のバインディングは、keymaps(キーマップ)と呼ばれるデータ構造に記録されます。Emacsには多くのkeymapsがあり、それぞれが特別の機会に使用されます。

global keymap
一番重要なキーマップは、グローバルキーマップ(global keymap)です。なぜならグローバルキーマップは常に効果があるからです。グローバルキーマップはFundamentalモードにたいしてキーを定義します([Major Modes](#Major-Modes)を参照してください)。これらの定義のほとんどは、、ほとんどすべてのメジャーモードでは一般的です。メジャーモードまたはマイナーモードは、いくつかのキーにたいするグローバル定義をオーバーライドするために、それぞれ独自のkeymapをもつことができます。

たとえば`g`のような自己挿入文字(self-inserting character)は、グローバルキーマップがそれをコマンドcommand `self-insert-command`にバインドするので、自己挿入を行なうのです。`C-a`のような標準的なEmacsの編集文字もグローバルキーマップから、それらの標準的な意味を取得します。`M-x
global-set-key`のような、キーをリバインドするコマンドは、新しいバインディングをグローバルマップの適切な位置に保存することにより機能します([Rebinding](#Rebinding)を参照してください)。

function key
ほとんどの現代的なキーボードは、文字キーと同じようにファンクションキーをもちます。ファンクションキーは文字キーが行なうように入力イベントを送り、キーマップはファンクションキーにたいするバインディングをもつことができます。キーシーケンスにはファンクションキーと文字をミックスすることもできます。たとえば、キーボードにファンクションキーHomeがある場合、Emacsは`C-x
Home`のようなキーシーケンスを認識できます。`S-down-mouse-1`のように、マウスイベントとキーボードイベントをミックスすることさえ可能です。

テキスト端末では、ファンクションキーをタイプすることにより、文字シーケンスがコンピューターに送られます。シーケンスの正確な詳細は、ファンクションキーと端末タイプに依存します(シーケンスが`ESC
[`で始まることもしばしばあります)。Emacsが端末タイプを理解する場合、自動的にそのようなシーケンスを1つの入力イベントとして処理します。

### プレフィクスキーマップ

内部的には、Emacsは各キーマップの1つのイベントだけを記録します。複数イベントのキーシーケンスの解釈は、キーマップの連鎖を生じます。最初のイベントにたいして最初のキーマップが定義を与え、シーケンス内の2番目のイベントを探すのに他のキーマップが使用され...と連鎖していきます。したがって`C-x`やESCなどのプレフィクスキーは独自のキーマップをもち、それらはプレフィクスの直後のイベントにたいする定義を保持します。

プレフィクスキーの定義は通常、それに続くイベントを探すのに使用するキーマップです。プレフィクスキーの定義として、関数定義がキーマップであるようなLispシンボルを指定することもできます。効果は同じですが、そのプレフィクスキーが何のためなのか説明するためのコマンド名を提供します。たとえば、`C-x`のバインディングはシンボル`Control-X-prefix`で、このシンボルの関数定義は、`C-x`コマンドにたいするキーマップです。プレフィクスキーとしての`C-c`、`C-x`、`C-h`、ESCは、グローバルキーマップに定義されているので、これらのプレフィクスキーは常に利用できます。

通常のプレフィクスキー以外に、“架空のプレフィクスキー(fictitious prefix key)”もあり、これらはメニューバーを表します。メニューバーのキーバインディングについての特別な情報は、section “Menu Bar” in The Emacs Lisp Reference Manualを参照してください。ポップアップメニューを呼び出すマウスボタンイベントもプレフィクスキーです。詳細については、section “Menu Keymaps” in The Emacs Lisp Reference Manualを参照してください。

いくつかのキーマップは、名前のついた変数に格納されています:

-   ctl-x-map
    `ctl-x-map`は、`C-x`の後の文字に使用されるマップにたいする変数名です。

-   help-map
    `help-map`は。`C-h`の後の文字のためのマップです。

-   esc-map
    `esc-map`は、ESCの後の文字のためのマップです。したがって、すべてのメタ文字がこのマップで定義されています。

-   ctl-x-4-map
    `ctl-x-4-map`は、`C-x 4`の後の文字のためのマップです。

-   mode-specific-map
    `mode-specific-map`は、`C-c`の後の文字のためのマップです。

### ローカルキーマップ

local keymap
minor mode keymap
ここまではグローバルマップの詳細を説明してきました。メジャーモードは、ローカルキーマップ(local keymaps)で独自のキーバインディングを提供することにより、Emacsをカスタマイズします。たとえばCモードは、C言語のためにカレント行をインデントするために、TABをオーバーライドします。マイナーモードもローカルキーマップをもつことができます。マイナーモードが効力をもつとき、マイナーモードのキーマップの定義は、メジャーモードのローカルキーマップとグローバルキーマップの両方をオーバーライドします。それに加えて、バッファーの一部のテキストに、他のすべてのキーマップをオーバーライドする独自のキーマップを指定できます。

ローカルキーマップは、あるキーをプレフィクスキーマップとして定義することにより、そのキーをプレフィクスキーとして再定義できます。そのキーがグローバルでもプレフィクスとして定義されている場合、そのキーのグローバルおよびローカルの定義(両方のキーマップ)が、相乗して効果をもちます。つまりプレフィクスキーに続くイベントを探すのに、両方の定義が使用されます。たとえばローカルキーマップが`C-c`をプレフィクスキーマップとして定義し、そのキーマップが`C-z`をコマンドとして定義する場合、これは`C-c
C-z`にローカルな意味を提供します。これは`C-c`で始まる他のシーケンスには影響を与えません。これらのシーケンスが独自のローカルバインディングをもたない場合、グローバルバインディングが効果をもちます。

これを別の方法で考えると、Emacsはキーシーケンス全体のバインディングにたいして、複数のキーマップを1つずつ探して、複数イベントキーシーケンスを処理すると考えることができます。最初にマイナーモードが有効な場合はマイナーモードのキーマップをチェックして、次にメジャーモードのキーマップをチェックして、それからグローバルキーマップをチェックするのです。これはキーの照合が機能する正確な方法ではありませんが、通常の場面における結果を理解するには充分です。

### ミニバッファーキーマップ

minibuffer keymaps
minibuffer-local-map
minibuffer-local-ns-map
minibuffer-local-completion-map
minibuffer-local-must-match-map
minibuffer-local-filename-completion-map
minibuffer-local-filename-must-match-map
ミニバッファーは独自のローカルキーマップのセットをもちます。これにはさまざまな補完やexitコマンドが含まれます。

-   `minibuffer-local-map`は、通常の入力(補完なし)に使用されます。

-   `minibuffer-local-ns-map`は同様ですが、SPCでRETと同じようにexitします。

-   `minibuffer-local-completion-map`は、寛大な補完(permissive completion)のためのキーマップです。

-   `minibuffer-local-must-match-map`は、強い補完(strict completion)と慎重な補完(cautious completion)のためのキーマップです。

-   `minibuffer-local-filename-completion-map`と`minibuffer-local-filename-must-match-map`は、前の2つと同様ですが、特にファイル名補完のためのキーマップです。これらはSPCをバインドしません。

### 対話的なキーバインディングの変更

key rebinding, this session
redefining keys, this session
binding keys
Emacsがキーを再定義する方法は、キーマップのそのキーのエントリーを変更する方法です。グローバルキーマップを変更できます。この場合すべてのメジャーモードで変更が効果をもちます(ただし同じキーにたいしてそれをオーバーライドする独自のローカルバインディングをもつ場合を除きます)。ローカルキーマップを変更することもできます。これは同じメジャーモードを使用するすべてのバッファーに効果があります。

このセクションでは、現在のEmacsセッションでキーをリバインドする方法を説明します。将来のEmacsセッションで効果をもつようにキーをリバインドする方法については、[Init Rebinding](#Init-Rebinding)を参照してください。

global-set-key
local-set-key
global-unset-key
local-unset-key
`M-x global-set-key RET key cmd RET`  
cmdを実行するkeyをグローバルに定義します。

`M-x local-set-key RET key cmd RET`  
cmdを実行するkeyを、(そのとき効力をもつメジャーモードで)ローカルに定義します。

`M-x global-unset-key RET key`  
グローバルマップでkeyを未定義にします。

`M-x local-unset-key RET key`  
(そのとき効力をもつメジャーモードで)ローカルにkeyを未定義にします。

たとえば以下は、通常の`C-z`にたいするグローバルな定義を置き換えて、`C-z`を`shell`コマンド([Interactive Shell](#Interactive-Shell)を参照してください)にバインドします:

    M-x global-set-key RET C-z shell RET

`global-set-key`コマンドは、キーの後にコマンド名を読み取ります。キーを押した後、以下のようなメッセージが表示されるので、そのキーにバインドしたいコマンドを入力できます:

    Set key C-z to command:

ファンクションキーとマウスイベントも同じ方法で再定義できます。リバインドするキーを指定するときに、ファンクションキーをタイプするか、マウスをクリックするだけです。

複数のイベントを含むキーも、同じ方法で再定義できます。Emacsは、(プレフィクスキーではない)完了キーまで、リバインドするキーの読み取りを続けます。したがってkeyに`C-f`をタイプすると、それで完了です。これによりミニバッファーに入って、すぐにcmdを読み取ります。しかし`C-x`をタイプした場合、これはプレフィクスなので、他の文字を読み取ります。それが`4`の場合、これもプレフィクス文字なので、さらに文字を読み取ります。たとえば、

    M-x global-set-key RET C-x 4 $ spell-other-window RET

これは、(架空のコマンド)`spell-other-window`を実行するように、`C-x 4 $`を再定義します。

`global-unset-key`で、キーのグローバルな定義を削除できます。これはそのキーを未定義(undefined)にします。その後このキーをタイプしても、Emacsはビープ音を鳴らすだけです。同様に`local-unset-key`は、カレントメジャーモードのキーマップでキーを未定義にして、メジャーモードにおいて、そのキーにたいするグローバル定義(またはグローバル定義に無い状態)が有効になります。

あるキーを再定義(または未定義に)してから、後でその変更を取り消したくなった場合、キーを未定義にしても上手くいきません — そのキーを標準の定義に再定義する必要があります。そのキーの標準の定義の名前を見つけるには、フレッシュなEmacsのFundamentalモードで、`C-h
c`を使用します。このマニュアルのキーのドキュメントにも、それらのコマンド名がリストされています。

間違ってコマンドを呼び出すことから自分を守りたい場合、そのキーを未定義にするより、コマンドを無効にするほうがよいでしょう。無効にされたコマンドは、実際にそれを実行したくなったとき、少しの手間で呼び出すことができます。[Disabling](#Disabling)を参照してください。

### initファイル内でのキーのリバインド

rebinding major mode keys
key rebinding, permanent
rebinding keys, permanently
いつでも使いたいキーバインドがある場合、初期化ファイルにLispコードを記述することにより、それらを指定できます。初期化ファイルの説明については、[Init File](#Init-File)を参照してください。

kbd
Lispを使用してキーバインディングを記述するには、いくつかの方法があります。一番簡単なのは`kbd`関数を使う方法で、これはキーシーケンスのテキスト表現 — このマニュアルでキーシーケンスを記述するのと同様な方法 — を、`global-set-key`の引数として渡す形式に変換します。たとえば以下は、`C-z`を`shell`コマンド([Interactive Shell](#Interactive-Shell)を参照してください)にバインドする方法の例です:

    (global-set-key (kbd "C-z") 'shell)

コマンド名`shell`の前のシングルクォートは、それを変数ではなくシンボル定数としてマークします。クォートを省略した場合、Emacsは`shell`を変数として評価しようとします。これはおそらくエラーを引き起こし、もちろんあなたはそれを望まないはずです。

以下に、ファンクションキーやマウスイベントなどを含めた、追加の例を示します:

    (global-set-key (kbd "C-c y") 'clipboard-yank)
    (global-set-key (kbd "C-M-q") 'query-replace)
    (global-set-key (kbd "<f5>") 'flyspell-mode)
    (global-set-key (kbd "C-<f5>") 'display-line-numbers-mode)
    (global-set-key (kbd "C-<right>") 'forward-sentence)
    (global-set-key (kbd "<mouse-2>") 'mouse-save-then-kill)

`kbd`を使うかわりに、キーシーケンスの指定にLisp文字列やベクターを使用することができます。文字列を使用するのは単純ですが、これはASCII文字とメタ修飾されたASCII文字だけで機能します。たとえば以下は、`C-x
M-l`を`make-symbolic-link`([Copying and Naming](#Copying-and-Naming)を参照)にバインドする方法の例です:

    (global-set-key "\C-x\M-l" 'make-symbolic-link)

TAB、RET、ESC、DELを含むキーシーケンスにバインドするには、文字列はEmacs Lispのエスケープシーケンス‘`\t`’、‘`\r`’、‘`\e`’、‘`\d`’を含むべきです。以下は、`C-x
TAB`を`indent-rigidly`([Indentation](#Indentation)を参照)にバインドする例です:

    (global-set-key "\C-x\t" 'indent-rigidly)

キーシーケンスがファンクションキーやマウスボタンイベント、または`C-=`や`H-a`のような非ASCII文字を含む場合、キーシーケンスを指定するのにベクターを使用することができます。ベクター内の各要素は入力イベントを意味します。要素はスペースで区切られ、一対の角カッコ(square brackets)で囲まれます。ベクターの要素が文字の場合は、それをLisp文字定数、つまり‘`?`’の後ろにその文字を、文字列内で表記されるような方法で記述します。ファンクションキーはシンボルで表され([Function Keys](#Function-Keys)を参照してください)、他の区切り文字や句読点なしで、単にシンボル名を記述します。以下に例をいくつか示します:

    (global-set-key [?\C-=] 'make-symbolic-link)
    (global-set-key [?\M-\C-=] 'make-symbolic-link)
    (global-set-key [?\H-a] 'make-symbolic-link)
    (global-set-key [f7] 'make-symbolic-link)
    (global-set-key [C-mouse-1] 'make-symbolic-link)

単純な場合でもベクターを使用できます:

    (global-set-key [?\C-z ?\M-l] 'make-symbolic-link)

非ASCII文字にたいするキーバインディングは、言語とコーディングシステムに問題を起こすかもしれません。 [Init Non-ASCII](#Init-Non_002dASCII)を参照してください。

[Local Keymaps](#Local-Keymaps)で説明したように、メジャーモードとマイナーモードはローカルキーマップを定義できます。これらのキーマップは、セッションで最初にそのモードが使用されるときに構築されます。これらのキーマップを変更したい場合は、モードフック(mode hook)を使用しなければなりません([Hooks](#Hooks)を参照してください)。

define-key
たとえばTexinfoモードは、フック`texinfo-mode-hook`を実行します。以下はTexinfoモードで、`C-c
n`と`C-c p`にローカルバインディングを追加するために、どのようにフックを使用できるかの例です:

    (add-hook 'texinfo-mode-hook
              (lambda ()
                (define-key texinfo-mode-map "\C-cp"
                            'backward-paragraph)
                (define-key texinfo-mode-map "\C-cn"
                            'forward-paragraph)))

### 修飾キー

modifier keys, and key rebinding
Emacsでは、デフォルトのキーバインディングがセットアップされているので、修飾されたアルファベット文字は大文字小文字が区別されません。つまり`C-A`は`C-a`と同じことを行い、`M-A`は`M-a`と同じことを行ないます。これはアルファベット文字だけに当てはまり、他のキーのシフトキーが押された(shifted)バージョンには適用されません。たとえば、`C-@`は`C-2`と同じではありません。

Control修飾されたアルファベット文字は、常に大文字小文字が区別されません。Emacsは常に`C-A`を`C-a`、`C-B`を`C-b`、...として扱います。これは歴史的な理由によります。

他の修飾キーでは、Emacsをカスタマイズするとき修飾されたアルファベットの大文字小文字を区別するようにできます。たとえば`M-a`と`M-A`で別のコマンドを実行できます。

一般的に使用される修飾キーはControlとMetaだけですが、Emacsは他の修飾キーもサポートします。これらはSuper、Hyper、Altと呼ばれます。これらの修飾キーを使用する方法を提供する端末の数は多くありません。ほとんどのキーボードでAltとラベルされたキーは、通常はAltではなくMeta修飾を発行します。Emacsの標準のキーバインディングでは、これらのキーで修飾された文字は含まれません。しかしこれらに意味を割り当てるようにEmacsをカスタマイズできます。修飾ビットは、それぞれ‘`s-`’、‘`H-`’、‘`A-`’になります。

これらの追加的な修飾キーがキーボードになくても、`C-x @`を使用して入力できます。`C-x @
h`はHyperフラグ、`C-x @ s`はSuperフラグ、`C-x @
a`はAltフラグを次の文字に加えます。たとえば`Hyper-Control-a`を入力するには、`C-x @ h
C-a`とタイプします(残念なことに同じ文字にたいして`C-x
@`を使用して、2つの修飾を追加する方法はありません。なぜなら最初の1つは2回目の`C-x`にたいして作用するからです)。

### ファンクションキーのリバインド

キーシーケンスには、通常の文字と同じようにファンクションキーを含めることができます。Lisp文字(実際は整数です)がキーボードの文字を表すように、Lispシンボルはファンクションキーを表します。ファンクションキーのラベルに示された単語が、それにタイプするLispシンボルの名前になります。以下は一般的なファンクションキーにたいする、慣例的なLisp名です:

`left`、`up`、`right`、`down`  
カーソル矢印キーです。

`begin`、`end`、`home`、`next`、`prior`  
その他のカーソルを再配置するキーです。

`select`、`print`、`execute`、`backtab`; `insert`、`undo`、`redo`、`clearline`; `insertline`、`deleteline`、`insertchar`、`deletechar`  
その他のファンクションキーです。

`f1`、`f2`、…、`f35`  
(キーボード上部にある)番号つきのファンクションキーです。

`kp-add`、`kp-subtract`、`kp-multiply`、`kp-divide`; `kp-backtab`、`kp-space`、`kp-tab`、`kp-enter`; `kp-separator`、`kp-decimal`、`kp-equal`; `kp-prior`、`kp-next`、`kp-end`、`kp-home`; `kp-left`、`kp-up`、`kp-right`、`kp-down`; `kp-insert `、`kp-delete`  
(標準的なキーボードでは右側にある)キーパッドの名前や句読点のキーです。

`kp-0`、`kp-1`、…、`kp-9`  
キーパッドの数字キーです。

`kp-f1`、`kp-f2`、`kp-f3`、`kp-f4`  
キーパッドのPFキーです。

これらの名前は便利ですが、いくつかのシステム(特にXを使用するシステム)では、異なる名前を使用するかもしれません。端末のファンクションキーにたいして、どのシンボルが使用されているか確認するには、`C-h
c`とタイプして、その後にそのファンクションキーを入力してください。

ファンクションキーにバインドする例については、[Init Rebinding](#Init-Rebinding)を参照してください。

keypad
多くのキーボードの右手側には、テンキーボード(numeric keypad)があります。キーパッドのテンキーは‘`Num
Lock`’とラベルされたキーで切り替えるにことにより、カーソル移動キーにもなります。デフォルトでは、Emacsはこれらのキーを、メインのキーボードの対応するキーに変換します。たとえば‘`Num
Lock`’がオンの場合、テンキーのlabeled ‘`8`’のラベルがついたキーは`kp-8`を生成し、これは`8`に変換されます。また‘`Num
Lock`’がオフの場合、このキーは`kp-up`を生成し、これはUPに変換されます。`8`やUPのようなキーをリバインドした場合、それはキーパッドの対応するキーにも影響します。しかし直接‘`kp-`’をリバインドした場合、これはメインのキーボードの等価なキーに影響を与えません。修飾されたキーは変換されないことに注意してください。たとえばMetaキーを押したまま、テンキーの‘`8`’を押すと、これは`M-kp-8`を生成します。

Emacsは変数`keypad-setup`、`keypad-numlock-setup`、`keypad-shifted-setup`、`keypad-numlock-shifted-setup`を使用することにより、テンキーのキーをバインドするための便利な方法を提供します。これらの変数は‘`keyboard`’カスタマイズグループで見つけることができます([Easy Customization](#Easy-Customization)を参照してください)。キーをリバインドして、数引数を発行するなど、他のタスクを行なうことができます。

### 名前のあるASCIIコントロール文字

当初TAB、RET、BS、LFD、ESC、DELは、特定のASCIIコントロール文字の名前として使用され、多用されるために自身の特別なキーをもつようになりました。たとえばTABは`C-i`の別の名前です。その後、ユーザーはEmacsでこれらのキーと、Ctrlキーと一緒にタイプするコントロール文字を区別できると便利なことに気づきました。したがってほとんどの現代的な端末では、これらは同じではありません。つまりTABは`C-i`と異なります。

これら2種類の入力を、キーボードが区別するなら、Emacsも区別することができます。Emacsは特別なキーを`tab`、`return`、`backspace`、`linefeed`、`escape`、`delete`という名前のファンクションキーとして扱います。これらのファンクションキーは、そのキー自体に何もバインドされていない場合は、対応するASCII文字に自動的に変換されます。結果として、ユーザーもLispプログラマーも、彼らがそうしたいと望まない限りは、これらの区別に注意を払う必要はありません。

(たとえば)TABと`C-i`を区別したくない場合は、ASCII文字のTAB(8進コード011)だけにたいしてバインディングを1つ指定します。これらを区別したいときは、ASCII文字にたいして1つのバインディング、ファンクションキーの`tab`にたいして別のバインディングを指定します。

通常のASCII端末では、TABと`C-i`(および同じような他のペアー)を区別する方法はありません。なぜなら端末はどちらの場合も同じ文字を送るからです。

### マウスボタンのリバインド

mouse button events
rebinding mouse buttons
click events
drag events
down events
button-down events
Emacsはマウスボタンを表すためにもLispシンボルを使用します。Emacsで通常のマウスイベントは、クリック(click)イベントです。これはボタンを押して、マウスを移動せずにボタンを離すと発生します。ドラッグ(drag)イベントも取得できます。これはボタンを押したままマウスを移動したとき発生します。ドラッグイベントは、最後にボタンを離したときにも発生します。

基本的なクリックイベントにたいするシンボルは、一番左のボタンが`mouse-1`、次が`mouse-2`、…となります。以下は、カレントウィンドウを2番目のマウスボタンで分割するように再定義する方法です:

    (global-set-key [mouse-2] 'split-window-below)

ドラッグイベントにたいするシンボルも同様ですが、単語‘`mouse`’の前にプレフィクス‘`drag-`’がつきます。たとえば左ボタンでのドラッグは`drag-mouse-1`イベントを生成します。

マウスボタンが押されたときに発生するイベントにたいして、バインディングを定義することもできます。これらのイベントは‘`drag-`’ではなく‘`down-`’で始まります。このようなイベントは、それらにキーがバインドされているときだけ生成されます。ボタンダウンイベントを受け取った場合、その後に常にそれに対応するクリックまたはドラッグイベントが続きます。

double clicks
triple clicks
もし望むならシングルクリック、ダブルクリック、トリプルクリックを区別することもできます。ダブルクリックとは、マウスボタンをほぼ同じ場所で2回クリックすることを意味します。最初のクリックは通常のクリックイベントを生成します。2回目のクリックが充分早ければ、かわりにダブルクリックイベントを生成します。ダブルクリックイベントにたいするイベントタイプは、たとえば`double-mouse-3`のように、‘`double-`’で始まります。

これは同じ場所での2回目のクリックに特別な意味を与えることができることを意味しますが、それは最初のクリックを受け取ったときに実行される、通常のシングルクリックにたいする定義も実行されることを前提にしなければなりません。

これはダブルクリックで行なえることを制限しますが、ユーザーインターフェースデザイナーはこの制限は任意のケースにおいて従うべき制限だと言います。ダブルクリックは、シングルクリックで行なう何かを、よりもっと行なうためのものであるべきです。ダブルクリックイベントにたいするコマンドは、ダブルクリックにたいして追加の作業を処理するべきです。

ダブルクリックイベントにバインディングがない場合、これは対応するシングルクリックイベントに変化します。したがって、特にダブルクリックイベントを定義していない場合、これはシングルクリックコマンドを2回実行します。

Emacsはトリプルクリックイベントもサポートし、それらの名前は‘`triple-`’で始まります。Emacsはクワドループルクリック(quadruple clicks: 4連クリック)をイベントタイプとして区別しません。3回目以降のクリックは、追加のトリプルクリックイベントを生成します。しかしクリックされた数はすべてイベントリストに記録されるので、Emacs Lispを知っていて、本当にそれを使いたい場合はそれらを区別できます(section “Click Events” in The Emacs Lisp Reference Manualを参照してください)。わたしたちは3連クリックを超えるクリックに明確な意味を与えるのは推奨しませんが、連続するクリックが同じ3つの意味のセットを巡回する — たとえば4連クリックは1クリックに等しく、5連クリックは2連クリックに等しく、6連クリックは3連クリックに等しい、とするのが便利なときがあるかもしれません。

Emacsはドラッグおよびボタンダウンイベントで、複数回ボタンが押されたことも記録します。たとえば、ボタンを2回押して、それからボタンを押したままマウスを移動した場合、Emacsは‘`double-drag-`’イベントを受け取ります。2回目にボタンを押した瞬間、Emacsは‘`double-down-`’イベントを受け取ります(そしてすべてのボタンダウンイベントと同様に、なにもバインドされていなければ無視されます)。

double-click-time
変数`double-click-time`は、複数回のクリックをグループ化するのに、クリックの間にどれだけの時間経過を許すかを指定します。変数の値の単位はミリ秒です。値が`nil`の場合、ダブルクリックは検知されません。値が`t`の場合、時間の制限はありません。デフォルトは500です。

double-click-fuzz
変数`double-click-fuzz`は、複数回のクリックをグループ化するのに、クリックの間にどれだけマウスが移動できるかを指定します。変数の値はウィンドウ化されたディスプレーではピクセル単位で、テキストモード端末では文字セルの1/8を単位とし、デフォルトは3です。

マウスイベントにたいするシンボルは、修飾キーの状態も示し、‘`C-`’、‘`M-`’、‘`H-`’、‘`s-`’、‘`A-`’、‘`S-`’のプレフィクスが通常つきます。‘`double-`’や‘`triple-`’は常に‘`drag-`’や‘`down-`’の前にきますが、これらのプレフィクスは常にそれより前にきます。

フレームにはバッファーのテキストを表示しない、モードラインやスクロールバーのような領域が含まれます。スクリーンの特別な領域でマウスボタンが押されたかどうかは、ダミーのプレフィクスキーで知ることができます。たとえばモードラインでマウスをクリックした場合、通常のマウスボタンシンボルの前にプレフィクスキー`mode-line`を受け取ります。したがって、以下はモードラインで左ボタンをクリックしたときに`scroll-up-command`を実行する方法です:

    (global-set-key [mode-line mouse-1] 'scroll-up-command)

以下はダミーのプレフィクスキーと、その意味の完全なリストです:

`mode-line`  
マウスはウィンドウのモードラインにあります。

`vertical-line`  
マウスは横に並んだウィンドウを分ける垂直ラインにあります(スクロールバーを使用している場合は、垂直ラインに表示されます)。

`vertical-scroll-bar`  
マウスは垂直スクロールバーにあります(これはEmacsが現在サポートしているスクロールバーにたいしてだけです)。

`menu-bar`  
マウスはメニューバーにあります。

`header-line`  
マウスはヘッダーラインにあります。

キーシーケンスにマウスボタンを複数配することもできますが、これは通常行なわれません。

### コマンドの無効化

disabled command
コマンドを無効にするとは、そのコマンドを対話的に呼び出しユーザーに確認を求めることを意味します。コマンドを無効にする目的は、ユーザーが間違ってコマンドを実行するのを防ぐためです。わたしたちは初心者を混乱させるようなコマンドにたいして、これを行なっています。

無効なコマンドを呼び出そうとすると、Emacsはコマンド名、コマンドのドキュメント、すぐに何を行なうかの手引きを対話的に表示します。その後、Emacsはコマンドを要求されたとおり実行するか、そのコマンドを有効にしてから実行するか、キャンセルするか入力を求めます。コマンドを有効にすると決めた場合は、他の質問 — 永続的に有効にするか、それともカレントセッションでだけ有効にするか — にも応えなければなりません(永続的に有効にする場合、これは自動的に初期化ファイルを編集することにより機能します)。`!`とタイプして、カレントセッションだけにたいして、*すべて*のコマンドを有効にすることもできます。

コマンド無効化の直接的なメカニズムは、コマンドにたいするLispシンボルの`disabled`プロパティーに非`nil`をputすることです。以下はこれを行なうLispプログラムです:

    (put 'delete-region 'disabled t)

`disabled`プロパティーの値が文字列の場合、その文字列はコマンドが使用されたときに表示されるメッセージに含まれます。

    (put 'delete-region 'disabled
         "It's better to use `kill-region' instead.\n")

disable-command
enable-command
初期化ファイルを直接編集するか、初期化ファイルを編集する`M-x
disable-command`コマンドにより、コマンドを無効にできます。同様に`M-x
enable-command`はコマンドを永続的に有効にするために、初期化ファイルを編集します。[Init File](#Init-File)を参照してください。

Emacsが`-q`または`--no-init-file`オプション([Initial Options](#Initial-Options)を参照してください)で呼び出された場合、これらのコマンドは初期化ファイルを編集しません。Emacsは初期化ファイルを読み込んでいないので、これを行なうと情報が失われるかもしれないからです。

コマンドが無効にされているかどうかは、それを呼び出すのに使用されるキーとは独立しています。`M-x`を使用してコマンドを呼び出しても、無効化は適用されます。しかしLispプログラムから関数として呼び出す場合、コマンドの無効化は効力をもちません。

Emacs初期化ファイル
-------------------

init file
.emacs file
~/.emacs file
Emacs initialization file
startup (init file)
Emacsを開始したとき、Emacsは通常、初期化ファイル(initialization file)、短くはinitファイルから、Lispプログラムのロードを試みます。このファイルは、もし存在する場合は、Emacsをどのように初期化するかを指定します。Emacsはファイル名`~/.emacs`、`~/.emacs.el`、`~/.emacs.d/init.el`を使用してinitファイルを探します。これら3つのファイル名から、使用するものを選択できます([Find Init](#Find-Init)を参照してください)。ここで`~/`は、ホームディレクトリーを意味します。

コマンドラインスイッチ‘`-q`’により、initファイルのロードを抑止でき、‘`-u`’ (または‘`--user`’)で、別のユーザーのinitファイルを指定できます([Initial Options](#Initial-Options)を参照してください)。

default.el
, the default init file
デフォルトinitファイルが存在する場合もあります。これは`default.el`という名前のライブラリーで、ライブラリーにたいする標準の検索パスから探されます。Emacsディストリビューションには、そのようなライブラリーは含まれていませんが、あなたのサイトは、ローカルなカスタマイズのためにこれを作成しているかもしれません。このライブラリーが存在する場合、Emacsを開始したときは常にこれがロードされます(ただし‘`-q`’を指定した場合は除きます)。しかしinitファイルがあれば、それが最初にロードされるので、そこで`inhibit-default-init`に非`nil`をセットすれば、`デフォルトinitファイル`はロードされません。

site init file
site-start.el
, the site startup file
あなたのサイトにはサイトスタートアップファイル(site startup file)もあるかもしれません。もし存在する場合、これは`site-start.el`という名前です。`default.el`と同様に、Emacsはこのファイルを、Lispライブラリーにたいする標準の検索パスから探します。Emacsはこのライブラリーをinitファイルの前にロードします。このライブラリーのロードを抑止するには、オプション‘`--no-site-file`’を使用します。[Initial Options](#Initial-Options)を参照してください。わたしたちは何かを変更する場合、`site-start.el`の使用を推奨しません。これを好まないユーザーもいるからです。変更を`default.el`に記述すれば、ユーザーはもっと簡単にそれをオーバーライドできます。

site-lisp
directories
`default.el`や`site-start.el`は、EmacsがLispライブラリーを検索する任意のディレクトリーに配置できます。変数`load-path` ([Lisp Libraries](#Lisp-Libraries)を参照してください)は、これらのディレクトリーを指定します。多くのサイトはこれらのファイルを、Emacsのインストールディレクトリーの中の、`site-lisp`(たとえば`/usr/local/share/emacs/site-lisp`)に配置します。

initファイルにたいするバイトコンパイル(section “Byte Compilation” in the Emacs Lisp Reference Manualを参照してください)は推奨されていません。一般的にこれは開始時のスピードの大幅な改善はせず、ファイルをリコンパイルするのを忘れたときに問題を起こすことが多いのです。よりよい解決策は、Emacsサーバー([Emacs Server](#Emacs-Server)を参照してください)を使用して、Emacsを開始する回数を減らすことです。initファイルで多くの関数を定義している場合、これらを(バイトコンパイルされた)別のファイルに移動して、それをinitファイルでロードします。

マイナーなカスタマイズを超えるような、実際のEmacs Lispプログラムを記述するつもりなら、Emacs Lisp Reference Manualを読むべきでしょう。 section “Emacs Lisp” in the Emacs Lisp Reference Manualを参照してください。

### initファイルの構文

initファイルには、1つ以上のLisp式が含まれています。式のそれぞれは引数をともなう関数名で、それらはすべてカッコで括られています。たとえば`(setq
fill-column
60)`は、変数`fill-column`([Filling](#Filling)を参照してください)を60にセットするために、関数`setq`を呼び出します。

`setq`で任意のLisp変数をセットできますが、`.emacs`の特定の変数にたいして、`setq`は多分あなたの望むとおりには動作しないでしょう。いくつかの変数は`setq`でセットしたとき、自動的にバッファーローカルになります。あなたが望むのは、`.emacs`でデフォルト値をセットすることなので、`setq-default`を使用します。マイナーモードのカスタマイズ可能な変数のいくつかは、それをCustomizeでセットすると、そのモードを有効にするために特別なことを行ないますが、通常の`setq`ではそれを行ないません。`.emacs`ファイルでモードを有効にするには、マイナーモードコマンドを呼び出します。以下のセクションには、これらの両方の方法の例があります。

`setq`の2番目の引数は、変数にたいする新しい値の式です。これには、定数、変数、関数呼び出し式を指定できます。`.emacs`では、定数が使用される場合がほとんどです。これは以下のとおりです:

数字:  
数字は10進で記述され、オプションで最初にマイナス記号がある場合があります。

文字列:  
Lisp string syntax

string syntax

Lispの文字列構文は、少数の例外を除き、Cの文字列構文と同じです。文字列定数の開始と終了にはダブルクォートを使用します。

文字列には改行を含む、特別なリテラル文字を含めることができます。しかし、それらにたいして、バックスラッシュシーケンスを使う方が明確になる場合が多くあります。改行は‘`\n`’、バックスペースは‘`\b`’、キャリッジリターンは‘`\r`’、タブは‘`\t`’、フォームフィード(control-L)は‘`\f`’、エスケープは‘`\e`’、バックスラッシュは‘`\\`’、ダブルクォートは‘`\"`’、そして8進コードがoooの文字は‘`\ooo`’です。バックスラッシュとダブルクォートだけは、バックスラッシュシーケンスが必須な文字です。

‘`\C-`’はコントロール文字のプレフィクスとして使用でき、‘`\C-s`’はASCIIのcontrol-Sです。‘`\M-`’はメタ文字のプレフィクスとして使用でき、‘`\M-a`’は`Meta-A`で、‘`\M-\C-a`’は`Ctrl-Meta-A`です。

initファイルに非ASCII文字を含めるための情報は、[Init Non-ASCII](#Init-Non_002dASCII)を参照してください。

文字:  
Lisp character syntax

character syntax

Lispの文字定数の構文は、たとえば`?x`、`?\n`、`?\"`、`?\)`のように、文字‘`?`’と、その後ろに文字または‘`\`’で始まるエスケープシーケンスからなります。Lispでは、文字列と文字は置き換え可能ではないことに注意してください。あるコンテキストでは一方が、他のコンテキストでは他方が要求されます。

非ASCII文字を送るキーにコマンドをバインドする情報については、[Init Non-ASCII](#Init-Non_002dASCII)を参照してください。

True:  
`t`は“true(真)”という意味です。

False:  
`nil`は“false(偽)”という意味です。

その他のLispオブジェクト:  
Lisp object syntax

シングルクォートに続けてLispオブジェクトを記述します。

### initファイルの例

以下はLisp式で一般的に行ないたいような事柄の例です:

-   変数`load-path`にディレクトリーを追加します。その後、Emacsに含まれていないLispライブラリーをそのディレクトリーに配置すれば、`M-x
    load-library`でそれらをロードすることができます。[Lisp Libraries](#Lisp-Libraries)を参照してください。

        (add-to-list 'load-path "/path/to/lisp/libraries")

-   Cモードで、ポイントが行の途中にある場合、TABが単にタブを挿入するようにします。

        (setq c-tab-always-indent nil)

    個の例では、変数の通常の値が`t`、つまり“true”の変数の値を、`nil`つまり“false”にしています。

-   (この設定をオーバーライドしないすべてのバッファーで)検索のデフォルトを、大文字小文字を区別させるようにします。

        (setq-default case-fold-search nil)

    これはデフォルト値をセットし、この変数にたいするローカル値([Locals](#Locals)を参照してください)をもたないすべてのバッファーに効果を及ぼします。`case-fold-search`を`setq`でセットした場合は、カレントバッファーだけに効果があり、それは多分あなたがinitファイルで行ないたいことではないはずです。

-   user-mail-address, in init file
    Emacsがあなたのメールアドレスを正しく推測できない場合、メールアドレスを指定します。

        (setq user-mail-address "cheney@torture.gov")

    Messageモードのような、さまざまなEmacsパッケージは、メールアドレスを知る必要がある場合に、`user-mail-address`を参照します。[Mail Headers](#Mail-Headers)を参照してください。

-   新しいバッファーにたいするデフォルトのモードをTextモードにします。

        (setq-default major-mode 'text-mode)

    Textモードに入るコマンドに`text-mode`が使用されていることに注意してください。前のシングルクォートはシンボルを定数にしています。そうしない場合、`text-mode`は変数名として扱われます。

-   西ヨーロッパのほとんどの言語をサポートするLatin-1文字を、デフォルトにセットアップします。

        (set-language-environment "Latin-1")

-   グローバルなマイナーモードのLine Numberモードをオフに切り替えます。

        (line-number-mode 0)

-   Textモードと関連するモードで、自動的にAuto Fillモードをオンに切り替えます([Hooks](#Hooks)を参照してください)。

        (add-hook 'text-mode-hook 'auto-fill-mode)

-   インストールされた`foo`という名前のライブラリー(実際には標準のEmacsディレクトリーの`foo.elc`または`foo.el`というファイル)をロードします。

        (load "foo")

    `load`の引数が、‘`/`’や‘`~`’で始まらない相対ファイル名の場合、`load`は`load-path`のディレクトリーを検索します([Lisp Libraries](#Lisp-Libraries)を参照してください)。

-   ホームディレクトリーの、コンパイルされたLispファイル`foo.elc`をロードします。

        (load "~/foo.elc")

    ここでは完全なファイル名が使用されているので、検索は行なわれません。

-   loading Lisp libraries automatically
    autoload Lisp libraries
    `mypackage`という名前のLispライブラリー(たとえば`mypackage.elc`や`mypackage.el`というファイル)をロードすることにより、関数`myfunction`の定義を探すようEmacsに指示します。

        (autoload 'myfunction "mypackage" "Do what I say." t)

    ここで文字列`"Do what I
    say."`は、この関数のドキュメント文字列です。これを`autoload`定義の中で指定することにより、そのパッケージがロードされていなくてもヘルプコマンドで利用可能になります。最後の引数`t`は、この関数がinteractive(対話的)であることを示します。つまり、この関数は`M-x
    myfunction
    RET`とタイプするか、キーにバインドすることにより、対話的に呼び出すことができます。関数がinteractiveでない場合は、`t`を省略するか、`nil`を使用します。

-   関数`make-symbolic-link`を実行するように、キー`C-x l`をリバインドします([Init Rebinding](#Init-Rebinding)を参照してください)。

        (global-set-key "\C-xl" 'make-symbolic-link)

    または

        (define-key global-map "\C-xl" 'make-symbolic-link)

    繰り返しになりますが、シングルクォートは`make-symbolic-link`を変数として値を参照するのではなく、シンボルとして参照するために使用されることに注意してください。

-   Lispモードだけで、同じことを行ないます。

        (define-key lisp-mode-map "\C-xl" 'make-symbolic-link)

-   Fundamentalモードで`next-line`を実行するすべてのキーにたいして、かわりに`forward-line`を実行するように再定義します。

    substitute-key-definition
        (substitute-key-definition 'next-line 'forward-line
                                   global-map)

-   `C-x C-v`を未定義にします。

        (global-unset-key "\C-x\C-v")

    キーを未定義にする1つの理由は、それをプレフィクスにできることです。単に`C-x C-v
    anything`を定義すると、`C-x C-v`はプレフィクスになりますが、最初に通常の`C-x
    C-v`にたいする非プレフィクス定義を開放しなければなりません。

-   Textモードで‘`$`’に句読点構文をもたせます。‘`$`’にたいする文字定数の使い方に注意してください。

        (modify-syntax-entry ?\$ "." text-mode-syntax-table)

-   確認なしでの、コマンド`narrow-to-region`の使用を有効にします。

        (put 'narrow-to-region 'disabled nil)

-   さまざまなプラットフォームとEmacsバージョンにたいして、設定を調整します。

    ユーザーは通常、すべてのシステムでEmacsが同じように振る舞うことを期待するので、すべてのプラットフォームで同じinitファイルを使用するのが妥当です。しかしEmacsをカスタマイズするのに使用する関数が、他のプラットフォームやEmacsバージョンで利用できないということも発生します。この状況に対処するには、以下のように、ある関数または機能が利用可能かテストする条件文の内部に、カスタマイズを配置します:

        (if (fboundp 'blink-cursor-mode)
            (blink-cursor-mode 0))

        (if (boundp 'coding-category-utf-8)
            (set-coding-priority '(coding-category-utf-8)))

    関数が定義されていない場合に発生するエラーを、単に無視することもできます。

        (ignore-errors (set-face-background 'region "grey75"))

    存在しない変数への`setq`は一般的に無害なので、これらを条件文の中に置く必要はありません。

### 端末固有の初期化

term-file-aliases
各端末タイプは、Emacsをその端末タイプで実行するときEmacsにロードされるLispライブラリーをもつことができます。termtypeという名前の端末タイプにたいして、そのライブラリーは`term/termtype`と呼ばれます(`term-file-aliases`の連想配列(association list)の中に`(termtype
.
alias)`という形式のエントリーがある場合、Emacsはtermtypeのところにaliasを使用します)。このライブラリーは通常のようにディレクトリー`load-path`を検索することにより見つけられ、サフィックスは‘`.elc`’と‘`.el`’です。通常はほとんどのEmacsライブラリーがあるディレクトリーの、サブディレクトリー`term`にあります。

端末固有ライブラリーの通常の目的は、`input-decode-map` (または、その前に`function-key-map`)を使用して、その端末のファンクションキーで使用されるエスケープシーケンスを、より意味のある名前にマップすることです。これがどのように行なわれるかの例は、ファイル`term/lk201.el`を参照してください。多くのファンクションキーは、Termcapデータベースの情報にしたがい、自動的にマップされます。端末固有ライブラリーは、Termcapが指定しないファンクションキーだけをマップすればよいのです。

端末タイプがハイフンを含む場合、最初のハイフンの前の部分だけが、ライブラリーの選択で意味をもちます。したがって端末タイプ‘`aaa-48`’と‘`aaa-30-rv`’は、両方ともライブラリー`term/aaa`を使用します。ライブラリー内のコードは、`(getenv
"TERM")`を使用して、完全なタイプ名を取得できます。

term-file-prefix
ライブラリーの名前は、変数`term-file-prefix`の値と、端末タイプを結合することにより構築されます。`.emacs`で`term-file-prefix`を`nil`にセットすることにより、端末固有ライブラリーのロードを抑止できます。

tty-setup-hook
Emacsは初期化の最後、`.emacs`と端末固有ライブラリーの両方が読み込まれた後に、フック`tty-setup-hook`を実行します。端末固有ライブラリーの任意の部分をオーバーライドしたい場合や、ライブラリーをもたない端末の初期化を定義したい場合は、このフックにフック関数を追加します。[Hooks](#Hooks)を参照してください。

### Emacsがinitファイルを探す方法

Emacsは通常、`.emacs`を探すために環境変数HOME ([HOME](#General-Variables)を参照してください)を使用します。これはファイル名での‘`~`’を意味します。`~/`の中に`.emacs`(または`.emacs.el`)が見つからない場合、Emacsは`~/.emacs.d/init.el`(`~/.emacs.el`と同様に、バイトコンパイルされている可能性があります)を探します。

しかし、`su`により開始されたシェルからEmacsを実行する場合、Emacsは現在の見かけのユーザーではなく、あなた自身の`.emacs`を探すことを試みます。このアイデアは、たとえスーパーユーザーとして実行しているときでも、自分のエディターカスタマイズを取得するべきだという考えです。

より正確には、最初にEmacsはどのユーザーのinitファイルを使用するか決定します。Emacsは環境変数LOGNAMEとUSERからユーザー名を取得します。どちらも存在しない場合、実効ユーザーIDを使用します。ユーザー名が実ユーザーIDとマッチしたとき、EmacsはHOMEを使用します。そうでない場合、Emacsはシステムのユーザーデータベースの、そのユーザー名に対応するホームディレクトリーを探します。

### initファイル内の非ASCII文字

international characters in
.emacs
non-
ASCII
characters in
.emacs
non-
ASCII
keys, binding
rebinding non-
ASCII
keys
initファイルの文字列やキーバインディングに、アクセントつき文字などの非ASCII文字が含まれる場合、それは言語やコーディングシステムに問題を起こすかもしれません。

initファイルで非ASCII文字を使用したい場合、initファイルの最初の行に‘`-*-coding:
coding-system-*-`’タグを配して、問題となる文字をサポートするコーディングシステムを指定するべきです。[Recognize Coding](#Recognize-Coding)を参照してください。なぜなら、非ASCIIテキストのでコーディングにたいするにたいするデフォルトのコーディングシステムは、Emacsがinitファイルでそのような文字列を使用する個所を読み込むまでに、セットアップされていないかもしれないので、Emacsがその文字列を間違ってデコードする可能性があるからです。‘`-*-coding:
coding-system-*-`’を記述した場合、`set-language-environment`を呼び出す等、他の方法でコーディングシステムを変更するEmacs Lispコードの追加は避けるべきです。

非ASCIIキーをバインドするには、ベクターを使用しなければなりません([Init Rebinding](#Init-Rebinding)を参照してください)。非ASCII文字はメタキーとして解釈されるので、文字列構文は使用できません。たとえば:

    (global-set-key [?char] 'some-function)

charを挿入するには、`C-q`とタイプしてからバインドしたいキーをタイプします。

永続的に認証情報を保つ
----------------------

他のサービスに接続するEmacsパッケージには、たとえばsection “Gnus” in The Gnus Manualやsection “Tramp” in The Tramp Manualで見られるように、認証([Passwords](#Passwords)を参照)を要求するものがいくつかあります。同じユーザー名とパスワードを何度も提供するのは煩わしいかもしれないので、Emacsは`auth-source`ライブラリーを通じて、認証情報を永続的に保つことを提案します。

~/.authinfo
file
~/.authinfo.gpg
file
~/.netrc file
デフォルトでは、認証情報はファイル`~/.authinfo`、`~/.authinfo.gpg`、または`~/.netrc`から取得されます。これらのファイルは以下のような、ftpプログラム由来として知られる、netrcファイルと同様の構文をもちます:

    machine mymachine login myloginname password mypassword port myport

同様に`auth-source`ライブラリーは現在のところ、クラシックなnetrcバックエンド、JSONファイル、Secret Service API、および標準的なUnixパスワードマネージャーのpassという、複数のストレージバックエンドをサポートしています。

auth-sources
これらの選択肢はすべて、ユーザーオプション`auth-sources`を通じてカスタマイズできます。section “Emacs auth-source” in Emacs auth-sourceを参照してください。

auth-source-save-behavior
設定されたバックエンドで見つからないようなパスワードがインタラクティブに入力された場合、いくつかのバックエンドはそれの永続的な保存を提案します。これはユーザーオプション`auth-source-save-behavior`をカスタマイズして、変更することができます。

中止と中断
==========

`C-g`; `C-Break (MS-DOSのみ)`  
quit(中止): コマンドの実行、または途中までタイプしたコマンドをキャンセルします。

`C-]`  
最内の再帰編集レベル(recursive editing level)をabort(中断)して、それを呼び出したコマンドをキャンセルします(`abort-recursive-edit`)。

`ESC ESC ESC`  
quitまたはabortのどちらか、意味のあるほうを行ないます(`keyboard-escape-quit`)。

`M-x top-level`  
現在実行中のすべての再帰編集レベルをabortします。

`C-/`; `C-x u`; `C-_`  
バッファー内容にたいする直前の変更をキャンセルします(`undo`)。

完了する前のコマンドをキャンセルする方法は2つあります。それは`C-g`によるquitと、`C-]`や`M-x
top-level`によるabortです。quitは途中までタイプしたコマンド、または実行中のコマンドをキャンセルします。abortは再帰編集レベルを抜けて、再帰編集を呼び出したコマンドをキャンセルします([Recursive Edit](#Recursive-Edit)を参照してください)。

quitting
C-g
`C-g`によるquitは、途中までタイプしたコマンドから抜けたり、望まない数引数から抜け出す方法です。さらに、あるコマンドが実行中の場合、`C-g`は比較的安全にコマンドを停止します。たとえば、長い時間がかかるkillコマンドをquitした場合、*すべて*のテキストがバッファーに残るか、または*すべて*のテキストがkillリングに残るか、もしかしたらその両方かもしれません。リージョンがアクティブの場合、Transient Markモードがオフでなければ、`C-g`はマークを非アクティブにします([Disabled Transient Mark](#Disabled-Transient-Mark)を参照してください)。インクリメンタル検索の途中では、`C-g`は特別に振る舞います。検索を抜けるには2回連続して`C-g`をタイプします。詳細は、[Incremental Search](#Incremental-Search)を参照してください。

MS-DOSでは、文字`C-Break`が`C-g`のような文字の役割をします。MS-DOSではユーザーとの相互作用を行なうとき以外に、実行中のコマンドで`C-g`を認識できないのが理由です。それとは対照的に、`C-Break`は常に認識できます。 [MS-DOS Keyboard](#MS_002dDOS-Keyboard)を参照してください。

keyboard-quit
`C-g`をタイプした瞬間に変数`quit-flag`を`t`にセットすることにより、`C-g`は機能します。Emacs Lispはこの変数を頻繁にチェックして、これが非`nil`のときはquitします。Emacsが入力待ちのときにタイプしたときだけ、`C-g`は実際にコマンドとして実行されます。この場合に実行されるコマンドは、`keyboard-quit`です。

テキスト端末では、最初の`C-g`が認識される前に2回目の`C-g`でquitした場合は、emergency escape(緊急エスケープ)機能がアクティブになり、シェルに戻ります。[Emergency Escape](#Emergency-Escape)を参照してください。

NFS and quitting
quitできない状況もいくつか存在します。Emacsがオペレーティングシステムが何か行なうのを待つような場合、待ちが発生する箇所で特定のシステムコールにたいして、Emacsが特別な対処をしない場合、quitは不可能です。ユーザーがquitしたいと望むようなシステムコールにたいして、わたしたちはこれを行なっていなすが、それでも処理できないケースに出会う場合もあります。とても一般的なケースの1つは、NFSを使用したファイルへの入出力待ちです。Emacs自体はquitする方法を知っていますが、多くのNFS実装は、NFSサーバーがハングしたとき、ユーザープログラムがNFSを待つのを止めることを、単に許していません。

aborting recursive edit
abort-recursive-edit
C-\]
`C-]` (`abort-recursive-edit`)によるabortは、再帰編集レベルを抜けて、それを呼び出したコマンドをキャンセルするのに使用されます。`C-g`によるquitはこれを行なわず、行なうこともできません。なぜならこれは再帰編集レベルの*中*で、途中までタイプされたコマンドをキャンセルするからです。どちらの操作も有用です。たとえば再帰編集中に、数引数を入力するために`C-u
8`とタイプした場合、`C-g`でその引数をキャンセルして、その再帰編集レベルに留まることができます。

keyboard-escape-quit
ESC ESC ESC
シーケンス`ESC ESC ESC` (`keyboard-escape-quit`)は、quitかabortのどちらかを呼び出します(多くのPCプログラムでESCは“抜け出す”ことを意味するので、このような定義にしました)。これは`C-g`のように、プレフィクス引数のキャンセル、選択されたリージョンのクリアー、また問い合わせつき置換から抜け出すこともできます。また`C-]`のように、ミニバッファーから抜け出したり、再帰編集から抜け出すこともできます。これは`C-x
1`のように、フレームの複数ウィンドウ分割から抜け出すこともできます。これが行なうことができないのは、実行中のコマンドの停止です。これは通常のコマンドとして実行されるので、Emacsが次のコマンドのために準備ができるまで、これを認識しないからです。

top-level
コマンド`M-x
top-level`は、現在の再帰編集レベルからすべての再帰編集レベルを抜けるための、充分な回数の`C-]`コマンドと等価です。ミニバッファーがアクティブなときは、ミニバッファーも抜けます。`C-]`は、1度に1レベル再帰編集レベルを抜けますが、`M-x
top-level`は、1度ですべての再帰編集レベルを抜けます。`C-]`と`M-x
top-level`の両方とも、他のすべてのコマンドと同様(そして`C-g`とは異なり)、Emacsがコマンドにたいして準備ができているときだけ効果があります。`C-]`は通常のキーで、このキーが意味をもつのは、それがキーマップでバインドされているときだけです。[Recursive Edit](#Recursive-Edit)を参照してください。

厳密に言えば`C-/` (`undo`)はキャンセルコマンドではありませんが、すでに実行を終えたコマンドをキャンセルすると考えることができます。undo機能についての詳細は、[Undo](#Undo)を参照してください。

Emacsのトラブルへの対処
=======================

troubleshooting Emacs
このセクションでは、キーボードコードのミクスアップ(mixup)、文字化け、メモリー不足、クラッシュやハングなど、Emacsが期待したとおりに動作しない状況の認識と対処法について説明します。

Emacsでバグを見つけたと思ったら何をすればよいかについては、[Bugs](#Bugs)を参照してください。

DELで削除できない場合
---------------------

DEL
vs
BACKSPACE
BACKSPACE
vs
DEL
DEL
does not delete
すべてのキーボードには多くのキーがありますが、通常BACKSPACEとラベルされたキーは、最後にタイプした文字を削除するのに使用されます。Emacsでは、このキーはDELに等しいと想定されています。

グラフィカルなディスプレーでEmacsを開始したとき、EmacsはどのキーがDELなのか自動的に決定します。いくつかの特殊なケースでは、Emacsがシステムから間違った情報を取得して、BACKSPACEが後方ではなく前方に削除する場合があります。

Deleteというキーをもつキーボードもあります。これは通常、前方に削除するために使用されます。Emacsでこのキーが後方に削除を行なう場合も、Emacsが間違った情報 — ただし反対の意味の — を受け取ったことを意味します。

テキスト端末で、BACKSPACEが文字を削除するかわりに、`Control-h`のようなヘルプコマンドのプロンプトを表示する場合、それはこのキーが実際は‘`BS`’文字を送っていることを意味します。EmacsはBSをDELと扱うべきですが、そうしていないのです。

normal-erase-is-backspace-mode
これらのケースのすべてにおいて、直ちに改善できることは同じでで、それはコマンド`M-x
normal-erase-is-backspace-mode`を使用する方法です。これはEmacsがDELの処理をサポートする2つのモードを切り替えるので、もしEmacsが間違ったモードで開始された場合、正しいモードに切り替えることができます。テキスト端末では、BSがDELとして扱われる場合にヘルプを見たいときは、`C-h`のかわりにF1を使用します。`C-?`が文字コード127を送る場合は、このキーも機能するでしょう。

すべてのEmacsセッションで問題を解決するには、初期化ファイル([Init File](#Init-File)を参照してください)に以下の行の1つを記述します。上記の最初のケースでは、BACKSPACEが後方ではなく前方に削除を行なうので、BACKSPACEがDELとして動作するように、以下の行を使用します:

    (normal-erase-is-backspace-mode 0)

他の2つのケースでは、以下の行を使用します:

    (normal-erase-is-backspace-mode 1)

normal-erase-is-backspace
すべてのEmacsセッションで問題を解決する別の方法は、変数`normal-erase-is-backspace`をカスタマイズする方法です。BSまたはBACKSPACEがDELとなるようにモードを指定するには値`t`、他のモードにたいしては`nil`を指定します。[Easy Customization](#Easy-Customization)を参照してください。

再帰編集レベル
--------------

stuck in recursive editing
recursive editing, cannot exit
再帰編集レベルは、Emacsの重要かつ便利な機能ですが、それを理解していない場合は、うまく機能していないように見えるかもしれません。

モードラインの、メジャーモードやマイナーモードを囲む丸カッコ(parentheses)の周囲に、角カッコ(square brackets)‘`[…]`’がある場合、それは再帰編集レベルにいることを意味します。もしこれが目的でない場合、またはその意味を理解していない場合は、すぐに再帰編集レベルを抜けるべきです。これを行なうには、`M-x
top-level`とタイプします。[Recursive Edit](#Recursive-Edit)を参照してください。

スクリーン上のゴミ
------------------

garbled display
display, incorrect
screen display, wrong
テキスト端末でテキストが間違って見える場合、まず行なうことはバッファーのテキストが間違っていないか確かめることです。画面全体を再描画するために、`C-l` (`recenter-top-bottom`)とタイプしてください。この後でスクリーンが正常に表示される場合、問題は前のスクリーンの更新にあります(そうでない場合は、以下のセクションを参照してください)。

ディスプレー更新の問題は、使用している端末にたいする間違ったterminfoエントリーの結果であることがしばしばあります。Emacsディストリビューションのファイル`etc/TERMS`は、この種の既知の問題にたいする解決を与えます。`INSTALL`のセクションの中の1つは、これらの問題にたいする一般的なアドバイスを含みます。正しいterminfoエントリーを使用しているようなら、それはterminfoエントリーにバグがあるか、特定の端末タイプで発生するEmacsのバグである可能性があります。

テキスト内のゴミ
----------------

garbled text
buffer text garbled
`C-l`がそのテキストが間違っていることを示す場合、最初に実際の結果を生成するのに何のコマンドをタイプしたか見るために、`C-h l` (`view-lossage`)とタイプします。それから`C-x u` (`undo`)を使用して、正しいと思える状態まで、1つずつ変更をundoします。

バッファーの先頭または最後の大量のテキストが失われているように見える場合は、モードラインに単語‘`Narrow`’が表示されていないかチェックします。もしこれが表示されている場合、表示されていないテキストはまだ存在しますが、一時的に制限されています。これに再びアクセスできるようにするには、`C-x
n w` (`widen`)とタイプします。[Narrowing](#Narrowing)を参照してください。

メモリー不足
------------

memory full
out of memory
‘`Virtual memory exceeded`’というエラーメッセージが表示された場合は、`C-x s` (`save-some-buffers`)で変更されたバッファーを保存してください。この方法は、バッファーを保存するのに最小限の追加メモリーを必要とします。Emacsはこのエラーが発生したときでも利用可能な予備メモリーを保持しており、それは`C-x
s`が処理を完了するのに充分なはずです。予備メモリーを使用したとき、モードラインの先頭に‘`!MEM
FULL!`’が表示された場合、それは予備メモリーも使い切ったことを意味します。

変更されたバッファーを変更したら、このEmacsセッションを終了して別のセッションを開始するか、`M-x
kill-some-buffers`を使用して、カレントEmacsジョブのスペースを開放できます。これにより充分なスペースが開放された場合、予備メモリーは再充填され、モードラインから‘`!MEM
FULL!`’の表示が消えます。これは同じEmacsセッションで、安全に編集を継続できることを意味します。

メモリー不足のときは、バッファーの保存やkillに`M-x buffer-menu`を使用しないでください。Buffer Menuはかなりの量のメモリーを必要とするので、予備メモリーの供給では不充分でしょう。

Emacsがクラッシュしたとき
-------------------------

crash report
backtrace
emacs\_backtrace.txt
file, MS-Windows
Emacsはクラッシュを前提としていませんが、もしクラッシュした場合、exitする前にクラッシュレポート(crash report)を生成します。クラッシュレポートは標準エラーストリームにプリントされます。EmacsがGNUシステムまたはUnixシステムでグラフィカルなデスクトップから開始された場合、標準エラーストリームは一般的に`~/.xsession-errors`のようなファイルにリダイレクトされるので、そこでクラッシュレポートを探すことができます。MS-Windowsでは、クラッシュレポートは標準エラーストリームに加え、Emacsプロセスのカレントとディレクトリーの、`emacs_backtrace.txt`という名前のファイルに書き込まれます。

クラッシュレポートのフォーマットは、プラットフォームに依存します。GNU Cライブラリーを使用するいくつかのプラットフォームでは、クラッシュレポートには、クラッシュ前の実行状態を説明するbacktraceが含まれ、これはクラッシュをデバッグする助けとなります。以下はGNUシステムの例です:

    Fatal error 11: Segmentation fault
    Backtrace:
    emacs[0x5094e4]
    emacs[0x4ed3e6]
    emacs[0x4ed504]
    /lib64/libpthread.so.0[0x375220efe0]
    /lib64/libpthread.so.0(read+0xe)[0x375220e08e]
    emacs[0x509af6]
    emacs[0x5acc26]
    …

数字‘`11`’ はクラッシュにたいするシステムのシグナル番号 — このケースではsegmentation fault — です。16進数字はプログラムのアドレスで、これによりデバッグツールを使用して、ソースコード行に関連付けることができます。たとえばGDBコマンド‘`list
*0x509af6`’は、‘`emacs[0x509af6]`’エントリーにたいするソースコード行をプリントします。システムに`addr2line`ユーティリティーがある場合、以下のシェルコマンドはソースコードの行番号とともに、backtraceを出力します:

    sed -n 's/.*\[\(.*\)]$/\1/p' backtrace |
      addr2line -C -f -i -p -e bindir/emacs-binary

ここで、backtraceはbacktraceのコピーを含むテキストファイル名、bindirはEmacs実行可能ファイルを含むディレクトリー名、emacs-binaryはEmacs実行可能ファイル(GNUおよびUnixシステムでは通常は`emacs`、MS-WindowsおよびMS-DOSでは`emacs.exe`)です。`-p`オプションがない古いバージョンの`addr2line`では、このオプションを省略してください。

core dump
coreファイルをサポートするシステムでは、Emacsはオプションでコアダンプ(core dump)を生成します。コアダンプはクラッシュ前のプログラムの状態に関する多くのデータを含むファイルで、通常GDBのようなデバッガーにロードして調べられます。多くのプラットフォームでは、コアダンプはデフォルトで無効になっているので、(たとえばシェルのスタートアップスクリプトで)シェルコマンド‘`ulimit
-c unlimited`’を実行して、明示的に有効にしなければなりません。

クラッシュ後のリカバリー
------------------------

recovering crashed session
Emacs、またはコンピューターがクラッシュした場合、クラッシュしたとき編集していたファイルを、自動保存ファイルからリカバリーすることができます。これを行なうには、再びEmacsを開始して、コマンド`M-x
recover-session`とタイプしてください。

このコマンドはm最初に中断されたセッションのファイルを、ファイルの日付とともにリストするバッファーを表示します。そこからリカバリーするファイルを、選択しなければなりません。通常リカバリーしたいファイルは、一番最近のセッションでしょう。選択したファイルにポイントを移動して、`C-c
C-c`とタイプしてください。

その後`recover-session`は、そのセッション中に編集していた各ファイルについて、検討を行ないます。そのようなファイルそれぞれについて、そのファイルをリカバリーするか尋ねるのです。あるファイルにたいして`y`と応えると、コマンドはファイルとファイルの自動保存ファイルの日付を表示して、再度そのファイルをリカバリーするか尋ねます。この2回目の質問にたいして同意するには、`yes`と応えなければなりません。`yes`と応えた場合、Emacsはそのファイルをvisitしますが、テキストは自動保存ファイルから取得します。

`recover-session`が終了すると、リカバリーを選択したファイルがEmacsバッファーに表示されます。そこでファイルを保存する必要があります。それらを保存することだけが、そのファイル自身を更新するのです。

ファイルに関連付けられていないバッファーをリカバリーしたいときや、自動保存が重要な更新を記録するほど最新でなかった場合、最後の手段として — コアダンプが保存されていて、Emacsの実行ファイルからデバッグシンボルがストリップされていないという条件の元に — コアダンプからそれらを取得するために、GDB(GNUデバッガー)で`etc/emacs-buffer.gdb`スクリプトを使用することができます。

コアダンプを入手したら、すぐに`core.emacs`のような別の名前にリネームします。これにより、他のクラッシュによるコアダンプの上書きを防ぎます。

このスクリプトを使用するには、Emacs実行ファイル名とコアダンプのファイル名を、‘`gdb /usr/bin/emacs
core.emacs`’のように指定します。`(gdb)`プロンプトで、‘`source
/usr/src/emacs/etc/emacs-buffer.gdb`’としてリカバリースクリプトをロードします。それから利用可能なバッファーを見るために、コマンド`ybuffer-list`とタイプします。これは各バッファーにたいして、バッファー番号をリストします。バッファーを保存するには、`ysave-buffer`を使用します。ここでバッファー番号とそのバッファーを書き込むファイル名を指定します。すでに存在するファイル名を使用するべきではありません。ファイルがすでに存在する場合、このスクリプトはそのファイルの古い内容のバックアップを作成しません。

緊急エスケープ
--------------

emergency escape
テキスト端末では、1回目の`C-g`にたいしてEmacsが実際に反応してquitする前に、2回目の`C-g`をタイプすると、緊急エスケープ(emergency escape)が、Emacsを即座にサスペンドします。これにより、どんなにひどくハングしていても、常にGNU Emacsを抜け出すことができます。物事が正しく処理されている場合、Emacsは最初の`C-g`を素早く認識・処理するので。2回目の`C-g`は緊急エスケープを引き起こしません。しかし何らかの問題が、Emacsが最初の`C-g`を処理するのを妨げる場合、2回目の`C-g`でシェルに戻ります。

緊急エスケープによるサスペンドからEmacsを再開する場合、サスペンド前に行なっていた何かに戻る前に、Emacsは回復の報告と、以下の2つの質問をします:

    Emacs is resuming after an emergency escape.
    Auto-save? (y or n)
    Abort (and dump core)? (y or n)

質問に応えるには、それぞれにたいして`y`または`n`の後に、RETをタイプします。

‘`Auto-save?`’にたいして`y`と応えると、自動保存が有効なすべての編集されたバッファーの自動保存を、即座に行ないます。`n`と応えると、これをスキップします。この質問は、Emacsが安全に自動保存を行えないような、何らかの状況にある場合は省略されます。

‘`Abort (and dump
core)?`’にたいして`y`と応えると、Emacsはクラッシュしてコアダンプします。これは専門家(wizard)が、なぜEmacsが最初の`C-g`でquitしなかったかを見つけ出すことを可能にします。コアダンプの後、実行は継続されません。

この質問に`n`と応えた場合、Emacsは実行を再開します。運がよければ、Emacsは最終的にquit要求を行なうでしょう。そうでない場合、連続して`C-g`をタイプして、緊急エスケープを再度呼び出します。

実際はEmacsがハングしているのではなく、遅いだけの場合、本当に意味するところを意図せずに、2連`C-g`の機能を呼び出してしまうかもしれません。この場合は、2つの質問の両方に`n`を応えれば、前の状態に戻ることができます。やがて要求したquitが行なわれるでしょう。

緊急エスケープはテキスト端末だけでアクティブになっています。グラフィカルなディスプレーでは、マウスを使用してEmacsをkillしたり、他のプログラムに切り替えることができます。

MS-DOSでは緊急エスケープを発生させるために、`C-Break`を2回タイプしなければなりません — しかしシステムコールがハングしたり、EmacsがCコードのタイトなループにハマっているときは機能しないケースがあります。

バグの報告
==========

bugs
Emacsでバグを見つけたと思ったときは、それを報告してください。それをfixすることは約束できませんし、それがバグであると常に認める訳ではありませんが、もちろんそれについて知りたいのです。追加したいと考える機能についても、同じことが言えます。以下のセクションは、有効なバグレポートを作成する助けとなるでしょう。

既存のバグレポートの既知の問題を読む
------------------------------------

バグを報告する前に、少しでも可能なら、それが既知のものか確認してください。実際には、それがもっと後のEmacsリリースや、Emacsの開発バージョンですでにfixされているかもしれません。以下は、既知の問題について読むことができる、主な場所のリストです:

-   `etc/PROBLEMS`ファイル。`C-h
    C-p`とタイプして読むことができます。このファイルには、Emacsをコンパイル、インストール、実行するときに出会う、既知の問題の詳しいリストが含まれています。次善策や解決策の提案も、多くあります。

-   bug tracker
    <https://debbugs.gnu.org>のGNU Bug Tracker。Emacsのバグは‘`emacs`’パッケージの下のトラッカーにファイルされています。トラッカーは、各バグの状態、最初のバグレポート、バグ報告者とEmacs開発者によるフォローアップメッセージについて情報を記録します。subject、severity、その他の条件でバグを検索できます。

    debbugs package
    ウェブページでバグトラッカーを閲覧するかわりに、`debbugs`パッケージを使用して、それをEmacsから閲覧できます。このパッケージはパッケージメニュー([Packages](#Packages)を参照してください)を通じてダウンロードできます。このパッケージは、バグをリストするコマンド`M-x
    debbugs-gnu`、特定のバグを検索する`M-x
    debbugs-gnu-search`を提供します。Emacsメンテナーにより適用されるユーザータグは、`M-x
    debbugs-gnu-usertags`で表示されます。

-   ‘`bug-gnu-emacs`’メーリングリスト(ニュースグループ‘`gnu.emacs.bug`’も利用可能)。リストのアーカイブは<https://lists.gnu.org/mailman/listinfo/bug-gnu-emacs>で見ることができます。このリストはバグトラッカーに送られたEmacsバグレポートとドローアップメッセージの、mirrorとして機能します。これにはバグトラッカーが導入される前(2008年以前)の古いバグレポートも含まれています。

    もし望むなら、メーリングリストに登録できます。このリストの目的はEmacsメンテナーにバグと機能リクエストの情報を提供するためのもので、報告には大量のデータが含まれるかもしれないことに注意してください。購読者はこれについて不満を言うべきではありません。

-   ‘`emacs-pretest-bug`’メーリングリスト。このリストは今は使用されておらず、主に歴史的な興味のためのものです。一時は(たとえばまだリリースされていない)Emacs開発バージョンのために使用されていました。2003年から2007年中頃までのアーカイブは、<https://lists.gnu.org/r/emacs-pretest-bug/>で見ることができます。現在は‘`bug-gnu-emacs`’にたいするエイリアスです。

-   ‘`emacs-devel`’メーリングリスト。このメーリングリストにバグを報告する人がときどきいます。しかしこのリストの主な目的は違うので、バグレポートはバグリストに送るほうがよいでしょう。バグを報告する前に、この一覧を読んだことに感謝を感じることはありません。

バグがあったとき
----------------

bug criteria
what constitutes an Emacs bug
Emacsが不正なメモリー位置にアクセスする場合(“segmentation fault”と呼ばれます)、または(“disk full”のようなメッセージではなく)プログラムに問題があることを示す、オペレーティングシステムのエラーメッセージとともに終了する場合、それは確実にバグです。

Emacsがバッファーの内容を正しく対応して表示しないとき、それはバグです。しかしバッファーのナローイング([Narrowing](#Narrowing)を参照してください)チェックするべきです。これはバッファーの一部を隠して、表示される方法を変更できるので、バグではありません。

コマンドが永久に完了しないなら、それはバグですが、本当にEmacsのせいか確認しなくてはなりません。コマンドの中には単に長時間かかるものがいくつかあります。`C-g` (MS-DOSでは`C-Break`)をタイプしてから、`C-h
l`で、Emacsが受け取った入力が、あなたがタイプしようと意図したものなのか確認します。その入力が、あなたが素早く処理されるべきだと*わかっている*ものだった場合は、バグを報告してください。そのコマンドが長時間かかるものか判らない場合は、マニュアルを調べるか、協力してくれる人に尋ねてください。

あなたの親しんでいるコマンドが、コマンドの通常の定義が正当なのに、Emacsのエラーメッセージを表示する場合、それはおそらくバグです。

コマンドが間違ったことを行なうなら、それはバグです。しかしそのコマンドが何を行なうべきか確実に知っているか確認してください。そのコマンドに詳しくない場合、コマンドは実際は正しく動いているのでしょう。疑うなら、コマンドのドキュメント([Name Help](#Name-Help)を参照してください)を参照してください。

あるコマンドの意図された定義が、それを編集するための最良の定義ではないこともあります。これはとても重要な問題の一種ですが、判断の問題でもあります。いくつかの既存の機能にたいする無知から、そのような決定を行なうのは簡単でもあります。通常の方法でドキュメントをチェックして、それを理解したと確信し、あなたがやりたいことが不可能だと確実に判るまでは、そのような問題にたいして不満を言わないのが、おそらく最良です。他のEmacsユーザーにも尋ねてみましょう。マニュアルを注意深く読んだ後でも、そのコマンドが何を想定しているか確信がもてないときは、不明解な単語をindex(索引)やglossary(用語集)でチェックしましょう。

注意深くマニュアルを読んだ後でも、そのコマンドが何を行なうべきか判らないとき、それは報告すべきマニュアルのバグであることを示します。Emacsのエクスパートでない人 — あなたを含めて — にたいして、すべてを明解にするのがマニュアルの役目です。プログラムのバグと同様に、ドキュメントのバグレポートは重要です。

関数や変数のビルトインドキュメントがマニュアルと異なる場合、どちらか一方が間違っていなければならないので、これはバグです。

Emacsの一部ではないパッケージについての問題は、そのパッケージの開発者にそれらを報告することにより開始したほうが良いでしょう。

バグレポートの理解
------------------

bug reporting
report an Emacs bug, how to
バグがあると判断したときは、それを報告すること、そして有用な方法で報告することが重要です。もっとも有用なのは、Emacsを起動するシェルコマンドから、問題が発生するまでに、何のコマンドをタイプしたかの正確な記述です。

バグレポートのもっとも重要な原理は、*事実*を報告することです。仮定や口頭の説明は、詳細な生データの代替にはなりません。事実の報告は簡単ですが、多くの人は事実のかわりに仮定の説明をしようと懸命に努め、それを報告するのです。その説明がEmacsが実装されている方法にたいする仮定にもとづく場合、それらは使い道がありません。その一方で事実の欠落により、わたしたちはバグについての実際の情報を得られないでしょう。実際に問題を*デバッグ*して、推定を超える説明を報告したい場合、それは有用です — しかし、どうか生の事実も同様に含めてください。

たとえば、`C-x C-f /glorp/baz.ugh
RET`とタイプして、ファイルをvisitしたとき、そのファイルが偶然大きい(とあなたは知っている)ファイルで、Emacsが‘`I
feel pretty
today`’と表示したとします。バグレポートにはすべての情報が必要になります。あなたは問題がファイルのサイズにあると仮定して、“大きなファイルをvisitしたら、Emacsが‘`I
feel pretty today`’と表示します”、などと報告すべきではありません。これはわたしたちが“推測説明(guessing explanations)”と呼ぶものです。ファイル名に‘`z`’があるという事実が、問題の原因かもしれません。もしそうなら、あなたの報告を受け取ったとき、わたしたちは大きなファイルで問題の再現を試み、それらのファイル名にはおそらく‘`z`’が含まれておらず、問題を確認できないでしょう。名前に‘`z`’が含まれるファイルをvisitしてみるべきだと、推測できる方法はありません。

`C-x
C-f`のではなく、“ファイルをvisit”とさえ言うべきではありません。同様にテキストを入力する方法では、“その行に3文字あるとき”ではなく、“`RET
A B C RET C-p`とタイプした後”と書いてください。

可能なら、すぐにバグを再現するために`emacs -Q`(Emacsは初期のカスタマイズなしで開始されます。[Initial Options](#Initial-Options)を参照してください)でEmacsを呼び出して、バグを発生させるステップを繰り返してみてください。この方法でバグを再現できたら、あなたの個人的なカスタマイズをバグから除外できます。バグレポートは、Emacsを`emacs
-Q`で開始したことから始まり、バグを再現させる正確な一連のステップを続けるべきです。可能ならバグを再現するのに必要な、正確なファイル内容を報告してください。

`emacs
-Q`では再現できないバグもいくつかあります。結局は再現するのが難しいバグもあります。そのような場合、何を行なったかを報告すべきです — が、前述したように、どうか最初にバグを発生させた生の事実を固持してください。

報告したい複数の問題がある場合は、どうかそれらを個別のバグとしてそれぞれ報告してください。

バグレポートのためのチェックリスト
----------------------------------

checklist before reporting a bug
bug reporting, checklist
バグを報告する前に、まずその問題がすでに報告されていないか、確認を試みてください([Known Problems](#Known-Problems)を参照してください)。

もし可能なら、その問題がすでにfixされていないか、最新リリース版のEmacsも試してみてください。同様に、最新の開発版を試してみるのもよいでしょう。これがある人にとっては簡単でないことは認識しているので、バグを報告する前に、絶対にこれを行なわなければならないと思わないでください。

report-emacs-bug
Emacsでバグレポートを書くベストな方法は、コマンド`M-x
report-emacs-bug`を使用する方法です。これはメールバッファー([Sending Mail](#Sending-Mail)を参照してください)をセットアップして、自動的に*いくつかの*重要な情報を挿入します。しかし、すべての必要な情報は提供できません。だから以下のガイドラインを読んで、それに従うべきです。そうすればメッセージを送る前に、他の重大な情報を手で入力できます。`M-x
report-emacs-bug`によって挿入されたいくつかの情報は、適切ではないと感じるかもしれませんが、完全に確信があるのでなければそれを残してください。そうすれば開発者たちがそれを判断できます。

レポートを記述し終えたら、`C-c C-c`とタイプすると、それはEmacsメンテナー <bug-gnu-emacs@gnu.org>に送られます (新しい機能や改善を提案したいときも、同じアドレスを使用します)。Emacsの中からメールを送れない場合、バグレポートのテキストを通常使用しているメールクライアントにコピーして(システムがサポートしている場合は、`C-c
M-i`でEmacsにそれを行なわせることができます)、そのアドレスに送信できます。または、そのアドレスに問題を説明する簡単なメールを送ることもできます。

レポートは‘`bug-gnu-emacs`’メーリングリストに送られ、<https://debbugs.gnu.org>のGNU Bug Trackerに保管されます。報告について、より詳細な情報を尋ねる必要がある場合のために、どうか有効な返信用アドレスを含めてください。提出されたレポートは調停されるので、レポートが見られるようになるまで遅れが生じることもあります。

バグを報告するためにGNU Bug Trackerがどのように機能するか知る必要はありませんが、もし望むなら、トラッカーのオンラインドキュメントで、使用できるさまざま機能を見ることができます。

‘`bug-gnu-emacs`’メーリングリストに送られたすべてのメールは、‘`gnu.emacs.bug`’ニュースグループにもゲートウェイされます。この逆も真ですが、バグレポート(または返信)をニュースグループにポストしないでください。これにより、さらに情報を尋ねるためにあなたに連絡するのが困難になるのと、それがバグトラッカーと充分に統合されていないからです。

データが500,000バイトを超える場合は、どうかそれを直接レポートに含めないでください。要求されたら送るという提案に留めるか、データをオンラインで利用可能にしてその場所を知らせてください。

GNU Bug Trackerはあなたの報告にたいしてバグ番号を付与するでしょう。以下のディスカッションでは、その番号を使用するようお願いいたします。

メンテナーがバグを詳細に調べられるように、レポートには以下の事項を含めるべきです:

-   Emacsのバージョン番号。これがないと、GNU Emacsのカレントバージョンで, バグを探す意義があるかを知ることができません。

    emacs-version
    この情報は、`M-x
    report-emacs-bug`により自動的にレポートに含まれますが、レポートでこのコマンドを使用しない場合は、`M-x
    emacs-version RET`とタイプして、バージョン番号を取得できます。このコマンドが機能しない場合、たぶんあなたはGNU Emacsではない他の何かを使っているので、どこか他のところにそのバグを報告する必要があるでしょう。

-   使用している機種のタイプ、およびオペレーティングシステム名とバージョン番号(繰り返しになりますが、これらは`M-x
    report-emacs-bug`で自動的にレポートに含まれます)。`M-x emacs-version
    RET`もこの情報を提供します。`*Messages*`バッファーからコマンドの出力をコピーすれば、すべてを正確に取得できます。

-   Emacsをインストールしたとき、`configure`に与えたオプション(`M-x
    report-emacs-bug`により自動的にレポートに含まれます)。

-   Emacsのソースにたいして行なった変更の完全なリスト(わたしたちには、変更されたEmacsのバグを詳細に調べる時間はないでしょう。しかし変更を行なっていて、それをわたしたちに告げないとしたら、それはわたしたちを野性のダチョウ狩りに送り出すようなものです)。

    これらの変更について正確に記述してください。英語による説明では充分ではありません。それらにたいする統一コンテキストdiff(unified context diff)も送ってください。

    独自のファイル追加や、他の機種へのポートも、ソースの変更です。

-   GNU Emacsの標準的なインストール手順からの、その他あらゆる逸脱の詳細。

-   バグを再現するのに必要なファイルの完全なテキスト。

    ファイルをvisitせずに問題を発生させる方法を説明できるなら、ぜひそうしてください。これによりデバッグがとても簡単になります。ファイルが必要な場合、わたしたちがファイルの正確な内容を見られるよう確実にしてください。たとえば、行末にスペースがあるか、バッファーの最終行の後に改行があるかが問題となる場合があります(最終行が終端されているかどうかを心配すべき理由はないかもしれませんが、それがバグだと報告することを試みてください)。

-   バグを再現するためにタイプする必要がある、正確なコマンド。少しでも可能なら、‘`-Q`’オプション([Initial Options](#Initial-Options)を参照してください)でEmacsを開始したときからの、完全なレシピを送ってください。このオプションはあなたの個人的なカスタマイズをバイパスします。

    open-dribble-file
    dribble file
    logging keystrokes
    Emacsへの入力を正確に記録する方法の1つとして、それをdribbleファイルに書き込む方法があります。このファイルを開始するには、`M-x
    open-dribble-file`コマンドを使用します。このコマンドからそのEmacsプロセスがkillされるまで、Emacsはすべての入力を指定されたdribbleファイルにコピーします。機密情報(パスワードなど)は、dribbleファイルへの記録を終了させることに注意してください。

-   open-termscript
    termscript file
    TERM, environment variable, and display bugs
    テキスト端末上での表示のバグである可能性がある場合は、端末タイプ(環境変数TERMの値)、その端末にたいする`/etc/termcap`の完全なtermcapエントリー(このファイルはすべての機種で同じではありません)、Emacsが実際に端末に送った出力。

    端末出力を収集する方法は、以下のLisp式

        (open-termscript "~/termscript")

    を、Emacs開始直後に、`M-:`を使用するか、`*scratch*`バッファーで実行します。その後Emacsプロセスがkillされるまで、Emacsはすべての端末出力を、指定されたtermscriptファイルにもコピーします。Emacs開始時にその問題が発生する場合は、この式をEmacs初期化ファイルに記述すれば、Emacsが最初にスクリーンを表示するときに、termscriptファイルもオープンされます。

    警告: バグをシミュレートする端末タイプへのアクセスなしに、端末依存バグをfixするのは、しばしば困難で、不可能なときもあります。

-   非ASCIIまたは国際化されたテキストと関連性がある場合は、Emacsを開始したときのlocale。GNU/LinuxとUnixシステム、またはBashのようなPOSIXスタイルのシェルを使用している場合、以下のシェルコマンドを使用して関連する値を見ることができます:

        echo LC_ALL=$LC_ALL LC_COLLATE=$LC_COLLATE LC_CTYPE=$LC_CTYPE \
          LC_MESSAGES=$LC_MESSAGES LC_TIME=$LC_TIME LANG=$LANG

    別の方法として、システムにそれがある場合は、GNU/LinuxおよびUnixコマンドを使用して、localeセッティングを表示できます。

    `M-!`コマンドを使用してEmacsからこれらのコマンドを実行して、`*Messages*`バッファーからコマンドの出力をバグレポートにコピーできます。かわりに`M-x
    getenv RET LC_ALL
    RET`とタイプすると、`LC_ALL`の値をエコーエリアに表示するので、`*Messages*`バッファーからこの出力をコピーすることもできます。

-   あなたが間違いと主張する動作の説明。たとえば“Emacsプロセスが致命的なシグナルを受け取った”とか“結果のテキストは以下だが、これは間違いだと思う”など。

    もちろん、Emacsが致命的なシグナルを受け取るというバグなら、見逃すことはないでしょう。しかし、そのバグが正しくないテキストの場合、メンテナーは何が間違っているか気づかないかもしれません。なぜそのような危険を放置するのですか?

    あなたが遭遇した問題が致命的なシグナルの場合でも、明示的にそれを告げるべきです。何か奇妙なこと — たとえばあなたのソースコピーの同期がとれていない、またはあなたのシステムのCライブラリーにバグがある(これはあり得ます) — が起こっているとしましょう。あなたのコピーはクラッシュするかもしれませんが、私たちのコピーはクラッシュしないでしょう。あなたがクラッシュすることを*告げて*いれば、わたしたちのEmacsはクラッシュしないので、バグはなかったとわたしたちは言うことができます。クラッシュすることを告げていない場合、わたしたちはバグがあるかどうか知ることができません — わたしたちの観察から、なんらかの結論を描くことも不可能です。

-   Emacs ManualやEmacs Lisp Reference Manualが、実際のEmacsの振る舞いを記述できていない、またはテキストが分かりにくいといったバグの場合、間違いだと思うテキストをマニュアルからコピーしてください。そのセクションが小さければ、セクション名だけで充分です。

-   バグの徴候がEmacsのエラーメッセージの場合、エラーメッセージの正確なテキストと、EmacsのLispプログラムがどのようにしてエラーに至ったかを示す、backtraceを報告するのが重要です。

    エラーメッセージを正確に取得するには、それを`*Messages*`バッファーからバグレポートにコピーします。一部だけではなく、すべてをコピーしてください。

    toggle-debug-on-error
    Edebug
    エラーにたいするbacktraceを作成するには、エラーが発生する前に`M-x
    toggle-debug-on-error`を使用します(つまり、このコマンドを与えた後で、バグを発生させなければなりません)。これはエラーによりbacktraceを表示するLispデバッガーを開始します。デバッガーのbacktraceをバグレポートにコピーしてください。EdebugパッケージでEmacs Lispプログラムをデバッグする情報については、section “Edebug” in the Emacs Lisp Reference Manualを参照してください。

    このデバッガーの使用は、バグを再現する方法を知っているときだけ利用可能です。バグを再現できなければ、最低でもエラーメッセージ全体をコピーしてください。

    debug-on-quit
    Emacsが無限ループや、とても長い処理にハマっているように見えるとき、(変数`debug-on-quit`が非`nil`の場合は)`C-g`とタイプするとLispデバッガーを開始して、backtraceを表示します。このbacktraceは、そのような長いloopのデバッグにたいして有用なので、backtraceを生成できたら、バグレポートにコピーしてください。

    debug-on-event
    (`inhibit-quit`がセットされている等で)、`C-g`にEmacsが応答しない場合、Emacsの外から`debug-on-event`で指定されたシグナル(デフォルトはSIGUSR2)を送ることにより、デバッガーに入ることができます。

-   Lispの世界にロードしたプログラム(初期化ファイルを含みます)をチェックしてください。任意の変数にたいするセットは、Emacsの機能に影響を与えるかもしれません。初期化ファイルをロードせずに、フレッシュな状態で開始されたEmacsでも、その問題が発生するか確認してください(`-Q`スイッチでEmacsを開始することによりinitファイルのロードを抑止できます)。それで問題が発生しなかったら、問題を発生させるためにLispの世界にロードしなければならないプログラムの、正確な内容を報告しなければなりません。

-   その問題がinitファイルやEmacsの標準システムの一部ではない他のLispプログラムに依存する場合、最初にそれらのプログラムのメンテナーに苦情を訴えて、それがバグでないことを確認すべきです。彼らが機能すると思われる方法でEmacsを使用してバグを確認した後、彼らがそのバグを報告すべきです。

-   GNU Emacsのソース中の何かについて言及したい場合、数行のコンテキストとともにそのコードの行を示してください。行番号だけを示すのは止めてください。

    開発ソースの行番号と、あなたのソースの行番号は一致しません。行番号だけでは、あなたのバージョンでその行番号がどのコードをさすのか、メンテナーが判断するのに余分な作業を要しますし、それに確信をもつこともできません。

-   GDBのようなCデバッガーからの追加情報は、そのマシンを利用できなくても問題を見つけることを可能にするかもしれません。GDBの使い方を知らなければ、どうかGDBマニュアルを読んでください — 非常に長いという訳ではありませんし、GDBは簡単に使用できます。GDBマニュアルを含むGDBディストリビューションはオンライン形式で見つけることができ、ほとんどはEmacsディストリビューションと同じ場所で見つけることができます。GDBの下でEmacsを実行するためには、Emacsをコンパイルした場所の`src`サブディレクトリーに移動するべきです。カレントディレクトリーが`src`であることは重要です。GDBはこのディレクトリーの`.gdbinit`を読み込みます。

    しかし、何がバグを引き起こしたかを示すような追加の情報を収集するときは、考える必要があります。

    backtrace for bug reports
    たとえば、多くの人はCレベルのbacktraceだけを送って着ますが、これだけではとても有用とは言えません。引数つきのシンプルなbacktraceは、GNU Emacsの中で何が起こっているかを少ししか伝えないことがしばしばです。なぜならbacktraceにリストされたほとんどの引数は、Lispオブジェクトへのポインターだからです。これらのポインターの数値は、何であれ意味をもちません。問題となるのはポインターが指すオブジェクトの内容(そして、その内容自身もポインターの場合がほとんどです)なのです。

    debug\_print
    有用な情報を提供するためには、Lispオブジェクトの値をLisp表記で示す必要があります。基底スタックの近傍のスタックフレームのいくつかで、Lispオブジェクト変数それぞれにたいしてこれを行ないます。どの変数がLispオブジェクトであるかはソースを調べます。なぜならデバッガーはそれらを整数と判断するからです。

    Lisp構文で変数の値を表示するには、最初にその値をプリントして、それからLispオブジェクトをLisp構文でプリントするために、ユーザー定義のGDBコマンド`pr`を使用します(他のデバッガーを使用しなければならない場合、そのオブジェクトを引数として、関数`debug_print`を呼び出します)。`pr`コマンドはファイル`.gdbinit`で定義されていて、(コアダンプではなく)実行中のプロセスにたいしてデバッグするときだけ機能します。

    LispエラーでEmacsを停止させてGDBに戻るには、`Fsignal`にブレークポイントを置きます。

    実行中のLisp関数の短いリストのためには、GDBコマンド`xbacktrace`をタイプします。

    ファイル`.gdbinit`では、データ型やLispオブジェクトの内容を調べるための、他のコマンドも定義されています。これらのコマンドの名前は‘`x`’で始まります。これらのコマンドは`pr`より低いレベルで動作するので、少し不便になりますが、コアダンプをデバッグしていたり、Emacsが致命的なシグナルを受け取ったときなど、`pr`が機能しないようなときでも、機能するでしょう。

    debugging Emacs, tricks and techniques
    Emacsのデバッグにたいする、より詳細なアドバイスと、他の有用なテクニックは、Emacsディストリビューションの、ファイル`etc/DEBUG`で利用可能です。そのファイルには、Emacsが応答しない問題を詳しく調べる手順も含まれています(多くの人はこれをEmacsが“ハング”したとみなしますが、実際はおそらく無限ループにハマっているのでしょう)。

    インストールしたEmacsのファイル`etc/DEBUG`を探すには、変数`data-directory`に保管されたディレクトリー名を使用します。

以下はバグレポートには不要な事柄です:

-   バグを取り巻く状況の説明 — これは再現可能なバグにたいしては必要ありません。

    バグに遭遇したとき人は、入力ファイルを変えてバグが発生しなくなるか、影響がないかなどを詳しく調べるのに、多くの時間を費やすことがしばしばです。

    これは大抵多くの時間がかかる割に、とても有用とは言えません。なぜならわたしたちがバグを探す方法は、ブレークポイントを設定したデバッガーの元で1つの例を実行することであり、一連の例から得られる推論ではないからです。追加の例を探すのを止めることにより、あなたも時間を節約できるでしょう。すぐにバグレポートを送って、編集作業に戻り、報告すべき他のバグを探す法がよいでしょう。

    もちろんオリジナルの*かわり*に、簡単な例を見つけることができたら、そちらのほうが便利です。出力中のエラーは簡単に見分けられますし、デバッガーでの実行も時間が短くなります

    しかし単純化は必須ではありません、これを行なうことができなかったり、試す時間がない場合は、どうかオリジナルのテストケースでバグを報告してください。

-   コアダンプファイル。

    コアダンプによるデバッグは有用ですが、それはあなたのEmacs実行ファイルと、あなたのマシンだけで行なうことができます。したがってEmacsメンテナーにコアダンプを送るのは、有益ではないでしょう。何よりも、コアダンプをメールのバグレポートに含めないでください! そのような巨大なメッセージは、すこぶる迷惑です。

-   Emacsを実行したときのシステムコールトレース。

    システムコールトレースは、ある特別な種類のデバッグにはとても有用ですが、有用な情報が少ない場合がほとんどです。したがって、クラッシュに関する情報を報告する*一番*の方法は、システムコールトレースを送ることだと考えているように思える人が多いのは奇妙です。おそらくソースコードやデバッグシンボルがないプログラムをデバッグする経験がもたらす、習慣的なやり方なのでしょう。

    ほとんどのプログラムでは、システムコールトレースより、backtraceのほうが、通常はずっとずっと参考になります。完全な情報を得るには、変数の値を表示して、それらを`pr`でLispオブジェクトとしてプリントすることによりbacktraceを補完すべきであるとはいえ、シンプルなbacktraceのほうが一般的により参考になります(上記参照)。

-   バグにたいするパッチ。

    バグにたいするパッチは、それが良いものなら有用です。しかし、そのパッチで充分だと思い込んで、テストケースのような、バグレポートに必要な他の情報を省略しないでください。わたしたちはそのパッチに問題を見つけて別の方法でfixすると判断するかもしれないし、結局はそれを理解できないかもしれません。わたしたちが、あなたがfixしようと試みているバグを理解できなければ、そしてなぜそのパッチが改善なのかを理解できなければ、私たちはそれを採用できません。

    わたしたちにパッチを理解させて、採用を簡単にするためのガイドラインについては、[Sending Patches](#Sending-Patches)を参照してください。

-   バグが何か、何に依存するかについての推測。

    そのような推測は通常間違っています。エキスパートでさえ、事実を見つけるために最初にデバッガーを使用しなければ、そのような事柄を正しく推測できないのです。

GNU Emacsへのパッチの送付
-------------------------

sending patches for GNU Emacs
patches, sending
GNU Emacsを改善するためにバグfixを書きたいなら、それはとても助けになります。変更を送るとき、メンテナーがそれらを使うのが簡単になるように、どうか以下のガイドラインにしたがってください。これらのガイドラインにしたがわない場合でも、あなたの情報はまだ有用でしょうが、それを使用するのに余分な作業が必要になります。GNU Emacsの保守は最良の状況でも多くの作業を要すので、わたしたちを助けるのにあなたがベストをすくさなければ、わたしたちはそれを維持できないのです。

各パッチは、わたしたちがそれを正しく評価するために、簡単な情報をもたなければなりません。

そのような情報がすべてあるなら、それらをメールメッセージにまとめて、開発者に送ってください。推奨される送信先は、<bug-gnu-emacs@gnu.org>です(これはバグおよび機能のためのリストです)。なぜなら、このリストにはパッチを簡単に確認するための追跡システム(tracking system)があるからです。そのパッチが完全ではなく、さらに議論が必要だと思うときは、かわりにそれを<emacs-devel@gnu.org>に送りたいと思うかもしれません。パッチを改訂したら、それを最初のトピックにたいするfollowupとして送ってください。

わたしたちはそのパッチをプレーンテキストとして受けとるのを好みます。それはインライン(メールクライアントが行ブレークを変更しないように注意してください)、またはMIMEアタッチメントのどちらでも構いません。

-   そのパッチがどんな問題をfixするのか、またはどんな改善をもたらすのか、あなたの変更にたいする説明を含めてください。

    -   既存のバグにたいするfixについては、‘`bug-gnu-emacs`’リストの関連するディスカッションか、<https://debbugs.gnu.org>のGNU Bug Trackerのバグエントリーに返信するのが最善でしょう。その変更が、なぜバグをfixするのか説明してください。

    -   新しい機能については、その機能と実装についての説明を含めてください。

    -   新しいバグにたいしては、あなたがfixしたと思っている問題にたいする、正しいバグレポートを含めてください。それを採用する前に、わたしたちはその変更が正しいと、私たち自身に納得させる必要があります。もしそれが正しくても、問題を再現する方法がない場合、それを理解する妨げになるでしょう。

-   将来このソースを読む人の理解を助けとなるように、なぜこの変更が必要なのか、適切なコメントを含めてください。

-   異なる理由にたいする変更を一緒に混ぜないでください。それらを*個別*に送ってください。

    異なる理由にたいして2つの変更を行なった場合、わたしたちをそれを一緒に採用したいとは思わないでしょう。1つだけを採用したいと思うかもしれません。それらを合わせて1つのdiffにして送った場合、それらを区別するために — 変更のどの部分がどの目的のためかを理解するために — 余計な作業を行なう必要があります。これを行なう時間がない場合、わたしたちは変更全体を無視する必要があるかもしれません。

    1つの変更を記述したら、その変更の説明と一緒にそれをすぐに送れば、2つの変更は混ざることはなくなり、それらを区別する余計な作業なしに、わたしたちはそれぞれを正しく判断することができます。

-   1つの変更を終えたら、それをすぐに送ってください。ときどき人は多くの変更を累積して、すべて一緒に送るのがわたしたちの助けとなると考えます。上述したように、それは正にあなたにできる最悪のことです。

    変更は個別に送るべきなので、すぐに送ることができるでしょう。これは、その変更が重要なものなら、それをすぐに採用するオプションをわたしたちに与えます。

-   パッチそのもの

    diffを作成するために、‘`diff
    -u`’を使用してください。コンテキストなしのdiffは確実に採用が困難です。それ以上に調べるのが難しくなります。わたしたちは変更の採用を望ましいか判断するために、つねにパッチを調べなければなりません。Contextフォーマットはコンテキストなしのdiffより優れていますが、好ましいのはUnifiedフォーマットです。

    GNU diffがある場合、Cコードのdiffの作成には‘`diff -u -F'^[_a-zA-Z0-9$]\+
    *('`’を使用してください。これは変更のある関数名を表示します。

    Emacsリポジトリーを使用している場合、あなたのコピーが(たとえば`git
    pull`などにより)最新であることを確認してください。あなたの変更をプライベートのブランチにコミットして、`git format-patch
    master`を使用することにより、マスターバージョンからパッチを生成できます。または変更をコミットせずに、`git
    diff`を使用することもできます。

-   どちらが古いバージョンで、どちらが新しいバージョンか、あいまいになるのを避けてください。どうかdiffの第1引数に古いバージョン、2番目の引数に新しいバージョンを指定してください。そして一方のバージョンにたいして、それが古いバージョンなのか、変更した新しいバージョンなのかを示す名前をつけてください。

-   あなたの変更にたいする、コミットログのエントリーを記述してください。それにより、わたしたちがそれを記述するために余計な作業をしなくてすみ、あなたが行なった変更をわたしたちが理解する助けにもなります。

    変更された場所を示すのが、コミットログの目的です。したがって変更した関数について、具体的である必要があります。大きな関数では、関数のどこを変更したか示すのが、助けになる場合が多々あります。

    それとは逆に、変更箇所を示せば、変更ログで変更目的の説明をする必要はありません。したがって、新しい関数を追加した場合、必要なのはそれが新しいということを示すだけです。変更目的の説明が必要だと感じたら、多分その通りなのでしょう、がコードのコメントにその説明を記述してください。変更目的はそこに記述されているほうが、より有用です。

    どのような種類の情報を記述するかを見るために、最近のコミットにたいするコミットログエントリーを見て、わたしたちが使用しているスタイルを学んでください。他のプロジェクトとは異なり、たとえばTexinfoファイルのような、ドキュメントにたいするコミットログも必要です。[Change Log](#Change-Log)、および section “Change Log Concepts” in GNU Coding Standardsを参照してください。

-   fixを記述するときは、わたしたちが他のシステムを壊すような変更は採用できないということを、念頭に置いてください。あなたの変更が、ほかのタイプのシステムでコンパイルされた場合の影響について、考えてください。

    一般的には改善となる*かもしれない*が、そう確信するのは難しいようなfixを送る人が、ときどきいます。そのような変更を採用するのは、わたしたちがそれをとても慎重に調べなければならないので、難しくなります。もちろん、その変更が正しい理由の説明は、わたしたちを納得させる助けになります。

    一番安全な変更は、特定の機種の設定ファイルにたいする変更です。これらの変更は、新しいバグを他の機種に作成しないので、安全です。

    インストールの安全性が明確な形式でパッチをデザインして、わたしたちの作業量を、良い状態に保つ助けとなってください。

Emacs開発への貢献
=================

contributing to Emacs
Emacsは共同制作によるプロジェクトであり、わたしたちは誰でも貢献できことを励行します。

Emacsに貢献する多くの方法があります:

-   バグ探しと報告。[Bugs](#Bugs)を参照してください。

-   Emacsユーザーメーリングリスト<https://lists.gnu.org/mailman/listinfo/help-gnu-emacs>の質問にたいする回答。

-   [Wiki](https://www.emacswiki.org/)またはEmacs source repository([Sending Patches](#Sending-Patches)を参照してください)のドキュメントの記述。

-   既存のバグレポートが新しいバージョンのEmacs<https://debbugs.gnu.org/cgi/pkgreport.cgi?which=pkg&data=emacs>でfixされているかのチェック。

-   既存バグのfixの報告。

-   Emacsディストリビューションの`etc/TODO`にリストされた機能の実装、およびパッチの送付。

-   新しい機能の実装、およびパッチの送付。

-   Emacsで動作するパッケージの開発と、あなた自身またはGNU ELPA(<https://elpa.gnu.org/>)での公開。

-   新しいプラットフォームへEmacsをポート。ただしこれは現在一般的ではありません。

Emacsを改善する作業をしたい場合は、 <emacs-devel@gnu.org>のメンテナーに連絡してください。 提案されたプロジェクトを尋ねたり、あなたのアイデアを提案することができます。

すでに改善を記述したことがある場合は、それについて教えてください。まだ作業を開始していなければ、作業を開始する前に、 <emacs-devel@gnu.org> に連絡をとるのが有益です。Emacsの他の部分にたいして、あなたの拡張がより適合する方法を提案することが可能かもしれません。

機能を実装するときは、Emacs coding standardsに従ってください。[Coding Standards](#Coding-Standards)を参照してください。くわえて、些細とは言えないような貢献にたいしてはFSFへの著作権の譲渡が必要になります。[Copyright Assignment](#Copyright-Assignment)を参照してください。

Emacsの開発バージョンは、開発者グループにより活発にメンテされている、レポジトリーからダウンロードできます。アクセスの詳細についてはEmacsプロジェクトのページ<https://savannah.gnu.org/projects/emacs/>を参照してください。

カレントワーキングバージョンにたいしてパッチを記述することは重要です。古いバージョンから開始した場合、パッチは時代遅れかもしれず(そのためメンテナーはそれを適用するのが難しくなります)、Emacsの変更によりあなたのパッチを不必要になっているかもしれません。リポジトリーソースからダウンロードした後は、ビルド手順についてファイル`INSTALL.REPO`を読むべきです(ビルド手順が通常のビルドとは異なります)。

より広範な貢献をしたい場合は、Emacs開発者になる方法についての情報を得るために、Emacsディストリビューションの`CONTRIBUTE`ファイルを参照してください。

(望む変更を実装する方法を理解するために)、以下のEmacsドキュメントを参照してください:

-   を参照してください。

-   を参照してください。

-   <https://www.gnu.org/software/emacs>

-   <https://www.emacswiki.org/>

コーディング規約
----------------

coding standards
貢献されたコードはGNUコーディング規約(GNU Coding Standards: <https://www.gnu.org/prep/standards/>)にしたがうべきです。これはシステムのinfoでも利用可能かもしれません。

これにしたがっていない場合、わたしたちがそれを使えるように、そのコードをfixする誰かを探す必要があるでしょう。

Emacsには追加のスタイルとコーディング規約があります:

-   section “Tips Appendix” in Emacs Lisp Referenceを参照してください。

-   Emacsに含まれるLispコードでは、`defadvice`と`with-eval-after-load`の使用を避けてください。

-   すべてのソースおよびテキストファイルの、すべての行末の空白文字を削除してください。

-   Emacsにはソースコード中にタブを使うかどうかの規約がありません。編集するファイル内の空白文字を変更しないでください。

-   Lispコード内のスペース文字は、`? `のかわりに`?\s`を使用してください。

著作権の割り当て
----------------

copyright assignment
FSF(Free Software Foundation)は、GNU Emacsの著作権所有者です。FSFはコンピューターユーザーの自由の促進、およびすべてのフリーソフトウェアーユーザーの権利を守るという、世界的な使命をもつ、非営利団体です。一般的な情報については、ウェブサイト<https://www.fsf.org/>を参照してください。

一般的には、GNU Emacs、およびGNU ELPAに格納されているパッケージにたいする些細とは言えない貢献にたいして、わたしたちは著作権をFSFに譲渡することを求めます。この背景にある理由については、<http://www.gnu.org/licenses/why-assign.html>を参照してください。

著作権譲渡はシンプルなプロセスです。いくつかの国の住民は、これを完全にコンピューター上で行なうことができます。わたしたちは<emacs-devel@gnu.org>メーリングリストで、あなたが始めるのを助けること、あなたがもつかもしれない疑問にたいして回答(または回答をもつ人物を指示)することができます。

(どうか注意してください: なぜいくつかのGNUプロジェクトは版権譲渡を求めるかについての一般的な議論は、emacs-develではoff-topicです。かわりにgnu-misc-discussを参照してください)

著作権放棄も可能ですが、好ましいのは譲渡です。著作権放棄者は、著作権譲渡者と同様に、FSFにサインされた書類を送ることが必要になります(単に“this is in the public domain”というだけでは充分ではありません)。著作権放棄は将来の作業には適用できないので、新しい何かを送りたいときは、毎回これを繰り返す必要があります。

わたしたちは、譲渡なしで小さな変更(大雑把に言うと15行以下)を受けとることができます。これはあなたの貢献全体にたいする蓄積的な制限です(たとえば5行パッチを3つ)。

GNU Emacsにたいして助けを得る方法
=================================

help in using Emacs
‘
help-gnu-emacs
’ mailing list
‘
gnu.emacs.help
’ newsgroup
インストール、使用方法、またはGNU Emacsの変更について助言を必要とする場合は、それを探す2つの方法があります:

-   メッセージを メーリングリスト<help-gnu-emacs@gnu.org>に送るか、 あなたの要求をニュースグループ`gnu.emacs.help`にポストしてください(このメーリングリストとニュースグループは相互接続しているので、どちらを使っても問題ありません)。

-   手数料を徴収して助言してくれる人物を、[service directory](https://www.fsf.org/resources/service/)で探してください。

GNU GENERAL PUBLIC LICENSE
==========================

Version 3, 29 June 2007
    Copyright © 2007 Free Software Foundation, Inc. https://fsf.org/

    Everyone is permitted to copy and distribute verbatim copies of this
    license document, but changing it is not allowed.

**Preamble**

The GNU General Public License is a free, copyleft license for software and other kinds of works.

The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program—to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too.

When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.

To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.

For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.

Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.

For the developers’ and authors’ protection, the GPL clearly explains that there is no warranty for this free software. For both users’ and authors’ sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.

Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users’ freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.

Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free.

The precise terms and conditions for copying, distribution and modification follow.

**TERMS AND CONDITIONS**

1.  Definitions.

    “This License” refers to version 3 of the GNU General Public License.

    “Copyright” also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.

    “The Program” refers to any copyrightable work licensed under this License. Each licensee is addressed as “you”. “Licensees” and “recipients” may be individuals or organizations.

    To “modify” a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a “modified version” of the earlier work or a work “based on” the earlier work.

    A “covered work” means either the unmodified Program or a work based on the Program.

    To “propagate” a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.

    To “convey” a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.

    An interactive user interface displays “Appropriate Legal Notices” to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.

2.  Source Code.

    The “source code” for a work means the preferred form of the work for making modifications to it. “Object code” means any non-source form of a work.

    A “Standard Interface” means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.

    The “System Libraries” of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A “Major Component”, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.

    The “Corresponding Source” for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work’s System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.

    The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.

    The Corresponding Source for a work in source code form is that same work.

3.  Basic Permissions.

    All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.

    You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.

    Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.

4.  Protecting Users’ Legal Rights From Anti-Circumvention Law.

    No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.

    When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work’s users, your or third parties’ legal rights to forbid circumvention of technological measures.

5.  Conveying Verbatim Copies.

    You may convey verbatim copies of the Program’s source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.

    You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.

6.  Conveying Modified Source Versions.

    You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:

    1.  The work must carry prominent notices stating that you modified it, and giving a relevant date.

    2.  The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to “keep intact all notices”.

    3.  You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.

    4.  If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.

    A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an “aggregate” if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation’s users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.

7.  Conveying Non-Source Forms.

    You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:

    1.  Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.

    2.  Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.

    3.  Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.

    4.  Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.

    5.  Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.

    A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.

    A “User Product” is either (1) a “consumer product”, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, “normally used” refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.

    “Installation Information” for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.

    If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).

    The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.

    Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.

8.  Additional Terms.

    “Additional permissions” are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.

    When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.

    Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:

    1.  Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or

    2.  Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or

    3.  Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or

    4.  Limiting the use for publicity purposes of names of licensors or authors of the material; or

    5.  Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or

    6.  Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.

    All other non-permissive additional terms are considered “further restrictions” within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.

    If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.

    Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.

9.  Termination.

    You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).

    However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.

    Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.

    Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.

10. Acceptance Not Required for Having Copies.

    You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.

11. Automatic Licensing of Downstream Recipients.

    Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.

    An “entity transaction” is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party’s predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.

    You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.

12. Patents.

    A “contributor” is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor’s “contributor version”.

    A contributor’s “essential patent claims” are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, “control” includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.

    Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor’s essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.

    In the following three paragraphs, a “patent license” is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To “grant” such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.

    If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. “Knowingly relying” means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient’s use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.

    If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.

    A patent license is “discriminatory” if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.

    Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.

13. No Surrender of Others’ Freedom.

    If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.

14. Use with the GNU Affero General Public License.

    Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.

15. Revised Versions of this License.

    The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.

    Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License “or any later version” applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.

    If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Program.

    Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.

16. Disclaimer of Warranty.

    THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

17. Limitation of Liability.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

18. Interpretation of Sections 15 and 16.

    If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.

**END OF TERMS AND CONDITIONS**

**How to Apply These Terms to Your New Programs**

If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.

To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the “copyright” line and a pointer to where the full notice is found.

    one line to give the program's name and a brief idea of what it does.
    Copyright (C) year name of author

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or (at
    your option) any later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see https://www.gnu.org/licenses/.

Also add information on how to contact you by electronic and paper mail.

If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:

    program Copyright (C) year name of author
    This program comes with ABSOLUTELY NO WARRANTY; for details type ‘show w’.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type ‘show c’ for details.

The hypothetical commands ‘`show w`’ and ‘`show c`’ should show the appropriate parts of the General Public License. Of course, your program’s commands might be different; for a GUI interface, you would use an “about box”.

You should also get your employer (if you work as a programmer) or school, if any, to sign a “copyright disclaimer” for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see <https://www.gnu.org/licenses/>.

The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read <https://www.gnu.org/licenses/why-not-lgpl.html>.

GNU Free Documentation License
==============================

Version 1.3, 3 November 2008
    Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
    https://fsf.org/

    Everyone is permitted to copy and distribute verbatim copies
    of this license document, but changing it is not allowed.

1.  PREAMBLE

    The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.

    This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software.

    We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.

2.  APPLICABILITY AND DEFINITIONS

    This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.

    A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.

    A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.

    The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.

    The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.

    A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”.

    Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTEX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.

    The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text.

    The “publisher” means any person or entity that distributes copies of the Document to the public.

    A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition.

    The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.

3.  VERBATIM COPYING

    You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.

    You may also lend copies, under the same conditions stated above, and you may publicly display copies.

4.  COPYING IN QUANTITY

    If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.

    If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.

    If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.

    It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.

5.  MODIFICATIONS

    You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:

    1.  Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.

    2.  List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.

    3.  State on the Title page the name of the publisher of the Modified Version, as the publisher.

    4.  Preserve all the copyright notices of the Document.

    5.  Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.

    6.  Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.

    7.  Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.

    8.  Include an unaltered copy of this License.

    9.  Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.

    10. Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.

    11. For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.

    12. Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.

    13. Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.

    14. Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section.

    15. Preserve any Warranty Disclaimers.

    If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles.

    You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.

    You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.

    The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.

6.  COMBINING DOCUMENTS

    You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.

    The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.

    In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”

7.  COLLECTIONS OF DOCUMENTS

    You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.

    You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.

8.  AGGREGATION WITH INDEPENDENT WORKS

    A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.

    If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.

9.  TRANSLATION

    Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.

    If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.

10. TERMINATION

    You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License.

    However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.

    Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.

    Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.

11. FUTURE REVISIONS OF THIS LICENSE

    The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See <https://www.gnu.org/licenses/>.

    Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.

12. RELICENSING

    “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site.

    “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization.

    “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document.

    An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008.

    The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.

**ADDENDUM: How to use this License for your documents**

To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:

      Copyright (C)  year  your name.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.3
      or any later version published by the Free Software Foundation;
      with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
      Texts.  A copy of the license is included in the section entitled ``GNU
      Free Documentation License''.

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this:

        with the Invariant Sections being list their titles, with
        the Front-Cover Texts being list, and with the Back-Cover Texts
        being list.

If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.

If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.

Emacs呼び出しにたいするコマンドライン引数
=========================================

command line arguments
arguments (command line)
options (command line)
switches (command line)
startup (command line arguments)
invocation (command line arguments)
Emacsは、Emacsを開始するとき、様々な動作を要求するための、コマンドライン引数をサポートします。これらのコマンド引数の中には、他のエディターとの互換性のためのものや、高度な動作を指定するものがあります。通常の編集にこれらを使用することはお勧めしません(コマンドラインから既存のEmacsジョブにアクセスする方法は、[Emacs Server](#Emacs-Server)を参照してください)。

‘`-`’で始まる引数はオプションで、‘`+linenum`’もオプションです。Emacsは、スタートアップ時に指定されたファイルをvisitします。コマンドラインで最後に指定されたファイルがカレントバッファーになり、それ以外のファイルも別のバッファーでvisitされます。ほとんどのプログラムと同様に、特別な引数‘`--`’は、それ以降のすべての引数が、(名前が‘`-`’で始まっていても)オプションではなくファイル名であることを指定します。

Emacsのコマンドオプションは、XウィンドウでEmacsが使用するウィンドウのサイズや位置、カラーなど、多くのことを指定できます。多くはありませんが、ファイルのLisp関数をバッチモードで実行するなど、高度な使い方をサポートするためのオプションもあります。このチャプターの各セクションでは、利用可能なオプションを、その目的に合わせて整理して説明します。

オプションを記述するには2つの方法があります。それは1つの‘`-`’で始まる短い形式と、‘`--`’で始まる長い形式です。たとえば、短い形式が‘`-d`’で、それに対応する長い形式は‘`--display`’です。

‘`--`’の長い形式は、覚えるのが簡単ですが、多くタイプしなければなりません。しかしオプション名全体を綴る必要はありません。あいまいさのない省略形で充分です。長いオプションが引数をとる場合、オプション名と、そのオプションにたいする引数を区切るには、スペースとイコール記号の両方を使用することができます。したがって‘`--display`’オプションにたいしては、‘`--display
sugar-bombs:0.0`’と‘`--display=sugar-bombs:0.0`’の、どちらでも記述することができます。関連性が明確になるのでイコール記号を推奨します。以下の表では、常にイコール記号で記すことにします。

initial options (command line)
action options (command line)
command-line-args
ほとんどのオプションは、Emacsを初期化する方法や、Emacsセッションのパラメーターを指定します。これらを初期化オプション(initial options)と呼びます。多くはありませんが、ライブラリーのロードや、Lisp関数の呼び出しなど、動作を指定するオプションもあります。これらを動作オプション(action options)と呼びます。これらとファイル名を合わせたものを、動作引数(action arguments)と呼びます。動作引数は、変数`command-line-args`に、文字列のリストとして保管されます(実際のところ、Emacsスタートアップ時には、コマンドラインで渡されたすべての引数が、`command-line-args`に含まれていますが、初期化を行なう間に、初期化引数は処理されるごとにこのリストから削除され、動作引数だけが残ります)。

動作引数
--------

以下は動作引数の表です:

‘`file`’; ‘`--file=file`’; ‘`--find-file=file`’; ‘`--visit=file`’  
visiting files, command-line argument

inhibit-startup-buffer-menu

指定されたfileをvisitします。[Visiting](#Visiting)を参照してください。

Emacsスタートアップ時、1つのウィンドウでスタートアップバッファーを表示し、fileをvisitするバッファーを別のウィンドウで表示します([Windows](#Windows)を参照してください)。複数のファイル引数を与えた場合、コマンドラインの最後に指定されたファイルが表示され、他のファイルもvisitされますが、表示はされません。

スタートアップバッファーが無効([Entering Emacs](#Entering-Emacs)を参照)の場合、ファイル引数が1つのときは1つのウィンドウでfileをvisitするバッファーを表示し、ファイル引数が2つのときは、Emacsはファイルを2つの別のウィンドウに表示します。ファイル引数が3つ以上の場合、Emacsは最後に指定されたファイルを1つのウィンドウに表示して、別のウィンドウにその他すべてのファイルを表示するバッファーメニュー([Several Buffers](#Several-Buffers)を参照)を表示します。このバッファーメニューの使用を抑制するには、変数`inhibit-startup-buffer-menu`を`t`に変更してください。

‘`+linenum file`’  
+

linenum

指定されたfileをvisitし、行番号linenumに移動します。

‘`+linenum:columnnum file`’  
指定されたfileをvisitし、行番号linenumに移動して、列番号columnnumにポイントを置きます。

‘`-l file`’; ‘`--load=file`’  
–load

loading Lisp libraries, command-line argument

関数`load`で、fileという名前のLispライブラリーをロードします。fileが絶対ファイル名でない場合、Emacsは最初にカレントディレクトリーを探して、次に`load-path` ([Lisp Libraries](#Lisp-Libraries)を参照してください)にリストされたディレクトリーを探します。

**警告:**前のコマンドライン引数にvisitされたファイルがある場合、カレントディレクトリーは最後にvisitされたファイルのディレクトリーになります。

‘`-L dir`’; ‘`--directory=dir`’  
–directory

変数`load-path`にリストされたディレクトリーの前に、ディレクトリーdirを追加します。複数の‘`-L`’オプションを指定した場合、Emacsはその順番を保持します。たとえば‘`-L
/foo -L /bar`’を使用すると、`load-path`は`("/foo" "/bar"
…)`となります。dirが‘`:`’で始まる場合、Emacsは‘`:`’を削除した残りを、`load-path`にリストされたディレクトリーの(前ではなく)後ろに追加します(MS Windowsでは‘`:`’のかわりに、`path-separator`の値‘`;`’を使用します)。

‘`-f function`’; ‘`--funcall=function`’  
–funcall

call Lisp functions, command-line argument

Lisp関数functionを呼び出します。それがインタラクティブな関数(コマンド)の場合、同じ関数をキーシーケンスで呼び出したときのように、引数を対話的に読み取ります。そうでない場合は、その関数を引数なしで呼び出します。

‘`--eval=expression`’; ‘`--execute=expression`’  
–execute

evaluate expression, command-line argument

Lisp式expressionを評価します。

‘`--insert=file`’  
–insert

insert file contents, command-line argument

fileの内容を、コマンドライン引数が処理されるときにカレントのバッファーに挿入します。これは通常、`*scratch*`バッファー([Lisp Interaction](#Lisp-Interaction)を参照してください)ですが、コマンドラインの前の引数がファイルをvisitしたりバッファーを切り替えるときは、別のバッファーになるでしょう。このコマンドライン引数の効果は、`M-x
insert-file`が行なうのと同様です([Misc File Ops](#Misc-File-Ops)を参照してください)。

‘`--kill`’  
–kill

確認なしでEmacsを終了します。

‘`--help`’  
–help

利用可能なすべてのオプションがリストされたUsageメッセージをプリントしてから、正常終了します。

‘`--version`’  
–version

Emacsのバージョンをプリントしてから、正常終了します。

初期化オプション
----------------

初期化オプションは、Emacsセッションにたいするパラメーターを指定します。このセクションでは、より一般的な初期化オプションを説明します。いくつかのオプションは、厳密には以降のセクションで説明するXウィンドウシステムに関連したオプションです。

いくつかの初期化オプションは、初期化ファイルのロードに影響します。Emacsは通常、`site-start.el`が存在する場合は最初にそれをロードし、ユーザーの初期化ファイルが存在すれば次にそれをロードして、デフォルト初期化ファイル`default.el`が存在すれば最後にそれをロードします([Init File](#Init-File)を参照してください)。それらのファイルのロードを抑制したり、それらのファイルを別のファイルで置き換えるオプションもあります。

‘`-chdir directory`’; ‘`--chdir=directory`’  
–chdir

change Emacs directory

他のことを行なう前にまず、カレントディレクトリーをdirectoryに変更します。これはEmacsが停止したのと同じディレクトリーで開始されるように、主にXでのセッション管理に使用されます。これによりデスクトップの保存と復元が簡単になります。

‘`-t device`’; ‘`--terminal=device`’  
–terminal

device for Emacs terminal I/O

端末の入出力にdeviceをデバイスとして使用します。このオプションは暗に‘`--no-window-system`’を含みます。

‘`-d display`’; ‘`--display=display`’  
–display

display for Emacs frame

Emacs初期フレームを開くために、Xウィンドウシステムとdisplayという名前のディスプレーを使用します。詳細は、[Display X](#Display-X)を参照してください。

‘`-nw`’; ‘`--no-window-system`’  
–no-window-system

disable window system

環境変数DISPLAYがセットされていても、ウィンドウシステムと直接やりとりしません。これはEmacsが、Emacsのすべての表示と出力のために、開始された端末を使用することを意味します。

batch mode

‘`-batch`’; ‘`--batch`’  
Emacsをバッチモード(batch mode)で実行します。バッチモードは、シェルスクリプトやmakeファイルから、Emacs Lispで記述されたプログラムを実行するために使用されます。Lispプログラムを呼び出すには、‘`-batch`’オプションと併せて、1つ以上の‘`-l`’、‘`-f`’、‘`--eval`’を使用します([Action Arguments](#Action-Arguments)を参照してください)。使用例は、[Command Example](#Command-Example)を参照してください。

バッチモードでは、Emacsは編集されるテキストを表示せず、`C-z`や`C-c`のような、標準の端末割り込みが通常の効果をもちます。通常はエコーエリアにメッセージをプリントするEmacs関数は、かわりに標準出力ストリーム(`stdout`)、または標準エラーストリーム(`stderr`)にメッセージをプリントします(正確に言うと、`prin1`、`princ`、`print`のような関数は`stdout`にプリントし、`message`や`error`は`stderr`にプリントします)。通常はミニバッファーからキーボード入力を読み取る関数は、かわりに端末の標準入力ストリーム(`stdin`)から入力を受け取ります。

‘`--batch`’は暗に‘`-q`’(初期化ファイルをロードしません)を含みますが、それでも`site-start.el`はロードされます。これはすべてのコマンドオプションを処理した後に、Emacsを終了します。それに加えて、自動保存が明示的に要求された場合を除き、自動保存を無効にします。また自動保存が要求されていない場合は、ファイルの保存での`fsync`システムコールを省略します。

‘`--script file`’  
–script

script mode

‘`--batch`’と同様に、Emacsをバッチモードで実行してから、fileのLispコードを読み込み実行します。

このオプションは通常、Emacsを実行する実行可能スクリプトの中で使用します。これは以下のテキストを最初の行に記述します:

    #!/usr/bin/emacs --script

これは‘`--script`’でEmacsを呼び出し、スクリプトファイル名はfileです。それからEmacs Lispは最初の行の‘`#!`’をコメント区切りとして扱います。

‘`--no-build-details`’  
–no-build-details

build details

deterministic build

Emacs実行可能形式からシステム名やビルド日時などの詳細を取り除き、そのビルドがより決定論的になります。

‘`-q`’; ‘`--no-init-file`’  
–no-init-file

bypassing init and

default.el

file

init file, not loading

default.el

file, not loading

初期化ファイルをロードしません([Init File](#Init-File)を参照してください)。Emacsがこのオプションで呼び出された場合、Customize機能は、保存のオプションを受け付けません([Easy Customization](#Easy-Customization)を参照してください)。このオプションは`site-start.el`のロードは無効にしません。

‘`--no-site-file`’; ‘`-nsl`’  
-nsl

site-start.el

file, not loading

`site-start.el`をロードしません([Init File](#Init-File)を参照してください)。‘`-Q`’オプションもこれを行ないますが、‘`-q`’のような他のオプションはこれを行ないません。

‘`--no-site-lisp`’  
–no-site-lisp

site-lisp

files, not loading

`load-path`に`site-lisp`ディレクトリーを含めません([Init File](#Init-File)を参照してください)。‘`-Q`’オプションもこれを行ないます。

‘`--no-splash`’  
–no-splash

splash screen

startup message

スタートアップ画面を表示しません。初期化ファイルで変数`inhibit-startup-screen`を非`nil`にセットしても、この効果を得ることができます([Entering Emacs](#Entering-Emacs)を参照してください)。

‘`--no-x-resources`’  
–no-x-resources

X resources, not loading

Xリソースをロードしません。初期化ファイルで変数`inhibit-x-resources`を`t`にセットしても、この効果を得ることができます([Resources](#Resources)を参照してください)。

‘`-Q`’; ‘`--quick`’  
–quick

最小のカスタマイズでEmacsを開始します。これは‘`-q`’、‘`--no-site-file`’、‘`--no-site-lisp`’、‘`--no-x-resources`’、‘`--no-splash`’を一緒に使用したのと同様です。

‘`-daemon`’; ‘`--daemon[=name]`’; ‘`--bg-daemon[=name]`’; ‘`--fg-daemon[=name]`’  
Emacsをデーモンとして開始します。これはフレームをオープンせずに、まずEmacsを開始した後、Emacsサーバーを開始します(オプションでサーバーに明示的にnameを指定できる)。`emacsclient`コマンドを使用して、編集のためにEmacsに接続できます。デーモンとしてのEmacsの使用についての情報は、[Emacs Server](#Emacs-Server)を参照してください。“バックグラウンド”のデーモンは端末から切り離され、バックグラウンドで実行されます(‘`--daemon`’は‘`--bg-daemon`’のエイリアス)。

‘`--no-desktop`’  
–no-desktop

保存されたデスクトップをリロードしません。[Saving Emacs Sessions](#Saving-Emacs-Sessions)を参照してください。

‘`-u user`’; ‘`--user=user`’  
–user

load init file of another user

あなたの初期化ファイルのかわりに、userの初期化ファイルをロードします。[23]

‘`--debug-init`’  
–debug-init

errors in init file

initファイルのエラーにたいして、Emacs Lispデバッガーを有効にします。section “Entering the Debugger on an Error” in The GNU Emacs Lisp Reference Manualを参照してください。

‘`--module-assertions`’  
–module-assertions

module verification

動的ロードモジュールを処理する際に、高価な正当性チェックを有効にします。これは、作成したモジュールがモジュールAPI仕様に従っているか検証したいモジュール作者を意図したものです。モジュール関連のassertが発生した場合、Emacsはabortします。section “Writing Dynamically-Loaded Modules” in The GNU Emacs Lisp Reference Manualを参照してください。

コマンド引数の例
----------------

以下は、引数とオプションを指定してEmacsを使用する例です。ここでは、ロードすることにより、Cプログラムをvisitしたカレントバッファーにたいして、何か便利な操作を行なう、`hack-c.el`という名前のLispプログラムファイルがあるとしましょう。

    emacs --batch foo.c -l hack-c -f save-buffer >& log

これは`foo.c`をvisitしてから、`hack-c.el`(これはvisitされたファイルに何らかの変更を行ないます)をロードし、`foo.c`を保存(`save-buffer`は`C-x
C-s`にバインドされた関数であることに注意してください)した後に、(‘`--batch`’オプションなので)Emacsを終了してシェルに戻ります。‘`--batch`’は、出力を`log`にリダイレクトしても問題がないことが保証されます。なぜならEmacsは作業するためのディスプレー端末をもたないと想定されるからです。

環境変数
--------

environment variables
環境(environment)とは、オペレーティングシステムの機能です。これは値と名前をもつ変数のコレクションからなります。それぞれの変数は環境変数(environment variable)と呼ばれます。環境変数名は大文字小文字を区別し、慣習では大文字だけを使用します。値はすべてテキスト文字列です。

何が環境を便利にしているかというと、それはサブプロセスが親プロセスから自動的に環境を継承できることです。これはログインシェルで環境変数をセットして、実行するすべて(Emacsを含む)のプログラムが、それを参照できることを意味します。Emacsのサブプロセス(シェル、コンパイラー、バージョンコントロールシステムなど)も、Emacsから環境を継承します。

setenv
getenv
initial-environment
Emacsの中では、コマンド`M-x getenv`は環境変数の名前を読み取って、その値をエコーエリアにプリントします。`M-x
setenv`はEmacs環境で変数をセットし、`C-u M-x
setenv`は変数を削除します(‘`$`’による環境変数の置き換えは、ファイル名にたいする値と同様に機能します。[File Names with $](#File-Names-with-_0024)を参照してください)。変数`initial-environment`は、Emacsにより継承された初期環境を保管します。

Emacsの外で環境変数をセットする方法は、オペレーティングシステム、特に使用しているシェルに依存します。たとえば以下はBashを使用して、環境変数ORGANIZATIONに‘`not
very much`’をセットする例です:

    export ORGANIZATION="not very much"

以下はcshまたはtcshでこれを行なう方法の例です:

    setenv ORGANIZATION "not very much"

EmacsがXウィンドウシステムを使用している場合、Xを制御するさまざまな環境変数は、Emacsも同様に制御します。詳細は、Xのドキュメントを参照してください。

### 一般的な変数

以下は、Emacsで特別な意味をもつ環境変数の、アルファベット順のリストです。これらの変数のほとんどは、他のプログラムでも使用されます。Emacsはこれらの環境変数がセットされていることを要求しませんが、セットされている場合はその値を使用します。

CDPATH  
CDPATH, environment variable

相対ディレクトリーを指定したときに、指定したディレクトリーを検索するために、`cd`コマンドにより使用されます。

DBUS\_SESSION\_BUS\_ADDRESS  
DBUS\_SESSION\_BUS\_ADDRESS, environment variable

D-BusサポートつきでEmacsがコンパイルされている場合、D-Busにより使用されます。通常これを変更する必要はありません。‘`unix:path=/dev/null`’のようなダミーアドレスをセットすることにより、D-Busセッションバスとの接続を抑止し、同様にD-Busセッションバスがまだ実行されていないときは自動的に開始します。

EMACSDATA  
EMACSDATA, environment variable

Emacsに含まれるアーキテクチャーに独立なファイルのディレクトリーです。これは変数`data-directory`の初期化に使用されます。

EMACSDOC  
EMACSDOC, environment variable

ドキュメント文字列ファイル(documentation string file)にたいするディレクトリーで、Lisp変数`doc-directory`の初期化に使用されます。

EMACSLOADPATH  
EMACSLOADPATH, environment variable

Emacs Lispファイルを検索する、コロンで区切られたディレクトリーのリスト[24]です。セットされている場合は、変数`load-path`の初期値です([Lisp Libraries](#Lisp-Libraries)を参照してください)。空の要素は、`load-path`のデフォルト値を意味します。たとえば‘`EMACSLOADPATH="/tmp:"`’を使用すると、デフォルトの`load-path`の前に`/tmp`を追加します。リストの中間に空の要素を指定するには、‘`EMACSLOADPATH="/tmp::/foo"`’のように、2つのコロンを続けます。

EMACSPATH  
EMACSPATH, environment variable

実行可能ファイルを検索するための、コロンで区切られたディレクトリーのリストです。セットされている場合、Emacsは変数`exec-path`([Shell](#Shell)を参照してください)を初期化するときに、PATH(以下参照)に加えてこれをを使用します。

EMAIL  
EMAIL, environment variable

user-mail-address, initialization

メールアドレスです。Lisp変数`user-mail-address`を初期化するために使用されます。Emacsのメールインターフェースは、送信メッセージの‘`From`’ヘッダーにこれを使用します([Mail Headers](#Mail-Headers)を参照してください)。

ESHELL  
ESHELL, environment variable

シェルモードで、環境変数SHELLをオーバーライドするために使用されます([Interactive Shell](#Interactive-Shell)を参照してください)。

HISTFILE  
HISTFILE, environment variable

ログインしている間のシェルコマンドが保存されるファイルの名前です。この変数のデフォルトは、Bashを使用している場合は`~/.bash_history`、kshのときは`~/.sh_history`、それ以外では`~/.history`です。

HOME  
HOME, environment variable

ディレクトリーツリー上で、あなたのファイルがある場所です。チルダ(`~`)で始まるファイル名の展開に使用されます。MS-DOSでは、この変数のデフォルトはEmacsが開始されたディレクトリーで、そのディレクトリー名が‘`/bin`’で終わる場合、‘`/bin`’は取り除かれます。Windowsでは、HOMEのデフォルト値は、ユーザープロファイルディレクトリーの`Application
Data`サブディレクトリー(つまり通常は`C:/Documents and
Settings/username/Application
Data`。usernameはユーザー名)ですが、後方互換のため、`C:/`に`.emacs`がある場合は、かわりに`C:/`がデフォルト値になります。

HOSTNAME  
HOSTNAME, environment variable

Emacsが実行されているホストの名前です。

INFOPATH  
INFOPATH, environment variable

コロンで区切られた、Infoファイルを検索するディレクトリーのリストです。

LC\_ALL; LC\_COLLATE; LC\_CTYPE; LC\_MESSAGES; LC\_MONETARY; LC\_NUMERIC; LC\_TIME; LANG  
LANG, environment variable

そのユーザーの優先されるlocaleです。localeには6つのカテゴリーがあり、それぞれ環境変数で指定されます。ソートはLC\_COLLATE、文字エンコーディングはLC\_CTYPE、システムメッセージはLC\_MESSAGES、通貨形式はLC\_MONETARY、数字はLC\_NUMERIC、日時はLC\_TIMEでlocaleを指定します。これらの変数の1つがセットされていない場合、そのカテゴリーのデフォルトは環境変数LANGの値、LANGがセットされていない場合は‘`C`’ localeになります。しかしLC\_ALLが指定された場合、これは他のすべてのlocale環境変数のセッティングをオーバーライドします。

MS-WindowsとmacOSでは、環境でLANGがまだセットされていない場合、Emacsはシステムワイドなデフォルト言語にもとづき、LANGをセットします。MS-Windowsのいくつかのバージョンでは、これはコントロールパネルの‘`Regional
Settings`’でセットでき、macOSではSystem Preferenceの“Language and Region”でセットできます。

LC\_CTYPEカテゴリーの値は、デフォルトの言語環境(language environment)とコーディングシステム(coding system)を選択するために、`locale-language-names`、`locale-charset-language-names`、`locale-preferred-coding-systems`のエントリーにたいしてマッチされます。[Language Environments](#Language-Environments)を参照してください。

LOGNAME  
LOGNAME, environment variable

ユーザーのログイン名です。USERも参照してください。

MAIL  
MAIL, environment variable

システムのメールinbox名です。

MH  
MH, environment variable

mhシステムのセットアップファイル名です。section “MH-E” in The Emacs Interface to MHを参照してください。

NAME  
NAME, environment variable

あなたの現実世界での名前です。これは変数`user-full-name`を初期化するために使用されます([Mail Headers](#Mail-Headers)を参照してください)。

NNTPSERVER  
NNTPSERVER, environment variable

ニュースサーバーの名前です。Gnusパッケージで使用されます。

ORGANIZATION  
ORGANIZATION, environment variable

あなたが属する組織の名前です。Gnusパッケージで、ポストの‘`Organization:`’ヘッダーをセットするために使用されます。

PATH  
PATH, environment variable

コロンで区切られた、実行可能ファイルを含むディレクトリーのリストです。これは変数`exec-path`を初期化するために使用されます([Shell](#Shell)を参照してください)。

PWD  
PWD, environment variable

セットされている場合、これはEmacsが開始されたときのデフォルトディレクトリーになるはずです。

REPLYTO  
REPLYTO, environment variable

セットされている場合は、変数`mail-default-reply-to`の初期値になります([Mail Headers](#Mail-Headers)を参照してください)。

SAVEDIR  
SAVEDIR, environment variable

新しいアーティクルがデフォルトで保存されるディレクトリーの名前です。Gnusパッケージにより使用されます。

SHELL  
SHELL, environment variable

Emacsの中からプログラムのパースや実行に使用されるインタープリターの名前です。

SMTPSERVER  
SMTPSERVER, environment variable

送信メールサーバーの名前です。これは変数`smtpmail-smtp-server`を初期化するために使用されます([Mail Sending](#Mail-Sending)を参照してください)。 background mode, on `xterm`

TERM  
TERM, environment variable

Emacsが使用する端末タイプです。Emacsがバッチモードで実行されていないとき、この変数はセットされていなければなりません。MS-DOSでは、デフォルトは‘`internal`’で、これはその機種固有のディスプレーを扱う、ビルトインの端末エミュレーションを指定します。

TERMCAP  
TERMCAP, environment variable

TERMで指定された端末をどのようにプログラムするかを記述する、termcapライブラリーファイルの名前です。デフォルトは`/etc/termcap`です。

TMPDIR; TMP; TEMP  
TEMP, environment variable

これらの環境変数は、変数`temporary-file-directory`を初期化するために使用されます。これは一時ファイルを置く場所を指定します([Backup](#Backup)を参照してください)。Emacsは最初にTMPDIRの使用を試みます。これがセットされていない場合、通常Emacsは`/tmp`にフォールバックします。しかしMS-WindowsとMS-DOSでは、かわりにTMP、次にTEMP、最後に`c:/temp`にフォールバックします。

TZ  
TZ, environment variable

これはデフォルトのタイムゾーン(もしかしたらサマータイムの情報も)を指定します。section “Time Zone Rules” in The GNU Emacs Lisp Reference Manualを参照してください。MS-DOSでは、Emacsを開始したときの環境でTZがセットされていない場合、EmacsはDOSが返す国コードにたいして、適切なデフォルト値を定義します。MS-Windowsでは、EmacsはTZを使用しません。

USER  
USER, environment variable

ユーザーのログイン名です。LOGNAMEも参照してください。MS-DOSでは、デフォルトは‘`root`’です。

VERSION\_CONTROL  
VERSION\_CONTROL, environment variable

変数`version-control`の初期化に使用されます([Backup Names](#Backup-Names)を参照してください)。

### その他の変数

これらの変数は、特定の設定だけにたいして使用されます:

COMSPECCOMSPEC  
MS-DOSとMS-Windowsで、バッチファイルとシェルの内部コマンドを呼び出すときに使用する、コマンドインタープリターの名前です。MS-DOSでは、環境変数SHELLのデフォルト値のためにも使用されます。

NAMENAME  
MS-DOSで、この変数は変数USERのデフォルト値として使用されます。

EMACSTESTEMACSTEST  
MS-DOSで、内部端末エミュレーターの操作ログに使用するファイルを指定します。この機能はバグレポートを送るときに便利です。

EMACSCOLORSEMACSCOLORS  
MS-DOSで、スクリーンカラーを指定します。Emacsは開始時の数瞬、デフォルトカラーを表示するので、それらの指定にこの方法が便利です。

この変数の値は2文字のエンコーディングで指定し、それぞれデフォルトフェイスにたいして、1文字目はフォアグラウンドカラー、2文字目はバックグラウンドカラーを指定します。それぞれの文字は、標準のPCテキストモードディスプレーのカラーを記述する、16進コードを指定します。たとえばlight grayの背景色でblueのテキストを得たい場合は、‘`EMACSCOLORS=17`’を指定します。ここで1はカラーblue、7はカラーlight grayを指定しています。

PCディスプレーは通常、8色のバックグラウンドカラーだけをサポートします。しかしバックグラウンドカラーにたいして、16色すべてを使用できるDOSディスプレーにモードを切り替えるので、実際には4ビットのバックグラウンドカラーすべてが使用されます。

PRELOAD\_WINSOCKPRELOAD\_WINSOCK  
MS-Windowsでこの変数をセットしている場合、Emacsは開始時に、最初に要求されたときまで待たずに、ネットワークライブラリーのロードと初期化を行ないます。

emacs\_diremacs\_dir  
MS-Windowsでは、emacs\_dirは特別な環境変数で、これはEmacsがインストールされたディレクトリーのフルパスを指します。Emacsが標準的なディレクトリー構造にインストールされた場合、この変数の値は自動的に計算されます。他の環境変数とは異なり、これは開始時にEmacsによりオーバーライドされるので、標準的なインストールをした場合には、あなた自身がこの変数のセッティングを使用することは、あまりないでしょう。EMACSLOADPATHのような他の環境変数をセットするとき、絶対パスをハードコーディングするより、emacs\_dirを使う法が便利だと気づくでしょう。これにより複数バージョンのEmacsが、同じ環境変数のセッティングを共有することが可能になり、環境やレジストリーのセッティングを変更せずに、Emacsのインストールディレクトリーを変更できるようになります。

### MS-Windowsのシステムレジストリー

addpm, MS-Windows installation program
registry, setting environment variables (MS-Windows)
MS-Windowsでは、インストールプログラム`addpm.exe`が、システムレジストリーの`HKEY_LOCAL_MACHINE`セクションの、`/Software/GNU/Emacs`の下のemacs\_dir、EMACSLOADPATH、EMACSDATA、EMACSPATH、EMACSDOC、SHELL、TERMの値を追加します。これを行なうのは、異なるバージョンのWindowsにたいして環境変数をセットする、標準的な場所がないからです。最近のバージョンのEmacsでは、`addpm.exe`の実行は絶対に必要ではなくなりましたが、古いバージョンからアップグレードする場合、`addpm.exe`は以前のインストールから、(おそらく最新のEmacsと互換性がない)古いレジストリーエントリーを取得しないことを保証します。

Emacsを開始したときは、環境のチェックと同様に、システムレジストリーの、これらの変数とHOME、LANG、PRELOAD\_WINSOCKもチェックします。

これらの変数の値を決定するために、Emacsは次の手順にしたがいます。最初に環境がチェックされます。そこで変数が見つからない場合、Emacsは`/Software/GNU/Emacs`のレジストリーキーを名前で探します。最初にレジストリーの`HKEY_CURRENT_USER`セクション、そこで見つからなければ、`HKEY_LOCAL_MACHINE`セクションを探します。それでもなおEmacsが値を決定できない場合、コンパイルされたときのデフォルトが使用されます。

上記の環境変数に加えて、Xリソース([X Resources](#X-Resources)を参照)を指定するために`/Software/GNU/Emacs`のレジストリーキーにセッティングを追加することもできます。`.Xdefaults`ファイル内で指定可能なほとんどのセッティングを、そのレジストリキーからセットできます。

ディスプレー名の指定
--------------------

display name (X Window System)
DISPLAY
environment variable
環境変数DISPLAYは、Emacsを含むすべてのXクライアントに、ウィンドウをどこに表示するかを指定します。通常の状況では、この変数の値は、Xサーバーを開始してローカルでジョブを実行したとき、デフォルトにセットされます。ディスプレーを自分で指定することもできます。これを行なう理由の1つは、他のシステムにログインして、そこでEmacsを実行し、ウィンドウはローカル端末のウィンドウに表示させたい場合です。

DISPLAYは、‘`host:display.screen`’という構文をもちます。ここでhostはXウィンドウシステムのサーバー機のホスト名、displayは、あなたのサーバー(Xサーバー)を、同一機種上の他のサーバーと区別するために任意に割り当てられる数字、そしてscreenフィールドは、Xサーバーが複数の端末スクリーンを制御することを可能にします。ピリオドとscreenフィールドはオプションです。screenが含まれる場合、通常は0です。

たとえば、あなたのホスト名が‘`glasperle`’で、あなたのサーバーが設定にリストされた最初の(もしかしたら唯一の)サーバーの場合、DISPLAYは‘`glasperle:0.0`’になります。

Emacsを実行するとき、変数DISPLAYを変更するか、オプション‘`-d
display`’または‘`--display=display`’で、明示的にディスプレーを指定できます。以下は例です:

    emacs --display=glasperle:0 &

‘`-nw`’オプションで、Xウィンドウシステムの使用を抑止できます。その場合、Emacsはディスプレーとして制御テキスト端末を使用します。[Initial Options](#Initial-Options)を参照してください。

セキュリティーの規制により、リモートシステムのプログラムが、ローカルシステムで表示を行なうのを禁ずることがあります。この場合、Emacsは以下のようなメッセージを出力します:

    Xlib:  connection to "glasperle:0.0" refused by server

ローカル機で`xhost`コマンドを使用することにより、リモート機からアクセスする権限を与えれば、この問題を解決できるでしょう。

フォント指定オプション
----------------------

font name (X Window System)
デフォルトのフォントを指定するために、コマンドラインオプション‘`-fn
font`’(または‘`--font`’。これは‘`-fn`’のエイリアスです)を使用できます。

‘`-fn font`’; ‘`--font=font`’  
–font

specify default font from the command line

fontをデフォルトフォントとして使用します。

コマンドラインでフォント名をEmacsに渡す場合、フォント名にシェルが特別に扱う文字(たとえばスペース)が含まれる場合は、クォーテーションマークで囲んでクォートする必要があるでしょう。たとえば:

    emacs -fn "DejaVu Sans Mono-12"

フォント名やデフォルトフォントを指定する別の方法についての詳細は、[Fonts](#Fonts)を参照してください。

ウィンドウカラーオプション
--------------------------

color of window, from command line
text colors, from command line
Emacsディスプレーのさまざまな場所で使用するカラーを指定するために、以下のコマンドラインオプションを使用できます。カラーは、カラーネーム(color names)か、RGBトリプレット(RGB triplets)のどちらかを使用して、指定します。

‘`-fg color`’; ‘`--foreground-color=color`’  
–foreground-color

foreground color, command-line argument

フォアグラウンドカラーを指定します。`default`フェイス([Faces](#Faces)を参照してください)で指定されたカラーをオーバーライドします。

‘`-bg color`’; ‘`--background-color=color`’  
–background-color

background color, command-line argument

バックグラウンドカラーを指定します。`default`フェイスで指定されたカラーをオーバーライドします。

‘`-bd color`’; ‘`--border-color=color`’  
–border-color

border color, command-line argument

Xウィンドウのボーダーカラーを指定します。EmacsがGTK+サポートつきでンパイルされいてる場合、効果はありません。

‘`-cr color`’; ‘`--cursor-color=color`’  
–cursor-color

cursor color, command-line argument

ポイントがある位置を示すEmacsのカーソルカラーを指定します。

‘`-ms color`’; ‘`--mouse-color=color`’  
–mouse-color

mouse pointer color, command-line argument

Emacsウィンドウにマウスがあるときの、マウスカーソルカラーを指定します。

‘`-r`’; ‘`-rv`’; ‘`--reverse-video`’  
–reverse-video

reverse video, command-line argument

フォアグラウンドカラーとバックグラウンドカラーを入れ替えて、反転表示します。

‘`--color=mode`’  
–color

standard colors on a character terminal

override character terminal color support

Emacsをテキスト端末で実行するときの、カラーサポートモード(color support mode)をセットします。その文字端末の`terminfo`データベースまたは`termcap`で示される、いくつかのサポートされたカラーをオーバーライドします。パラメーターmodeには、以下の1つを指定できます:

‘`never`’; ‘`no`’  
端末の能力がカラーをサポートすると指定していても、カラーを使用しません。

‘`default`’; ‘`auto`’  
`--color`を指定しないときと同じです。Emacsは開始時に端末がカラーをサポートするか検知して、もしサポートされていれば、カラーディスプレーをオンに切り替えます。

‘`always`’; ‘`yes`’; ‘`ansi8`’  
無条件にカラーサポートをオンに切り替えて、標準的な8カラーにたいするANSIエスケープシーケンスによるカラーコマンドを使用します。

‘`num`’  
num個のカラーにたいするカラーモードを使用します。numが−1の場合、カラーサポートをオフに切り替えます(‘`never`’と同じです)。0の場合、この端末にたいするデフォルトのカラーサポートを使用します(‘`auto`’と同じです)。そうでない場合、num個のカラーにたいする適切な標準モードを使用します。端末の能力により、numの値に応じて、Emacsは8色、16色、88色、256色のカラーモードに切り替えることができるでしょう。numカラーをサポートするモードが存在しない場合、Emacsはあたかもnumに0が指定された場合のように、その端末のデフォルトのカラーサポートを使用します。

modeが省略された場合のデフォルトは、ansi8です。

たとえばcoralのマウスカーソルと、slate blueのテキストカーソルを使用するには、以下のように入力します:

    emacs -ms coral -cr 'slate blue' &

‘`-rv`’オプションを指定するか、Xリソースの‘`reverseVideo`’で、フォアグラウンドとバックグラウンドのカラーを反転できます。

‘`-fg`’、‘`-bg`’、‘`-rv`’オプションの機能は、テキスト端末でも、グラフィカルなディスプレーと同様です。

ウィンドウのサイズと位置にたいするオプション
--------------------------------------------

geometry of Emacs window
position and size of Emacs frame
width and height of Emacs frame
specifying fullscreen for Emacs frame
以下は、Emacsの初期フレームのサイズと位置を指定する、コマンドラインオプションのリストです:

‘`-g widthxheight[{+-}xoffset{+-}yoffset]]`’; ‘`--geometry=widthxheight[{+-}xoffset{+-}yoffset]]`’  
–geometry

geometry, command-line argument

サイズwidthとheight(文字の列数と行数)、および位置xoffsetとyoffset(ピクセル)を指定します。パラメーターwidthとheightはすべてのフレームに適用されますが、xoffsetとyoffsetは初期フレームだけに適用されます。

‘`-fs`’; ‘`--fullscreen`’  
–fullscreen

fullscreen, command-line argument

スクリーンのサイズになるように、幅と高さを指定します。通常は、ウィンドウマネージャーによる装飾は表示されません(Emacsを起動した後に、F11 `toggle-frame-fullscreen`を使用して、この状態を切り替えることができます)。

‘`-mm`’; ‘`--maximized`’  
–maximized

maximized, command-line argument

Emacsのフレームが最大化されるよう指定します。これは通常、そのフレームがウィンドウマネージャーによる装飾をもつことを意味します(Emacsを起動した後に、`M-F10` `toggle-frame-maximized`を使用して、この状態を切り替えることができます)。

‘`-fh`’; ‘`--fullheight`’  
–fullheight

fullheight, command-line argument

高さがスクリーンの高さになるように指定します。

‘`-fw`’; ‘`--fullwidth`’  
–fullwidth

fullwidth, command-line argument

幅がスクリーンと同じ幅になるように指定します。

‘`--geometry`’オプションでは、`{+-}`は、プラス記号かマイナス記号のどちらかを意味します。xoffsetの前のプラス記号はスクリーンの左端からの距離、マイナス記号は右端からの距離を意味します。yoffsetの前のプラス記号はスクリーンの上端からの距離、マイナス記号は下端からの距離を意味します。xoffsetとyoffsetの値自体に正または負の値を指定できますが、それはこれらの意味を変更するものではなく、方向だけを変更します。

Emacsは、`xterm`がジオメトリーを解釈するのと同じ単位を使用します。widthとheightは文字で数えられるので、大きなフォントは、小さなフォントより大きなフレームを作成します(プロポーショナルフォントを指定した場合、Emacsは幅の単位として、そのプロポーショナルフォントの最大幅を使用します)。xoffsetとyoffsetはピクセルで数えます。

ジオメトリー指定で、すべてのフィールドを指定する必要はありません。xoffsetとyoffsetの両方を省略した場合、ウィンドウマネージャーがEmacsフレームをどこに配置するかを決定するか、もしかしたらマウスでその場所を指定できるかもしれません。たとえば‘`164x55`’は、ウィンドウの幅が164(通常のウィンドウを横に2つ並べられる幅)で、55行分の高さを指定します。

デフォルトのフレーム幅は80文字で、デフォルトの高さは36行です。幅と高さの、どちらか一方、または両方を省略できます。ジオメトリーが整数で開始される場合、Emacsはそれを幅と解釈します。ジオメトリーの開始が‘`x`’でその後に整数が続く場合、Emacsはそれを高さと解釈します。したがって‘`81`’は幅だけを指定し、‘`x45`’は高さだけを指定します。

ジオメトリーを‘`+`’か‘`-`’で開始した場合、それはオフセットを示し、幅と高さの両方のサイズが省略されたことを意味します。したがって‘`-3`’はxoffsetだけを指定します(オフセットを1つだけ与えたとき、それは常にxoffsetになります)。‘`+3-3`’はxoffsetとyoffsetの両方を指定し、フレームをスクリーンの左下に配置します。

Xリソースファイル([Resources](#Resources)を参照してください)で、任意またはすべてのフィールドにたいするデフォルトを指定できます。それらにたいしてフィールドを選択して、‘`--geometry`’オプションでオーバーライドできます。

モードラインとエコーエリアはフレームの2行を占めるので、初期のテキストウィンドウの高さは、ジオメトリーで指定した高さより、2つ少なくなります。非X-toolkitバージョンのEmacsでは、指定した数から、メニューバーの占める1行が引かれます。しかしX-toolkitバージョンでは、メニューバーは付加的で、指定された高さにたいして数えられません。ツールバーがある場合も、それは付加的です。

メニューバーやツールバーを有効または無効にすることにより、通常のテキストが利用できるスペースが変わります。したがって、Emacsがツールバーつき(デフォルト)で開始しされ、ツールバーがあることを前提にジオメトリー指定を処理して、それを初期化ファイルでツールバーを無効にしていた場合、あなたが指定したのと異なるフレームジオメトリーになるでしょう。ツールバーがないサイズを得るには、Xリソースで“no tool bar”を指定します([Table of Resources](#Table-of-Resources)を参照してください)。そうすれば、Emacsは指定されたジオメトリーを処理するときに、ツールバーがないことを知ることができます。

‘`--fullscreen`’、‘`--maximized`’、‘`--fullwidth`’、‘`--fullheight`’のどれか1つを使用するとき、フレームが本当に最大化またはフルスクリーンに見えるようにするために、変数`frame-resize-pixelwise`を非`nil`値にすることを要求するウィンドウマネージャーがいくつかあります。

位置にたいする、プログラム指定とユーザー指定の両方を無視するようにできるオプションをもつウィンドウマネージャーがいくつかあります。これらのオプションがセットされている場合、Emacsはウィンドウを正しく配置するのに失敗します。

内枠ボーダーと外枠ボーダー
--------------------------

borders (X Window System)
１つのEmacsフレームは内枠ボーダー(internal border)と、外枠ボーダー(outer border)をもちます。内枠ボーダーはフレームのテキスト部分の周囲にある、バックグラウンドカラーによる追加の縁取り(extra strip)です。内枠ボーダーはEmacs自身が描画します。外枠ボーダーはフレームのツールバーとメニューバーの外側にあり、Xにより描画されます。ウィンドウマネージャーにより描画される外部ボーダー(external border)も存在します。外部ボーダーのサイズは、Emacs内からセットすることはできません。

‘`-ib width`’; ‘`--internal-border=width`’  
–internal-border

internal border width, command-line argument

内枠ボーダー(フレームのテキストエリア周辺)の幅に、ピクセル単位でwidthを指定します。

‘`-bw width`’; ‘`--border-width=width`’  
–border-width

main border width, command-line argument

outer border width, command-line argument

外枠ボーダーの幅に、ピクセル単位でwidthを指定します。

フレームのサイズを指定するとき、ボーダーは含まれません。フレームの位置は、外枠ボーダーの縁端から測られます。

ピクセル幅nの内枠ボーダーを指定するには、‘`-ib
n`’オプションを使用します。デフォルトは1です。外枠ボーダーの幅を指定するには、‘`-bw
n`’を使用します(ウィンドウマネージャーはその指定に注意を払わないかもしれませんが)。外枠ボーダーのデフォルト幅は2です。

フレームタイトル
----------------

Emacshフレームは常に指定されたタイトルをもち、それはウィンドウ装飾とアイコンに、フレームの名前として表示されます。デフォルトのタイトルは‘`invocation-name@machine`’という形式(フレームが1つだけのとき)か、選択されたウィンドウのバッファー名(複数のフレームがある場合)になります。

コマンドラインオプションで、Emacsの初期フレームにデフォルト以外のタイトルを指定できます:

‘`-T title`’; ‘`--title=title`’  
–title

frame title, command-line argument

Emacs初期フレームのタイトルとしてtitleを指定します。

‘`--name`’オプション([Resources](#Resources)を参照してください)でも、Emacs初期フレームのタイトルを指定できます。

アイコン
--------

icons (X Window System)
minimizing a frame at startup
‘`-iconic`’; ‘`--iconic`’  
start iconified, command-line argument

Emacsをアイコン化した状態で開始します。

‘`-nbi`’; ‘`--no-bitmap-icon`’  
–no-bitmap-icon

Emacs icon, a gnu

Emacsアイコンの使用を無効にします。

ほとんどのウィンドウマネージャーでは、Emacsフレームをアイコン化(または“最小化”)して、見えなくすることができます。いくつかのウィンドウマネージャーでは、他のウィンドウマネージャーがアイコン化されたウィンドウを完全に見えなくするのにたいして、アイコン化されたウィンドウを小さなアイコンでおきかえるものもあります。‘`-iconic`’オプションは、フレームをすぐに表示するのではなく、アイコン化された状態で実行を開始するよう、Emacsに指示します。テキストフレームはアイコン化の解除(または“最小化の解除”)をするまで表示されません。

デフォルトでは、EmacsはEmacsロゴを含むアイコンを使用します。Gnomeのようなデスクトップ環境では、このアイコンは他のコンテキスト、たとえばEmacsフレームに切り替えるときにも表示されます。‘`-nbi`’または‘`--no-bitmap-icon`’オプションは、使用するアイコンの種類をウィンドウマネージャーに選択させるよう、Emacsに指示します。通常これはフレームのタイトルを含んだ、ただの矩形です。

その他のディスプレーオプション
------------------------------

‘`--parent-id id`’  
XEmbedプロトコルを通じて、idを親XウィンドウIDとする、クライアントXウィンドウとして、Emacsを開始します。現在のところ、このオプションは開発者にとって有用です。

‘`-vb`’; ‘`--vertical-scroll-bars`’  
–vertical-scroll-bars

vertical scroll bars, command-line argument

垂直スクロールバーを有効にします。

‘`-lsp pixels`’; ‘`--line-spacing=pixels`’  
–line-spacing

line spacing, command-line argument

行間の追加のスペースpixelsを、ピクセルで指定します。

‘`-nbc`’; ‘`--no-blinking-cursor`’  
–no-blinking-cursor

blinking cursor disable, command-line argument

グラフィカルなディスプレーで、点滅カーソルを無効にします。

‘`-D`’; ‘`--basic-display`’  
–basic-display

メニューバー、ツールバー、スクロールバー、ツールチップを無効にして、点滅カーソルをオフに切り替えます。これは表示問題のデバッグするテストケースを簡単にするのに有用です。

‘`--xrm`’オプション([Resources](#Resources)を参照してください)は、追加のXリソース値を指定します。

Xのオプションとリソース
=======================

Xを使用するプログラムにたいして通常行なうように、Xリソースを使用してEmacsのXに関連する外観をカスタマイズできます。

EmacsがGTK+サポートつきでコンパイルされている場合、メニューバー、スクロールバー、ダイアログボックスなどの、さまざまなグラフィカルウィジェットの外観は GTK+リソースで決定されるので、これについても説明します。 EmacsがGTK+のサポートなしでビルドされた場合、これらのウィジェットの外観は追加のXリソースにより決定されます。

MS-Windowsでは、システムレジストリー([MS-Windows Registry](#MS_002dWindows-Registry)を参照してください)を使用して、いくつかの外観を同じようにカスタマイズできます。

Xリソース
---------

resources
X resources
~/.Xdefaults
file
~/.Xresources
file
Xウィンドウシステムの下で実行されているプログラムは、クラスとリソースの階層の下にユーザーオプションを組織化します。これらのオプションにたいして、Xリソースファイル(X resource file)でデフォルト値を指定できます。Xリソースファイルは、通常`~/.Xdefaults`または`~/.Xresources`という名前です。このファイルの内容を変更しても、変更は即座に効果をもちません。これはXサーバーが独自にリソースのリストを保持しているからです。これを更新するには、たとえば‘`xrdb
~/.Xdefaults`’のように、コマンド`xrdb`を使用します。

一般的にXリソースを通じて指定されたセッティングは、特に初期フレームのパラメーター([Frame Parameters](#Frame-Parameters)を参照)に関して、Emacsのinitファイル([Init File](#Init-File)を参照)のセッティングをオーバーライドします。

registry, setting resources (MS-Windows)
(MS-WindowsシステムはXリソースファイルをサポートしません。そのようなシステムでは、EmacsはWindowsレジストリーの中からXリソースを探します。最初にキー‘`HKEY_CURRENT_USER\SOFTWARE\GNU\Emacs`’の下を探します。これはカレントユーザーだけに影響し、システムワイドなセッティングをオーバーライドします。次にキー‘`HKEY_LOCAL_MACHINE\SOFTWARE\GNU\Emacs`’の下を探します。これはシステムのすべてのユーザーに影響します。メニューとスクロールバーは、MS-Windowsのネイティブなウィジェットなので、Display Control Panelのシステムワイドなセッティングからしかカスタマイズできません。以下で説明するように、コマンドラインオプション‘`-xrm`’を使用して、リソースをセットすることもできます。)

Xリソースファイルの各行は、1つのオプション、または関連するオプションのコレクションにたいして値を指定します。ファイル内で行が出現する順番に意味はありません。各リソース指定は、プログラム名(program name)とリソース名(resource name)から構成されます。これらの名前の大文字小文字は区別されます。以下は例です:

    emacs.cursorColor: dark green

プログラム名は、そのリソースが適用される実行可能ファイルの名前です。Emacsでは通常、‘`emacs`’です。Emacsの実行可能ファイル名の如何にかかわらずに、Emacsのすべてのインスタンスに適用される定義を指定するには、‘`Emacs`’を使用します。

リソース名はプログラムセッティングの名前です。たとえばEmacsは、‘`cursorColor`’リソースを、テキストカーソルのカラーを制御するリソースと認識します。

リソースは、名前のついたクラスにグループ化されます。たとえば‘`Foreground`’クラスには、リソース‘`cursorColor`’、‘`foreground`’、‘`pointerColor`’が含まれます([Table of Resources](#Table-of-Resources)を参照してください)。以下のように、リソース名を使用するかわりに、クラス内のすべてのリソースにたいしてデフォルト値を指定するのに、クラス名を使用できます:

    emacs.Foreground: dark green

変数`inhibit-x-resources`を非`nil`値にセットした場合、EmacsはXリソースを処理しません。コマンドラインオプション‘`-Q`’ (または‘`--quick`’)でEmacsを呼び出した場合、`inhibit-x-resources`は自動的に`t`にセットされます([Initial Options](#Initial-Options)を参照してください)。

これに加えて、Xリソースファイルをオーバーライドするために、以下のコマンドラインオプションが使用できます:

‘`-name name`’; ‘`--name=name`’  
resource name, command-line argument

このオプションは初期Emacsフレームのプログラム名をnameにセットします。これは初期フレームのタイトルもnameにセットします。このオプションは、それ以降のフレームには影響しません。

このオプションを指定しない場合、プログラム名としてEmacs実行可能ファイル名をデフォルトとして使用されます。

整合性のため、‘`-name`’は、特定のフレームに属さない、他のリソース値にたいして使用する名前も指定します。

Emacs呼び出しの名前がつくリソースは、‘`Emacs`’という名前のクラスにも所属します。‘`emacs`’のかわりに‘`Emacs`’と記述した場合、実行可能ファイル名にかかわらず、そのリソースは、すべてのEmacsジョブのすべてのフレームに適用されます。

‘`-xrm resource-value`’; ‘`--xrm=resource-value`’  
resource values, command-line argument

このオプションは、現在のEmacsジョブにたいして、Xリソース値を指定します。

resource-valueは、Xリソースファイルの内部で使用するのと同じ形式をもつ必要があります。複数のリソース指定を含めるために、複数の‘`-xrm`’オプションを利用可能です。‘`#include
\"filename\"`’を使用して、ファイルのリソース指定をすべてインクルードすることもできます。‘`-xrm`’で指定されたリソース値は、他のすべてのリソース指定に優先します。

EmacsにたいするXリソースの表
----------------------------

以下のテーブルは、Emacsが認識するXリソース名です。いくつかのリソースは、Emacsが種々のXツールキット(GTK+、Lucid、...等)とともにコンパイルされていなければ効果がないことに注意してください(以下ではそのような場合は個々にを示す)。

`background` (class `Background`)  
バックグラウンドカラーです([Colors](#Colors)を参照してください)。

`bitmapIcon` (class `BitmapIcon`)  
‘`on`’のときはEmacsアイコンを表示し、‘`off`’のときは表示しないように、ウィンドウマネージャーに指示します。アイコンの説明は、[Icons X](#Icons-X)を参照してください。

`borderColor` (class `BorderColor`)  
フレームの外枠ボーダーのカラーです。EmacsがGTK+サポートつきでコンパイルされている場合、効果はありません。

`borderWidth` (class `BorderWidth`)  
フレームの外枠ボーダーの幅(ピクセル)です。EmacsがGTK+サポートつきでコンパイルされている場合、効果はありません。

`cursorBlink` (class `CursorBlink`)  
開始時に、このリソースの値が‘`off`’、‘`false`’、‘`0`’の場合、EmacsはBlink Cursorモードを無効にします([Cursor Display](#Cursor-Display)を参照してください)。

`cursorColor` (class `Foreground`)  
テキストカーソルのカラーです。Emacs開始時にこのリソースが指定されている場合、Emacsはその値を`cursor`フェイス([Faces](#Faces)を参照してください)のバックグラウンドカラーとしてセットします。

`font` (class `Font`)  
`default`フェイスにたいするフォント名です([Fonts](#Fonts)を参照してください)。フォントセット名([Fontsets](#Fontsets)を参照してください)を指定することもできます。

`fontBackend` (class `FontBackend`)  
フォントの描画に使用するバックエンドを、優先順にカンマ区切りで記述したリストです。たとえば値‘`x,xft`’は、EmacsにXコアフォントドライバー(X core font driver)を使用してフォントを描画し、それに失敗したときはXftフォントドライバー(Xft font driver)にフォールバックするよう指示します。このリソースは通常、セットしないでおくべきです。その場合、Emacsは利用可能なすべてのバックエンドの使用を試みます。

`foreground` (class `Foreground`)  
テキストにたいするデフォルトのフォアグラウンドカラーです。

`fullscreen` (class `Fullscreen`)  
望ましいフルスクリーンサイズを指定します。値は`fullboth`、`maximized`、`fullwidth`、`fullheight`のうちどれか1つを指定でき、これらはコマンドラインオプションの‘`-fs`’、‘`-mm`’、‘`-fw`’、‘`-fh`’に相当します([Window Size X](#Window-Size-X)を参照してください)。これは初期フレームだけに適用されることに注意してください。

`geometry` (class `Geometry`)  
ウィンドウのサイズと位置です。値にはコマンドラインオプション‘`-g`’または‘`--geometry`’と同じ形式で、サイズと位置を指定します。

サイズはEmacsセッションのすべてのフレームに適用されますが、位置は初期フレーム(特定のフレームにたいするリソースの場合は、そのフレーム)だけに適用されます。

このリソースを、‘`emacs*geometry`’のように指定しないように気をつけてください。これはEmacsのメインのフレームと同じように、個別のメニューにも影響します。

`horizontalScrollBars` (class `ScrollBars`)  
このリソースの値が‘`off`’、‘`false`’、‘`0`’の場合、Emacsは開始時にHorizontal Scroll Barモードを無効にします([Scroll Bars](#Scroll-Bars)を参照)。

`iconName` (class `Title`)  
アイコンに表示する名前です。

`internalBorder` (class `BorderWidth`)  
フレームの内枠ボーダーの幅(ピクセル)です。

`lineSpacing` (class `LineSpacing`)  
line spacing

行間の追加のスペース(ピクセル)です。

`menuBackground` (class `Background`)  
background for menus

ツールキット版でないEmacsの、メニューのバックグラウンドカラーです(ツールキット版の場合は[Motif Resources](#Motif-Resources)と[GTK resources](#GTK-resources)を参照してください)。

`menuBar` (class `MenuBar`)  
menu bar (X resource)

このリソースの値が‘`off`’、‘`false`’、‘`0`’の場合、Emacsは開始時にMenu Barモードを無効にします([Menu Bars](#Menu-Bars)を参照してください)。

`minibuffer` (class `Minibuffer`)  
‘`none`’の場合、Emacsはこのフレームにミニバッファーを作成しません。かわりに別のミニバッファーフレームを使用します。

`paneFont` (class `Font`)  
font for menus

ツールキット版でないEmacsの、メニューペインタイトルのフォント名です(ツールキット版の場合は[Lucid Resources](#Lucid-Resources)、[Motif Resources](#Motif-Resources)、[GTK resources](#GTK-resources)を参照)。

`paneForeground` (class `Foreground`)  
foreground for menus

ツールキット版でないEmacsの、メニューペインタイトルのフォント名です(ツールキット版の場合は[Lucid Resources](#Lucid-Resources)、[Motif Resources](#Motif-Resources)、[GTK resources](#GTK-resources)を参照)。

`pointerColor` (class `Foreground`)  
マウスカーソルのカラーです。多くのグラフィカルなデスクトップ環境では、この方法でEmacsがマウスカーソルを変更するのを許さないので、効果はありません。

`privateColormap` (class `PrivateColormap`)  
‘`on`’の場合、Emacsが使用するクラスPseudoColorのdefault visualが使用されている場所で、プライベートなカラーマップを使用します。

`reverseVideo` (class `ReverseVideo`)  
‘`on`’の場合はデフォルトのフォア九ラウンドカラーとバックグラウンドカラーを切り替え、‘`off`’の場合は指定されたカラーを使用します。

`screenGamma` (class `ScreenGamma`)  
gamma correction

カラーのガンマ補正で、フレームパラメーターの`screen-gamma`と等価です。

`scrollBar` (class `ScrollBar`)  
scroll bar

このリソースの値が‘`off`’、‘`false`’、‘`0`’の場合、Emacsは開始時にScroll Barモードを無効にします([Scroll Bars](#Scroll-Bars)を参照してください)。

`scrollBarWidth` (class `ScrollBarWidth`)  
scrollbar width

スクロールバーの幅(ピクセル)で、フレームパラメーターの`scroll-bar-width`と等価です。EmacsがGTK+サポートつきでコンパイルされている場合は、このリソースをセットしないでください。

`selectionFont` (class `SelectionFont`)  
ツールキット版でないEmacsの、ポップアップメニューアイテムのフォント名です(ツールキット版の場合は[Lucid Resources](#Lucid-Resources)、[Motif Resources](#Motif-Resources)、[GTK resources](#GTK-resources)を参照)。

`selectionForeground` (class `SelectionForeground`)  
ツールキット版でないEmacsの、ポップアップメニューアイテムのフォアグラウンドカラーです(ツールキット版の場合は[Lucid Resources](#Lucid-Resources)、[Motif Resources](#Motif-Resources)、[GTK resources](#GTK-resources)を参照してください)。

`selectionTimeout` (class `SelectionTimeout`)  
選択にたいする応答を待つ時間(ミリ秒)です。選択したオーナーが、この時間内に応答しない場合は諦めます。値0は必要なだけ待つことを意味します。

`synchronous` (class `Synchronous`)  
debugging X problems

synchronous X mode

‘`on`’の場合、Emacsを同期モード(synchronous mode)で実行します。同期モードはXに関する問題のデバッグに有用です。

`title` (class `Title`)  
初期Emacsフレームのタイトルバーに表示する名前です。

`toolBar` (class `ToolBar`)  
tool bar

このリソースの値が‘`off`’、‘`false`’、‘`0`’の場合、Emacsは開始時にTool Barモードを無効にします([Tool Bars](#Tool-Bars)を参照してください)。

`useXIM` (class `UseXIM`)  
XIM

X input methods

input methods, X

‘`false`’または‘`off`’の場合、X入力メソッド(XIM: X input methods)の使用を無効にします。これはEmacsがXIMサポートつきでビルドされた場合だけ関係があります。Xのクライアント/サーバーのリンクが遅いときは、XIMをオフにするのが便利かもしれません。

`verticalScrollBars` (class `ScrollBars`)  
‘`left`’の場合はフレームの左側、‘`right`’の場合は右側、‘`off`’のときはスクロールバーをもちません([Scroll Bars](#Scroll-Bars)を参照)。

`visualClass` (class `VisualClass`)  
Xカラーディスプレーのvisual classです。指定する場合、値は‘`TrueColor`’、‘`PseudoColor`’、‘`DirectColor`’、‘`StaticColor`’、‘`GrayScale`’、‘`StaticGray`’で始まり、その後に‘`-depth`’が続きます。ここでdepthは色平面の数です。

特定のEmacsフェイスのカスタマイズに、Xリソースを使用することもできます([Faces](#Faces)を参照してください)。たとえば‘`face.attributeForeground`’をセットするのは、フェイスfaceの‘`foreground`’属性をカスタマイズするのと等価です。しかし、わたしたちはXリソースを使用してフェイスのカスタマイズするかわりに、Emacs内でフェイスをカスタマイズする方法を推奨します。[Face Customization](#Face-Customization)を参照してください。

Lucidのメニューとダイアログ
---------------------------

Menu X Resources (Lucid widgets)
Dialog X Resources (Lucid widgets)
Lucid Widget X Resources
EmacsがLucidウィジェットを使用したXツールキットサポートつきでコンパイルされた場合、メニューバー([Menu Bar](#Menu-Bar)を参照)、ポップアップメニュー、ダイアログボックス([Dialog Boxes](#Dialog-Boxes)を参照)の外観をカスタマイズするために、Xリソースを使用できます。メニューバーにたいするリソースは、‘`pane.menubar`’クラスの中に集められています(例のごとくEmacs実行可能ファイル名または、すべてのEmacs呼び出しに対応する‘`Emacs`’の後に続けて記述します)。ポップアップメニューにたいするリソースは、‘`menu*`’クラスの中です。ダイアログボックスにたいするリソースは、‘`dialog*`’クラスの中です。

たとえばメニューバーエントリーを‘`Courier-12`’フォントで表示するには、以下のように記述します:

    Emacs.pane.menubar.font: Courier-12

Lucidウィジェットは、あなたのlocaleで他国語テキストを表示できます。これを有効にするには、`font`リソースのかわりに、`fontSet`リソースを指定します。`font`と`fontSet`の両方のリソースが指定された場合は、`fontSet`リソースが使用されます。

以下はメニューバー、ポップアップメニュー、ダイアログにたいするリソースのリストです:

`font`  
メニューアイテムのテキストにたいするフォントです。

`fontSet`  
メニューアイテムのテキストにたいするフォントセットです。

`background`  
バックグラウンドカラーです。

`buttonForeground`  
選択されたアイテムのフォアグラウンドカラーです。

`foreground`  
フォアグラウンドカラーです。

`horizontalSpacing`  
アイテム間の水平間隔(ピクセル)です。デフォルトは3です。

`verticalSpacing`  
アイテム間の垂直間隔(ピクセル)です。デフォルトは2です。

`arrowSpacing`  
(サブメニューを示す)矢印と、それに付随するテキストの間の水平間隔です。デフォルトは10です。

`shadowThickness`  
3Dのボタン、矢印、その他グラフィカルな要素の陰線(shadow lines)の厚さです。デフォルトは1です。

`margin`  
メニューバーの余白(文字数)です。デフォルトは1です。

MotifメニューのXリソース
------------------------

Menu X Resources (Motif widgets)
Motif Widget X Resources
EmacsがMotifまたはLessTifのウィジェットを使用するXツールキットサポートつきでコンパイルされた場合、メニューバー([Menu Bar](#Menu-Bar)を参照)、ポップアップメニュー、ダイアログボックス([Dialog Boxes](#Dialog-Boxes)を参照)の外観をカスタマイズするために、Xリソースを使用できます。しかし、これらのリソースは、Lucidウィジェットとは組織方法が異なります。

メニューバーにたいするリソース名は‘`pane.menubar`’クラスの中にあり、それらは以下の形式で指定しなければなりません:

    Emacs.pane.menubar.subwidget.resource: value

ポップアップメニューにたいするリソースは、‘`pane.menubar`’ではなく、‘`menu*`’クラスの中にあります。ダイアログボックスにたいするリソースは‘`dialog`’クラスの中です。どの場合でも、それぞれのメニュー文字列がサブウィジェットです。サブウィジェットの名前は、メニューアイテム文字列と同じです。たとえば、メニューバーの中の‘`File`’メニューは、‘`emacs.pane.menubar.File`’という名前のサブウィジェットです。

通常は、メニューバー全体に同じリソースを指定したいでしょう。これを行なうには、特定のウィジェット名のかわりに‘`*`’を使用します。たとえば、サブメニューを含むすべてのメニューバーアイテムに、フォント‘`8x16`’を指定するには、以下のように記述します:

    Emacs.pane.menubar.*.fontList: 8x16

サブメニューの中の各アイテムは、Xリソースにたいする独自の名前をもちます。たとえば‘`File`’サブメニューは、‘`Save
(current buffer)`’という名前のアイテムをもちます。サブメニューアイテムにたいするリソース指定は以下のようになります:

    Emacs.pane.menubar.popup_*.menu.item.resource: value

たとえば、以下は‘`Save (current buffer)`’アイテムにフォントを指定する方法です:

    Emacs.pane.menubar.popup_*.File.Save (current buffer).fontList: 8x16

‘`Tools`’の下の、‘`Spell Checking`’の下の‘`Complete
Word`’のような、第2レベルのアイテムには、以下のテンプレートが当てはまります:

    Emacs.pane.menubar.popup_*.popup_*.menu.resource: value

たとえば、

    Emacs.pane.menubar.popup_*.popup_*.Spell Checking.Complete Word: value

(これは長い1行で記述する必要があります。)

サブメニューアイテムにメニューバー自体とは異なる外観を与えたい場合、最初にすべてにたいしてリソースを指定してから、そのサブメニューにたいする値をオーバーライドしなければなりません。以下は例です:

    Emacs.pane.menubar.*.fontList: 9x18
    Emacs.pane.menubar.popup_*.fontList: 8x16

LessTifのファイル選択ボックスにたいしてリソースを指定するには、以下のように‘`fsb*`’を使用します:

    Emacs.fsb*.fontList: 8x16

以下はLessTifのメニューバーとポップアップメニューにたいするリソースのリストです:

`armColor`  
アームドボタン(armed button: 押されてまだ離されていないボタン)を表示するカラーです。

`fontList`  
使用するフォントです。

`marginBottom`; `marginHeight`; `marginLeft`; `marginRight`; `marginTop`; `marginWidth`  
アイテムの周囲に残すスペースの量を、ボーダーも含めて指定します。

`borderWidth`  
メニューアイテムの各辺のボーダーの幅です。

`shadowThickness`  
ボーダーの影の幅です。

`bottomShadowColor`  
ボーダーの影の底辺と右辺のカラーです。

`topShadowColor`  
ボーダーの影の上辺と左辺のカラーです。

GTK+リソース
------------

GTK+ resources
resource files for GTK+
~/.gtkrc-2.0
file
~/.emacs.d/gtkrc
file
EmacsがGTK+サポートつきでコンパイルされた場合、EmacsのGTK+ウィジェット(例: メニュー、ダイアログ、ツールバー、スクロールバー)をカスタマイズする一番簡単な方法は、たとえばGNOME theme selectorなどで適切なGTK+テーマを選択する方法です。

GTK+バージョン2では、Emacsで使用されるGTK+ウィジェットの外観をカスタマイズするために、GTK+リソースも使用できます。これらのリソースは、ファイル`~/.emacs.d/gtkrc`(Emacs固有のGTK+リソース用)、またはファイル`~/.gtkrc-2.0`(一般的なGTK+リソース用)のどちらかで指定されます。GTK+は、GNOMEでGConfを実行するとき`~/.gtkrc-2.0`を無視するように思われるため、わたしたちは`~/.emacs.d/gtkrc`の使用を推奨します。しかし`~/.emacs.d/gtkrc`によるカスタマイズをオーバーライドするGTK+テーマがあることに注意してください。これにたいして、わたしたちができることはありません。GTK+リソースは、EmacsのGTK+ウィジェットと関係のない側面、たとえばEmacsのメインウィンドウのフォントやカラーにたいしては影響しません。これらは通常のXリソースに管理されます([Resources](#Resources)を参照してください)。

以下のセクションでは、EmacsにたいしてGTK+リソースをカスタマイズする方法を説明します。GTK+リソースについての詳細は、<https://developer.gnome.org/gtk2/stable/gtk2-Resource-Files.html>のGTK+ APIドキュメントを参照してください。

GTK+バージョン3では、GTK+リソースは完全に異なるシステムに置き換えられました。GTK+ウィジェットの外観は、今やCSS-likeなスタイルのファイル、すなわちGTK+をインストールしたディレクトリーの`gtk-3.0/gtk.css`、およびローカルなスタイルセッティングにたいしては`~/.themes/theme/gtk-3.0/gtk.css`で決定されます(themeはカレントGTK+テーマの名前です)。したがってこのセクションのGTK+リソースの説明は、GTK+3に適合しません。GTK+3スタイリングシステムについての詳細は、<https://developer.gnome.org/gtk3/3.0/GtkCssProvider.html>を参照してください。

### GTK+ Resource Basics

GTK+2リソースファイル(通常は`~/.emacs.d/gtkrc`)で、リソースをセットする一番簡単な方法は、単に変数に値を割り当てる方法です。たとえば以下の行を利ソースファイルに置くことにより、すべてのGTK+ウィジェットのフォントが‘`courier-12`’に変更されます:

    gtk-font-name = "courier 12"

この場合、フォント名はFontconfigスタイルのフォント名やXLFDではなく、GTKフォントパターン(Pangoフォント名とも呼ばれます)で記述しなければなりません。[Fonts](#Fonts)を参照してください。

ウィジェットをカスタマイズするには、最初にスタイルを定義して、そのスタイルをウィジェットに適用します。以下はメニューにたいしてフォントをセットする例です(文字‘`#`’はコメントを示します):

    # Define the style ‘my_style’.
    style "my_style"
    {
      font_name = "helvetica bold 14"
    }

    # Specify that widget type ‘*emacs-menuitem*’ uses ‘my_style’.
    widget "*emacs-menuitem*" style "my_style"

この例のウィジェット名にはワイルドカードが含まれるので、このスタイルは‘`*emacs-menuitem*`’にマッチするすべてのウィジェットに適用されます。ウィジェットは、外側のウィジェットから内側のウィジェットへと、それが含まれる方法により、名前がつけられます。以下はEmacsメニューバーに‘`my_style`’を指定して適用する例です:

    widget "Emacs.pane.menubar.*" style "my_style"

以下はスクロールバーを部分的に変更する方法を示す、より複雑な例です:

    style "scroll"
    {
      fg[NORMAL] = "red"     # Arrow color.
      bg[NORMAL] = "yellow"  # Thumb and background around arrow.
      bg[ACTIVE] = "blue"    # Trough color.
      bg[PRELIGHT] = "white" # Thumb color when the mouse is over it.
    }

    widget "*verticalScrollBar*" style "scroll"

### GTK+ウィジェット名

GTK+ widget names
GTK+ウィジェットはウィジェット名(widget name)とウィジェットクラス(widget class)により指定されます。ウィジェット名は特定のウィジェット(たとえば‘`emacs-menuitem`’)を参照し、ウィジェットクラスは似通ったウィジェット(たとえば‘`GtkMenuItem`’)のコレクションを参照します。ウィジェットは常にクラスをもちますが、名前をもつ必要はありません。

絶対名(absolute names)とは、一連のウィジェット名またはウィジェットクラスで、他のウィジェットに埋め込まれたウィジェットの階層に対応します。たとえば、`top`という名前の`GtkWindow`が、`box`という名前の`GtkVBox`を含み、それがさらに`menubar`という名前の`GtkMenuBar`を含む場合、メニューバーウィジェットの完全クラス名は`GtkWindow.GtkVBox.GtkMenuBar`で、完全ウィジェット名は`top.box.menubar`になります。

GTK+リソースファイルには、ウィジェットの外観を指定する2種類のコマンドを含めることができます:

`widget`  
クラス名または単にクラスにもとづいてウィジェットのスタイルを指定します。

`widget_class`  
クラス名にもとづいてウィジェットのスタイルを指定します。

`widget`コマンドを使用する例は、前のセクションを参照してください。`widget_class`コマンドも同じように使用されます。ウィジェット名/ウィジェットクラスとスタイルはダブルクォートで囲わなければならないこと、そしてこれらのコマンドはGTK+リソースファイルのトップレベルに記述しなければならないことに注意してください。

前に記したように、ウィジェット名とウィジェットクラスはシェルのワイルドカード構文で指定することができます。‘`*`’は0文字以上にマッチし、‘`?`’は1文字にマッチします。以下はすべてのウィジェットにスタイルを割り当てる例です:

    widget "*" style "my_style"

### EmacsでのGTK+ウィジェット名

GTK+ widget names in Emacs
GTK+ widget classes
Emacsフレームが使用するGTK+ウィジェットを以下にリストします:

`Emacs` (class `GtkWindow`)  
`pane` (class `GtkVBox`)  
`menubar` (class `GtkMenuBar`)  
\[menu item widgets\]  

\[unnamed widget\] (class `GtkHandleBox`)  
`emacs-toolbar` (class `GtkToolbar`)  
\[tool bar item widgets\]  

`emacs` (class `GtkFixed`)  
`verticalScrollBar` (class `GtkVScrollbar`)  

Emacsウィンドウの内容は、`emacs`ウィジェットにより描画されます。複数のEmacsウィンドウがある場合でも、それぞれのスクロールバーウィジェットの名前は`verticalScrollBar`であることに注意してください。

たとえば、以下はメニューバーのスタイルをセットする、2つの異なる方法の例です:

    widget "Emacs.pane.menubar.*" style "my_style"
    widget_class "GtkWindow.GtkVBox.GtkMenuBar.*" style "my_style"

GTK+ダイアログにたいしては、Emacsはクラス`GtkDialog`の、`emacs-dialog`という名前のウィジェットを使用します。ファイル選択にたいしては、Emacsはクラス`GtkFileSelection`の、`emacs-filedialog`という名前のウィジェットを使用します。

ポップアップメニューとダイアログのウィジェットは独立したウィンドウであり、`Emacs`ウィジェットに含まれていないので、それらのGTK+完全名は‘`Emacs`’で始まりません。これらのウィジェットをカスタマイズするには、以下のようにワイルドカードを使用します:

    widget "*emacs-dialog*" style "my_dialog_style"
    widget "*emacs-filedialog* style "my_file_style"
    widget "*emacs-menuitem* style "my_menu_style"

Emacsのすべてのメニューにスタイルを適用したい場合は、以下を使用します:

    widget_class "*Menu*" style "my_menu_style"

### GTK+スタイル

GTK+ styles
以下は2つのGTK+スタイル宣言の例です:

    pixmap_path "/usr/share/pixmaps:/usr/include/X11/pixmaps"

    style "default"
    {
      font_name = "helvetica 12"

      bg[NORMAL] = { 0.83, 0.80, 0.73 }
      bg[SELECTED] = { 0.0, 0.55, 0.55 }
      bg[INSENSITIVE] = { 0.77, 0.77, 0.66 }
      bg[ACTIVE] = { 0.0, 0.55, 0.55 }
      bg[PRELIGHT] = { 0.0, 0.55, 0.55 }

      fg[NORMAL] = "black"
      fg[SELECTED] = { 0.9, 0.9, 0.9 }
      fg[ACTIVE] = "black"
      fg[PRELIGHT] = { 0.9, 0.9, 0.9 }

      base[INSENSITIVE] = "#777766"
      text[INSENSITIVE] = { 0.60, 0.65, 0.57 }

      bg_pixmap[NORMAL] = "background.xpm"
      bg_pixmap[INSENSITIVE] = "background.xpm"
      bg_pixmap[ACTIVE] = "background.xpm"
      bg_pixmap[PRELIGHT] = "<none>"

    }

    style "ruler" = "default"
    {
      font_name = "helvetica 8"
    }

スタイル‘`ruler`’は‘`default`’を継承します。この方法により、既存のスタイルを元にすることができます。フォントとカラーの構文は以下に記述されています。

この例が示すように、ウィジェットの状態にもとづいてフォアグラウンドとバックグラウンドのカラーに複数の値を指定することが可能です。以下の状態が利用できます:

`NORMAL`  
ウィジェットのフォルトの状態です。

`ACTIVE`  
ウィジェットが何かを行なう準備ができた状態です。これはスクロールバーの溝(trough)にも適用できます。たとえば`bg[ACTIVE] =
"red"`はスクロールバーの溝を赤にセットします。ボタンのarmed(ボタンが押されてまだ離されていない状態)も、この状態です。

`PRELIGHT`  
マウスポインターがその上にきたとき、ウィジェットが操作可能な状態です — たとえばマウスがスクロールバーのハンドルの上やメニューアイテムの上にきたときの状態です。押されていないボタンの上にマウスがくると、そのボタンはこの状態になります。

`SELECTED`  
ユーザーにより選択されたデータにたいする状態です。それは選択されたテキストやリストの選択されたアイテムの場合もあります。この状態はEmacsでは使用されません。

`INSENSITIVE`  
ウィジェットが可視だが通常の方法では操作できない状態 — たとえば押せないボタンや、無効なメニューアイテムなどです。無効なメニューアイテムを黄色で表示するには、`fg[INSENSITIVE] =
"yellow"`を使用します。

以下をスタイル宣言に記述できます:

`bg[state] = color`  
ウィジェットのバックグラウンドカラーを指定します。編集可能なテキストは`bg`ではなく`base`を使用することに注意してください。

`base[state] = color`  
編集可能なテキストのバックグラウンドカラーを指定します。Emacsでは、ファイルダイアログのテキストフィールドのバックグラウンドに、このカラーが使用されます。

`bg_pixmap[state] = "pixmap"`  
(バックグラウンドカラーのかわりに)バックグラウンドイメージを指定します。pixmapはイメージファイル名です。GTK+はXPM、XBM、GIF、JPEG、PNGヲ含む、いくつかのイメージファイルを使用することができます。親ウィジェットと同じイメージをウィジェットに使用したい場合は、‘`<parent>`’を使用します。イメージを使わない場合は、‘`<none>`’を使用します。‘`<none>`’で、親スタイルから継承されたバックグラウンドイメージをキャンセルできます。

ファイル名は絶対ファイル名で指定できません。GTK+は`pixmap_path`で指定されたディレクトリーのpixmapファイルを探します。`pixmap_path`は、ダブルクォートされたファイルをコロンで区切ったリストで、`gtkrc`ファイルのトップレベルで指定します(スタイル定義の中ではありません。上記の例を参照してください)。

    pixmap_path "/usr/share/pixmaps:/usr/include/X11/pixmaps"

`fg[state] = color`  
使用するウィジェットのフォアグラウンドカラーを指定します。これはメニューやボタンのテキストのカラー、スクロールバーの矢印のカラーです。編集可能なテキストにたいしては、`text`を使用します。

`text[state] = color`  
編集可能なテキストのカラーです。Emacsでは、ファイルダイアログのテキストフィールドに使用されるカラーです。

`font_name = "font"`  
ウィジェット内のテキストのフォントを指定します。fontは、‘`Sans Italic
10`’のような、GTK(Pango)スタイルのフォント名です。[Fonts](#Fonts)を参照してください。名前は大文字小文字を区別しません。

カラーを指定する3つの方法があります。それはカラーネーム、RGBトリプレット、GTKスタイルRGBトリプレットです。カラーネームとRGBトリプレットについては、[Colors](#Colors)を参照してください。カラーネームは‘`"red"`’のように、ダブルクォートで囲む必要があります。RGBトリプレットは‘`#ff0000`’のように、ダブルクォートで囲う必要がありません。GTKスタイルRGBトリプレットは`{
r, g, b
}`という形式をもち、r、g、bは、0から65535の整数か、0.0から1.0の浮動小数点数です。

Emacs 25 アンチニュース
=======================

時代に逆らって生きるユーザーのために、以下はEmacsバージョン25.3へのダウングレードに関する情報です。Emacs 26.2機能の不在による結果としての偉大なる単純さを、ぜひ堪能してください。

-   Emacsはビルド時にデフォルトでGnuTLSライブラリーを要求しなくなりました。ビルトインとしてTLS機能を欲するユーザーは、ビルド時に明示的に要求するか — 永遠に口を閉じているかです。わたしたちはTLS機能をもつことにより、libgnutls不在によるエラーメッセージにより、ユーザーやパッケージをビルドする人を煩わせるのは、正当性はないと判断しました。また、GnuTLSとともにビルドする場合は、バージョン2.12.2はあなたが時代を逆行するにしたがい利用性と知名度が減少するので、2.12.2より古いバージョンが容認されると判断しました。

-   同様の理由により、安全でないチャンネルを通じた平文によりPOP3メールを取得する、わたしたち自身のバージョンの`movemail`をビルドするように戻しました。あなたが時代を逆行するにしたがい、POP3の安全な代替物の利用性は減少していき、わたしたちは単にそれを熱烈に支持するだけです。さらにconfigure時のオプション`--with-mailutils`は、観察可能な過去において意味をもたないため削除されました。

-   わたしたちは`systemd`と、それに類するサービスにたいするサポートを削除しました。これらのサービスを通じたEmacs使用を可能にするユーザーのinitファイルは提供されなくなり、これらのサービス下でのEmacsクライアントにとっては重要だったEmacsサーバーのソケット起動にたいするサポートも削除されました。繰り返しますが、これらのサービスはあなたが時代を逆行するにしたがい知名度を失うので、これらをサポートするコードはEmacsを肥大化させるだけの不要コードなのです。

-   Emacsの再現可能なビルドは、過去の開発により不必要になるので、サポートされなくなります。

-   `--fg-daemon`はなくなり、`--daemon`だけが残りました。新しい光り輝く“愚かなEmacs(headless Emacs)”を欲すべきか否かというジレンマなどでグズグズする必要はありません。Hail, simplicity!(単純さ、万歳!)

-   あなたが時代を逆行するにしたがいTrueColorをサポートするテキスト端末は地歩を失うので、わたしたちはテキスト端末の24ビットカラーにたいするサポートを削除しました。テキスト端末に色を望むなら、8ビットカラーで満足すべきなのです。(正直に言うと、わたしたちはテキスト端末はモノクロであるべきと考えています。ただ、あなたがこの機能に戻るためには、古いEmacsバージョンへとダウングレードを続ける必要があるでしょう。)

-   Emacs 25.3ではスクリプト内の‘`#!/usr/bin/env
    interpreter`’形式によるフォーマット識別子(magic signature)はサポートされなくなります。時代を逆行するということは、すべてのインタープリターは単一のディレクトリー`/bin`にあるという原始Unixデザインに近づくことを意味するので、この空想的な機能は単に不必要となるのが確実です。

-   X上でのEmacsディスプレイのダブルバッファリング機能は削除されました。たとえこの機能で得られるものを一部の人々が熱望するとしても、わたしたちはその複雑性と2、3の突発的で驚くべき副作用は、それにより得られるものを正当化しないと判断しました。確かにEmacs 25.3は、あるユースケースにおいてはチカチカします。しかしEmacsユーザーは彼らが何年もしてきたように、そんなことは乗り越えるのです。この機能がなくなったので、今や不必要となったフレームパラメーター`inhibit-double-buffering`も削除しました。

-   サポートされていないクォート文字の代替えとして表示されていたnon-breaking hyphenとASCII文字は、再び`escape-glyph`フェイスを使用して表示されます。わたしたちは3つの異なるフェイスより単一のフェイスをもつほうが、ユーザーのEmacsカスタマイズ作業をより単純にすると考えます。同じ理由により`header-line-highlight`は削除され、Emacsディスプレイのモードライン周辺の要素は単なる`highlight`フェイスとなります。

-   Cのスタックオーバーフローのような致命的な例外や致命的なシグナルからのリカバリーの試みは、無効にできなくなりました。Emacsに含まれるリカバリー機能は十分に信頼に足るので、これらの状況が発生したときに編集内容を失うような危険にさらす必要はないとわたしたちは判断しました。したがって、変数`attempt-stack-overflow-recovery`および`attempt-orderly-shutdown-on-fatal-signal`は削除されました。

-   タイマーはユーザーレベルの機能ではないとわたしたちは判断したため、`list-timers`コマンドは削除されました。ユーザーはタイマーへの干渉を許されるべきではないのです。近くのEmacs Lisp導師に、セッション内に暴走タイマー(runaway timer)があったらどうなるか尋ねてください。(もちろん、あなたが時代を逆行するにしたがい、そのような暴走タイマーは稀になり、実際のタイマーは反対方向の時間には対処できないので、自動的にシャットダウンを開始するでしょう。)

-   マウスやタッチパッドを使用した水平スクロールは削除されました。過去にはワイドモニターはそれほどポピュラーではなかったので、水平スクロールはもはや必要とされないでしょう。水平スクロールにたいするマウスサポートの削除は、以前のバージョンのEmacsにおける水平スクロール完全削除の最初のステップです。

-   わたしたちは`emacsclient`の`--tramp`オプションは、あまりに危険かつ複雑なことに気づいたので、クライアントコードと使い方の単純化のため削除しました。

-   `display-raw-bytes-as-hex`変数はなくなったので、8進エスケープでのみrawバイトの表示が可能です。Emacsユーザーなら、8進から他の基数への変換など、眠りながらできるべきなのです!

-   バッファーにたいする行番号の表示は、ディスプレイ余白に番号を表示するだけの`linum-mode`モードのようなアドオンを使用したときだけ可能になります。これらの機能を用いた行番号表示は低速でもあり、第一そのような機能はEmacsっぽくなく、Emacsに含まれるべきではないと、わたしたちは確信しています。その結果、`display-line-numbers-mode`は削除されました。

-   Emacsのシンプル化という永遠の課題のもと、わたしたちはオプション`--alternate-editor`および環境変数ALTERNATE\_EDITORを通じてコマンドライン引数をEmacsに渡すためのサポートを削除しました。残ったのは真のEmacs — `emacs`として呼び出されたときは、これらすべての奇妙なオプションなど必要としないEmacsだけです!

-   “単一行水平スクロール(single-line horizontal scrolling)”として知られる複雑さは、Emacs 25.3からなくなります。これは、“他のエディター”に屈従する機能でした。そのかわりに毎回ウィンドウ全体を水平スクロールすることにより、他のエディターをEmacsに屈従させましょう。わたしの後に続けてください、“Emacs流オンリー!!(The Emacs way is the Only Way!)”

-   TurkishやGreekのようないくつかのlocaleで使用されていた、非ASCIIの空想的な大文字小文字変換は、7ビットASCIIにおける大文字と小文字の単純な関連性のみを残して削除されました。同様に、大文字小文字を変換したときに複数の文字に変換されるような関連性も — 削除されました。

-   Enchant、および同じようなスペルチェックコマンドは、`ispell-buffer`によりサポートされなくなりました。あなたが時代を逆行するにしたがいEnchantは次第に消え去り、それにたいするサポートも必要なくなります。

-   TrampはGoogle Driveリポジトリーにたいするサポートを失いました。あなたが時代を逆行するにしたがいクラウドストレージは逐次消え去るので、この機能は冗長になっていきます。

-   不必要に複雑と思われる、いくつかのコマンドは削除されました。それらのコマンドには、たとえば`replace-buffer-contents`や`apropos-local-variable`が含まれます。

-   Emacs 25.3では、コンピューターのメモリー容量とディスク容量を削減して、良好な状態に保つために、その他多くの機能とファイルが削除されました。

EmacsとmacOS / GNUstep
======================

macOS
Macintosh
GNUstep
このセクションでは、GNU/Linuxまたはその他のオペレーティングシステムでGNUstepライブラリーとともにビルドされたEmacs、またはmacOSでネイティブウィンドウシステムのサポートつきでビルドされたEmacsを使用する際の特性を説明します。macOSでは、Emacsはウィンドウシステムサポートなし/あり、X11、Cocoaインターフェースのいずれかでビルドできます。このセクションはCocoaビルドだけに適合します。バージョン10.6より前のmacOSはサポートしません。

GNUstepはフリーソフトウェアであり、macOSはそうではありません。非フリーなオペレーティングシステムのため、macOSはすべてのコンピューターユーザーが享受すべき自由を、ユーザーに与えません。これは不当です。あなたの自由のために、わたしたちはフリーなオペレーティングシステムへの切り替えを強く推奨します。

わたしたちは、商業オペレーティングシステム上のGNU Emacsをサポートします。なぜならそれは、この自由の経験が、商業オペレーティングシステムから脱却するよう、ユーザーを奮起するだろうからです。

さまざまな歴史的、技術的な理由により、Emacsは内部的に“Cocoa”や“macOS”ではなく、‘`Nextstep`’という用語を使用します。たとえばこのセクションで説明するほとんどのコマンドや変数は‘`ns-`’で始まりますが、これは‘`Nextstep`’を短縮したものです。NeXTstepは1980年代にNeXT Inc.からリリースされたアプリケーションインターフェースで、Cocoaはそれの直系の子孫です。Cocoaとは別に、他にもNeXTstepスタイルのシステムのGNUstepがあり、これはフリーソフトウェアです。これを記述している時点で、EmacsのGNUstepサポートはアルファ状態([GNUstep Support](#GNUstep-Support)を参照してください)ですが、わたしたちは、将来これを改善したいと望んでいます。

macOSおよびGNUstepでのEmacsの基本的な使い方
-------------------------------------------

modifier keys (macOS)
デフォルトでは、キーAltとOptionは、Metaと同じです。MacのCmdキーはSuperと同じで、Emacsは他のMac/GNUstepアプリケーション([Mac / GNUstep Events](#Mac-_002f-GNUstep-Events)を参照してください)を模倣するこれらの修飾キーを使用した、一連のキーバインドを提供します。これらのキーバインドは通常の方法で変更できます([Key Bindings](#Key-Bindings)を参照してください)。

ns-alternate-modifier
ns-right-alternate-modifier
変数`ns-right-alternate-modifier`は、右のAltとOptionキーの動作を制御します。変数の値が`left`(デフォルト)の場合、これらのキーは左側のキーと同じように動作します。値が`control`、`meta`、`alt`、`super`、`hyper`の場合、これらのキーはその値に対応する修飾キーのように動作します。値`left`は、`ns-alternate-modifier`と同じキーであることを意味します。値`none`は、Emacsにこれらを無視するよう指示します。この場合は、右OptionキーにたいするmacOS強調システム(accentuation system)のデフォルトの挙動を得ることができます。

`S-mouse-1`は`mouse-3`と同様に、クリックした位置にリージョンを調整します(`mouse-save-then-kill`)。`S-mouse-1`が通常行なうように、デフォルトフェイスを変更するためのポップアップメニュー([Text Scale](#Text-Scale)を参照してください)は表示しません。この変更は、Emacsが他のMac/GNUstepアプリケーションと同じように動作させるためです。

メニューを使用してファイルを開いたり保存するときや、`Cmd-o`や`Cmd-S`といったキーバインドを使用する場合、Emacsはファイル名の読み取りにグラフィカルなファイルダイアログを使用します。しかし`C-x
C-f`のような標準のEmacsのキーシーケンスを使用する場合、Emacsはミニバッファーを使用してファイル名を読み取ります。

copy/paste to/from primary selection (macOS)
GNUstepでは、X-windows環境においてテキストをXのプライマリー選択(primary selection)に転送するために、`C-w`や`M-w`のかわりに、`Cmd-c`を使用する必要があります。そうでない場合、Emacsはクリップボード選択を使用します。同様に(`C-y`のかわりに)`Cmd-y`は、killリングやクリップボードではなく、Xのプライマリー選択からyankします。

### 環境変数の取得

environment variables (macOS)
latexやmanのような、Emacsの下で実行される多くのプログラムは、環境変数のセッティングに依存します。Emacsがシェルから起動された場合、自動的にこれらの環境変数を継承し、Emacsのサブプロセスもそれらを継承します。しかしEmacsがFinderから起動された場合は、シェルの子プロセスではないので、環境変数はセットされません。これによりサブプロセスの振る舞いが、シェルから実行したときと異なることが起こり得ます。

変数PATHおよびMANPATHにたいしては、macOSではPATHをセットするシステムワイドな手法は、`/etc/paths`ファイルと`/etc/paths.d`ディレクトリーを使用することが推奨されています。

Mac/GNUstepでのカスタマイズ
---------------------------

多くはありませんが、Nextstepポートに特有のカスタマイズオプションがいくつかあります。たとえば修飾キーやフルスクリーン動作に影響するオプションです。そのようなオプションをすべて閲覧するには、`M-x
customize-group RET ns RET`を使用します。

### フォントパネル

ns-popup-font-panel
標準のMac/GNUstepのフォントパネルにアクセスするには、`M-x
ns-popup-font-panel`を使用します。これは一番最近使用された、またはクリックされたフレームの、デフォルトフォントをセットします。

Core Text, on macOS
font backend, on macOS
macOSでは、EmacsはデフォルトでCore Textベースのフォントバックエンドを使用します。古いフォントスタイルにしたい場合は、Emacsを起動する前に、以下のコマンドラインを入力します:

    % defaults write org.gnu.Emacs FontBackend ns

macOSおよびGNUstepでのウィンドウシステムイベント
------------------------------------------------

events on macOS
Nextstepアプリケーションは、Xでは同等なものがない、特別なイベントを受け取ります。これらは、対応するキーストロークのシーケンスとしてではなく、特別に定義されたキーイベントとして送られます。Emacsでは、これらのキーイベントを、通常のキーストロークのように、関数にバインドできます。以下はこのようなイベントのリストです。

ns-open-file  
ns-pop-up-frames

このイベントは、他のNextstepアプリケーションがEmacsにファイルを開くよう要求したときに発生します。これの典型的な理由としては、ユーザーがFinderアプリケーションでファイルをダブルクリックしたときなどです。デフォルトでは、Emacsはこのイベントにたいして、新しいフレームを開いて、そのフレームでファイルをvisitして応答します(`ns-find-file`)。例外として、選択されたバッファーが`*scratch*`バッファーの場合、Emacsは選択されたフレームでファイルをvisitします。

Emacsが`ns-open-file`イベントにたいしてどのように応答するかは、`ns-pop-up-frames`を変更することにより、変えることができます。デフォルト値は‘`fresh`’で、これは上で説明したとおりの動作を行ないます。値`t`は、ファイルを常に新しいフレームでvisitすることを意味します。値`nil`は、ファイルを常に選択されたフレームでvisitすることを意味します。

ns-open-temp-file  
このイベントは、他のアプリケーションがEmacsに一時ファイルを開くように要求したとき発生します。デフォルトでは、単に`ns-open-file`イベントを生成することにより処理され、結果は上で説明したとおりになります。

ns-open-file-line  
ProjectBuilderやgdbのようないくつかのアプリケーションは、特定のファイルだけではなく、そのファイルの特定の行、または一連の行を要求します。Emacsはそのファイルをvisitして要求された行をハイライトすることにより、これを処理します(`ns-open-file-select-line`)。

ns-drag-n-drop  
このイベントは、ユーザーが他のアプリケーションから、Emacsフレームにファイルをドラッグしたとき発生します。デフォルトの動作は、マウスの下にあるウィンドウでファイルをオープンするか、マウスの下にあるウィンドウのポイント位置にテキストを挿入します。テキストを強制的に挿入するために、Metaキーとの併用が必要な場合もあるかもしれません。

ns-change-font  
このイベントは、ユーザーがNextstep font panel(これは`Cmd-t`で開くことができます)でフォントを選択したとき発生します。デフォルトの動作は、選択されたフレームのフォントを変更します(`ns-respond-to-changefont`)。選択されたフォントの名前とサイズは、変数`ns-input-font`と`ns-input-fontsize`に格納されます。

ns-power-off  
このイベントは、ユーザーがEmacsを実行中にログアウトしたとき、またはアプリケーションメニューから“Quit Emacs”を選択したとき発生します。デフォルトの動作は、ファイルをvisitしているすべてのバッファーを保存します。

using Nextstep services (macOS)
Emacsはユーザーに、‘`ns-service-`’で始まりサービス名で終わるコマンドを通じて、Nextstepサービスを使用することも可能にします。`M-x
ns-service-TAB`とタイプして、これらのコマンドをリストを見ることができます。これらの関数は、マークされたテキストを処理(結果でそれを置き換える)したり、文字列を引数として結果を文字列で返します。Lisp関数`ns-perform-service`を使用して、任意の文字列を任意のサービスに渡して、結果を受けとることもできます。新たに利用可能になったサービスにアクセスするには、Emacsの再起動が必要なことに注意してください。

GNUstepにたいするサポート
-------------------------

EmacsはGNUstepの下でビルドして実行することができますが、解決すべき問題が残っています。興味のある開発者は、 <emacs-devel@gnu.org>に連絡してください。

EmacsとMicrosoft Windows/MS-DOS
===============================

Microsoft Windows
MS-Windows, Emacs peculiarities
このセクションでは、Microsoft WindowsでEmacsを使用する際の特性を説明します。これらの特性の中には、Microsoft’sの古いMS-DOSオペレーティングシステムに関連するものもあります。しかしMS-DOS*だけ*に関連するEmacs機能については、別の セクション([MS-DOS](#MS_002dDOS)を参照してください)で説明します。

フリーなオペレーティングシステムのため、MS-Windowsはすべてのコンピューターユーザーが享受すべき自由を、ユーザーに与えません。これは不当です。あなたの自由のために、わたしたちはフリーなオペレーティングシステムへの切り替えを強く推奨します。

わたしたちは、商業オペレーティングシステム上のGNU Emacsをサポートします。なぜならそれは、この自由の経験が、商業オペレーティングシステムから脱却するよう、ユーザーを奮起するだろうからです。

MS-WindowsでのEmacsの振る舞いは、ロングファイル名のサポート、複数フレーム、スクロールバー、マウスメニュー、サブプロセスを含めて、このマニュアルの他の部分でドキュメントされているのと、だいたい同じです。しかし多くはありませんが、特別に考慮すべきこともあるので、それらについてはここで説明します。

MS-WindowsでEmacsを開始する方法
-------------------------------

starting Emacs on MS-Windows
MS-WindowsでEmacsを開始するには、いくつかの方法があります:

1.  runemacs.exe
    desktop shortcut, MS-Windows
    start directory, MS-Windows
    directory where Emacs starts on MS-Windows
    デスクトップのショートカットアイコンから、それを左マウスボタンでダブルクリックするか、1回クリックしてからRETを押します。デスクトップのショートカットは、ショートカットの“Target”(ショートカットの‘Properties”の中にあります)に、`emacs.exe`ではなく、`runemacs.exe`の絶対ファイル名を指定する必要があります。なぜならショートカットのターゲットが`emacs.exe`(Windowsから見る限りこれはコンソールプログラムです)のときに作成されるコンソールウィンドウを、`runemacs.exe`は隠すからです。この方法を使用する場合、Emacsはショートカットで指定されたディレクトリーで開始されます。これを制御するには、ショートカットを右クリックして“Properties”を選択し、“Shortcut”タブで“Start in”フィールドを変更します。

2.  pinning Emacs to Windows task bar
    タスクバーのショートカットアイコンを左マウスボタンで1回クリックします。Windows Vista以降のバージョンでは、タスクバー内に表示される実行中プログラムのアイコンをピン留め(pinning)することにより、そのようなショートカットが作成できます。Emacsでこれを行うことができますが、その後にピン留めされたショートカットのプロパティで、実行するプログラムを`emacs.exe`*ではなく*`runemacs.exe`に変更する必要があるでしょう。Startメニュー内のEmacsアイコンをマウスの右ボタンでクリックして、‘`Pin
    to
    taskbar`’を選択する方法でも、タスクバーにEmacsをピン留めすることができます。繰り返しますが、実行するプログラムには、`runemacs.exe`を指定してください。ショートカットのプロパティで“Start in”をセットすることにより、Emacsを開始する場所を制御できます。

3.  コマンドプロンプトウィンドウから、プロンプトにたいして`emacs
    RET`とタイプします。そのコマンドプロンプトウィンドウからは、Emacsを終了するまで、他のコマンドを呼び出すことはできなくなります。この場合、EmacsはWindowsシェルのカレントディレクトリーで開始されます。

4.  コマンドプロンプトウィンドウから、プロンプトにたいして`runemacs
    RET`とタイプします。そのコマンドプロンプトウィンドウから、すぐに別のコマンドを呼び出すことが可能になります。この場合EmacsはWindowsシェルのカレントディレクトリーで開始されます。

5.  Windowsの`Run`ダイアログ(通常は`Start`ボタンをクリックしてアクセスできる)を使用します。そのダイアログ内で`runemacs
    RET`とタイプすれば、Windowsでのユーザーの`HOME`ディレクトリーの親ディレクトリーで、Emacsが起動するでしょう。[Windows HOME](#Windows-HOME)を参照してください。

6.  invoking Emacs from Windows Explorer
    emacsclient.exe
    emacsclientw.exe
    `emacsclient.exe`または`emacsclientw.exe`を通じてEmacsを開始します。これらのコマンドは、Emacsを他のプログラムから呼び出して、他のプログラムから要求された編集ジョブのために、実行中のEmacsプロセスを再使用します。[Emacs Server](#Emacs-Server)を参照してください。2つのコマンドの違いは、`emacsclient.exe`がコンソールプログラムなのにたいして、`emacsclientw.exe`はWindowsのGUIプログラムであるという点です。どちらのプログラムも、プログラムを終了して呼び出したプログラムに制御を戻す前に、Emacsが編集ジョブの終了をシグナルするまで待ちます。これらのコマンドを、それぞれどのような場合に使用するかは、編集サービスを必要とするプログラムが期待することに依存します。そのプログラム自身がコンソール(テキストモード)プログラムの場合は、`emacsclient.exe`を使用するべきです。そうすれば呼び出したプログラムと同じコマンドウィンドウにメッセージとプロンプトが表示されます。対照的に呼び出し側のプログラムがGUIプログラムの場合は、`emacsclientw.exe`を使用するほうがよいでしょう。なぜなら`emacsclient.exe`はGUIプログラムから呼び出された場合、コマンドウィンドウをポップアップするからです。`emacsclientw.exe`を使いたい状況としては、Windows Explorerでファイルを右クリックして、ポップアップメニューで“Open With”を選択する場合です。`emacsclient`を呼び出すときにEmacsが実行中でない(またはサーバーとして実行されていない)場合は、‘`--alternate-editor=`’または‘`-a`’オプションを使用します。このオプションは常にエディターを与えます。`emacsclient`を通じて呼び出された場合、Emacsは`emacsclient`を呼び出したプログラムのカレントディレクトリーで開始されます。

emacsclient
, on MS-Windows
MS-Windowsの制限により、Emacsは同一セッションでGUIとテキストモードのフレームをもつことはできないことに注意してください。また複数のコマンドプロンプトウィンドウでテキストモードのフレームを開くこともできません。なぜならWindowsのプログラムは、それぞれ1度に1つのコンソールしかもつことができないからです。これらの理由により、`emacsclient`を`-c`オプションで呼び出したとき、Emacsサーバーがテキストモードセッションで実行されている場合、Emacsは常にそれが開始されたのと同じコマンドプロンプトウィンドウに、テキストモードのフレームを開きます。GUIフレームはサーバーがGUIセッションで実行されているときだけ作成されます。同様に、`emacsclient`を`-t`オプションで呼び出したとき、サーバーがGUIセッションで実行されている場合はGUIフレームを作成し、サーバーセッションがコマンドプロンプトウィンドウのテキストモードで実行されている場合はテキストモードのフレームを作成します。[emacsclient Options](#emacsclient-Options)を参照してください。

テキストファイルとバイナリーファイル
------------------------------------

text and binary files on MS-DOS/MS-Windows
GNU Emacsはテキスト行を分けるのに改行文字を使用します。これはGNU、Unixmその他のPOSIX準拠システムで使用されている慣習です。

end-of-line conversion on MS-DOS/MS-Windows
対照的にMS-DOSとMS-Windowsは、テキスト行を分けるのに、通常はCR(carriage-return: キャリッジリターン)とその後にLF(linefeed: ラインフィード)の、2文字からなるシーケンスを使用します(LFは改行と同じ文字です)。したがってこれらのファイルを便利に編集するために、Emacsはこれらの行末(EOL: end-of-line)文字を変換する必要があります。そしてこれはEmacsが通常行なっていることです。Emacsはファイルを読み込むときCRLFを改行に変換して、ファイルに書き込むときは改行をCRLFに変換します。国際化文字コードの変換を処理するのと同じ仕組みが、この変換でも行なわれます([Coding Systems](#Coding-Systems)を参照してください)。

cursor location, on MS-DOS
point location, on MS-DOS
ほとんどのファイルにおいて、この特別なフォーマット変換の重要な問題は、Emacsが報告する文字の位置([Position Info](#Position-Info)を参照してください)が、オペレーティングシステムが認識するファイルサイズの情報と一致しないことです。

それに加えて、ファイル内容から行の区切りにCRLFではなく改行(LF)が使用されているとEmacsが認識した場合、Emacsはファイルの読み書きでEOL変換を行ないません。したがって特別に何かを行なわなくても、GNUおよびUnixシステムのファイルをMS-DOSで読み書きでき、編集した後でも、それらのファイルのEOLはUnixスタイルの慣習にしたがいます。

カレントバッファーにたいして、どのEOL変換が使用されているかは、モードラインに表示されます。そのバッファーにたいしてMS-DOSのEOL変換が使用されている場合、MS-WindowsでビルドされたEmacsでは、モードラインの先頭付近の、コーディングシステムニーモニックの後ろにバックスラッシュ‘`\`’が表示されます。なんのEOL変換も処理されていない場合、そのファイルのEOLフォーマットが通常のCRLFではないことを警告するために、バックスラッシュのかわりに文字列‘`(Unix)`’が表示されます。

DOS-to-Unix conversion of files
ファイルをvisitして、DOSスタイルとUnixスタイルのどちらを使用するか指定するには、コーディングシステムを指定します([Text Coding](#Text-Coding)を参照してください)。たとえば`C-x RET c unix RET C-x C-f
foobar.txt`は、EOL変換をせずに、ファイル`foobar.txt`をvisitします。CRLFで終わる行がある場合、Emacsは行末に‘`^M`’を表示します。同様に、`C-x
RET
f`コマンドで、そのバッファーを指定したEOLフォーマットで保存するよう指示できます。たとえばバッファーをUnixのEOLフォーマットで保存するには、`C-x
RET f unix RET C-x
C-s`とタイプします。DOSのEOL変換でファイルをvisitしていて、それをUnixのEOLフォーマットで保存すると、`dos2unix`コマンドのように、そのファイルをUnixのEOLスタイルに変換できます。

untranslated file system
add-untranslated-filesystem
NFS、Samba、または他の類似した方法により、GNUおよびUnixシステムを使用しているコンピューターのファイルシステムにアクセスする場合、Emacsはそれらのファイルシステム上のファイル — たとえファイルを新たに作成する場合でも、EOL変換を行なうべきではありません。EOL変換を行なわないようにするには、関数`add-untranslated-filesystem`を呼び出して、それらのファイルシステムがuntranslated(変換なし)だと指定します。この関数は、ドライブ文字とオプションでディレクトリーを含む、ファイルシステム名を引数にとります。たとえば、

    (add-untranslated-filesystem "Z:")

これはZドライブが変換なしのファイルシステムであると指定し、

    (add-untranslated-filesystem "Z:\\foo")

これはドライブZのディレクトリー`\foo`は、変換なしのファイルシステムだと指定します。

`.emacs`や`init.el`などのinitファイル、または`site-start.el`の中で`add-untranslated-filesystem`を使用するのが、ほとんどでしょう。`site-start.el`に記述しておけば、そのサイトのすべてのユーザーが恩恵にあずかることができます。

remove-untranslated-filesystem
`add-untranslated-filesystem`の効果を取り消すには、関数`remove-untranslated-filesystem`を使用します。この関数は、前に`add-untranslated-filesystem`で使用された文字列と同様の文字列を引数にとります。

ファイルシステムを変換なしと指定しても、影響があるのはEOL変換だけで、文字セットの変換に影響はありません。原則的として、行末に改行を使用するUnixスタイルをデフォルトとして、新たにファイルを作成するようEmacsに指示します。[Coding Systems](#Coding-Systems)を参照してください。

MS-Windowsのファイル名
----------------------

file names on MS-Windows
MS-WindowsとMS-DOSでは通常、ファイル名の名前単位の区切りにバックスラッシュを使用します(他のシステムではスラッシュを使用します)。MS-DOSおよびMS-WindowsのEmacsは、スラッシュとバックスラッシュのどちらも使用でき、ファイル名に含まれるドライブ文字も識別できます。

file-name completion, on MS-Windows
MS-DOSおよびMS-Windowsでは、ファイル名は大文字小文字を区別せず、Emacsもデフォルトではファイル名の補完で大文字小文字の違いを無視します。これを行うために、MS-DOS/MS-Windowsでは`read-file-name-completion-ignore-case`のデフォルト値は非`nil`です。[Completion Options](#Completion-Options)を参照してください。

w32-get-true-file-attributes
変数`w32-get-true-file-attributes`は、`file-attributes`や`directory-files-and-attributes`のように、より正確にプリミティブなファイル属性を判断するために、Emacsが追加のシステムコールを呼び出すべきかを制御します。これらの追加のシステムコールは、ファイルの正しい所有者、リンクカウントと、パイプのような特殊ファイルのファイルタイプを取得するのに必要となります。システムコールを使用しない場合、ファイルの所有者はカレントユーザーとなり、リンクカウントは常に1に、そして特殊ファイルは通常ファイルとなるでしょう。

この変数の値が`local`(デフォルト)の場合、Emacsはローカルの固定ドライブのファイルにたいしてのみ、システムコールを呼び出します。他の非`nil`値は、ファイルがリムーバブルメディアやリモートボリュームにある場合も、システムコールを呼び出すことを意味し、これはDiredやその他の関連する機能の速度低下を招く恐れがあります。値`nil`はシステムコールを呼び出さないことを意味します。非`nil`値は、FAT、FAT32、exFATのようなボリュームより、ハードリンクやファイルセキュリティーをサポートするNTFSのボリュームの場合のほうが有用です。

file names, invalid characters on MS-Windows
Unixとは異なり、MS-Windowsのファイルシステムでは、ファイル名に使用されるかもしれない複数の文字にたいして制限があります。以下の文字は使用できません:

-   シェルのリダイレクション文字‘`<`’、‘`>`’、‘`|`’。

-   コロン‘`:`’(ただしドライブ文字を除く)。

-   スラッシュ‘`/`’とバックスラッシュ‘`\`’(ただしディレクトリー区切り文字の場合を除く)。

-   ワイルドカード文字‘`*`’と‘`?`’。

-   コードポイントが10進の1から31の制御文字。特にファイル名の中の改行は許されていません。

-   コードポイント0のnull文字(この制限はUnixファイルシステムにもあります)。

これらに加えて、ファイル名拡張子の有無に関わらず、`NUL`、`LPT1`、`PRN`、`CON`のようなDOSの文字デバイスに名前がマッチする任意のファイルは、どのディレクトリーにあっても、文字デバイスとして解釈されます。したがってその文字デバイスを使用したいときだけ、そのようなファイル名を使用します。

MS-Windowsでの`ls`のエミュレーション
------------------------------------

Dired, and MS-Windows/MS-DOS
ls
emulation
Diredは通常、Diredバッファーで表示するディレクトリーリストを生成するために、外部プログラムの`ls`を使用します。しかしMS-WindowsとMS-DOSには、GNU `ls`のいくつかのポートは存在するものの、システムにはそのようなプログラムがありません。したがって、そのようなシステム上のEmacsは、`ls-lisp.el`パッケージを使用することにより、Lispで`ls`を*エミュレート*します。`ls-lisp.el`は、`ls`のほぼ完全なエミュレーションを提供し、エミュレーションに特化したオプションと機能もあります。 それらについては、このセクションで説明します。

`ls`エミュレーションは、`ls`スイッチの多くをサポートしますが、すべてをサポートする訳ではありません。サポートされているオプションは、`-A`、`-a`、`-B`、`-C`、`-c`、`-G`、`-g`、`-h`、`-i`、`-n`、`-R`、`-r`、`-S`、`-s`、`-t`、`-U`、`-u`、`-v`、`-X`です。`-F`オプションは、部分的にサポートされています(ファイルをクラス化する文字を追加しますが、シンボリックリンクのフォローを抑止しません)。

ls-lisp-use-insert-directory-program
MS-WindowsとMS-DOSでは、`ls-lisp.el`はEmacsが構築されるとき事前ロードされるので、それらの環境では常に`ls`のLispエミュレーションが使用されます。ポートされた`ls`がある場合、`ls-lisp-use-insert-directory-program`を非`nil`値にセットすることにより、変数`insert-directory-program`にセットされた名前の外部プログラムを使用するように戻すことができます。

Dired sorting order, on MS-Windows/MS-DOS
`ls-lisp.el`がファイルをソートする順序は、以下で説明するいくつかのカスタマイズ可能なオプションに依存します。

ls-lisp-use-string-collate
デフォルトのソート順は、システムlocaleから派生したlocale固有ルールにしたがいます。`ls-lisp-use-string-collate`を`nil`値にカスタマイズすることにより、localeから独立したソート順にすることができます。

Unicode Collation Algorithm (UCA), and
ls-lisp.el
ls-lisp-UCA-like-collation
GNUおよびUnixシステムでは、localeのエンコーディングがUTF-8のときの照合順はUCA(Unicode Collation Algorithm: Unicode照合順序アルゴリズム )にしたがいます。MS-Windowsで同様の効果を得るには、変数`ls-lisp-UCA-like-collation`が非`nil`値をもつべきです(これがデフォルトです)。結果となるソート順は句読点、シンボル文字、空白文字を無視するので、`.foobar`、`foobar`、`foo
bar`は別々ではなく一緒に表示されるでしょう。

ls-lisp-ignore-case
デフォルトでは、`ls-lisp.el`はディレクトリーのリストを生成するのに、大文字小文字を区別するソート順を使用します。これは他のプラットフォームと同じような見映えにリストするためです。大文字小文字を区別せずにファイルをソートしたい場合は、変数`ls-lisp-ignore-case`に非`nil`値をセットしてください。

ls-lisp-dirs-first
デフォルトでは、`ls`の動作をエミュレートするために、ファイルとサブディレクトリーは一緒にソートされます。しかしネイティブのMS-WindowsとMS-DOSのファイルマネージャーでは、ファイルの前にディレクトリーがリストされます。このように動作させたい場合は、オプション`ls-lisp-dirs-first`を非`nil`値にカスタマイズしてください。

ls-lisp-verbosity
変数`ls-lisp-verbosity`は、`ls-lisp.el`が表示するファイル属性を制御します。値にはシンボル`links`、`uid`、`gid`を1つ以上含むリストを指定します。`links`は、そのファイルデータに関連付けられている(links toとも言います)別のファイルの数を表示することを意味し、これはNTFSボリュームでのみ有用です。`uid`はそのファイルを所有するユーザーの、数字による識別子を表示することを意味します。`gid`はそのファイルの所有者のグループの、数字による識別子を表示することを意味します。デフォルト値は`(links
uid gid)`で、3つのすべてのオプション属性が表示されます。

ls-lisp-emulation
変数`ls-lisp-emulation`は、上記で説明した3つのオプション`ls-lisp-ignore-case`、`ls-lisp-dirs-first`、`ls-lisp-verbosity`でデフォルトをセットすることにより、`ls`エミュレーションの風合いを制御します。このオプションの値には、以下のシンボルを指定できます:

`GNU`; `nil`  
GNUシステムをエミュレートします(デフォルト)。これは`ls-lisp-ignore-case`と`ls-lisp-dirs-first`を`nil`に、`ls-lisp-verbosity`を`(links
uid gid)`にセットします。

`UNIX`  
Unixシステムをエミュレートします。`GNU`と同様ですが、`ls-lisp-verbosity`は`(links
uid)`にセットします。

`MacOS`  
macOSをエミュレートします。`ls-lisp-ignore-case`を`t`に、`ls-lisp-dirs-first`と`ls-lisp-verbosity`を`nil`にセットします。

`MS-Windows`  
MS-Windowsをエミュレートします。`ls-lisp-ignore-case`と`ls-lisp-dirs-first`を`t`にセットし、`ls-lisp-verbosity`を、Windows 9Xでは`nil`、Windowsのモダンなバージョンでは`t`にセットします。これらのプラットフォームのEmacsユーザーの多くがデフォルトとしてGNUを好むため、たとえWindowsにおいても、デフォルトのエミュレーションは`MS-Windows`ではないことに注意してください。

これ以外の値を`ls-lisp-emulation`にセットするのは、`GNU`をセットするのと同じです。このオプションをカスタマイズすることにより、必要に応じて3つの従属オプションを更新するために、関数`ls-lisp-set-options`が呼び出されます。`ls-lisp.el`がロードされた後(MS-WindowsとMS-DOSでは事前ロードされることに注意してください)に、customizeを使用せずにこの変数の値を変更した場合、この関数を手動で呼び出して、同じ結果を得ることができます。

ls-lisp-support-shell-wildcards
変数`ls-lisp-support-shell-wildcards`は、ファイル名パターンがサポートされる方法を制御します。非`nil`(デフォルト)の場合、ファイル名パターンはシェルスタイルのワイルドカードとして扱われ、`nil`の場合はEmacsの正規表現として扱われます。

ls-lisp-format-time-list
変数`ls-lisp-format-time-list`は、ファイルの日付と時刻の書式をフォーマットする方法を定義します。Emacsがカレントlocaleを判断できる場合、*この変数の値は無視されます*(しかし`ls-lisp-use-localized-time-format`の値が非`nil`の場合、Emacsはカレントlocaleが利用できるときでも`ls-lisp-format-time-list`にしたがいます。以下を参照してください)。

`ls-lisp-format-time-list`の値は、2つの文字列からなるリストです。最初の文字列は、そのファイルがその年に変更されている場合に使用され、2番目の文字列はそれより古いファイルに使用されます。2つの文字列では、日時の一部を置換するために‘`%`’シーケンスを使用できます。たとえば:

    ("%b %e %H:%M" "%b %e  %Y")

これらの‘`%`’シーケンスにたいする文字列の置換は、カレントlocaleに依存することに注意してください。日時のフォーマットの仕様については、section “Time Parsing” in The Emacs Lisp Reference Manualを参照してください。

ls-lisp-use-localized-time-format
Emacsは通常、ファイルのタイムスタンプの日時フォーマットに、慣習にしたがったフォーマット、またはISOスタイルのフォーマットを使用します。しかし変数`ls-lisp-use-localized-time-format`の値が非`nil`の場合、Emacsはファイルのタイムスタンプを、`ls-lisp-format-time-list`の指定にしたがってフォーマットします。`ls-lisp-format-time-list`の‘`%`’シーケンスは、localeにしたがった月の名前と曜日名を生成し、それによりDiredの列表示がずれるかもしれません。`ls-lisp-use-localized-time-format`のデフォルト値は`nil`です。

MS-WindowsでのHOMEディレクトリーと開始ディレクトリー
----------------------------------------------------

HOME directory on MS-Windows
Windowsで`HOME`に相当するのは、ユーザー固有のアプリケーションデータディレクトリーで、それの実際の位置はWindowsのバージョンに依存します。典型的な値は、Windows 2000からXPでは`C:\Documents and Settings\username\Application
Data`、Windows Vista以降では`C:\Documents and
Settings\username\Application Data`、そしてWindows 9X/MEでは`C:\WINDOWS\Application
Data`か`C:\WINDOWS\Profiles\username\Application
Data`のいずれかです。このディレクトリーが存在しない、またはアクセスできない場合、Emacsは`HOME`のデフォルト値を`C:\`にフォールバックします。

環境変数HOMEをシステムの他のディレクトリーを指すように明示的にセットすることにより、`HOME`のデフォルト値をオーバーライドできます。HOMEはコマンドシェルプロンプト、または‘`My
Computer`’の‘`Properties`’ダイアログからセットできます。`HOME`はシステムレジストリーからもセットできます。[MS-Windows Registry](#MS_002dWindows-Registry)を参照してください。

古いバージョンのEmacs[25]との互換性のため、ドライブ`C:`のルートディレクトリー`C:\`に`.emacs`という名前のファイルが存在する場合、そしてHOMEが環境とレジストリーのどちらでもセットされていない場合、Emacsは`C:\`をデフォルトの`HOME`の場所として扱い、たとえアプリケーションデータディレクトリーが存在する場合でも、そこを探しません。古い名前の`_emacs`(以下参照)ではなく、`C:\`の`.emacs`だけが探されることに注意してください。`C:\.emacs`を使用して`HOME`を定義する方法は、推奨されていません。Emacsはスタートアップ時にそれが使用されていることに関して、警告を表示するでしょう。

最終的な場所がどこであれ、Emacsはその場所を指すように環境変数HOMEの内部値をセットし、通常ホームディレクトリーで探したり作成するファイルとディレクトリーのために、その場所を使用します。

Emacsがホームディレクトリーをどこだと認識しているかは、`C-x d ~/
RET`とタイプして常に確認できます。これはホームディレクトリーのファイルのリストを表示し、最初の行にホームディレクトリーの完全な名前を表示します。同様にinitファイルをvisitするには、(initファイルの名前が`.emacs`の場合)`C-x
C-f ~/.emacs RET`とタイプしてください。

init file
.emacs
on MS-Windows
[Init File](#Init-File)で述べられるとおり、initファイルは任意の名前をもつことができます。

\_emacs
init file, MS-Windows
MS-DOSはドットで始まるファイル名を使用できず、古いWindowsシステムではそのような名前のファイルを作成するのが困難だったので、EmacsのWindowsポートは、ホームディレクトリーに`_emacs`が存在して、`.emacs`が存在しない場合、`_emacs`という名前のinitファイルをサポートします。この名前は時代遅れと考えられおり、使用した場合、Emacsは警告を表示するでしょう。

MS-Windowsでのキーボードの使用方法
----------------------------------

keyboard, MS-Windows
このセクションでは、Emacsでのキーボード入力に関するWindows固有の機能について説明します。

MS-Windows keyboard shortcuts
MS-Windowsプログラムで慣習的に使用されるキー組み合わせ(“キーボードショートカット”として知られる)の多くが、伝統的なEmacsのキーバインドと衝突します(これらEmacsのキーバインドは、Microsoftが設立される数年前には確立されていました)。衝突の例には`C-c`、`C-x`、`C-z`、`C-a`、`W-SPC`が含まれます。CUAモード([CUA Bindings](#CUA-Bindings)を参照してください)を有効にすることにより、これらのいくつかの意味をMS-Windowsでの意味に近づけるよう再定義できます。他のWindowsのようにEmacsを振る舞わせる他のオプション機能として、Delete Selectionモード([Using Region](#Using-Region)を参照)があります。

w32-alt-is-meta
Alt
key (MS-Windows)
デフォルトでは、Altとラベルされたキーは、Metaキーにマップされます。かわりに`Alt`修飾を生成したい場合は、変数`w32-alt-is-meta`に`nil`をセットしてください。

w32-register-hot-key
w32-unregister-hot-key
MS-Windowsでは、`Alt-TAB`、およびWindowsキーと組み合わされたいくつかのキーのような特定のキー組み合わせは、Windowsが使用するために予約済みです。これらのキー組み合わせは、Emacsがそれを読み取る前に、システムにより解釈されます。さらにWindows 10では、たとえその時点で特定のキー組み合せがホットキーとして定義されていなくても、すべてのWindowsキーと組み合わされたキーは、アプリケーションに決して渡されないように、システムにより予約済みです。関数`w32-register-hot-key`を使用して、Windowsに横取りされることなく、Emacsがキーシーケンスを取得できます。ホットキー(hot key)として登録した場合、そのキー組み合せはWindowsが処理する前にシステムの入力キューから取り出され、そのシーケンスがもつWindowsにたいする特別な意味を、効果的にオーバーライドします。これはEmacsがアクティブなときだけオーバーライドされ、他のアプリケーションがフォアグラウンドのときには、そのキーは通常どおり振る舞います。

`w32-register-hot-key`に指定する引数は、1つの修飾キー、1つのキーを指定しなければなりません。control修飾とshift修飾は、引数に影響を与えません。`w32-alt-is-meta`が`t`(デフォルト)の場合、meta修飾はAltキーと解釈され、super修飾とhyper修飾はそれぞれ、`w32-lwindow-modifier`と`w32-rwindow-modifier`のバインディングに解釈されます。さらにキーがなく末尾がダッシュの修飾は、Emacs用にその修飾にたいしてるWindowsが定義するすべてのホットキーをオーバーライドすることを示します。

M-TAB, (MS-Windows)
M-
TAB
vs
Alt
-
TAB
(MS-Windows)
Alt
-
TAB
vs
M-
TAB
(MS-Windows)
たとえば`(w32-register-hot-key
[M-tab])`により、(たとえばトップレベルのポイント位置の単語やシンボルを補完したり、インクリメンタル検索において以前に検索した文字列で現在の検索文字列を補完したり等)、Emacsで通常使用するように`M-TAB`を使用できます。`(w32-register-hot-key
[s-])`と`w32-lwindow-modifier`を併用すると、WindowsキーにもとづくWindowsのすべてのショートカットを無効にします。[26]

`w32-register-hot-key`は、関数呼び出し時に`w32-[lr]window-modifier`の値をチェックすることに注意してください。したがって、`w32-lwindow-modifier`を`super`としてセットしてから`(w32-register-hot-key
[s-r])`を呼び出し、最後に同じように`w32-rwindow-modifier`を`super`としてセットできます。その結果、左WindowsキーとRの組み合せは、その組み合せにたいしてEmacsでバインドした関数を呼び出し、右WindowsキーとRの組み合せはWindowsの`Run`ダイアログをオープンします。

ホットキーの登録には常に、与えられたホットキーにたいするshift修飾とcontrol修飾による組み合せのすべてが含まれます。つまり、`s-a`をホットキーとして登録すると、同様に`S-s-a`、`C-s-a`、`C-S-s-a`が登録されます。

Windows 98、およびWindows MEではホットキーの登録はより制限されます。ホットキーが常に完全指定されねばなりません。望む結果を得るために、`w32-phantom-key-code`をカスタマイズできます。

関数`w32-unregister-hot-key`は、引数となるキーシーケンスにたいして、`w32-register-hot-key`と逆のことを行ないます。

w32-capslock-is-shiftlock
デフォルトでは、CapsLockキー(このキーは小文字を大文字に変換します)は通常の文字キーだけに効果をもちます。しかし変数`w32-capslock-is-shiftlock`を非`nil`値にセットした場合、CapsLockは非文字キーにも同様に効果をもつようになり、その非文字キーをタイプするとき、あたかもSHIFTキーが押されたかのようになります。

w32-enable-caps-lock
変数`w32-enable-caps-lock`に`nil`値をセットした場合、CapsLockキーは、タイプされた文字にたいするシフトが押されたバージョンのキーではなく、かわりにシンボル`capslock`を生成します。デフォルト値は`t`です。

w32-enable-num-lock
keypad keys (MS-Windows)
同様に`w32-enable-num-lock`が`nil`の場合、NumLockキーはシンボル`kp-numlock`を生成します。デフォルトは`t`で、これはNumLockに期待された動作、すなわちテンキー上のキーのもつ意味の切り替えを行ないます。

w32-apps-modifier
変数`w32-apps-modifier`は、Appsキー(通常は右Altキーと右Ctrlキーの間にあります)の効果を制御します。変数の値には、対応する修飾キーを示すシンボル`hyper`、`super`、`meta`、`alt`、`control`、`shift`のどれか1つを指定するか、`nil`を指定してそれをキー`apps`として扱います。デフォルトは`nil`です。

w32-lwindow-modifier
w32-rwindow-modifier
w32-scroll-lock-modifier
変数`w32-lwindow-modifier`は、左Windowsキー(通常はstartとWindowsのロゴのラベル)の効果を決定します。この変数の値が`nil` (デフォルト)の場合、このキーはシンボル`lwindow`を生成します。シンボル`hyper`、`super`、`meta`、`alt`、`control`、`shift`のうち、どれか1つをセットした場合は、対応する修飾が生成されます。これと似た変数`w32-rwindow-modifier`は、右Windowsキーの効果を制御し、`w32-scroll-lock-modifier`はScrLockと同様のことを行います。これらの変数が`nil`にセットされている場合、右Windowsキーがシンボル`rwindow`、ScrLockがシンボル`scroll`を生成します。たとえばキーボード上のScroll Lock LED標示を切り替える等、他のアプリケーションのときと同様の効果をScrLockに生成させたい場合は、`w32-scroll-lock-modifier`の値に上記の修飾シンボルではなく`t`か、任意の非`nil`をセットしてください。

w32-pass-alt-to-system
Windows system menu
Alt
key invokes menu (Windows)
EmacsがネイティブのWindowsアプリケーションとしてコンパイルされていると、Windowsメニューを呼び出すAltをタップ(tapping: 覗き見)するWindows機能をオフに切り替えます。これはEmacsではMetaとして用いられるからです。Emacsを使用するとき、ユーザーが1度Metaキーを押して、後で気が変わることがあります。もしこのキーがWindowsメニューを立ち上げる効果をもつ場合、それに続くコマンドの意味が変更されてしまいます。多くのユーザーは、これにイライラするでしょう。

`w32-pass-alt-to-system`を非`nil`値にセットすることにより、Altキーの覗き見にたいするWindowsのデフォルトの処理を再び有効にできます。

w32-pass-lwindow-to-system
w32-pass-rwindow-to-system
変数`w32-pass-lwindow-to-system`と`w32-pass-rwindow-to-system`は、左Windowsキーと右Windowsキーが、Windowsに渡されるか、Emacsに渡されるかを決定します。値が`nil`の場合、これらのキーはEmacsに渡され、それ以外の場合はWindowsに渡されます。両方の変数のデフォルトは`t`です。これらのキーをWindowsに渡すことにより、たとえば`Lwindow`は`Start`メニューを開くなどの、通常の効果が生成されます。

w32-recognize-altgr
AltGr (MS-Windows)
AltGr
key (MS-Windows)
変数`w32-recognize-altgr`は、(もしそれがキーボードにあれば)AltGrキー(またはそれと同種のキー)が右Altと左Ctrlキーを一緒に押したときの組み合わせとするか、それともそれをAltGrキーとして認識するかを制御します。デフォルトは`t`で、これはそれらのキーが`AltGr`を生成することを意味します。これを`nil`にセットすることにより、AltGrキー(またはそれと同種のキー)との組み合わせは、Ctrl修飾とMeta修飾の組み合わせとして解釈されます。

MS-Windowsでのマウスの使用方法
------------------------------

mouse, and MS-Windows
このセクションでは、マウスに関連したWindows固有の変数について説明します。

w32-mouse-button-tolerance
simulation of middle mouse button
変数`w32-mouse-button-tolerance`は、2ボタンマウスで、マウス中央ボタンを模倣する際の時間間隔を、ミリ秒で指定します。左ボタンと右ボタンの両方のボタンが、この時間間隔のうちに離された場合、Emacsはそれらどちらかのボタンのダブルクリックイベントのかわりに、マウス中央ボタンのクリックイベントを生成します。

w32-pass-extra-mouse-buttons-to-system
変数`w32-pass-extra-mouse-buttons-to-system`が非`nil`の場合、EmacsはWindowsに第4、第5マウスボタンを渡します。

w32-swap-mouse-buttons
変数`w32-swap-mouse-buttons`、は3ボタンマウスが`mouse-2`イベントを生成するかを制御します。これが`nil`(デフォルト)の場合、中央のボタンは`mouse-2`を生成し、右ボタンは`mouse-3`を生成します。この変数が非`nil`の場合、これら2つのボタンの役割は逆になります。

Windows 9X/MEおよびWindows NT/2000/XP/Vista/7/8/10でのサブプロセス
------------------------------------------------------------------

subprocesses on MS-Windows
DOS applications, running from Emacs
WindowsのネイティブアプリケーションとしてコンパイルされたEmacsには、(DOSバージョンとは対照的に)非同期サブプロセスにたいする完全なサポートが含まれます。Windowsバージョンでは、同期および非同期サブプロセスは、すべてのバージョンのWindowsで32ビット、または64bitのWindowsアプリケーションを実行する限りうまく動作します。しかしサブプロセスでDOSアプリケーションを実行する場合は、問題に遭遇したり、そのアプリケーションを実行できないかもしれません。また、2つのサブプロセスで2つのDOSアプリケーションを実行する場合は、システムを再起動する必要があるかもしれません。

Windows9X標準のコマンドインプリターはDOSアプリケーションなので、そのようなシステムを使用する場合に、これらの問題が重要になります。しかしこれらの問題についてわたしたちができることはありません。Microsoftだけがこれをfixできるのです。

サブプロセスで1つのDOSアプリケーションを実行する場合、それが“様式に従って(well-behaved)”いる限り、そしてスクリーンへの直接アクセスや、その他の異例なことを行なわない限り、そのサブプロセスは期待されたとおりに動作すべきです。CPUモニターアプリケーションがある場合、そのDOSアプリケーションがアイドル状態でも、CPUは100%ビジーに見えるかもしれませんが、これは単にCPUモニターがプロセッサー負荷を計測する方法によるものです。

他のDOSアプリケーションを別のサブプロセスで開始する前に、DOSアプリケーションを終了しなければなりません。EmacsはDOSサブプロセスに割り込み、または終了させることができません。プログラムの終了コマンドを与えることだけが、そのようなサブプロセスを終了できる唯一の方法です。

同時に別のサブプロセスで2つのDOSアプリケーションの実行を試みた場合、それらの一方、または両方が非同期であっても、最初のサブプロセスが終了するまで、2番目に開始されたサブプロセスはサスペンドされます。

kill DOS application
もし最初のサブプロセスと対話することができ、終了を指示できたら2番目のプロセスは通常どおり実行を継続するはずです。しかし2番目のサブプロセスが同期実行されている場合、Emacsは最初のサブプロセスが終了するまでハングするでしょう。最初のプロセスがユーザーによる入力なしには終了しない場合、Windows9Xでは再起動する以外に選択肢はありません。Windows NT以降で実行している場合、プロセスビューアーアプリケーションを使用して、適切なNTVDMのインスタンスをkillすることができます(これにより、両方のDOSサブプロセスが終了します)。

このような状況でWindows9Xを再起動する場合、`Start`メニューの`Shutdown`コマンドを使用しないでください。これは通常システムをハングさせます。かわりに`Ctrl-Alt-DEL`とタイプして`Shutdown`を選択します。これは処理を行なうのに数分かかるかもしれませんが、通常どおり機能します。

w32-quote-process-args
変数`w32-quote-process-args`は、Emacsがプロセス引数をクォートする方法を制御します。非`nil`は文字`"`でクォートすることを意味します。変数の値が文字の場合、Emacsは任意のクォート文字をエスケープするのに、その文字を使用します。それ以外の場合、プログラムのタイプにもとづいて、適切なエスケープ文字を選択します。

w32-pipe-buffer-size
変数`w32-pipe-buffer-size`は、サブプロセスとの通信のためにパイプを作成するときに、Emacsがシステムに要求するバッファーサイズを制御します。デフォルト値は0で、この場合はOSがサイズを選択します。有効な正の値を指定した場合は、そのサイズ(byte)のバッファーを要求します。これは、サブプロセスと、バッファーされたパイプ入出力にたいして通常とは異なる動作を見せるプログラムとの通信を調整するのに使用できます。

w32-shell-execute
関数`w32-shell-execute`は、特定のタイプのファイルやドキュメントにたいして、ある種の標準的なWindows操作を処理するために登録された、MS-Windowsアプリケーションを実行するカスタマイズコマンドを記述するのに有用かもしれません。この関数はWindows APIの`ShellExecute`にたいするラッパーです。詳細は、MS-WindowsのAPIドキュメントを参照してください。

MS-Windowsでの印刷
------------------

POSIXスタイルの`lpr`プログラムが利用できない場合、MS-DOSとMS-Windowsでは、`lpr-buffer`([Printing](#Printing)を参照してください)や`ps-print-buffer`([PostScript](#PostScript)を参照してください)のような印刷コマンドは、プリンターポートの1つに出力を送ります。同じEmacs変数がすべてのシステムでの印刷を制御しますが、MS-DOSとMS-Windowsでは、それらの変数が異なるデフォルト値をもつ場合があります。

MS WindowsのEmacsは、(関数`default-printer-name`を使用して)デフォルトプリンターの自動検出を試みます。しかし、これはある稀なケースでは失敗することがあり、Emacsから別のプリンターを使用したいと思うときがあるかもしれません。このセクションの残りの部分では、Emacsに使用するプリンターを指示する方法を説明します。

printer-name, (MS-DOS/MS-Windows)
ローカルプリンターを使用したい場合、Lisp変数`lpr-command`に`""`(これはWindowsではデフォルトです)をセットして、`printer-name`にプリンターポート、たとえば通常のローカルプリンターポート`"PRN"`、または`"LPT2"`、またはシリアルプリンターにたいする`"COM1"`などをセットします。`printer-name`にファイル名をセットすることもできます。この場合、“印刷”された出力は、そのファイルに追加されます。`printer-name`を`"NUL"`にセットした場合、印刷された出力は破棄されます(システムのnullデバイスに送られます)。

`printer-name`にそのプリンターのUNC共有名 — たとえば`"//joes_pc/hp4si"`のような — をセットすることにより、他のマシンで共有されているプリンターを使用することもできます(ここではスラッシュを使用するか、バックスラッシュを使用するかは問題ではありません)。共有プリンターの名前を探すには、サーバーのリストを取得するために、コマンドプロンプトでコマンド‘`net
view`’を実行して、‘`net view
server-name`’でそのサーバーで共有されているプリンター(とディレクトリー)の名前を確認します。かわりにデスクトップの‘`Network
Neighborhood`’アイコンをクリックして、ネットワークを通じてプリンターを共有しているマシンを確認することもできます。

‘
net use
’, and printing on MS-Windows
networked printers (MS-Windows)
プリンターが‘`net
view`’で出力されない場合、または`printer-name`にUNC共有名をセットしても、そのプリンターからハードコピーが出力されない場合、‘`net
use`’コマンドを使用して、`"LPT2"`のようなローカルプリンターポートを、ネットワークプリンターに接続できます。たとえば`net
use LPT2:
\\joes_pc\hp4si`[27]により、Windowsに`LPT2`ポートをキャプチャーさせて、印刷物をマシン`joes_pc`に接続されているプリンターにリダイレクトします。このコマンド後は、`printer-name`に`"LPT2"`をセットすることにより、そのネットワークプリンターでハードコピーが印刷されます。

あるWindowsネットワークソフトウェアーでは、`"LPT2"`のような特定のプリンターポートをキャプチャーして、‘`net
use`’のかわりに`Control
Panel->Printers`を通じてネットワークプリンターにリダイレクトするよう、Windowsに指示できます。

`printer-name`にファイル名をセットする場合、絶対ファイル名を使用するのが最良です。Emacsはカレントバッファーのデフォルトディレクトリーに合わせて作業ディレクトリーを変更するので、`printer-name`のファイル名が相対ファイル名の場合、結果として印刷が行なわれたバッファーのディレクトリーごとに、複数のファイルができてしまいます。

変数`printer-name`の値が正しいのに、印刷してもそのプリンターからハードコピーが印刷されない場合、そのプリンターがプレーンテキストの印刷をサポートしない可能性があります(安価なプリンターのいくつかでは、この機能が省略されています)。そのような場合、以下で説明するPostScriptプリントコマンドを試してみてください。

print-buffer (MS-DOS)
print-region (MS-DOS)
lpr-headers-switches (MS-DOS)
コマンド`print-buffer`および`print-region`は、印刷された各ページにヘッダーを生成するために、`pr`プログラムを呼び出すか、`lpr`プログラムの特別なスイッチを使用します。通常MS-DOSとMS-Windowsにはこれらのプログラムがないので、デフォルトでは印刷ページのヘッダーの印刷リクエストは単に無視されるように、`lpr-headers-switches`がセットされています。したがって`print-buffer`と`print-region`は、`lpr-buffer`および`lpr-region`と同じ出力を生成します。適切な`pr`プログラム(たとえばGNU Coreutilsのもの)がある場合は、`lpr-headers-switches`に`nil`をセットします。するとEmacsはページヘッダーを生成するために`pr`を呼び出し、その結果を`printer-name`で指定されたプリンターで印刷します。

print-region-function (MS-DOS)
lpr usage under MS-DOS
lpr-command (MS-DOS)
lpr-switches (MS-DOS)
最後に、もし`lpr`によく似たものがある場合、変数`lpr-command`を`"lpr"`にセットします。するとEmacsは他のシステムと同じように、印刷に`lpr`を使用します(そのプログラムの名前が`lpr`でない場合は、`lpr-command`に適切な値をセットします)。`lpr-command`が`""`でないときに、変数`lpr-switches`は、その標準的な意味をもちます。変数`printer-name`の値が文字列のとき、Unixの場合のように、`lpr`の`-P`オプションの値としてその文字列が使用されます。

ps-print-buffer (MS-DOS)
ps-spool-buffer (MS-DOS)
ps-printer-name (MS-DOS)
ps-lpr-command (MS-DOS)
ps-lpr-switches (MS-DOS)
類似の変数`ps-lpr-command`、`ps-lpr-switches`、`ps-printer-name` ([PostScript Variables](#PostScript-Variables)を参照してください)は、PostScriptファイルがどのように印刷されるかを定義します。これらの変数は、上記で説明した非PostScript印刷にたいする変数と同じ方法で使用されます。したがって非PostScript印刷にたいして`printer-name`が使用される方法と同様に、`ps-printer-name`の値はPostScript出力が送られるデバイス(またはファイル)の名前として使用されます(2つの異なるポートに接続された2つのプリンターがあり、それらの1つだけがPostScriptプリンターの場合、2つの個別の変数セットをもつことができます)。

Ghostscript, use for PostScript printing
変数`ps-lpr-command`のデフォルト値は`""`で、これはPostScript出力を`ps-printer-name`で指定されたプリンターポートに送りますが、`ps-lpr-command`にはPostScriptファイルを受け付けるプログラム名をセットすることもできます。したがって非PostScriptプリンターがある場合、この変数に(Ghostscriptのような)PostScriptのインタープリタープログラムをセットできます。インタープリタープログラムに渡す必要があるスイッチを指定するには、`ps-lpr-switches`を使用します(`ps-printer-name`の値が文字列の場合、`-P`オプションにたいする値として、スイッチのリストが追加されます。これはおそらく`lpr`を使用する場合だけ有用なので、インタープリターを使用するときは`ps-printer-name`に文字列以外の何かをセットすれば、無視させることができます)。

たとえばシステムのデフォルトプリンターで、Ghostscriptを使用して印刷するには、以下を`.emacs`に記述します:

    (setq ps-printer-name t)
    (setq ps-lpr-command "D:/gs6.01/bin/gswin32c.exe")
    (setq ps-lpr-switches '("-q" "-dNOPAUSE" "-dBATCH"
                            "-sDEVICE=mswinpr2"
                            "-sPAPERSIZE=a4"))

(Ghostscriptがディレクトリー`D:/gs6.01`にインストールされていると仮定します。)

MS-Windowsでのフォント指定
--------------------------

font specification (MS Windows)
Emacs23からは、フォントはフォント名、サイズ、オプションのプロパティーにより指定されるようになりました。フォントを指定するフォーマットは、モダンなフリーデスクトップで使用されているfontconfigライブラリーから由来しています。

      [Family[-PointSize]][:Option1=Value1[:Option2=Value2[...]]]

後方互換のため、古いXLFDベースのフォーマットもサポートされます。

font backend selection (MS-Windows)
Emacs23以降では、いくつかのフォントバックエンドがサポートされています。現在のところ、Windowsではバックエンドとして、`gdi`と`uniscribe`がサポートされます。`gdi`フォントバックエンドは、すべてのバージョンのWindowsで利用でき、Windowsでネイティブにサポートされるすべてのフォントをサポートします。`uniscribe`フォントバックエンドはWindows 2000以降で利用でき、TrueTypeフォントとOpenTypeフォントをサポートします。複雑なレイアウトを要求するいくつかの言語は、Uniscribeバックエンドだけが正しくサポートできる言語もあります。デフォルトでは、どちらのバックエンドもサポートされていれば有効になり、`gdi`より`uniscribe`が優先されます。これをオーバーライドして、Uniscribeが利用できる場合もGDIバックエンドを使用するには、コマンドライン引数`-xrm
Emacs.fontBackend:gdi`を指定してEmacsを呼び出すか、レジストリーのキー‘`HKEY_CURRENT_USER\SOFTWARE\GNU\Emacs`’または‘`HKEY_LOCAL_MACHINE\SOFTWARE\GNU\Emacs`’のいずれかの下に、リソース`Emacs.fontBackend`を追加して値を`gdi`にセットします([Resources](#Resources)を参照してください)。

font properties (MS Windows)
以下は、MS-Windowsのすべてのフォントバックエンドにたいして一般的なオプションのプロパティーです:

`weight`  
フォントのweightを指定します。特別な値`light`、`medium`、`demibold`、`bold`、`black`は、`weight=`を使わずに指定できます(例: `Courier
New-12:bold`)。それ以外の場合、weightは100から900の数字か、`font-weight-table`の中の名前のついたweightを指定します。指定されない場合は、regularフォントが指定されたとみなします。

font-slant-table (MS-Windows)

`slant`  
フォントがitalicかどうかを指定します。特別な値`roman`、`italic`、`oblique`は、`slant=`を使わずに指定できます(例: `Courier
New-12:italic`)。それ以外の場合は、数字か、`font-slant-table`内のなまえつきのslantの1つを指定します。Windowsでは、150を越える任意のslantはitalicとして扱われ、150以下のものはすべてromanとして扱われます。

`family`  
フォントファミリーを指定しますが、通常はフォント名の最初でファミリーを指定します。

`pixelsize`  
フォントサイズをピクセルで指定します。これはファミリー名の後のポイントサイズ指定のかわりに使用することができます。

`adstyle`  
そのフォントにたいする、追加のスタイル情報を指定します。MS-Windowsでは、値`mono`、`sans`、`serif`、`script`、`decorative`が認識されます。これはフォントファミリーが指定されていない場合のフォールバックとして、もっとも有用です。

w32-charset-info-alist

`registry`  
そのフォントがカバーすることを期待される、文字セットregistryを指定します。ほとんどのTrueTypeフォントとOpenTypeフォントは、複数の国際化文字セット(national character sets)をカバーするUnicodeフォントですが、ここで`w32-charset-info-alist`から、特定の文字セットをサポートするregistry指定を使用することにより、選択されるフォントを絞り込むことができます。

`spacing`  
フォントがspacingされる方法を指定します。`p`はプロポーショナルフォントを指定し、`m`および`c`はモノスペースフォントを指定します。

`foundry`  
Windowsでは使用されませんが、情報的な目的のために、そしてこれをセットしようとするコードによる問題を防ぐため、ビットマップフォントでは`raster`、スケーラブルフォントでは`outline`、どちらともタイプが特定できなかった場合は`unknown`が、内部的にセットされます。

font properties (MS Windows gdi backend)
Options specific to `GDI` fonts:

`script`  
そのフォントがサポートすべきUnicodeの部分範囲(subrange)を指定します。

Windowsでは`latin`、`greek`、`coptic`、`cyrillic`、`armenian`、`hebrew`、`arabic`、`syriac`、`nko`、`thaana`、`devanagari`、`bengali`、`gurmukhi`、`gujarati`、`oriya`、`tamil`、`telugu`、`kannada`、`malayam`、`sinhala`、`thai`、`lao`、`tibetan`、`myanmar`、`georgian`、`hangul`、`ethiopic`、`cherokee`、`canadian-aboriginal`、`ogham`、`runic`、`khmer`、`mongolian`、`symbol`、`braille`、`han`、`ideographic-description`、`cjk-misc`、`kana`、`bopomofo`、`kanbun`、`yi`、`byzantine-musical-symbol`、`musical-symbol`、`mathematical`のscriptが認識されます。

font antialiasing (MS Windows)

`antialias`  
アンチエイリアシング(antialiasing)の方法を指定します。値`none`は、アンチエイリアシングを行なわないことを意味します。`standard`は、標準のアンチエイリアシングを使用することを意味します。`subpixel`は、subpixelアンチエイリアシング(WindowsではCleartypeとして知られます)を使用することを意味します。`natural`は、文字間のspacing調整つきでsubpixelアンチエイリアシングを使用することを意味します。指定されない場合、そのフォントはシステムのデフォルトのアンチエイリアシングを使用します。

その他のWindows固有の機能
-------------------------

このセクションでは、他のどれにも当てはまらないWindows固有の機能について説明します。

w32-use-visible-system-caret
screen reader software, MS-Windows
変数`w32-use-visible-system-caret`は、システムカレット(system caret)を可視にするか決定するフラグです。スクリーンリーダーソフトウェアーが使用されていないときのデフォルトは`nil`で、これはEmacsがポイント位置を示すために自分でカーソルを描画することを意味します。非`nil`値は、Emacsがシステムカレットでポイント位置を示すことを意味します。これはスクリーンリーダーソフトウェアーの使用を容易にし、そのようなソフトウェアーがEmacsの実行を検知したときのデフォルトになります。この変数が非`nil`の場合、カーソル表示に影響を与える他の変数は効果がなくなります。

w32-grab-focus-on-raise
frame focus policy, MS-Windows
変数`w32-grab-focus-on-raise`が非`nil`値にセットされている場合、フレームがraiseされるときフォーカスを奪います。デフォルトは`t`で、これはWindowsのデフォルトのclick-to-focusポリシーに適合します。

EmacsとMS-DOS
-------------

MS-DOS peculiarities
このセクションでは、EmacsをMS-DOSで使用する際の特質を、簡単に説明します。 MS-DOSとMicrosoftの現在のオペレーティングシステムのWindowsについての情報は、[Microsoft Windows](#Microsoft-Windows)の中にあります。

EmacsをMS-DOSにたいしてビルドした場合、そのバイナリーはWindows 3.X、Windows NT、Windows 9X/ME、Windows 2000/XPでもDOSアプリケーションとして実行されます。MS-DOSにたいしてビルドされたEmacsを使用する場合、このチャプターの内容は、それらすべてのシステムに適用されます。

MS-DOS(およびWindows)でのテキストファイルにたいするEmacsの特別な処理については、[Text and Binary](#Text-and-Binary)を参照してください 。

### MS-DOSでのキーボードの使用方法

DEL (MS-DOS)
BS (MS-DOS)
EmacsでDELと呼ばれるキー(ほとんどのワークステーションでそれが指定されているのが由来です)は、PCではBS(バックスペース)として知られています。PC固有の端末の初期化で、BSがDELとして動作するよう再マップされるのは、これが理由です。同じ理由により、Deleteキーは`C-d`として動作するように、再マップされます。

C-g (MS-DOS)
C-Break (MS-DOS)
quitting on MS-DOS
MS-DOSにたいしてビルドされたEmacsは、`C-Break`を`C-g`のような、中止(quit)文字として認識します。新たな入力にたいして準備ができるまで、`C-g`をタイプしてもEmacsが検知できないのは、これが理由です。そのため、実行中のコマンドを停止させるために、`C-g`を使用することはできません ([Quitting](#Quitting)を参照してください)。 対照的に`C-Break`は、(他のシステムでの`C-g`のように)、タイプされるとすぐに検知されるので、実行中のコマンドを停止したり、緊急エスケープのために使用されます ([Emergency Escape](#Emergency-Escape)を参照してください)。

Meta (under MS-DOS)
Hyper (under MS-DOS)
Super (under MS-DOS)
dos-super-key
dos-hyper-key
PCのキーボードマップは、左AltキーをMetaキーとして使用します。SUPERキーとHyperキーをエミュレートするために、2つの選択肢があります。変数`dos-hyper-key`および`dos-super-key`に、1または2をセットすることにより、右Ctrlキーと右Altキーのどちらかを選択します。`dos-super-key`と`dos-hyper-key`がどちらも1以外の場合、デフォルトにより右AltキーもMetaキーにマップされます。しかしMSｰDOSの国際化キーボードサポートプログラム`KEYB.COM`がインストールされている場合、非US配列のキーボードでは右Altは`~`や`@`のような文字を入力するために使用されるので、Emacsは右AltをMetaにマップしません。この場合、左AltキーだけをMetaキーとして使用することになるでしょう。

C-j (MS-DOS)
dos-keypad-mode
変数`dos-keypad-mode`は、テンキーにより返されるキーコードを制御するフラグ変数です。以下の行を`_emacs`ファイルに記述して、テンキーのENTERキーを、`C-j`のように定義することもできます:

    ;; Make the ENTER key from the numeric keypad act as C-j.
    (define-key function-key-map [kp-enter] [?\C-j])

### MS-DOSでびマウスの使用方法

mouse support under MS-DOS
MS-DOSのEmacsはマウスをサポートします(デフォルト端末のみ)。メニューやメニューバーの使用を含めて、マウスコマンドはドキュメントされているように機能します ([Menu Bar](#Menu-Bar)を参照してください)。 MS-DOSのEmacsではスクロールバーは機能しません。PCマウスには通常2つしかボタンがありません。これらは`mouse-1`、`mouse-2`として機能しますが、これらのボタンを一緒に押すと、`mouse-3`の効果をもちます。マウスにボタンが3つある場合、Emacsは開始時にそれを検知し、Xのようにすべての3ボタンは通常のように機能します。

メニューアイテムの上にマウスポインターが移動すると、メニューバーとポップアップメニューにたいするヘルプ文字列が、エコーエリアに表示されます。マウスに反応するテキストはハイライト ([Mouse References](#Mouse-References)を参照してください) もサポートされます。

mouse, set number of buttons
msdos-set-mouse-buttons
マウスドライバーのいくつかのバージョンは、マウスのボタン数を正しく報告しません。たとえばホイールつきのマウスは3つボタンがあると報告されますが、Emacsに渡されるのはそのうち2つだけです。真ん中のボタンとして使用されるホイールのクリックも渡されません。このような場合、マウスボタンがいくつあるかEmacsに指示するために、`M-x
msdos-set-mouse-buttons`コマンドを使用できます。initファイル`_emacs`に以下の行を追加することにより、そのようなセッティングを永続化できます:

    ;; Treat the mouse like a 2-button mouse.
    (msdos-set-mouse-buttons 2)

Windows clipboard support
MS-DOSにたいしてビルドされたEmacsは、Windows上で実行されているときは、クリップボード操作をサポートします。killリングにテキストを置くコマンド、またはkillリングからテキストをyankするコマンドは、EmacsがXウィンドウシステムで行なうように、最初にWindowsのクリップボードをチェックします ([Mouse Commands](#Mouse-Commands)を参照してください)。 Windows上でのMS-DOS版のEmacsは、プライマリー選択とカットバッファーだけをサポートします。セカンダリー選択は常に空になります。

クリップボードに対するアクセス方法はWindowsにより実装されているため、クリップボードに置くことができるテキストの長さは、Emacsが利用可能なDOSメモリー量により制限されます。通常はクリップボードに最大620KBのテキストを置くことができますが、この制限はシステム設定に依存し、Emacsを他のプログラムのサブプロセスとして実行している場合は、もっと少なくなります。killしたテキストが一致しない場合、Emacsはその旨を告げるメッセージを出力して、クリップボードにテキストを置きません。

ヌル文字をWindowsクリップボードに置くこともできません。killされたテキストにヌル文字が含まれる場合、Emacsはそのようなテキストをクリップボードに置かず、その結果にたいするメッセージをエコーエリアに表示します。

dos-display-scancodes
変数`dos-display-scancodes`が非`nil`の場合、Emacsは各キーストロークのASCII値とキーボードのスキャンコードを表示します。この機能は、デバッグのための`view-lossage`コマンドを補足するためのものです。

### MS-DOSでの表示

faces under MS-DOS
fonts, emulating under MS-DOS
MS-DOSのディスプレーでは、boldやitalicのようなフォントの変種が使用できませんが、複数のフェイスをサポートしており、それぞれのフェイスでフォアグラウンドとバックグラウンドのカラーを指定できます。したがってm異なるカラーを使用するために関連するフェイスを定義することにより、フォントを使用するEmacsパッケージ(`font-lock`やEnriched Textモードなそ)の完全な機能を使用することができます。利用できるカラーとフェイスと、それらの外観を確認するには、`list-colors-display`コマンド ([Colors](#Colors)を参照してください) 、および`list-faces-display` ([Faces](#Faces)を参照してください) を使用してください。

DOSディスプレーでネイティブにサポートされていないグリフと文字をEmacsが表示する方法については、このチャプターの後のほうの、[MS-DOS and MULE](#MS_002dDOS-and-MULE)を参照してください。

cursor shape on MS-DOS
Emacsを開始したとき、Emacsはカーソルの形状を塗りつぶしたボックスに変更します。他のシステムではボックスカーソルがEmacsのデフォルトなので、これは互換性のためです。デフォルトのカーソル形状は、変数`default-frame-alist`の中の`cursor-type`パラメーターでbarを指定することにより変更できます ([Creating Frames](#Creating-Frames)を参照してください)。 MS-DOS端末は垂直バーのカーソルをサポートしないので、カーソルは水平バーになり、フレームのパラメターで`width`パラメーターが指定された場合、それは実際には水平バーの高さになります。この理由により、MS-DOSではカーソルタイプ`bar`と`hbar`は同じ効果を生みます。拡張として、以下のようにして、バーカーソル指定にはwidthと同様に、カーソルが行を読み取る開始位置を含めることができます:

     '(cursor-type bar width . start)

これに加えて、widthパラメーターが負の場合、カーソルバーはその文字セルの最上部から開始されます。

frames on MS-DOS
MS-DOS端末は1度に1つのフレームだけを表示できます。MS-DOSで動作するEmacsのフレーム機能は、Emacsがテキスト端末で動作する場合と同じように機能します ([Frames](#Frames)を参照してください)。 MS-WindowsでDOS窓からEmacsを実行した場合、フルスクリーンより小さい可視フレームを作成できますが、それでもEmacsは1度に1つのフレームしか表示できません。

frame size under MS-DOS
dos-mode4350
dos-mode25
`dos-mode4350`コマンドはディスプレーを43行または50行に切り替え、それはハードウェアーに依存します。`dos-mode25`コマンドはスクリーンサイズをデフォルトの80x25に切り替えます。

デフォルトではEmacsが理解するするスクリーンサイズは、列を80列、行を25、28、35、40、43、50行にセットする方法だけです。しかしビデオアダプターが、ディスプレーを他のサイズに切り替える特別なビデオモードをもつ場合、Emacsもそれをサポートするようにできます。Emacsにフレームをn行m列のサイズに切り替えるように指示した場合、Emacsは`screen-dimensions-nxm`という名前があるかチェックして、もしあれば切り替えるビデオモードの値(整数でなければなりません)としてそれを使用します(Emacsは`AL`レジスターに`screen-dimensions-nxm`の値をセットして、BIOS関数の`Set
Video
Mode`を呼び出すことによりそのビデオモードに切り替えます)。たとえばビデオアダプターがビデオモードを85にしたとき、サイズ66x80に切り替わるとしましょう。その場合、以下を`_emacs`ファイルに記述して、Emacsにそれをサポートさせることができます:

    (setq screen-dimensions-66x80 85)

MS-DOSのEmacsは特定のサポートされたフレームサイズだけしかセットできないので、可能性のあるすべてのフレームのサイズ変更要求に従うことはできません。サポートされていないサイズが要求された場合、Emacsは指定されたサイズを越える、次に大きなサポートされたサイズを選択します。この場合、たとえば36x80フレームを要求して、かわりに40x80を得ることになります。

変数`screen-dimensions-nxm`は、指定されたサイズに正確にマッチするときだけ使用され、サポートされた次に大きなサイズを検索するときには、無視されます。上記の例ではVGAは38x80のサイズをサポートし、`screen-dimensions-38x80`を適切な値で定義していても、36x80フレームを要求すると40x80のスクリーンになります。この場合サイズを38x80にするには、`screen-dimensions-36x80`という名前の変数に、`screen-dimensions-38x80`と同じビデオもーどの値をセットして、これを行なうことができます。

MS-DOSでフレームサイズを変更すると、他のすべてのフレームも新しいサイズに変更されます。

### MS-DOSでのファイル名

file names under MS-DOS
init file, default name under MS-DOS
MS-DOSでは、ファイル名は大文字小文字を区別せず8文字に制限され、それに加えてオプションでピリオドと追加の3文字を使用できます。Emacsは他のオペレーティングシステムで、ファイル名を処理するためのこれらの制限を充分認識しています。たとえばファイル名の前のドット‘`.`’はMS-DOSでは無効なので、Emacsはそれらを透過的にアンダースコアー‘`_`’に変換します。したがって、MS-DOSではデフォルトのinitファイル ([Init File](#Init-File)を参照してください) は`_emacs`と呼ばれます。ピリオドの前後の余分な文字は、一般的にMS-DOS自身により無視されます。したがってファイル`LongFileName.EvenLongerExtension`をvisitした場合、それは暗黙に`longfile.eve`となりますが、それでもEmacsはモードラインに長いファイル名を表示し続けます。それ以外ではMS-DOSで有効なファイル名を指定するのはユーザーの責任です。上記の透過的な変換は、Emacsに組み込まれたファイル名だけにたいして機能します。

backup file names on MS-DOS
MS-DOSでのファイル名にたいする上記の制限は、オリジナルのファイル名の文字を失うことなしにバックアップファイルの名前を構築するのを、ほとんど不可能にします ([Backup Names](#Backup-Names)を参照してください)。 たとえば`docs.txt`というファイルにたいするバックアップファイルの名前は、単一のバックアップを使用しているときでさえ`docs.tx~`になります。

file names under Windows 95/NT
long file names in DOS box under Windows 95/NT
Windows 9X、Windows ME、Windows 2000/XPでEmacsをDOSアプリケーションとして実行する場合、長いファイル名のサポートをオンに切り替えることができます。これを行なうと、Emacsはファイル名を切り詰めたり、ファイル名を小文字に変換するかわりに、指定された文字通りのファイル名を使用します。長いファイル名のサポートを有効にするには、Emacsを開始する前に、環境変数LFNを‘`y`’にセットします。残念なことにWindows NTはDOSプログラムが長いファイル名にアクセスすることを許さないので、MS-DOSにたいしてビルドされたEmacsは、短い8+3のエイリアスだけを見ることになります。

HOME directory under MS-DOS
MS-DOSにはホームディレクトリーという概念がないので、MS-DOS上のEmacsはEmacsがインストールされた場所が、環境変数HOMEの値であるかのように振る舞います。つまりEmacsのバイナリー`emacs.exe`がディレクトリー`c:/utils/emacs/bin`にある場合、EmacsはHOMEが‘`c:/utils/emacs`’にセットされているかのように動作します。この場所は特に、Emacsがinitファイル`_emacs`を探す場所でもあります。これを念頭におけば、GNUやUnixのように、ファイル名の中で‘`~`’をホームディレクトリーのエイリアスとして使用できます。Emacsを開始する前に、その環境でHOME変数をセットすることもできます。この変数の値は、上記のデフォルトの振る舞いをオーバーライドします。

MS-DOSのEmacsは、`/dev`という名前を特別に使います。なぜならGJGPPのエミュレーターライブラリーの機能は、I/Oデバイスの名前がそのディレクトリーにあるかのように振る舞うからです。わたしたちは任意のディスクにたいして、`/dev`という名前のディレクトリーの使用を避けることを推奨します。

### 印刷とMS-DOS

`lpr-buffer` ([Printing](#Printing)を参照してください)や、`ps-print-buffer` ([PostScript](#PostScript)を参照してください) のようなコマンドは、POSIXスタイルの`lpr`プログラムが利用できない場合、出力を1つのプリンターポートに送ることにより、MS-DOSで機能します。同じEmacs変数がすべてのシステムでの印刷を制御しますが、MS-DOSでは異なるデフォルト値をもつ場合もあります。

ネットワークプリンターでの印刷のセットアップに関する詳細は、[Windows Printing](#Windows-Printing)を参照してください 。

プリンターが同じlocaleにたいして異なるエンコーディングを使用するWindows機に接続されている場合にも、非ASCIIテキストのDOSコードページによるエンコーディングを期待するプリンターがいくつかあります。たとえばlocaleがLatin-1のとき、Windowsはコードページ1252を使用しますが、DOSはコードページ850を使用します。[MS-DOS and MULE](#MS_002dDOS-and-MULE)を参照してください。Windowsからそのようなプリンターで印刷する場合、`M-x
lpr-buffer`の前に、`C-x RET c` (`universal-coding-system-argument`)を使用することができます。その場合、Emacsは指定したDOSコードページにテキストを変換します。たとえば`C-x
RET c cp850-dos RET M-x lpr-region
RET`は、リージョンをコードページ850のエンコーディングに変換して印刷します。

dos-printer
dos-ps-printer
MS-DOSでは後方互換のため、`dos-printer` (`dos-ps-printer`)に値がセットされている場合、`printer-name` (`ps-printer-name`)の値をオーバーライドします。

### MS-DOSでの国際化サポート

international support (MS-DOS)
MS-DOSのEmacsは、異なる文字セット同士を変換するためのコーディングシステムを含む、GNU、Unix、その他のプラットフォームでサポートされているのと同じ国際化文字セットをサポートします ([International](#International)を参照してください)。 しかしMS-DOSと、MS-Windowsや他のシステムとの間の非互換により、このサポートには知っておくべきいくつかのDOS特有の状況があります。このセクションではこれらの状況について説明します。

以下の説明では、主にEmacsのMS-DOSポートについて、特に経験豊富なEmacsユーザーにとって密接に関係する部分について説明します。

`M-x dos-codepage-setup`  
カレントDOSコードページにたいして、適切なEmacsディスプレーとコーディングシステムをセットアップします。

codepage, MS-DOS
DOS codepages
MS-DOSは常に256文字の文字セットをサポートするようにデザインされていますが、それからさまざまな文字セットを選択できます。選択できる文字セットはDOSコードページとして知られます。各コードページはすべて128文字のASCII文字を含みますが、それ以外の128文字(コード128から255)は、コードページごとに異なります。各コードページは850、862のように3桁の数字で識別されます。

同時に複数のフォントを使用できるXとは対照的に、通常MS-DOSは1つのセッションで複数のコードページを使用できません。MS-DOSはシステムの開始時に1つのコードページをロードするようにデザインされており、それを変更するには再起動が必要です[28]。MS-Windowsのような他のシステムでDOSの実行可能ファイルを実行するときも、ほぼ同じ制限が適用されます。

dos-codepage
MS-DOSでのマルチバイト処理にたいして、Emacsは選択されたDOSコードページで表示できる文字を知る必要があります。そのため起動後に、選択されたコードページ番号を得るためにシステムに問い合わせを行い、その番号を変数`dos-codepage`に格納します。実際のコードページは異なっていても、カレントコードページにたいしてデフォルト値437を返すシステムがいくつかあります(通常これはディスプレーハードウェアーに組み込まれているコードページを使用しているとき発生します)。initファイルで変数`dos-codepage`をセットすることにより、Emacsに別のコードページを指定できます。

language environment, automatic selection on MS-DOS
マルチバイトのEmacsは特定のDOSコードページ — 日本語コードページ932のような極東アジアのスクリプトを表示できるものや、1つのISO 8859文字セットをエンコードするものがあります。

極東アジアのコードページは、それらの国々にたいするMULE文字セットの1つを直接表示できるので、Emacsはそのコードページでサポートされる適切な端末コーディングシステムを使用するためにセットアップを行なうだけです。このセクションの残りの部分で説明する特別な機能は、主にISO 8859文字セットをエンコードするコードページに関するものです。

ISO文字セットの1つに対応するコードページにたいして、Emacsはそのコードページ番号にもとづいた文字セットを認識します。Emacsは、カレントコードページを使用したファイルの読み書きをサポートするためのコーディングシステムを自動的に作成して、そのコーディングシステムをデフォルトとして使用します。このコーディングシステムの名前は`cpnnn`で、nnnはコードページ番号です。[29]

mode line (MS-DOS)
`cpnnn`というコーディングシステムはすべて、モードラインのニーモニックに文字‘`D`’ (“DOS”)を使用します。端末のコーディングシステムと、ファイルI/Oにたいするデフォルトのコーディングシステムは、開始時に適切な`cpnnn`コーディングシステムにセットされているので、普通はMS-DOSのモードラインは‘`-DD\-`’で始まります。 [Mode Line](#Mode-Line)を参照してください。 極東アジアのDOS端末は`cpnnn`コーディングシステムを使用しないので、Emacsデフォルトのモードラインが初期表示されます。

コードページ番号は使用しているスクリプトも示すので、Emacsはそのスクリプトにたいする言語環境を選択するために、自動的に`set-language-environment`を実行します ([Language Environments](#Language-Environments)を参照してください)。

バッファーにISO 8859文字セット以外の文字が含まれていて、それが選択されたDOSコードページでサポートされていない場合、EmacsはASCII文字のシーケンスを使用して、それを表示します。たとえばカレントコードページが文字‘`ò`’(grave accentつきの小文字の‘`o`’)にたいするグリフをもたない場合、その文字は‘`` {`o} ``’と表示されます。ここで中カッコ(braces)はそれが1つの文字であることを示す指標です(これはギリシャ文字やヘブライのアルファベットのような非ラテン文字にたいして不格好に見えるかもしれませんが、その言語を知る人はこれを読むことができます)。その文字がスクリーンの複数列を占めていても、それは単なる1つの文字であり、Emacsコマンドは、それを1文字として扱います。

MS-Windows codepages
MS-Windowsは独自のコードページを提供し、同じロケールにたいするDOSコードページとは異なります。たとえばDOSコードページと同じ文字をサポートするWindowsコードページは1252で、DOSコードページ855と同じ文字をサポートするWindowsコードページは1252、などです。EmacsのMS-Windowsバージョンを‘`-nw`’オプションで呼び出したとき、Emacsはカレントコードページを使用して表示を行ないます。

### MS-DOSでのサブプロセス

compilation under MS-DOS
inferior processes under MS-DOS
compile (MS-DOS)
grep (MS-DOS)
MS-DOSは単一プロセスの“オペレーティングシステム”なので、非同期サブプロセスは利用できません。特にShellモードと、その変種は機能しません。非同期サブプロセスを使用するEmacs機能のほとんどは、ShellモードやGUDを含めて、MS-DOSでは動作しません。疑わしいときは、コマンドを実行してみれば、機能しない場合は非同期プロセスがサポートされない旨を告げるメッセージが出力されます。

`M-x compile`によるEmacsでのコンパイル、`M-x grep`によるファイル検索、`M-x
diff`によるファイル間の相違の表示は、同期的に内部プロセスを実行することにより機能します。これはその内部プロセスが終了するまで、編集を行なうことができないことを意味します。

`ispell`プログラムの同期呼び出しにたいする特別なサポートにより、スペルチェックも機能します。これは他のプラットフォームでの非同期呼び出しより遅くなります。

MS-DOSでは、機能しないShellモードのかわりに、`M-x
eshell`コマンドを使用することができます。これはPOSIX-likeなシェルを、Emacs Lispで実装したEshellパッケージを呼び出します。

対照的に、ネイティブなWindowsアプリケーションとしてコンパイルされたEmacsは、非同期サブプロセスを**サポートします** [Windows Processes](#Windows-Processes)を参照してください。

printing under MS-DOS
`lpr-buffer` ([Printing](#Printing)を参照してください)と、`ps-print-buffer` (see [PostScript](#PostScript)を参照してください)は、プリンターポートの1つに出力を送ることにより、MS-DOSでも機能します。[MS-DOS Printing](#MS_002dDOS-Printing)を参照してください。

MS-DOSでサブプロセスを同期実行する場合は、そのプログラムが終了することと、そのプログラムがキーボード入力の読み取りを試みないことを確認してください。プログラムが自分で終了しない場合、それを終了させることはできません。なぜならMS-DOSはプロセスを終了させる一般的な方法を提供しないからです。このような場合、`C-c`や`C-Break`を押すことが助けになる場合もあります。

MS-DOSでは、他のマシンにあるファイルへのアクセスもサポートされません。何らかのネットワークリダイレクト処理により、MS-DOSにネットワークアクセス機能が組み込まれていない限り、メール送信、ウェブ閲覧、リモートログインなどのようなネットワーク指向のコマンドは機能しません。

directory listing on MS-DOS
dired-listing-switches (MS-DOS)
MS-DOSのDiredは`ls-lisp`パッケージを使用します ([ls in Lisp](#ls-in-Lisp)を参照してください)。 したがってMS-DOSのDiredは、変数`dired-listing-switches`に記述できる、利用可能なオプションは限られます。機能するオプションは‘`-A`’、‘`-a`’、‘`-c`’、‘`-i`’、‘`-r`’、‘`-S`’、‘`-s`’、‘`-t`’、‘`-u`’です。

The GNU Manifesto
=================

> The GNU Manifesto which appears below was written by Richard Stallman at the beginning of the GNU project, to ask for participation and support. For the first few years, it was updated in minor ways to account for developments, but now it seems best to leave it unchanged as most people have seen it.
>
> Since that time, we have learned about certain common misunderstandings that different wording could help avoid. Footnotes added in 1993 help clarify these points.
>
> For up-to-date information about available GNU software, please see our web site, <https://www.gnu.org>. For software tasks and other ways to contribute, see <https://www.gnu.org/help>.

What’s GNU? Gnu’s Not Unix!
---------------------------

GNU, which stands for Gnu’s Not Unix, is the name for the complete Unix-compatible software system which I am writing so that I can give it away free to everyone who can use it.[30] Several other volunteers are helping me. Contributions of time, money, programs and equipment are greatly needed.

So far we have an Emacs text editor with Lisp for writing editor commands, a source level debugger, a yacc-compatible parser generator, a linker, and around 35 utilities. A shell (command interpreter) is nearly completed. A new portable optimizing C compiler has compiled itself and may be released this year. An initial kernel exists but many more features are needed to emulate Unix. When the kernel and compiler are finished, it will be possible to distribute a GNU system suitable for program development. We will use TEX as our text formatter, but an nroff is being worked on. We will use the free, portable X window system as well. After this we will add a portable Common Lisp, an Empire game, a spreadsheet, and hundreds of other things, plus on-line documentation. We hope to supply, eventually, everything useful that normally comes with a Unix system, and more.

GNU will be able to run Unix programs, but will not be identical to Unix. We will make all improvements that are convenient, based on our experience with other operating systems. In particular, we plan to have longer file names, file version numbers, a crashproof file system, file name completion perhaps, terminal-independent display support, and perhaps eventually a Lisp-based window system through which several Lisp programs and ordinary Unix programs can share a screen. Both C and Lisp will be available as system programming languages. We will try to support UUCP, MIT Chaosnet, and Internet protocols for communication.

GNU is aimed initially at machines in the 68000/16000 class with virtual memory, because they are the easiest machines to make it run on. The extra effort to make it run on smaller machines will be left to someone who wants to use it on them.

To avoid horrible confusion, please pronounce the “G” in the word “GNU” when it is the name of this project.

Why I Must Write GNU
--------------------

I consider that the golden rule requires that if I like a program I must share it with other people who like it. Software sellers want to divide the users and conquer them, making each user agree not to share with others. I refuse to break solidarity with other users in this way. I cannot in good conscience sign a nondisclosure agreement or a software license agreement. For years I worked within the Artificial Intelligence Lab to resist such tendencies and other inhospitalities, but eventually they had gone too far: I could not remain in an institution where such things are done for me against my will.

So that I can continue to use computers without dishonor, I have decided to put together a sufficient body of free software so that I will be able to get along without any software that is not free. I have resigned from the AI lab to deny MIT any legal excuse to prevent me from giving GNU away.

Why GNU Will Be Compatible with Unix
------------------------------------

Unix is not my ideal system, but it is not too bad. The essential features of Unix seem to be good ones, and I think I can fill in what Unix lacks without spoiling them. And a system compatible with Unix would be convenient for many other people to adopt.

How GNU Will Be Available
-------------------------

GNU is not in the public domain. Everyone will be permitted to modify and redistribute GNU, but no distributor will be allowed to restrict its further redistribution. That is to say, proprietary modifications will not be allowed. I want to make sure that all versions of GNU remain free.

Why Many Other Programmers Want to Help
---------------------------------------

I have found many other programmers who are excited about GNU and want to help.

Many programmers are unhappy about the commercialization of system software. It may enable them to make more money, but it requires them to feel in conflict with other programmers in general rather than feel as comrades. The fundamental act of friendship among programmers is the sharing of programs; marketing arrangements now typically used essentially forbid programmers to treat others as friends. The purchaser of software must choose between friendship and obeying the law. Naturally, many decide that friendship is more important. But those who believe in law often do not feel at ease with either choice. They become cynical and think that programming is just a way of making money.

By working on and using GNU rather than proprietary programs, we can be hospitable to everyone and obey the law. In addition, GNU serves as an example to inspire and a banner to rally others to join us in sharing. This can give us a feeling of harmony which is impossible if we use software that is not free. For about half the programmers I talk to, this is an important happiness that money cannot replace.

How You Can Contribute
----------------------

I am asking computer manufacturers for donations of machines and money. I’m asking individuals for donations of programs and work.

One consequence you can expect if you donate machines is that GNU will run on them at an early date. The machines should be complete, ready to use systems, approved for use in a residential area, and not in need of sophisticated cooling or power.

I have found very many programmers eager to contribute part-time work for GNU. For most projects, such part-time distributed work would be very hard to coordinate; the independently-written parts would not work together. But for the particular task of replacing Unix, this problem is absent. A complete Unix system contains hundreds of utility programs, each of which is documented separately. Most interface specifications are fixed by Unix compatibility. If each contributor can write a compatible replacement for a single Unix utility, and make it work properly in place of the original on a Unix system, then these utilities will work right when put together. Even allowing for Murphy to create a few unexpected problems, assembling these components will be a feasible task. (The kernel will require closer communication and will be worked on by a small, tight group.)

If I get donations of money, I may be able to hire a few people full or part time. The salary won’t be high by programmers’ standards, but I’m looking for people for whom building community spirit is as important as making money. I view this as a way of enabling dedicated people to devote their full energies to working on GNU by sparing them the need to make a living in another way.

Why All Computer Users Will Benefit
-----------------------------------

Once GNU is written, everyone will be able to obtain good system software free, just like air.[31]

This means much more than just saving everyone the price of a Unix license. It means that much wasteful duplication of system programming effort will be avoided. This effort can go instead into advancing the state of the art.

Complete system sources will be available to everyone. As a result, a user who needs changes in the system will always be free to make them himself, or hire any available programmer or company to make them for him. Users will no longer be at the mercy of one programmer or company which owns the sources and is in sole position to make changes.

Schools will be able to provide a much more educational environment by encouraging all students to study and improve the system code. Harvard’s computer lab used to have the policy that no program could be installed on the system if its sources were not on public display, and upheld it by actually refusing to install certain programs. I was very much inspired by this.

Finally, the overhead of considering who owns the system software and what one is or is not entitled to do with it will be lifted.

Arrangements to make people pay for using a program, including licensing of copies, always incur a tremendous cost to society through the cumbersome mechanisms necessary to figure out how much (that is, which programs) a person must pay for. And only a police state can force everyone to obey them. Consider a space station where air must be manufactured at great cost: charging each breather per liter of air may be fair, but wearing the metered gas mask all day and all night is intolerable even if everyone can afford to pay the air bill. And the TV cameras everywhere to see if you ever take the mask off are outrageous. It’s better to support the air plant with a head tax and chuck the masks.

Copying all or parts of a program is as natural to a programmer as breathing, and as productive. It ought to be as free.

Some Easily Rebutted Objections to GNU’s Goals
----------------------------------------------

> “Nobody will use it if it is free, because that means they can’t rely on any support.”
>
> “You have to charge for the program to pay for providing the support.”

If people would rather pay for GNU plus service than get GNU free without service, a company to provide just service to people who have obtained GNU free ought to be profitable.[32]

We must distinguish between support in the form of real programming work and mere handholding. The former is something one cannot rely on from a software vendor. If your problem is not shared by enough people, the vendor will tell you to get lost.

If your business needs to be able to rely on support, the only way is to have all the necessary sources and tools. Then you can hire any available person to fix your problem; you are not at the mercy of any individual. With Unix, the price of sources puts this out of consideration for most businesses. With GNU this will be easy. It is still possible for there to be no available competent person, but this problem cannot be blamed on distribution arrangements. GNU does not eliminate all the world’s problems, only some of them.

Meanwhile, the users who know nothing about computers need handholding: doing things for them which they could easily do themselves but don’t know how.

Such services could be provided by companies that sell just hand-holding and repair service. If it is true that users would rather spend money and get a product with service, they will also be willing to buy the service having got the product free. The service companies will compete in quality and price; users will not be tied to any particular one. Meanwhile, those of us who don’t need the service should be able to use the program without paying for the service.

> “You cannot reach many people without advertising, and you must charge for the program to support that.”
>
> “It’s no use advertising a program people can get free.”

There are various forms of free or very cheap publicity that can be used to inform numbers of computer users about something like GNU. But it may be true that one can reach more microcomputer users with advertising. If this is really so, a business which advertises the service of copying and mailing GNU for a fee ought to be successful enough to pay for its advertising and more. This way, only the users who benefit from the advertising pay for it.

On the other hand, if many people get GNU from their friends, and such companies don’t succeed, this will show that advertising was not really necessary to spread GNU. Why is it that free market advocates don’t want to let the free market decide this?[33]

> “My company needs a proprietary operating system to get a competitive edge.”

GNU will remove operating system software from the realm of competition. You will not be able to get an edge in this area, but neither will your competitors be able to get an edge over you. You and they will compete in other areas, while benefiting mutually in this one. If your business is selling an operating system, you will not like GNU, but that’s tough on you. If your business is something else, GNU can save you from being pushed into the expensive business of selling operating systems.

I would like to see GNU development supported by gifts from many manufacturers and users, reducing the cost to each.[34]

> “Don’t programmers deserve a reward for their creativity?”

If anything deserves a reward, it is social contribution. Creativity can be a social contribution, but only in so far as society is free to use the results. If programmers deserve to be rewarded for creating innovative programs, by the same token they deserve to be punished if they restrict the use of these programs.

> “Shouldn’t a programmer be able to ask for a reward for his creativity?”

There is nothing wrong with wanting pay for work, or seeking to maximize one’s income, as long as one does not use means that are destructive. But the means customary in the field of software today are based on destruction.

Extracting money from users of a program by restricting their use of it is destructive because the restrictions reduce the amount and the ways that the program can be used. This reduces the amount of wealth that humanity derives from the program. When there is a deliberate choice to restrict, the harmful consequences are deliberate destruction.

The reason a good citizen does not use such destructive means to become wealthier is that, if everyone did so, we would all become poorer from the mutual destructiveness. This is Kantian ethics; or, the Golden Rule. Since I do not like the consequences that result if everyone hoards information, I am required to consider it wrong for one to do so. Specifically, the desire to be rewarded for one’s creativity does not justify depriving the world in general of all or part of that creativity.

> “Won’t programmers starve?”

I could answer that nobody is forced to be a programmer. Most of us cannot manage to get any money for standing on the street and making faces. But we are not, as a result, condemned to spend our lives standing on the street making faces, and starving. We do something else.

But that is the wrong answer because it accepts the questioner’s implicit assumption: that without ownership of software, programmers cannot possibly be paid a cent. Supposedly it is all or nothing.

The real reason programmers will not starve is that it will still be possible for them to get paid for programming; just not paid as much as now.

Restricting copying is not the only basis for business in software. It is the most common basis because it brings in the most money. If it were prohibited, or rejected by the customer, software business would move to other bases of organization which are now used less often. There are always numerous ways to organize any kind of business.

Probably programming will not be as lucrative on the new basis as it is now. But that is not an argument against the change. It is not considered an injustice that sales clerks make the salaries that they now do. If programmers made the same, that would not be an injustice either. (In practice they would still make considerably more than that.)

> “Don’t people have a right to control how their creativity is used?”

“Control over the use of one’s ideas” really constitutes control over other people’s lives; and it is usually used to make their lives more difficult.

People who have studied the issue of intellectual property rights[35] carefully (such as lawyers) say that there is no intrinsic right to intellectual property. The kinds of supposed intellectual property rights that the government recognizes were created by specific acts of legislation for specific purposes.

For example, the patent system was established to encourage inventors to disclose the details of their inventions. Its purpose was to help society rather than to help inventors. At the time, the life span of 17 years for a patent was short compared with the rate of advance of the state of the art. Since patents are an issue only among manufacturers, for whom the cost and effort of a license agreement are small compared with setting up production, the patents often do not do much harm. They do not obstruct most individuals who use patented products.

The idea of copyright did not exist in ancient times, when authors frequently copied other authors at length in works of non-fiction. This practice was useful, and is the only way many authors’ works have survived even in part. The copyright system was created expressly for the purpose of encouraging authorship. In the domain for which it was invented—books, which could be copied economically only on a printing press—it did little harm, and did not obstruct most of the individuals who read the books.

All intellectual property rights are just licenses granted by society because it was thought, rightly or wrongly, that society as a whole would benefit by granting them. But in any particular situation, we have to ask: are we really better off granting such license? What kind of act are we licensing a person to do?

The case of programs today is very different from that of books a hundred years ago. The fact that the easiest way to copy a program is from one neighbor to another, the fact that a program has both source code and object code which are distinct, and the fact that a program is used rather than read and enjoyed, combine to create a situation in which a person who enforces a copyright is harming society as a whole both materially and spiritually; in which a person should not do so regardless of whether the law enables him to.

> “Competition makes things get done better.”

The paradigm of competition is a race: by rewarding the winner, we encourage everyone to run faster. When capitalism really works this way, it does a good job; but its defenders are wrong in assuming it always works this way. If the runners forget why the reward is offered and become intent on winning, no matter how, they may find other strategies—such as, attacking other runners. If the runners get into a fist fight, they will all finish late.

Proprietary and secret software is the moral equivalent of runners in a fist fight. Sad to say, the only referee we’ve got does not seem to object to fights; he just regulates them (“For every ten yards you run, you can fire one shot”). He really ought to break them up, and penalize runners for even trying to fight.

> “Won’t everyone stop programming without a monetary incentive?”

Actually, many people will program with absolutely no monetary incentive. Programming has an irresistible fascination for some people, usually the people who are best at it. There is no shortage of professional musicians who keep at it even though they have no hope of making a living that way.

But really this question, though commonly asked, is not appropriate to the situation. Pay for programmers will not disappear, only become less. So the right question is, will anyone program with a reduced monetary incentive? My experience shows that they will.

For more than ten years, many of the world’s best programmers worked at the Artificial Intelligence Lab for far less money than they could have had anywhere else. They got many kinds of non-monetary rewards: fame and appreciation, for example. And creativity is also fun, a reward in itself.

Then most of them left when offered a chance to do the same interesting work for a lot of money.

What the facts show is that people will program for reasons other than riches; but if given a chance to make a lot of money as well, they will come to expect and demand it. Low-paying organizations do poorly in competition with high-paying ones, but they do not have to do badly if the high-paying ones are banned.

> “We need the programmers desperately. If they demand that we stop helping our neighbors, we have to obey.”

You’re never so desperate that you have to obey this sort of demand. Remember: millions for defense, but not a cent for tribute!

> “Programmers need to make a living somehow.”

In the short run, this is true. However, there are plenty of ways that programmers could make a living without selling the right to use a program. This way is customary now because it brings programmers and businessmen the most money, not because it is the only way to make a living. It is easy to find other ways if you want to find them. Here are a number of examples.

A manufacturer introducing a new computer will pay for the porting of operating systems onto the new hardware.

The sale of teaching, hand-holding and maintenance services could also employ programmers.

People with new ideas could distribute programs as freeware[36], asking for donations from satisfied users, or selling hand-holding services. I have met people who are already working this way successfully.

Users with related needs can form users’ groups, and pay dues. A group would contract with programming companies to write programs that the group’s members would like to use.

All sorts of development can be funded with a Software Tax:

> Suppose everyone who buys a computer has to pay x percent of the price as a software tax. The government gives this to an agency like the NSF to spend on software development.
>
> But if the computer buyer makes a donation to software development himself, he can take a credit against the tax. He can donate to the project of his own choosing—often, chosen because he hopes to use the results when it is done. He can take a credit for any amount of donation up to the total tax he had to pay.
>
> The total tax rate could be decided by a vote of the payers of the tax, weighted according to the amount they will be taxed on.
>
> The consequences:
>
> -   The computer-using community supports software development.
>
> -   This community decides what level of support is needed.
>
> -   Users who care which projects their share is spent on can choose this for themselves.
>
In the long run, making programs free is a step toward the post-scarcity world, where nobody will have to work very hard just to make a living. People will be free to devote themselves to activities that are fun, such as programming, after spending the necessary ten hours a week on required tasks such as legislation, family counseling, robot repair and asteroid prospecting. There will be no need to be able to make a living from programming.

We have already greatly reduced the amount of work that the whole society must do for its actual productivity, but only a little of this has translated itself into leisure for workers because much nonproductive activity is required to accompany productive activity. The main causes of this are bureaucracy and isometric struggles against competition. Free software will greatly reduce these drains in the area of software production. We must do this, in order for technical gains in productivity to translate into less work for us.

Glossary
========

glossary
Abbrev  
An abbrev is a text string that expands into a different text string when present in the buffer. For example, you might define a few letters as an abbrev for a long phrase that you want to insert frequently. See [Abbrevs](#Abbrevs).

Aborting  
Aborting means getting out of a recursive edit (q.v.). The commands `C-]` and `M-x top-level` are used for this. See [Quitting](#Quitting).

Active Region  
Setting the mark (q.v.) at a position in the text also activates it. When the mark is active, we call the region an active region. See [Mark](#Mark).

Alt  
Alt is the name of a modifier bit that a keyboard input character may have. To make a character Alt, type it while holding down the Alt key. Such characters are given names that start with `Alt-` (usually written `A-` for short). (Note that many terminals have a key labeled Alt that is really a Meta key.) See [Alt](#User-Input).

Argument  
See [Glossary—Numeric Argument](#Glossary_002d_002d_002dNumeric-Argument).

ASCII character  
An ASCII character is either an ASCII control character or an ASCII printing character. See [User Input](#User-Input).

ASCII control character  
An ASCII control character is the Control version of an upper-case letter, or the Control version of one of the characters ‘`@[\]^_?`’.

ASCII printing character  
ASCII letters, digits, space, and the following punctuation characters: ‘`` !@#$%^&*()_-+=|\~`{}[]:;"'<>,.?/ ``’.

Auto Fill Mode  
Auto Fill mode is a minor mode (q.v.) in which text that you insert is automatically broken into lines of a given maximum width. See [Filling](#Filling).

Auto Saving  
Auto saving is the practice of periodically saving the contents of an Emacs buffer in a specially-named file, so that the information will be preserved if the buffer is lost due to a system error or user error. See [Auto Save](#Auto-Save).

Autoloading  
Emacs can automatically load Lisp libraries when a Lisp program requests a function from those libraries. This is called “autoloading”. See [Lisp Libraries](#Lisp-Libraries).

Backtrace  
A backtrace is a trace of a series of function calls showing how a program arrived at a certain point. It is used mainly for finding and correcting bugs (q.v.). Emacs can display a backtrace when it signals an error or when you type `C-g` (see [Glossary—Quitting](#Glossary_002d_002d_002dQuitting)). See [Checklist](#Checklist).

Backup File  
A backup file records the contents that a file had before the current editing session. Emacs makes backup files automatically to help you track down or cancel changes you later regret making. See [Backup](#Backup).

Balancing Parentheses  
Emacs can balance parentheses (or other matching delimiters) either manually or automatically. You do manual balancing with the commands to move over parenthetical groupings (see [Moving by Parens](#Moving-by-Parens)). Automatic balancing works by blinking or highlighting the delimiter that matches the one you just inserted, or inserting the matching delimiter for you (see [Matching Parens](#Matching)).

Balanced Expressions  
A balanced expression is a syntactically recognizable expression, such as a symbol, number, string constant, block, or parenthesized expression in C. See [Balanced Expressions](#Expressions).

Balloon Help  
See [Glossary—Tooltips](#Glossary_002d_002d_002dTooltips).

Base Buffer  
A base buffer is a buffer whose text is shared by an indirect buffer (q.v.).

Bidirectional Text  
Some human languages, such as English, are written from left to right. Others, such as Arabic, are written from right to left. Emacs supports both of these forms, as well as any mixture of them—this is “bidirectional text”. See [Bidirectional Editing](#Bidirectional-Editing).

Bind  
To bind a key sequence means to give it a binding (q.v.). See [Rebinding](#Rebinding).

Binding  
A key sequence gets its meaning in Emacs by having a binding, which is a command (q.v.)—a Lisp function that is run when you type that sequence. See [Binding](#Commands). Customization often involves rebinding a character to a different command function. The bindings of all key sequences are recorded in the keymaps (q.v.). See [Keymaps](#Keymaps).

Blank Lines  
Blank lines are lines that contain only whitespace. Emacs has several commands for operating on the blank lines in the buffer. See [Blank Lines](#Blank-Lines).

Bookmark  
Bookmarks are akin to registers (q.v.) in that they record positions in buffers to which you can return later. Unlike registers, bookmarks persist between Emacs sessions. See [Bookmarks](#Bookmarks).

Border  
A border is a thin space along the edge of the frame, used just for spacing, not for displaying anything. An Emacs frame has an ordinary external border, outside of everything including the menu bar, plus an internal border that surrounds the text windows, their scroll bars and fringes, and separates them from the menu bar and tool bar. You can customize both borders with options and resources (see [Borders X](#Borders-X)). Borders are not the same as fringes (q.v.).

Buffer  
The buffer is the basic editing unit; one buffer corresponds to one text being edited. You normally have several buffers, but at any time you are editing only one, the current buffer, though several can be visible when you are using multiple windows or frames (q.v.). Most buffers are visiting (q.v.) some file. See [Buffers](#Buffers).

Buffer Selection History  
Emacs keeps a buffer selection history that records how recently each Emacs buffer has been selected. This is used for choosing which buffer to select. See [Buffers](#Buffers).

Bug  
A bug is an incorrect or unreasonable behavior of a program, or inaccurate or confusing documentation. Emacs developers treat bug reports, both in Emacs code and its documentation, very seriously and ask you to report any bugs you find. See [Bugs](#Bugs).

Button Down Event  
A button down event is the kind of input event (q.v.) generated right away when you press down on a mouse button. See [Mouse Buttons](#Mouse-Buttons).

By Default  
See [Glossary—Default](#Glossary_002d_002d_002dDefault).

Byte Compilation  
See [Glossary—Compilation](#Glossary_002d_002d_002dCompilation).

cf.; c.f.  
Short for “confer” in Latin, which means “compare with” or “compare to”. The second variant, “c.f.”, is a widespread misspelling.

`C-`  
`C-` in the name of a character is an abbreviation for Control. See [C-](#User-Input).

`C-M-`  
`C-M-` in the name of a character is an abbreviation for Control-Meta. If your terminal lacks a real Meta key, you type a Control-Meta character by typing ESC and then typing the corresponding Control character. See [C-M-](#User-Input).

Case Conversion  
Case conversion means changing text from upper case to lower case or vice versa. See [Case](#Case).

Case Folding  
Case folding means ignoring the differences between case variants of the same letter: upper-case, lower-case, and title-case. Emacs performs case folding by default in text search. See [Lax Search](#Lax-Search).

Character  
Characters form the contents of an Emacs buffer. Also, key sequences (q.v.) are usually made up of characters (though they may include other input events as well). See [User Input](#User-Input).

Character Folding  
Character folding means ignoring differences between similarly looking characters, such as between `a`, and `ä` and `á`. Emacs performs character folding by default in text search. See [Lax Search](#Lax-Search).

Character Set  
Emacs supports a number of character sets, each of which represents a particular alphabet or script. See [International](#International).

Character Terminal  
See [Glossary—Text Terminal](#Glossary_002d_002d_002dText-Terminal).

Click Event  
A click event is the kind of input event (q.v.) generated when you press a mouse button and release it without moving the mouse. See [Mouse Buttons](#Mouse-Buttons).

Client  
See [Glossary—Server](#Glossary_002d_002d_002dServer).

Clipboard  
A clipboard is a buffer provided by the window system for transferring text between applications. On the X Window System, the clipboard is provided in addition to the primary selection (q.v.); on MS-Windows and Mac, the clipboard is used *instead* of the primary selection. See [Clipboard](#Clipboard).

Coding System  
A coding system is a way to encode text characters in a file or in a stream of information. Emacs has the ability to convert text to or from a variety of coding systems when reading or writing it. See [Coding Systems](#Coding-Systems).

Command  
A command is a Lisp function specially defined to be able to serve as a key binding in Emacs or to be invoked by its name (see [Glossary—Command Name](#Glossary_002d_002d_002dCommand-Name)). When you type a key sequence (q.v.), its binding (q.v.) is looked up in the relevant keymaps (q.v.) to find the command to run. See [Commands](#Commands).

Command History  
See [Glossary—Minibuffer History](#Glossary_002d_002d_002dMinibuffer-History).

Command Name  
A command name is the name of a Lisp symbol that is a command (see [Commands](#Commands)). You can invoke any command by its name using `M-x` (see [Running Commands by Name](#M_002dx)).

Comment  
A comment is text in a program which is intended only for humans reading the program, and which is specially marked so that it will be ignored when the program is loaded or compiled. Emacs offers special commands for creating, aligning and killing comments. See [Comments](#Comments).

Common Lisp  
Common Lisp is a dialect of Lisp (q.v.) much larger and more powerful than Emacs Lisp. Emacs provides a subset of Common Lisp in the CL package. See section “Overview” in Common Lisp Extensions.

Compilation  
Compilation is the process of creating an executable program from source code. Emacs has commands for compiling files of Emacs Lisp code (see section “Byte Compilation” in the Emacs Lisp Reference Manual) and programs in C and other languages (see [Compilation](#Compilation)). Byte-compiled Emacs Lisp code loads and executes faster.

Complete Key  
A complete key is a key sequence that fully specifies one action to be performed by Emacs. For example, `X` and `C-f` and `C-x
m` are complete keys. Complete keys derive their meanings from being bound (see [Glossary—Bind](#Glossary_002d_002d_002dBind)) to commands (q.v.). Thus, `X` is conventionally bound to a command to insert ‘`X`’ in the buffer; `C-x m` is conventionally bound to a command to begin composing a mail message. See [Keys](#Keys).

Completion  
Completion is what Emacs does when it automatically expands an abbreviation for a name into the entire name. Completion is done for minibuffer (q.v.) arguments when the set of possible valid inputs is known; for example, on command names, buffer names, and file names. Completion usually occurs when TAB, SPC or RET is typed. See [Completion](#Completion).

Continuation Line  
When a line of text is longer than the width of the window, it normally takes up more than one screen line when displayed (but see [Glossary—Truncation](#Glossary_002d_002d_002dTruncation)). We say that the text line is continued, and all screen lines used for it after the first are called continuation lines. See [Continuation Lines](#Continuation-Lines). A related Emacs feature is filling (q.v.).

Control Character  
A control character is a character that you type by holding down the Ctrl key. Some control characters also have their own keys, so that you can type them without using Ctrl. For example, RET, TAB, ESC and DEL are all control characters. See [User Input](#User-Input).

Copyleft  
A copyleft is a notice giving the public legal permission to redistribute and modify a program or other work of art, but requiring modified versions to carry similar permission. Copyright is normally used to keep users divided and helpless; with copyleft we turn that around to empower users and encourage them to cooperate.

The particular form of copyleft used by the GNU project is called the GNU General Public License. See [Copying](#Copying).

Ctrl  
The Ctrl or control key is what you hold down in order to enter a control character (q.v.). See [Glossary—C-](#Glossary_002d_002d_002dC_002d).

Current Buffer  
The current buffer in Emacs is the Emacs buffer on which most editing commands operate. You can select any Emacs buffer as the current one. See [Buffers](#Buffers).

Current Line  
The current line is the line that point is on (see [Point](#Point)).

Current Paragraph  
The current paragraph is the paragraph that point is in. If point is between two paragraphs, the current paragraph is the one that follows point. See [Paragraphs](#Paragraphs).

Current Defun  
The current defun is the defun (q.v.) that point is in. If point is between defuns, the current defun is the one that follows point. See [Defuns](#Defuns).

Cursor  
The cursor is the rectangle on the screen which indicates the position (called point; q.v.) at which insertion and deletion takes place. The cursor is on or under the character that follows point. Often people speak of “the cursor” when, strictly speaking, they mean “point”. See [Cursor](#Point).

Customization  
Customization is making minor changes in the way Emacs works, to reflect your preferences or needs. It is often done by setting variables (see [Variables](#Variables)) or faces (see [Face Customization](#Face-Customization)), or by rebinding key sequences (see [Keymaps](#Keymaps)).

cut and paste

Cut and Paste  
See [Glossary—Killing](#Glossary_002d_002d_002dKilling), and [Glossary—Yanking](#Glossary_002d_002d_002dYanking).

Daemon  
A daemon is a standard term for a system-level process that runs in the background. Daemons are often started when the system first starts up. When Emacs runs in daemon-mode, it does not open a display. You connect to it with the `emacsclient` program. See [Emacs Server](#Emacs-Server).

Default Argument  
The default for an argument is the value that will be assumed if you do not specify one. When the minibuffer is used to read an argument, the default argument is used if you just type RET. See [Minibuffer](#Minibuffer).

Default  
A default is the value that is used for a certain purpose when you do not explicitly specify a value to use.

Default Directory  
When you specify a file name that does not start with ‘`/`’ or ‘`~`’, it is interpreted relative to the current buffer’s default directory. (On MS systems, file names that start with a drive letter ‘`x:`’ are treated as absolute, not relative.) See [Default Directory](#Minibuffer-File).

Defun  
A defun is a major definition at the top level in a program. The name “defun” comes from Lisp, where most such definitions use the construct `defun`. See [Defuns](#Defuns).

DEL  
DEL is a character that runs the command to delete one character of text before the cursor. It is typically either the Delete key or the BACKSPACE key, whichever one is easy to type. See [DEL](#Erasing).

Deletion  
Deletion means erasing text without copying it into the kill ring (q.v.). The alternative is killing (q.v.). See [Deletion](#Killing).

Deletion of Files  
Deleting a file means erasing it from the file system. (Note that some systems use the concept of a trash can, or recycle bin, to allow you to undelete files.) See [Miscellaneous File Operations](#Misc-File-Ops).

Deletion of Messages  
Deleting a message (in Rmail, and other mail clients) means flagging it to be eliminated from your mail file. Until you expunge (q.v.) the Rmail file, you can still undelete the messages you have deleted. See [Rmail Deletion](#Rmail-Deletion).

Deletion of Windows  
Deleting a window means eliminating it from the screen. Other windows expand to use up the space. The text that was in the window is not lost, and you can create a new window with the same dimensions as the old if you wish. See [Windows](#Windows).

Directory  
File directories are named collections in the file system, within which you can place individual files or subdirectories. They are sometimes referred to as “folders”. See [Directories](#Directories).

Directory Local Variable  
A directory local variable is a local variable (q.v.) that applies to all the files within a certain directory. See [Directory Variables](#Directory-Variables).

Directory Name  
On GNU and other Unix-like systems, directory names are strings that end in ‘`/`’. For example, `/no-such-dir/` is a directory name whereas `/tmp` is not, even though `/tmp` names a file that happens to be a directory. On MS-Windows the relationship is more complicated. See section “Directory Names” in the Emacs Lisp Reference Manual.

Dired  
Dired is the Emacs facility that displays the contents of a file directory and allows you to “edit the directory”, performing operations on the files in the directory. See [Dired](#Dired).

Disabled Command  
A disabled command is one that you may not run without special confirmation. The usual reason for disabling a command is that it is confusing for beginning users. See [Disabling](#Disabling).

Down Event  
Short for “button down event” (q.v.).

Drag Event  
A drag event is the kind of input event (q.v.) generated when you press a mouse button, move the mouse, and then release the button. See [Mouse Buttons](#Mouse-Buttons).

Dribble File  
A dribble file is a file into which Emacs writes all the characters that you type on the keyboard. Dribble files can be used to make a record for debugging Emacs bugs. Emacs does not make a dribble file unless you tell it to. See [Bugs](#Bugs).

e.g.  
Short for “exempli gratia” in Latin, which means “for example”.

Echo Area  
The echo area is the bottom line of the screen, used for echoing the arguments to commands, for asking questions, and showing brief messages (including error messages). The messages are stored in the buffer `*Messages*` so you can review them later. See [Echo Area](#Echo-Area).

Echoing  
Echoing is acknowledging the receipt of input events by displaying them (in the echo area). Emacs never echoes single-character key sequences; longer key sequences echo only if you pause while typing them.

Electric  
We say that a character is electric if it is normally self-inserting (q.v.), but the current major mode (q.v.) redefines it to do something else as well. For example, some programming language major modes define particular delimiter characters to reindent the line, or insert one or more newlines in addition to self-insertion.

End Of Line  
End of line is a character or a sequence of characters that indicate the end of a text line. On GNU and Unix systems, this is a newline (q.v.), but other systems have other conventions. See [end-of-line](#Coding-Systems). Emacs can recognize several end-of-line conventions in files and convert between them.

Environment Variable  
An environment variable is one of a collection of variables stored by the operating system, each one having a name and a value. Emacs can access environment variables set by its parent shell, and it can set variables in the environment it passes to programs it invokes. See [Environment](#Environment).

EOL  
See [Glossary—End Of Line](#Glossary_002d_002d_002dEnd-Of-Line).

Error  
An error occurs when an Emacs command cannot execute in the current circumstances. When an error occurs, execution of the command stops (unless the command has been programmed to do otherwise) and Emacs reports the error by displaying an error message (q.v.).

Error Message  
An error message is output displayed by Emacs when you ask it to do something impossible (such as, killing text forward when point is at the end of the buffer), or when a command malfunctions in some way. Such messages appear in the echo area, accompanied by a beep.

ESC  
ESC is a character used as a prefix for typing Meta characters on keyboards lacking a Meta key. Unlike the Meta key (which, like the SHIFT key, is held down while another character is typed), you press the ESC key as you would press a letter key, and it applies to the next character you type.

etc.  
Short for “et cetera” in Latin, which means “and so on”.

Expression  
See [Glossary—Balanced Expression](#Glossary_002d_002d_002dBalanced-Expression).

Expunging  
Expunging an Rmail, Gnus newsgroup, or Dired buffer is an operation that truly discards the messages or files you have previously flagged for deletion.

Face  
A face is a style of displaying characters. It specifies attributes such as font family and size, foreground and background colors, underline and strike-through, background stipple, etc. Emacs provides features to associate specific faces with portions of buffer text, in order to display that text as specified by the face attributes. See [Faces](#Faces).

File Local Variable  
A file local variable is a local variable (q.v.) specified in a given file. See [File Variables](#File-Variables), and [Glossary—Directory Local Variable](#Glossary_002d_002d_002dDirectory-Local-Variable).

File Locking  
Emacs uses file locking to notice when two different users start to edit one file at the same time. See [Interlocking](#Interlocking).

File Name  
A file name is a name that refers to a file. File names may be relative or absolute; the meaning of a relative file name depends on the current directory, but an absolute file name refers to the same file regardless of which directory is current. On GNU and Unix systems, an absolute file name starts with a slash (the root directory) or with ‘`~/`’ or ‘`~user/`’ (a home directory). On MS-Windows/MS-DOS, an absolute file name can also start with a drive letter and a colon, e.g., ‘`d:`’.

Some people use the term “pathname” for file names, but we do not; we use the word “path” only in the term “search path” (q.v.).

File-Name Component  
A file-name component names a file directly within a particular directory. On GNU and Unix systems, a file name is a sequence of file-name components, separated by slashes. For example, `foo/bar` is a file name containing two components, ‘`foo`’ and ‘`bar`’; it refers to the file named ‘`bar`’ in the directory named ‘`foo`’ in the current directory. MS-DOS/MS-Windows file names can also use backslashes to separate components, as in `foo\bar`.

Fill Prefix  
The fill prefix is a string that should be expected at the beginning of each line when filling is done. It is not regarded as part of the text to be filled. See [Filling](#Filling).

Filling  
Filling text means adjusting the position of line-breaks to shift text between consecutive lines, so that all the lines are approximately the same length. See [Filling](#Filling). Some other editors call this feature “line wrapping”.

Font Lock  
Font Lock is a mode that highlights parts of buffer text in different faces, according to the syntax. Some other editors refer to this as “syntax highlighting”. For example, all comments (q.v.) might be colored red. See [Font Lock](#Font-Lock).

Fontset  
A fontset is a named collection of fonts. A fontset specification lists character sets and which font to use to display each of them. Fontsets make it easy to change several fonts at once by specifying the name of a fontset, rather than changing each font separately. See [Fontsets](#Fontsets).

Formfeed Character  
See [Glossary—Page](#Glossary_002d_002d_002dPage).

Frame  
A frame is a rectangular cluster of Emacs windows. Emacs starts out with one frame, but you can create more. You can subdivide each frame into Emacs windows (q.v.). When you are using a window system (q.v.), more than one frame can be visible at the same time. See [Frames](#Frames). Some other editors use the term “window” for this, but in Emacs a window means something else.

Free Software  
Free software is software that gives you the freedom to share, study and modify it. Emacs is free software, part of the GNU project (q.v.), and distributed under a copyleft (q.v.) license called the GNU General Public License. See [Copying](#Copying).

Free Software Foundation  
The Free Software Foundation (FSF) is a charitable foundation dedicated to promoting the development of free software (q.v.). For more information, see [the FSF website](https://fsf.org/).

Fringe  
On a graphical display (q.v.), there’s a narrow portion of the frame (q.v.) between the text area and the window’s border. These “fringes” are used to display symbols that provide information about the buffer text (see [Fringes](#Fringes)). Emacs displays the fringe using a special face (q.v.) called `fringe`. See [fringe](#Faces).

FSF  
See [Glossary—Free Software Foundation](#Glossary_002d_002d_002dFree-Software-Foundation).

FTP  
FTP is an acronym for File Transfer Protocol. This is one standard method for retrieving remote files (q.v.).

Function Key  
A function key is a key on the keyboard that sends input but does not correspond to any character. See [Function Keys](#Function-Keys).

Global  
Global means “independent of the current environment; in effect throughout Emacs”. It is the opposite of local (q.v.). Particular examples of the use of “global” appear below.

Global Abbrev  
A global definition of an abbrev (q.v.) is effective in all major modes that do not have local (q.v.) definitions for the same abbrev. See [Abbrevs](#Abbrevs).

Global Keymap  
The global keymap (q.v.) contains key bindings that are in effect everywhere, except when overridden by local key bindings in a major mode’s local keymap (q.v.). See [Keymaps](#Keymaps).

Global Mark Ring  
The global mark ring records the series of buffers you have recently set a mark (q.v.) in. In many cases you can use this to backtrack through buffers you have been editing, or in which you have found tags (see [Glossary—Tags Table](#Glossary_002d_002d_002dTags-Table)). See [Global Mark Ring](#Global-Mark-Ring).

Global Substitution  
Global substitution means replacing each occurrence of one string by another string throughout a large amount of text. See [Replace](#Replace).

Global Variable  
The global value of a variable (q.v.) takes effect in all buffers that do not have their own local (q.v.) values for the variable. See [Variables](#Variables).

GNU  
GNU is a recursive acronym for GNU’s Not Unix, and it refers to a Unix-compatible operating system which is free software (q.v.). See [Manifesto](#Manifesto). GNU is normally used with Linux as the kernel since Linux works better than the GNU kernel. For more information, see [the GNU website](https://www.gnu.org/).

Graphic Character  
Graphic characters are those assigned pictorial images rather than just names. All the non-Meta (q.v.) characters except for the Control (q.v.) characters are graphic characters. These include letters, digits, punctuation, and spaces; they do not include RET or ESC. In Emacs, typing a graphic character inserts that character (in ordinary editing modes). See [Inserting Text](#Inserting-Text).

Graphical Display  
A graphical display is one that can display images and multiple fonts. Usually it also has a window system (q.v.).

Highlighting  
Highlighting text means displaying it with a different foreground and/or background color to make it stand out from the rest of the text in the buffer.

Emacs uses highlighting in several ways. It highlights the region whenever it is active (see [Mark](#Mark)). Incremental search also highlights matches (see [Incremental Search](#Incremental-Search)). See [Glossary—Font Lock](#Glossary_002d_002d_002dFont-Lock).

Hardcopy  
Hardcopy means printed output. Emacs has various commands for printing the contents of Emacs buffers. See [Printing](#Printing).

HELP  
HELP is the Emacs name for `C-h` or F1. You can type HELP at any time to ask what options you have, or to ask what a command does. See [Help](#Help).

Help Echo  
Help echo is a short message displayed in the echo area (q.v.) when the mouse pointer is located on portions of display that require some explanations. Emacs displays help echo for menu items, parts of the mode line, tool-bar buttons, etc. On graphical displays, the messages can be displayed as tooltips (q.v.). See [Tooltips](#Tooltips).

Home Directory  
Your home directory contains your personal files. On a multi-user GNU or Unix system, each user has his or her own home directory. When you start a new login session, your home directory is the default directory in which to start. A standard shorthand for your home directory is ‘`~`’. Similarly, ‘`~user`’ represents the home directory of some other user.

Hook  
A hook is a list of functions to be called on specific occasions, such as saving a buffer in a file, major mode activation, etc. By customizing the various hooks, you can modify Emacs’s behavior without changing any of its code. See [Hooks](#Hooks).

Hyper  
Hyper is the name of a modifier bit that a keyboard input character may have. To make a character Hyper, type it while holding down the Hyper key. Such characters are given names that start with `Hyper-` (usually written `H-` for short). See [Modifier Keys](#Modifier-Keys).

i.e.  
Short for “id est” in Latin, which means “that is”.

Iff  
“Iff” means “if and only if”. This terminology comes from mathematics. Try to avoid using this term in documentation, since many are unfamiliar with it and mistake it for a typo.

Inbox  
An inbox is a file in which mail is delivered by the operating system. Rmail transfers mail from inboxes to Rmail files in which the mail is then stored permanently or until explicitly deleted. See [Rmail Inbox](#Rmail-Inbox).

Incremental Search  
Emacs provides an incremental search facility, whereby Emacs begins searching for a string as soon as you type the first character. As you type more characters, it refines the search. See [Incremental Search](#Incremental-Search).

Indentation  
Indentation means blank space at the beginning of a line. Most programming languages have conventions for using indentation to illuminate the structure of the program, and Emacs has special commands to adjust indentation. See [Indentation](#Indentation).

Indirect Buffer  
An indirect buffer is a buffer that shares the text of another buffer, called its base buffer (q.v.). See [Indirect Buffers](#Indirect-Buffers).

Info  
Info is the hypertext format used by the GNU project for writing documentation.

Input Event  
An input event represents, within Emacs, one action taken by the user on the terminal. Input events include typing characters, typing function keys, pressing or releasing mouse buttons, and switching between Emacs frames. See [User Input](#User-Input).

Input Method  
An input method is a system for entering non-ASCII text characters by typing sequences of ASCII characters (q.v.). See [Input Methods](#Input-Methods).

Insertion  
Insertion means adding text into the buffer, either from the keyboard or from some other place in Emacs.

Interlocking  
See [Glossary—File Locking](#Glossary_002d_002d_002dFile-Locking).

Isearch  
See [Glossary—Incremental Search](#Glossary_002d_002d_002dIncremental-Search).

Justification  
Justification means adding extra spaces within lines of text in order to adjust the position of the text edges. See [Fill Commands](#Fill-Commands).

Key Binding  
See [Glossary—Binding](#Glossary_002d_002d_002dBinding).

Keyboard Macro  
Keyboard macros are a way of defining new Emacs commands from sequences of existing ones, with no need to write a Lisp program. You can use a macro to record a sequence of commands, then play them back as many times as you like. See [Keyboard Macros](#Keyboard-Macros).

keyboard shortcuts

Keyboard Shortcut  
A keyboard shortcut is a key sequence (q.v.) that invokes a command. What some programs call “assigning a keyboard shortcut”, Emacs calls “binding a key sequence”. See [Glossary—Binding](#Glossary_002d_002d_002dBinding).

Key Sequence  
A key sequence (key, for short) is a sequence of input events (q.v.) that are meaningful as a single unit. If the key sequence is enough to specify one action, it is a complete key (q.v.); if it is not enough, it is a prefix key (q.v.). See [Keys](#Keys).

Keymap  
The keymap is the data structure that records the bindings (q.v.) of key sequences to the commands that they run. For example, the global keymap binds the character `C-n` to the command function `next-line`. See [Keymaps](#Keymaps).

Keyboard Translation Table  
The keyboard translation table is an array that translates the character codes that come from the terminal into the character codes that make up key sequences.

Kill Ring  
The kill ring is where all text you have killed (see [Glossary—Killing](#Glossary_002d_002d_002dKilling)) recently is saved. You can reinsert any of the killed text still in the ring; this is called yanking (q.v.). See [Yanking](#Yanking).

Killing  
Killing means erasing text and saving it on the kill ring so it can be yanked (q.v.) later. Some other systems call this “cutting”. Most Emacs commands that erase text perform killing, as opposed to deletion (q.v.). See [Killing](#Killing).

Killing a Job  
Killing a job (such as, an invocation of Emacs) means making it cease to exist. Any data within it, if not saved in a file, is lost. See [Exiting](#Exiting).

Language Environment  
Your choice of language environment specifies defaults for the input method (q.v.) and coding system (q.v.). See [Language Environments](#Language-Environments). These defaults are relevant if you edit non-ASCII text (see [International](#International)).

Line Wrapping  
See [Glossary—Filling](#Glossary_002d_002d_002dFilling).

Lisp  
Lisp is a programming language. Most of Emacs is written in a dialect of Lisp, called Emacs Lisp, which is extended with special features that make it especially suitable for text editing tasks.

List  
A list is, approximately, a text string beginning with an open parenthesis and ending with the matching close parenthesis. In C mode and other non-Lisp modes, groupings surrounded by other kinds of matched delimiters appropriate to the language, such as braces, are also considered lists. Emacs has special commands for many operations on lists. See [Moving by Parens](#Moving-by-Parens).

Local  
Local means “in effect only in a particular context”; the relevant kind of context is a particular function execution, a particular buffer, or a particular major mode. It is the opposite of “global” (q.v.). Specific uses of “local” in Emacs terminology appear below.

Local Abbrev  
A local abbrev definition is effective only if a particular major mode is selected. In that major mode, it overrides any global definition for the same abbrev. See [Abbrevs](#Abbrevs).

Local Keymap  
A local keymap is used in a particular major mode; the key bindings (q.v.) in the current local keymap override global bindings of the same key sequences. See [Keymaps](#Keymaps).

Local Variable  
A local value of a variable (q.v.) applies to only one buffer. See [Locals](#Locals).

`M-`  
`M-` in the name of a character is an abbreviation for Meta, one of the modifier keys that can accompany any character. See [M-](#User-Input).

`M-C-`  
`M-C-` in the name of a character is an abbreviation for Control-Meta; it means the same thing as `C-M-` (q.v.).

`M-x`  
`M-x` is the key sequence that is used to call an Emacs command by name. This is how you run commands that are not bound to key sequences. See [Running Commands by Name](#M_002dx).

Mail  
Mail means messages sent from one user to another through the computer system, to be read at the recipient’s convenience. Emacs has commands for composing and sending mail, and for reading and editing the mail you have received. See [Sending Mail](#Sending-Mail). See [Rmail](#Rmail), for one way to read mail with Emacs.

Mail Composition Method  
A mail composition method is a program runnable within Emacs for editing and sending a mail message. Emacs lets you select from several alternative mail composition methods. See [Mail Methods](#Mail-Methods).

Major Mode  
The Emacs major modes are a mutually exclusive set of options, each of which configures Emacs for editing a certain sort of text. Ideally, each programming language has its own major mode. See [Major Modes](#Major-Modes).

Margin  
The space between the usable part of a window (including the fringe) and the window edge.

Mark  
The mark points to a position in the text. It specifies one end of the region (q.v.), point being the other end. Many commands operate on all the text from point to the mark. Each buffer has its own mark. See [Mark](#Mark).

Mark Ring  
The mark ring is used to hold several recent previous locations of the mark, in case you want to move back to them. Each buffer has its own mark ring; in addition, there is a single global mark ring (q.v.). See [Mark Ring](#Mark-Ring).

Menu Bar  
The menu bar is a line at the top of an Emacs frame. It contains words you can click on with the mouse to bring up menus, or you can use a keyboard interface to navigate it. See [Menu Bars](#Menu-Bars).

Message  
See [Glossary—Mail](#Glossary_002d_002d_002dMail).

Meta  
Meta is the name of a modifier bit which you can use in a command character. To enter a meta character, you hold down the Meta key while typing the character. We refer to such characters with names that start with `Meta-` (usually written `M-` for short). For example, `M-<` is typed by holding down Meta and at the same time typing `<` (which itself is done, on most terminals, by holding down SHIFT and typing `,`). See [Meta](#User-Input).

On some terminals, the Meta key is actually labeled Alt or Edit.

Meta Character  
A Meta character is one whose character code includes the Meta bit.

Minibuffer  
The minibuffer is the window that appears when necessary inside the echo area (q.v.), used for reading arguments to commands. See [Minibuffer](#Minibuffer).

Minibuffer History  
The minibuffer history records the text you have specified in the past for minibuffer arguments, so you can conveniently use the same text again. See [Minibuffer History](#Minibuffer-History).

Minor Mode  
A minor mode is an optional feature of Emacs, which can be switched on or off independently of all other features. Each minor mode has a command to turn it on or off. Some minor modes are global (q.v.), and some are local (q.v.). See [Minor Modes](#Minor-Modes).

Minor Mode Keymap  
A minor mode keymap is a keymap that belongs to a minor mode and is active when that mode is enabled. Minor mode keymaps take precedence over the buffer’s local keymap, just as the local keymap takes precedence over the global keymap. See [Keymaps](#Keymaps).

Mode Line  
The mode line is the line at the bottom of each window (q.v.), giving status information on the buffer displayed in that window. See [Mode Line](#Mode-Line).

Modified Buffer  
A buffer (q.v.) is modified if its text has been changed since the last time the buffer was saved (or since it was created, if it has never been saved). See [Saving](#Saving).

Moving Text  
Moving text means erasing it from one place and inserting it in another. The usual way to move text is by killing (q.v.) it and then yanking (q.v.) it. See [Killing](#Killing).

MULE  
MULE

Prior to Emacs 23, MULE was the name of a software package which provided a MULtilingual Enhancement to Emacs, by adding support for multiple character sets (q.v.). MULE was later integrated into Emacs, and much of it was replaced when Emacs gained internal Unicode support in version 23.

Some parts of Emacs that deal with character set support still use the MULE name. See [International](#International).

Multibyte Character  
A multibyte character is a character that takes up several bytes in a buffer. Emacs uses multibyte characters to represent non-ASCII text, since the number of non-ASCII characters is much more than 256. See [International Characters](#International-Chars).

Named Mark  
A named mark is a register (q.v.), in its role of recording a location in text so that you can move point to that location. See [Registers](#Registers).

Narrowing  
Narrowing means creating a restriction (q.v.) that limits editing in the current buffer to only a part of the text. Text outside that part is inaccessible for editing (or viewing) until the boundaries are widened again, but it is still there, and saving the file saves it all. See [Narrowing](#Narrowing).

Newline  
Control-J characters in the buffer terminate lines of text and are therefore also called newlines. See [Glossary—End Of Line](#Glossary_002d_002d_002dEnd-Of-Line).

nil

t

`nil`  
`nil` is a value usually interpreted as a logical “false”. Its opposite is `t`, interpreted as “true”.

Numeric Argument  
A numeric argument is a number, specified before a command, to change the effect of the command. Often the numeric argument serves as a repeat count. See [Arguments](#Arguments).

Overwrite Mode  
Overwrite mode is a minor mode. When it is enabled, ordinary text characters replace the existing text after point rather than pushing it to one side. See [Minor Modes](#Minor-Modes).

Package  
A package is a collection of Lisp code that you download and automatically install from within Emacs. Packages provide a convenient way to add new features. See [Packages](#Packages).

Page  
A page is a unit of text, delimited by formfeed characters (ASCII control-L, code 014) at the beginning of a line. Some Emacs commands are provided for moving over and operating on pages. See [Pages](#Pages).

Paragraph  
Paragraphs are the medium-size unit of human-language text. There are special Emacs commands for moving over and operating on paragraphs. See [Paragraphs](#Paragraphs).

Parsing  
We say that certain Emacs commands parse words or expressions in the text being edited. Really, all they know how to do is find the other end of a word or expression.

Point  
Point is the place in the buffer at which insertion and deletion occur. Point is considered to be between two characters, not at one character. The terminal’s cursor (q.v.) indicates the location of point. See [Point](#Point).

Prefix Argument  
See [Glossary—Numeric Argument](#Glossary_002d_002d_002dNumeric-Argument).

Prefix Key  
A prefix key is a key sequence (q.v.) whose sole function is to introduce a set of longer key sequences. `C-x` is an example of prefix key; any two-character sequence starting with `C-x` is therefore a legitimate key sequence. See [Keys](#Keys).

Primary Selection  
The primary selection is one particular X selection (q.v.); it is the selection that most X applications use for transferring text to and from other applications.

The Emacs commands that mark or select text set the primary selection, and clicking the mouse inserts text from the primary selection when appropriate. See [Shift Selection](#Shift-Selection).

Prompt  
A prompt is text used to ask you for input. Displaying a prompt is called prompting. Emacs prompts always appear in the echo area (q.v.). One kind of prompting happens when the minibuffer is used to read an argument (see [Minibuffer](#Minibuffer)); the echoing that happens when you pause in the middle of typing a multi-character key sequence is also a kind of prompting (see [Echo Area](#Echo-Area)).

q.v.  
Short for “quod vide” in Latin, which means “which see”.

Query-Replace  
Query-replace is an interactive string replacement feature provided by Emacs. See [Query Replace](#Query-Replace).

Quitting  
Quitting means canceling a partially typed command or a running command, using `C-g` (or `C-BREAK` on MS-DOS). See [Quitting](#Quitting).

Quoting  
Quoting means depriving a character of its usual special significance. The most common kind of quoting in Emacs is with `C-q`. What constitutes special significance depends on the context and on convention. For example, an ordinary character as an Emacs command inserts itself; so in this context, a special character is any character that does not normally insert itself (such as DEL, for example), and quoting it makes it insert itself as if it were not special. Not all contexts allow quoting. See [Quoting](#Inserting-Text).

Quoting File Names  
Quoting a file name turns off the special significance of constructs such as ‘`$`’, ‘`~`’ and ‘`:`’. See [Quoted File Names](#Quoted-File-Names).

Read-Only Buffer  
A read-only buffer is one whose text you are not allowed to change. Normally Emacs makes buffers read-only when they contain text which has a special significance to Emacs; for example, Dired buffers. Visiting a file that is write-protected also makes a read-only buffer. See [Buffers](#Buffers).

Rectangle  
A rectangle consists of the text in a given range of columns on a given range of lines. Normally you specify a rectangle by putting point at one corner and putting the mark at the diagonally opposite corner. See [Rectangles](#Rectangles).

Recursive Editing Level  
A recursive editing level is a state in which part of the execution of a command involves asking you to edit some text. This text may or may not be the same as the text to which the command was applied. The mode line (q.v.) indicates recursive editing levels with square brackets (‘`[`’ and ‘`]`’). See [Recursive Edit](#Recursive-Edit).

Redisplay  
Redisplay is the process of correcting the image on the screen to correspond to changes that have been made in the text being edited. See [Redisplay](#Screen).

Regexp  
See [Glossary—Regular Expression](#Glossary_002d_002d_002dRegular-Expression).

Region  
The region is the text between point (q.v.) and the mark (q.v.). Many commands operate on the text of the region. See [Region](#Mark).

Register  
Registers are named slots in which text, buffer positions, or rectangles can be saved for later use. See [Registers](#Registers). A related Emacs feature is bookmarks (q.v.).

Regular Expression  
A regular expression is a pattern that can match various text strings; for example, ‘`a[0-9]+`’ matches ‘`a`’ followed by one or more digits. See [Regexps](#Regexps).

Remote File  
A remote file is a file that is stored on a system other than your own. Emacs can access files on other computers provided that they are reachable from your machine over the network, and (obviously) that you have a supported method to gain access to those files. See [Remote Files](#Remote-Files).

Repeat Count  
See [Glossary—Numeric Argument](#Glossary_002d_002d_002dNumeric-Argument).

Replacement  
See [Glossary—Global Substitution](#Glossary_002d_002d_002dGlobal-Substitution).

Restriction  
A buffer’s restriction is the amount of text, at the beginning or the end of the buffer, that is temporarily inaccessible. Giving a buffer a nonzero amount of restriction is called narrowing (q.v.); removing a restriction is called widening (q.v.). See [Narrowing](#Narrowing).

RET  
RET is a character that in Emacs runs the command to insert a newline into the text. It is also used to terminate most arguments read in the minibuffer (q.v.). See [Return](#User-Input).

Reverting  
Reverting means returning to the original state. For example, Emacs lets you revert a buffer by re-reading its file from disk. See [Reverting](#Reverting).

Saving  
Saving a buffer means copying its text into the file that was visited (q.v.) in that buffer. This is the way text in files actually gets changed by your Emacs editing. See [Saving](#Saving).

Scroll Bar  
A scroll bar is a tall thin hollow box that appears at the side of a window. You can use mouse commands in the scroll bar to scroll the window. The scroll bar feature is supported only under windowing systems. See [Scroll Bars](#Scroll-Bars).

Scrolling  
Scrolling means shifting the text in the Emacs window so as to see a different part of the buffer. See [Scrolling](#Scrolling).

Searching  
Searching means moving point to the next occurrence of a specified string or the next match for a specified regular expression. See [Search](#Search).

Search Path  
A search path is a list of directories, to be used for searching for files for certain purposes. For example, the variable `load-path` holds a search path for finding Lisp library files. See [Lisp Libraries](#Lisp-Libraries).

Secondary Selection  
The secondary selection is one particular X selection (q.v.); some X applications can use it for transferring text to and from other applications. Emacs has special mouse commands for transferring text using the secondary selection. See [Secondary Selection](#Secondary-Selection).

Selected Frame  
The selected frame is the one your input currently operates on. See [Frames](#Frames).

Selected Window  
The selected window is the one your input currently operates on. See [Basic Window](#Basic-Window).

Selecting a Buffer  
Selecting a buffer means making it the current (q.v.) buffer. See [Select Buffer](#Select-Buffer).

Selection  
Windowing systems allow an application program to specify selections whose values are text. A program can also read the selections that other programs have set up. This is the principal way of transferring text between window applications. Emacs has commands to work with the primary (q.v.) selection and the secondary (q.v.) selection, and also with the clipboard (q.v.).

Self-Documentation  
Self-documentation is the feature of Emacs that can tell you what any command does, or give you a list of all commands related to a topic you specify. You ask for self-documentation with the help character, `C-h`. See [Help](#Help).

Self-Inserting Character  
A character is self-inserting if typing that character inserts that character in the buffer. Ordinary printing and whitespace characters are self-inserting in Emacs, except in certain special major modes.

Sentences  
Emacs has commands for moving by or killing by sentences. See [Sentences](#Sentences).

Server  
Within Emacs, you can start a “server” process, which listens for connections from “clients”. This offers a faster alternative to starting several Emacs instances. See [Emacs Server](#Emacs-Server), and [Glossary—Daemon](#Glossary_002d_002d_002dDaemon).

Sexp  
A sexp (short for “s-expression”) is the basic syntactic unit of Lisp in its textual form: either a list, or Lisp atom. Sexps are also the balanced expressions (q.v.) of the Lisp language; this is why the commands for editing balanced expressions have ‘`sexp`’ in their name. See [Sexps](#Expressions).

Simultaneous Editing  
Simultaneous editing means two users modifying the same file at once. Simultaneous editing, if not detected, can cause one user to lose his or her work. Emacs detects all cases of simultaneous editing, and warns one of the users to investigate. See [Simultaneous Editing](#Interlocking).

SPC  
SPC is the space character, which you enter by pressing the space bar.

Speedbar  
The speedbar is a special tall frame that provides fast access to Emacs buffers, functions within those buffers, Info nodes, and other interesting parts of text within Emacs. See [Speedbar](#Speedbar).

Spell Checking  
Spell checking means checking correctness of the written form of each one of the words in a text. Emacs can use various external spelling-checker programs to check the spelling of parts of a buffer via a convenient user interface. See [Spelling](#Spelling).

String  
A string is a kind of Lisp data object that contains a sequence of characters. Many Emacs variables are intended to have strings as values. The Lisp syntax for a string consists of the characters in the string with a ‘`"`’ before and another ‘`"`’ after. A ‘`"`’ that is part of the string must be written as ‘`\"`’ and a ‘`\`’ that is part of the string must be written as ‘`\\`’. All other characters, including newline, can be included just by writing them inside the string; however, backslash sequences as in C, such as ‘`\n`’ for newline or ‘`\241`’ using an octal character code, are allowed as well.

String Substitution  
See [Glossary—Global Substitution](#Glossary_002d_002d_002dGlobal-Substitution).

Syntax Highlighting  
See [Glossary—Font Lock](#Glossary_002d_002d_002dFont-Lock).

Syntax Table  
The syntax table tells Emacs which characters are part of a word, which characters balance each other like parentheses, etc. See section “Syntax Tables” in The Emacs Lisp Reference Manual.

Super  
Super is the name of a modifier bit that a keyboard input character may have. To make a character Super, type it while holding down the SUPER key. Such characters are given names that start with `Super-` (usually written `s-` for short). See [Modifier Keys](#Modifier-Keys).

Suspending  
Suspending Emacs means stopping it temporarily and returning control to its parent process, which is usually a shell. Unlike killing a job (q.v.), you can later resume the suspended Emacs job without losing your buffers, unsaved edits, undo history, etc. See [Exiting](#Exiting).

TAB  
TAB is the tab character. In Emacs it is typically used for indentation or completion.

Tags Table  
A tags table is a file that serves as an index to the function definitions in one or more other files. See [Tags Tables](#Tags-Tables).

Termscript File  
A termscript file contains a record of all characters sent by Emacs to the terminal. It is used for tracking down bugs in Emacs redisplay. Emacs does not make a termscript file unless you tell it to. See [Bugs](#Bugs).

Text  
“Text” has two meanings (see [Text](#Text)):

-   Data consisting of a sequence of characters, as opposed to binary numbers, executable programs, and the like. The basic contents of an Emacs buffer (aside from the text properties, q.v.) are always text in this sense.

-   Data consisting of written human language (as opposed to programs), or following the stylistic conventions of human language.

Text Terminal  
A text terminal, or character terminal, is a display that is limited to displaying text in character units. Such a terminal cannot control individual pixels it displays. Emacs supports a subset of display features on text terminals.

Text Properties  
Text properties are annotations recorded for particular characters in the buffer. Images in the buffer are recorded as text properties; they also specify formatting information. See [Editing Format Info](#Editing-Format-Info).

Theme  
A theme is a set of customizations (q.v.) that give Emacs a particular appearance or behavior. For example, you might use a theme for your favorite set of faces (q.v.).

Tool Bar  
The tool bar is a line (sometimes multiple lines) of icons at the top of an Emacs frame. Clicking on one of these icons executes a command. You can think of this as a graphical relative of the menu bar (q.v.). See [Tool Bars](#Tool-Bars).

Tooltips  
Tooltips are small windows displaying a help echo (q.v.) text, which explains parts of the display, lists useful options available via mouse clicks, etc. See [Tooltips](#Tooltips).

Top Level  
Top level is the normal state of Emacs, in which you are editing the text of the file you have visited. You are at top level whenever you are not in a recursive editing level (q.v.) or the minibuffer (q.v.), and not in the middle of a command. You can get back to top level by aborting (q.v.) and quitting (q.v.). See [Quitting](#Quitting).

Transient Mark Mode  
The default behavior of the mark (q.v.) and region (q.v.), in which setting the mark activates it and highlights the region, is called Transient Mark mode. In GNU Emacs 23 and onwards, it is enabled by default. See [Disabled Transient Mark](#Disabled-Transient-Mark).

Transposition  
Transposing two units of text means putting each one into the place formerly occupied by the other. There are Emacs commands to transpose two adjacent characters, words, balanced expressions (q.v.) or lines (see [Transpose](#Transpose)).

Trash Can  
See [Glossary—Deletion of Files](#Glossary_002d_002d_002dDeletion-of-Files).

Truncation  
Truncating text lines in the display means leaving out any text on a line that does not fit within the right margin of the window displaying it. See [Truncation](#Continuation-Lines), and [Glossary—Continuation Line](#Glossary_002d_002d_002dContinuation-Line).

TTY  
See [Glossary—Text Terminal](#Glossary_002d_002d_002dText-Terminal).

Undoing  
Undoing means making your previous editing go in reverse, bringing back the text that existed earlier in the editing session. See [Undo](#Undo).

Unix  
Unix is a class of multi-user computer operating systems with a long history. There are several implementations today. The GNU project (q.v.) aims to develop a complete Unix-like operating system that is free software (q.v.).

User Option  
A user option is a face (q.v.) or a variable (q.v.) that exists so that you can customize Emacs by setting it to a new value. See [Easy Customization](#Easy-Customization).

Variable  
A variable is an object in Lisp that can store an arbitrary value. Emacs uses some variables for internal purposes, and has others (known as “user options”; q.v.) just so that you can set their values to control the behavior of Emacs. The variables used in Emacs that you are likely to be interested in are listed in the Variables Index in this manual (see [Variable Index](#Variable-Index)). See [Variables](#Variables), for information on variables.

Version Control  
Version control systems keep track of multiple versions of a source file. They provide a more powerful alternative to keeping backup files (q.v.). See [Version Control](#Version-Control).

Visiting  
Visiting a file means loading its contents into a buffer (q.v.) where they can be edited. See [Visiting](#Visiting).

Whitespace  
Whitespace is any run of consecutive formatting characters (space, tab, newline, backspace, etc.).

Widening  
Widening is removing any restriction (q.v.) on the current buffer; it is the opposite of narrowing (q.v.). See [Narrowing](#Narrowing).

Window  
Emacs divides a frame (q.v.) into one or more windows, each of which can display the contents of one buffer (q.v.) at any time. See [Screen](#Screen), for basic information on how Emacs uses the screen. See [Windows](#Windows), for commands to control the use of windows. Some other editors use the term “window” for what we call a “frame” in Emacs.

Window System  
A window system is software that operates on a graphical display (q.v.), to subdivide the screen so that multiple applications can have their own windows at the same time. All modern operating systems include a window system.

Word Abbrev  
See [Glossary—Abbrev](#Glossary_002d_002d_002dAbbrev).

Word Search  
Word search is searching for a sequence of words, considering the punctuation between them as insignificant. See [Word Search](#Word-Search).

Yanking  
Yanking means reinserting text previously killed (q.v.). It can be used to undo a mistaken kill, or for copying or moving text. Some other systems call this “pasting”. See [Yanking](#Yanking).

Acknowledgments
===============

Many people have contributed code included in the Free Software Foundation’s distribution of GNU Emacs. To show our appreciation for their public spirit, we list here in alphabetical order those who have written substantial portions. Others too numerous to mention have reported and fixed bugs, and added features to many parts of Emacs. We thank them for their generosity as well.

This list is intended to mention every contributor of a major package or feature we currently distribute; if you know of someone we have omitted, please make a bug report. More comprehensive information is available in the `ChangeLog` files, summarized in the file `etc/AUTHORS` in the distribution.

-   Per Abrahamsen wrote the customization facilities, as well as `double.el`, for typing accented characters not normally available from the keyboard; `xt-mouse.el`, which allows mouse commands through Xterm; `gnus-cus.el`, which implements customization commands for Gnus; `gnus-cite.el`, a citation-parsing facility for news articles; `gnus-score.el`, scoring for Gnus; `cpp.el`, which hides or highlights parts of C programs according to preprocessor conditionals; and the widget library files `wid-browse.el`, `wid-edit.el`, `widget.el`. He also co-wrote `gnus-soup.el`.

-   Tomas Abrahamsson wrote `artist.el`, a package for producing ASCII art with a mouse or with keyboard keys.

-   Jay K. Adams wrote `jka-compr.el` and `jka-cmpr-hook.el`, providing automatic decompression and recompression for compressed files.

-   Michael Albinus wrote `dbus.el`, a package that implements the D-Bus message bus protocol; `zeroconf.el`, a mode for browsing Avahi services; `secrets.el`, an interface to keyring daemons for storing confidential data; and `filenotify.el` and the associated low-level interface routines, for watching file status changes. He and Kai Großjohann wrote the Tramp package, which provides transparent remote file editing using ssh, ftp, and other network protocols. He and Daniel Pittman wrote `tramp-cache.el`.

-   Ralf Angeli wrote `scroll-lock.el`, a minor mode which keeps the point vertically fixed by scrolling the window when moving up and down in the buffer.

-   Aurélien Aptel added dynamic module support to Emacs. Philipp Stephani and others also worked on the dynamic module code.

-   Joe Arceneaux wrote the original text property implementation, and implemented support for X11.

-   Emil Åström, Milan Zamaza, and Stefan Bruda wrote `prolog.el`, a mode for editing Prolog (and Mercury) code.

-   Miles Bader wrote `image-file.el`, support code for visiting image files; `minibuf-eldef.el`, a minor mode that hides the minibuffer default value when appropriate; `rfn-eshadow.el`, shadowing of `read-file-name` input; `mb-depth.el`, display of minibuffer depth; `button.el`, the library that implements clickable buttons; `face-remap.el`, a package for changing the default face in individual buffers; and `macroexp.el` for macro-expansion. He also worked on an early version of the lexical binding code.

-   David Bakhash wrote `strokes.el`, a mode for controlling Emacs by moving the mouse in particular patterns.

-   Juanma Barranquero wrote `emacs-lock.el` (based on the original version by Tom Wurgler), which makes it harder to exit with valuable buffers unsaved; and `frameset.el`, for saving and restoring the frame/window setup. He also made many other contributions to other areas, including MS Windows support.

-   Eli Barzilay wrote `calculator.el`, a desktop calculator for Emacs.

-   Steven L. Baur wrote `footnote.el` which lets you include footnotes in email messages; and `gnus-audio.el` and `earcon.el`, which provide sound effects for Gnus. He also wrote `gnus-setup.el`.

-   Alexander L. Belikoff, Sergey Berezin, Sacha Chua, David Edmondson, Noah Friedman, Andreas Fuchs, Mario Lang, Ben Mesander, Lawrence Mitchell, Gergely Nagy, Michael Olson, Per Persson, Jorgen Schäfer, Alex Schroeder, and Tom Tromey wrote ERC, an advanced Internet Relay Chat client (for more information, see the file `CREDITS` in the ERC distribution).

-   Scott Bender, Michael Brouwer, Christophe de Dinechin, Carl Edman, Christian Limpach and Adrian Robert developed and maintained the NeXTstep port of Emacs.

-   Stephen Berman wrote `todo-mode.el` (based on the original version by Oliver Seidel), a package for maintaining `TODO` list files.

-   Anna M. Bigatti wrote `cal-html.el`, which produces HTML calendars.

-   Ray Blaak and Simon South wrote `opascal.el`, a mode for editing Object Pascal source code.

-   Martin Blais, Stefan Merten, and David Goodger wrote `rst.el`, a mode for editing reStructuredText documents.

-   Jim Blandy wrote Emacs 19’s input system, brought its configuration and build process up to the GNU coding standards, and contributed to the frame support and multi-face support. Jim also wrote `tvi970.el`, terminal support for the TeleVideo 970 terminals; and co-wrote `wyse50.el` (q.v.).

-   Per Bothner wrote `term.el`, a terminal emulator in an Emacs buffer.

-   Terrence M. Brannon wrote `landmark.el`, a neural-network robot that learns landmarks.

-   Frank Bresz wrote `diff.el`, a program to display `diff` output.

-   Peter Breton implemented `dirtrack.el`, a library for tracking directory changes in shell buffers; `filecache.el`, which records which directories your files are in; `locate.el`, which interfaces to the `locate` command; `find-lisp.el`, an Emacs Lisp emulation of the `find` program; `net-utils.el`; and the generic mode feature.

-   Emmanuel Briot wrote `xml.el`, an XML parser for Emacs; and `ada-prj.el`, editing of Ada mode project files, as well as co-authoring `ada-mode.el` and `ada-xref.el`.

-   Kevin Broadey wrote `foldout.el`, providing folding extensions to Emacs’s outline modes.

-   David M. Brown wrote `array.el`, for editing arrays and other tabular data.

-   Włodek Bzyl and Ryszard Kubiak wrote `ogonek.el`, a package for changing the encoding of Polish characters.

-   Bill Carpenter provided `feedmail.el`, a package for massaging outgoing mail messages and sending them through various popular mailers.

-   Per Cederqvist and Inge Wallin wrote `ewoc.el`, an Emacs widget for manipulating object collections. Per Cederqvist, Inge Wallin, and Thomas Bellman wrote `avl-tree.el`, for balanced binary trees.

-   Hans Chalupsky wrote `advice.el`, an overloading mechanism for Emacs Lisp functions; and `trace.el`, a tracing facility for Emacs Lisp.

-   Chris Chase, Carsten Dominik, and J. D. Smith wrote IDLWAVE mode, for editing IDL and WAVE CL.

-   Bob Chassell wrote `texnfo-upd.el`, `texinfo.el`, and `makeinfo.el`, modes and utilities for working with Texinfo files; and `page-ext.el`, commands for extended page handling. He also wrote the Emacs Lisp introduction. See Introduction to Programming in Emacs Lisp.

-   Jihyun Cho wrote `hanja-util.el` and `hangul.el`, utilities for Korean Hanja.

-   Andrew Choi and Yamamoto Mitsuharu wrote the Carbon support, used prior to Emacs 23 for macOS. Yamamoto Mitsuharu continued to contribute to macOS support in the newer Nextstep port; and also improved support for multi-monitor displays.

-   Chong Yidong was the Emacs co-maintainer from Emacs 23 to 24.3. He made many improvements to the Emacs display engine. He also wrote `tabulated-list.el`, a generic major mode for lists of data; and improved support for themes and packages.

-   James Clark wrote SGML mode, a mode for editing SGML documents; and nXML mode, a mode for editing XML documents. He also contributed to Emacs’s dumping procedures.

-   Mike Clarkson wrote `edt.el`, an emulation of DEC’s EDT editor.

-   Glynn Clements provided `gamegrid.el` and a couple of games that use it, Snake and Tetris.

-   Andrew Cohen wrote `spam-wash.el`, to decode and clean email before it is analyzed for spam.

-   Theresa O’Connor wrote `json.el`, a file for parsing and generating JSON files.

-   Georges Brun-Cottan and Stefan Monnier wrote `easy-mmode.el`, a package for easy definition of major and minor modes.

-   Andrew Csillag wrote M4 mode (`m4-mode.el`).

-   Doug Cutting and Jamie Zawinski wrote `disass.el`, a disassembler for compiled Emacs Lisp code.

-   Mathias Dahl wrote `image-dired.el`, a package for viewing image files as thumbnails.

-   Julien Danjou wrote an implementation of desktop notifications (`notifications.el`, and related packages for ERC and Gnus); and `color.el`, a library for general color manipulation. He also made various contributions to Gnus.

-   Vivek Dasmohapatra wrote `htmlfontify.el`, to convert a buffer or source tree to HTML.

-   Matthieu Devin wrote `delsel.el`, a package to make newly-typed text replace the current selection.

-   Eric Ding wrote `goto-addr.el`,

-   Jan Djärv added support for the GTK+ toolkit and X drag-and-drop. He also wrote `dynamic-setting.el`.

-   Carsten Dominik wrote RefTEX, a package for setting up labels and cross-references in LATEX documents; and co-wrote IDLWAVE mode (q.v.). He was the original author of Org mode, for maintaining notes, todo lists, and project planning. Bastien Guerry subsequently took over maintainership. Benjamin Andresen, Thomas Baumann, Joel Boehland, Jan Böcker, Lennart Borgman, Baoqiu Cui, Dan Davison, Christian Egli, Eric S. Fraga, Daniel German, Chris Gray, Konrad Hinsen, Tassilo Horn, Philip Jackson, Martyn Jago, Thorsten Jolitz, Jambunathan K, Tokuya Kameshima, Sergey Litvinov, David Maus, Ross Patterson, Juan Pechiar, Sebastian Rose, Eric Schulte, Paul Sexton, Ulf Stegemann, Andy Stewart, Christopher Suckling, David O’Toole, John Wiegley, Zhang Weize, Piotr Zieliński, and others also wrote various Org mode components. For more information, see section “History and acknowledgments” in The Org Manual.

-   Scott Draves wrote `tq.el`, help functions for maintaining transaction queues between Emacs and its subprocesses.

-   Benjamin Drieu wrote `pong.el`, an implementation of the classical pong game.

-   Viktor Dukhovni wrote support for dumping under SunOS version 4.

-   John Eaton and Kurt Hornik wrote Octave mode.

-   Rolf Ebert, Markus Heritsch, and Emmanuel Briot wrote Ada mode.

-   Paul Eggert integrated the Gnulib portability library, and made many other portability fixes to the C code; as well as his contributions to VC and the calendar.

-   Stephen Eglen wrote `mspools.el`, which tells you which Procmail folders have mail waiting in them.

-   Torbjörn Einarsson wrote `f90.el`, a mode for Fortran 90 files.

-   Tsugutomo Enami co-wrote the support for international character sets.

-   David Engster wrote `mairix.el` and `nnmairix.el`, an interface to the Mairix indexing tool.

-   Hans Henrik Eriksen wrote `simula.el`, a mode for editing SIMULA 87 code.

-   Michael Ernst wrote `reposition.el`, a command for recentering a function’s source code and preceding comment on the screen.

-   Ata Etemadi wrote `cdl.el`, functions for working with Common Data Language source code.

-   Frederick Farnbach implemented `morse.el`, which converts text to Morse code.

-   Oscar Figueiredo wrote EUDC, the Emacs Unified Directory Client, which is an interface to directory servers via LDAP, CCSO PH/QI, or BBDB; and `ldap.el`, the LDAP client interface.

-   Fred Fish wrote the support for dumping COFF executable files.

-   Karl Fogel wrote `bookmark.el`, which implements named placeholders; `mail-hist.el`, a history mechanism for outgoing mail messages; and `saveplace.el`, for preserving point’s location in files between editing sessions.

-   Gary Foster wrote `scroll-all.el`, a mode for scrolling several buffers together.

-   Romain Francoise contributed ACL (Access Control List) support, for preserving extended file attributes on backup and copy.

-   Noah Friedman wrote `rlogin.el`, an interface to Rlogin, `type-break.el`, which reminds you to take periodic breaks from typing, and `eldoc-mode`, a mode to show the defined parameters or the doc string for the Lisp function near point.

-   Shigeru Fukaya wrote a testsuite for the byte-compiler.

-   Keith Gabryelski wrote `hexl.el`, a mode for editing binary files.

-   Kevin Gallagher rewrote and enhanced the EDT emulation, and wrote `flow-ctrl.el`, a package for coping with unsuppressible XON/XOFF flow control.

-   Fabián E. Gallina rewrote `python.el`, the major mode for the Python programming language used in Emacs 24.3 onwards.

-   Kevin Gallo added multiple-frame support for Windows NT and wrote `w32-win.el`, support functions for the MS-Windows window system.

-   Juan León Lahoz García wrote `wdired.el`, a package for performing file operations by directly editing Dired buffers.

-   Howard Gayle wrote much of the C and Lisp code for display tables and case tables. He also wrote `rot13.el`, a command to display the plain-text form of a buffer encoded with the Caesar cipher; `vt100-led.el`, a package for controlling the LEDs on VT100-compatible terminals; and much of the support for ISO-8859 European character sets (which includes `iso-ascii.el`, `iso-insert.el`, `iso-swed.el`, `iso-syntax.el`, `iso-transl.el`, and `swedish.el`).

-   Stephen Gildea made the Emacs quick reference card, and made many contributions for `time-stamp.el`, a package for maintaining last-change time stamps in files.

-   Julien Gilles wrote `gnus-ml.el`, a mailing list minor mode for Gnus.

-   David Gillespie wrote the Common Lisp compatibility packages; `Calc`, an advanced calculator and mathematical tool, since maintained and developed by Jay Belanger; `complete.el`, a partial completion mechanism; and `edmacro.el`, a package for editing keyboard macros.

-   Bob Glickstein wrote `sregex.el`, a facility for writing regexps using a Lisp-like syntax.

-   Boris Goldowsky wrote `avoid.el`, a package to keep the mouse cursor out of the way of the text cursor; `shadowfile.el`, a package for keeping identical copies of files in more than one place; `format.el`, a package for reading and writing files in various formats; `enriched.el`, a package for saving text properties in files; `facemenu.el`, a package for specifying faces; and `descr-text.el`, describing text and character properties.

-   Michelangelo Grigni wrote `ffap.el` which visits a file, taking the file name from the buffer.

-   Odd Gripenstam wrote `dcl-mode.el` for editing DCL command files.

-   Michael Gschwind wrote `iso-cvt.el`, a package to convert between the ISO 8859-1 character set and the notations for non-ASCII characters used by TEX and net tradition.

-   Bastien Guerry wrote `gnus-bookmark.el`, bookmark support for Gnus; as well as helping to maintain Org mode (q.v.).

-   Henry Guillaume wrote `find-file.el`, a package to visit files related to the currently visited file.

-   Doug Gwyn wrote the portable `alloca` implementation.

-   Ken’ichi Handa implemented most of the support for international character sets, and wrote most of the Emacs 23 font handling code. He also wrote `composite.el`, which provides a minor mode that composes characters automatically when they are displayed; `isearch-x.el`, a facility for searching non-ASCII text; and `ps-bdf.el`, a BDF font support for printing non-ASCII text on a PostScript printer. Together with Naoto Takahashi, he wrote `quail.el`, an input facility for typing non-ASCII text from an ASCII keyboard.

-   Jesper Harder wrote `yenc.el`, for decoding yenc encoded messages.

-   Alexandru Harsanyi wrote a library for accessing SOAP web services.

-   K. Shane Hartman wrote `chistory.el` and `echistory.el`, packages for browsing command history lists; `electric.el` and `helper.el`, which provide an alternative command loop and appropriate help facilities; `emacsbug.el`, a package for reporting Emacs bugs; `picture.el`, a mode for editing ASCII pictures; and `view.el`, a package for perusing files and buffers without editing them.

-   John Heidemann wrote `mouse-copy.el` and `mouse-drag.el`, which provide alternative mouse-based editing and scrolling features.

-   Jon K Hellan wrote `utf7.el`, support for mail-safe transformation format of Unicode.

-   Karl Heuer wrote the original blessmail script, implemented the `intangible` text property, and rearranged the structure of the `Lisp_Object` type to allow for more data bits.

-   Manabu Higashida ported Emacs to MS-DOS.

-   Anders Holst wrote `hippie-exp.el`, a versatile completion and expansion package.

-   Tassilo Horn wrote DocView mode, allowing viewing of PDF, PostScript and DVI documents.

-   Tom Houlder wrote `mantemp.el`, which generates manual C`++` template instantiations.

-   Joakim Hove wrote `html2text.el`, a html to plain text converter.

-   Denis Howe wrote `browse-url.el`, a package for invoking a WWW browser to display a URL.

-   Lars Magne Ingebrigtsen did a major redesign of the Gnus news-reader and wrote many of its parts. Several of these are now general components of Emacs, including: `dns.el` for Domain Name Service lookups; `format-spec.el` for formatting arbitrary format strings; `netrc.el` for parsing of `.netrc` files; and `time-date.el` for general date and time handling. He also wrote `network-stream.el`, for opening network processes; `url-queue.el`, for controlling parallel downloads of URLs; and implemented libxml2 support. He also wrote `eww.el`, an Emacs Lisp web browser; and implemented native zlib decompression. Components of Gnus have also been written by: Nagy Andras, David Blacka, Scott Byer, Ludovic Courtès, Julien Danjou, Kevin Greiner, Kai Großjohann, Joe Hildebrand, Paul Jarc, Simon Josefsson, Sascha Lüdecke, David Moore, Jim Radford, Benjamin Rutt, Raymond Scholz, Thomas Steffen, Reiner Steib, Jan Tatarik, Didier Verna, Ilja Weis, Katsumi Yamaoka, Teodor Zlatanov, and others (see section “Contributors” in the Gnus Manual).

-   Andrew Innes contributed extensively to the MS-Windows support.

-   Seiichiro Inoue improved Emacs’s XIM support.

-   Philip Jackson wrote `find-cmd.el`, to build a `find` command-line.

-   Ulf Jasper wrote `icalendar.el`, a package for converting Emacs diary entries to and from the iCalendar format; `newsticker.el`, an RSS and Atom based Newsticker; and `bubbles.el`, a puzzle game.

-   Kyle Jones wrote `life.el`, a package to play Conway’s Game of Life.

-   Terry Jones wrote `shadow.el`, a package for finding potential load-path problems when some Lisp file shadows another.

-   Simon Josefsson wrote `dns-mode.el`, an editing mode for Domain Name System master files; `dig.el`, a Domain Name System interface; `flow-fill.el`, a package for interpreting RFC2646 formatted text in messages; `fringe.el`, a package for customizing the fringe; `imap.el`, an Emacs Lisp library for talking to IMAP servers; `password-cache.el`, a password reader; `nnimap.el`, the IMAP back-end for Gnus; `url-imap.el` for the URL library; `rfc2104.el`, a hashed message authentication facility; the Gnus S/MIME and Sieve components; and `tls.el` and `starttls.el` for the Transport Layer Security protocol.

-   Arne Jørgensen wrote `latexenc.el`, a package to automatically guess the correct coding system in LATEX files.

-   Alexandre Julliard wrote `vc-git.el`, support for the Git version control system.

-   Tomoji Kagatani implemented `smtpmail.el`, used for sending out mail with SMTP.

-   Ivan Kanis wrote `vc-hg.el`, support for the Mercurial version control system.

-   Henry Kautz wrote `bib-mode.el`, a mode for maintaining bibliography databases compatible with `refer` (the `troff` version) and `lookbib`, and `refbib.el`, a package to convert those databases to the format used by the LATEX text formatting package.

-   Taichi Kawabata added support for Devanagari script and the Indian languages, and wrote `ucs-normalize.el` for Unicode normalization.

-   Taro Kawagishi implemented the MD4 Message Digest Algorithm in Lisp; and wrote `ntlm.el` and `sasl-ntlm.el` for NT LanManager authentication support.

-   Howard Kaye wrote `sort.el`, commands to sort text in Emacs buffers.

-   Michael Kifer wrote `ediff`, an interactive interface to the `diff`, `patch`, and `merge` programs; and Viper, an emulator of the VI editor.

-   Richard King wrote the first version of `userlock.el` and `filelock.c`, which provide simple support for multiple users editing the same file. He also wrote the initial version of `uniquify.el`, a facility to make buffer names unique by adding parts of the file’s name to the buffer name.

-   Peter Kleiweg wrote `ps-mode.el`, a mode for editing PostScript files and running a PostScript interpreter interactively from within Emacs.

-   Karel Klíč contributed SELinux support, for preserving the Security-Enhanced Linux context of files on backup and copy.

-   Shuhei Kobayashi wrote `hex-util.el`, for operating on hexadecimal strings; and support for HMAC (Keyed-Hashing for Message Authentication).

-   Pavel Kobyakov wrote `flymake.el`, a minor mode for performing on-the-fly syntax checking.

-   David M. Koppelman wrote `hi-lock.el`, a minor mode for interactive automatic highlighting of parts of the buffer text.

-   Koseki Yoshinori wrote `iimage.el`, a minor mode for displaying inline images.

-   Robert Krawitz wrote the original `xmenu.c`, part of Emacs’s pop-up menu support.

-   Sebastian Kremer wrote `dired-mode`, with contributions by Lawrence R. Dodd. He also wrote `ls-lisp.el`, a Lisp emulation of the `ls` command for platforms that don’t have `ls` as a standard program.

-   David Kågedal wrote `tempo.el`, providing support for easy insertion of boilerplate text and other common constructions.

-   Igor Kuzmin wrote `cconv.el`, providing closure conversion for statically scoped Emacs lisp.

-   Daniel LaLiberte wrote `edebug.el`, a source-level debugger for Emacs Lisp; `cl-specs.el`, specifications to help `edebug` debug code written using David Gillespie’s Common Lisp support; and `isearch.el`, Emacs’s incremental search minor mode. He also co-wrote `hideif.el` (q.v.).

-   Karl Landstrom and Daniel Colascione wrote `js.el`, a mode for editing JavaScript.

-   Vinicius Jose Latorre wrote the Emacs printing facilities, as well as `ps-print` (with Jim Thompson, Jacques Duthen, and Kenichi Handa), a package for pretty-printing Emacs buffers to PostScript printers; `delim-col.el`, a package to arrange text into columns; `ebnf2ps.el`, a package that translates EBNF grammar to a syntactic chart that can be printed to a PostScript printer; and `whitespace.el`, a package that detects and cleans up excess whitespace in a file (building on an earlier version by Rajesh Vaidheeswarran).

-   Frederic Lepied wrote `expand.el`, which uses the abbrev mechanism for inserting programming constructs.

-   Peter Liljenberg wrote `elint.el`, a Lint-style code checker for Emacs Lisp programs.

-   Lars Lindberg wrote `msb.el`, which provides more flexible menus for buffer selection; co-wrote `imenu.el` (q.v.); and rewrote `dabbrev.el`, originally written by Don Morrison.

-   Anders Lindgren wrote `autorevert.el`, a package for automatically reverting files visited by Emacs that were changed on disk; `cwarn.el`, a package to highlight suspicious C and C`++` constructs; and `follow.el`, a minor mode to synchronize windows that show the same buffer.

-   Thomas Link wrote `filesets.el`, a package for handling sets of files.

-   Juri Linkov wrote `misearch.el`, extending isearch to multi-buffer searches; the code in `files-x.el` for handling file- and directory-local variables; and the `info-finder` feature that creates a virtual Info manual of package keywords.

-   Leo Liu wrote `pcmpl-x.el`, providing completion for miscellaneous external tools; and revamped support for Octave in Emacs 24.4.

-   Károly Lőrentey wrote the multi-terminal code, which allows Emacs to run on graphical and text terminals simultaneously.

-   Martin Lorentzon wrote `vc-annotate.el`, support for version control annotation.

-   Dave Love wrote much of the code dealing with Unicode support and Latin-N unification. He added support for many coding systems, including the various UTF-7 and UTF-16 coding systems. He also wrote `autoarg-mode`, a global minor mode whereby digit keys supply prefix arguments; `autoarg-kp-mode`, which redefines the keypad numeric keys to digit arguments; `autoconf.el`, a mode for editing Autoconf files; `cfengine.el`, a mode for editing Cfengine files; `elide-head.el`, a package for eliding boilerplate text from file headers; `hl-line.el`, a minor mode for highlighting the line in the current window on which point is; `cap-words.el`, a minor mode for motion in `CapitalizedWordIdentifiers`; `latin1-disp.el`, a package that lets you display ISO 8859 characters on Latin-1 terminals by setting up appropriate display tables; the version of `python.el` used prior to Emacs 24.3; `smiley.el`, a facility for displaying smiley faces; `sym-comp.el`, a library for performing mode-dependent symbol completion; `benchmark.el` for timing code execution; and `tool-bar.el`, a mode to control the display of the Emacs tool bar. With Riccardo Murri he wrote `vc-bzr.el`, support for the Bazaar version control system.

-   Eric Ludlam wrote the Speedbar package; `checkdoc.el`, for checking doc strings in Emacs Lisp programs; `dframe.el`, providing dedicated frame support modes; `ezimage.el`, a generalized way to place images over text; `chart.el` for drawing bar charts etc.; and the EIEIO (Enhanced Implementation of Emacs Interpreted Objects) package. He was also the main author of the CEDET (Collection of Emacs Development Environment Tools) package. Portions were also written by Jan Moringen, David Ponce, and Joakim Verona.

-   Roland McGrath wrote `compile.el` (since updated by Daniel Pfeiffer), a package for running compilations in a buffer, and then visiting the locations reported in error messages; `etags.el`, a package for jumping to function definitions and searching or replacing in all the files mentioned in a `TAGS` file; with Sebastian Kremer `find-dired.el`, for using `dired` commands on output from the `find` program; `grep.el` for running the `grep` command; `map-ynp.el`, a general purpose boolean question-asker; `autoload.el`, providing semi-automatic maintenance of autoload files.

-   Alan Mackenzie wrote the integrated AWK support in CC Mode, and maintained CC Mode from Emacs 22 onwards.

-   Michael McNamara and Wilson Snyder wrote Verilog mode.

-   Christopher J. Madsen wrote `decipher.el`, a package for cracking simple substitution ciphers.

-   Neil M. Mager wrote `appt.el`, functions to notify users of their appointments. It finds appointments recorded in the diary files used by the `calendar` package.

-   Ken Manheimer wrote `allout.el`, a mode for manipulating and formatting outlines, and `icomplete.el`, which provides incremental completion feedback in the minibuffer.

-   Bill Mann wrote `perl-mode.el`, a mode for editing Perl code.

-   Brian Marick and Daniel LaLiberte wrote `hideif.el`, support for hiding selected code within C `#ifdef` clauses.

-   Simon Marshall wrote `regexp-opt.el`, which generates a regular expression from a list of strings; and the fast-lock and lazy-lock font-lock support modes. He also extended `comint.el` and `shell.el`, originally written by Olin Shivers.

-   Bengt Martensson, Dirk Herrmann, Marc Shapiro, Mike Newton, Aaron Larson, and Stefan Schoef, wrote `bibtex.el`, a mode for editing BibTEX bibliography files.

-   Charlie Martin wrote `autoinsert.el`, which provides automatic mode-sensitive insertion of text into new files.

-   Yukihiro Matsumoto and Nobuyoshi Nakada wrote Ruby-mode.

-   Tomohiro Matsuyama wrote the native Elisp profiler.

-   Thomas May wrote `blackbox.el`, a version of the traditional blackbox game.

-   David Megginson wrote `derived.el`, which allows one to define new major modes by inheriting key bindings and commands from existing major modes.

-   Will Mengarini wrote `repeat.el`, a command to repeat the preceding command with its arguments.

-   Richard Mlynarik wrote `cl-indent.el`, a package for indenting Common Lisp code; `ebuff-menu.el`, an electric browser for buffer listings; `ehelp.el`, bindings for browsing help screens; and `rfc822.el`, a parser for E-mail addresses in the format used in mail messages and news articles (Internet RFC 822 and its successors).

-   Gerd Möllmann was the Emacs maintainer from the beginning of Emacs 21 development until the release of 21.1. He wrote the new display engine used from Emacs 21 onwards, and the asynchronous timers facility. He also wrote `ebrowse`, the C`++` browser; `jit-lock.el`, the Just-In-Time font-lock support mode; `tooltip.el`, a package for displaying tooltips; `authors.el`, a package for maintaining the `AUTHORS` file; and `rx.el`, a regular expression constructor.

-   Stefan Monnier was the Emacs (co-)maintainer from Emacs 23 until late in the development of 25.1. He added support for Arch and Subversion to VC, re-wrote much of the Emacs server to use the built-in networking primitives, and re-wrote the abbrev and minibuffer completion code for Emacs 23. He also wrote `PCL-CVS`, a directory-level front end to the CVS version control system; `reveal.el`, a minor mode for automatically revealing invisible text; `smerge-mode.el`, a minor mode for resolving `diff3` conflicts; `diff-mode.el`, a mode for viewing and editing context diffs; `css-mode.el` for Cascading Style Sheets; `bibtex-style.el` for BibTEX Style files; `mpc.el`, a client for the Music Player Daemon (MPD); `smie.el`, a generic indentation engine; and `pcase.el`, implementing ML-style pattern matching. In Emacs 24, he integrated the lexical binding code, cleaned up the CL namespace (making it acceptable to use CL functions at runtime), added generalized variables to core Emacs Lisp, and implemented a new lightweight advice mechanism.

-   Morioka Tomohiko wrote several packages for MIME support in Gnus and elsewhere.

-   Sen Nagata wrote `crm.el`, a package for reading multiple strings with completion, and `rfc2368.el`, support for `mailto:` URLs.

-   Erik Naggum wrote the time-conversion functions. He also wrote `disp-table.el`, for dealing with display tables; `mailheader.el`, for parsing email headers; and `parse-time.el`, for parsing time strings.

-   Takahashi Naoto co-wrote `quail.el` (q.v.), and wrote `robin.el`, another input method.

-   Thomas Neumann and Eric Raymond wrote `make-mode.el`, a mode for editing makefiles.

-   Thien-Thi Nguyen and Dan Nicolaescu wrote `hideshow.el`, a minor mode for selectively displaying blocks of text.

-   Dan Nicolaescu added support for running Emacs as a daemon. He also wrote `romanian.el`, support for editing Romanian text; `iris-ansi.el`, support for running Emacs on SGI’s `xwsh` and `winterm` terminal emulators; and `vc-dir.el`, displaying the status of version-controlled directories.

-   Hrvoje Nikšić wrote `savehist.el`, for saving the minibuffer history between Emacs sessions.

-   Jeff Norden wrote `kermit.el`, a package to help the Kermit dialup communications program run comfortably in an Emacs shell buffer.

-   Andrew Norman wrote `ange-ftp.el`, providing transparent FTP support.

-   Kentaro Ohkouchi created the Emacs icons used beginning with Emacs 23.

-   Christian Ohler wrote `ert.el`, a library for automated regression testing.

-   Alexandre Oliva wrote `gnus-mlspl.el`, a group params-based mail splitting mechanism.

-   Takaaki Ota wrote `table.el`, a package for creating and editing embedded text-based tables.

-   Pieter E. J. Pareit wrote `mixal-mode.el`, an editing mode for the MIX assembly language.

-   David Pearson wrote `quickurl.el`, a simple method of inserting a URL into the current buffer based on text at point; `5x5.el`, a game to fill all squares on the field.

-   Jeff Peck wrote `sun.el`, key bindings for sunterm keys.

-   Damon Anton Permezel wrote `hanoi.el`, an animated demonstration of the Towers of Hanoi puzzle.

-   William M. Perry wrote `mailcap.el` (with Lars Magne Ingebrigtsen), a MIME media types configuration facility; `mwheel.el`, a package for supporting mouse wheels; co-wrote (with Dave Love) `socks.el`, a Socks v5 client; and developed the URL package.

-   Per Persson wrote `gnus-vm.el`, the VM interface for Gnus.

-   Jens Petersen wrote `find-func.el`, which makes it easy to find the source code for an Emacs Lisp function or variable.

-   Nicolas Petton wrote `map.el`, a library providing map-manipulation functions that work on alists, hash-table and arrays; `seq.el`, a library providing advanced sequence manipulation functions and macros; and `thunk.el`, a library providing functions and macros to delay the evaluation of forms. He also created the new icon in Emacs 25.

-   Daniel Pfeiffer wrote `conf-mode.el`, a mode for editing configuration files; `copyright.el`, a package for updating copyright notices in files; `executable.el`, a package for executing interpreter scripts; `sh-script.el`, a mode for editing shell scripts; `skeleton.el`, implementing a concise language for writing statement skeletons; and `two-column.el`, a minor mode for simultaneous two-column editing.

    Daniel also rewrote `apropos.el` (originally written by Joe Wells), for finding commands, functions, and variables matching a regular expression; and, together with Jim Blandy, co-authored `wyse50.el`, support for Wyse 50 terminals. He also co-wrote `compile.el` (q.v.) and `ada-stmt.el`.

-   Richard L. Pieri wrote `pop3.el`, a Post Office Protocol (RFC 1460) interface for Emacs.

-   Fred Pierresteguy and Paul Reilly made Emacs work with X Toolkit widgets.

-   François Pinard, Greg McGary, and Bruno Haible wrote `po.el`, support for PO translation files.

-   Christian Plaunt wrote `soundex.el`, an implementation of the Soundex algorithm for comparing English words by their pronunciation.

-   David Ponce wrote `recentf.el`, a package that puts a menu of recently visited files in the Emacs menu bar; `ruler-mode.el`, a minor mode for displaying a ruler in the header line; and `tree-widget.el`, a package to display hierarchical data structures.

-   Francesco A. Potortì wrote `cmacexp.el`, providing a command which runs the C preprocessor on a region of a file and displays the results. He also expanded and redesigned the `etags` program.

-   Michael D. Prange and Steven A. Wood wrote `fortran.el`, a mode for editing Fortran code.

-   Ashwin Ram wrote `refer.el`, commands to look up references in bibliography files by keyword.

-   Eric S. Raymond wrote `vc.el`, an interface to the RCS and SCCS source code version control systems, with Paul Eggert; `gud.el`, a package for running source-level debuggers like GDB and SDB in Emacs; `asm-mode.el`, a mode for editing assembly language code; `AT386.el`, terminal support package for IBM’s AT keyboards; `cookie1.el`, support for fortune-cookie programs like `yow.el` and `spook.el`; `finder.el`, a package for finding Emacs Lisp packages by keyword and topic; `keyswap.el`, code to swap the BS and DEL keys; `loadhist.el`, functions for loading and unloading Emacs features; `lisp-mnt.el`, functions for working with the special headers used in Emacs Lisp library files; and code to set and make use of the `load-history` lisp variable, which records the source file from which each lisp function loaded into Emacs came.

-   Edward M. Reingold wrote the calendar and diary support, with contributions from Stewart Clamen (`cal-mayan.el`), Nachum Dershowitz (`cal-hebrew.el`), Paul Eggert (`cal-dst.el`), Steve Fisk (`cal-tex.el`), Michael Kifer (`cal-x.el`), Lara Rios (`cal-menu.el`), and Denis B. Roegel (`solar.el`). Andy Oram contributed to its documentation. Reingold also contributed to `tex-mode.el`, a mode for editing TEX files, as did William F. Schelter, Dick King, Stephen Gildea, Michael Prange, and Jacob Gore.

-   David Reitter wrote `mailclient.el` which can send mail via the system’s designated mail client.

-   Alex Rezinsky wrote `which-func.el`, a mode that shows the name of the current function in the mode line.

-   Rob Riepel wrote `vt-control.el`, providing some control functions for the DEC VT line of terminals.

-   Nick Roberts wrote `t-mouse.el`, for mouse support in text terminals; and `gdb-ui.el`, a graphical user interface to GDB. Together with Dmitry Dzhus, he wrote `gdb-mi.el`, the successor to `gdb-ui.el`.

-   Danny Roozendaal implemented `handwrite.el`, which converts text into “handwriting”.

-   Markus Rost wrote `cus-test.el`, a testing framework for customize.

-   Guillermo J. Rozas wrote `scheme.el`, a mode for editing Scheme and DSSSL code.

-   Martin Rudalics implemented improved display-buffer handling in Emacs 24; and implemented pixel-wise resizing of windows and frames.

-   Ivar Rummelhoff wrote `winner.el`, which records recent window configurations so you can move back to them.

-   Jason Rumney ported the Emacs 21 display engine to MS-Windows, and has contributed extensively to the MS-Windows port of Emacs.

-   Wolfgang Rupprecht wrote Emacs 19’s floating-point support (including `float-sup.el` and `floatfns.c`).

-   Kevin Ryde wrote `info-xref.el`, a library for checking references in Info files.

-   James B. Salem and Brewster Kahle wrote `completion.el`, providing dynamic word completion.

-   Holger Schauer wrote `fortune.el`, a package for using fortune in message signatures.

-   William Schelter wrote `telnet.el`, support for `telnet` sessions within Emacs.

-   Ralph Schleicher wrote `battery.el`, a package for displaying laptop computer battery status, and `info-look.el`, a package for looking up Info documentation for symbols in the buffer.

-   Michael Schmidt and Tom Perrine wrote `modula2.el`, a mode for editing Modula-2 code, based on work by Mick Jordan and Peter Robinson.

-   Ronald S. Schnell wrote `dunnet.el`, a text adventure game.

-   Philippe Schnoebelen wrote `gomoku.el`, a Go Moku game played against Emacs; and `mpuz.el`, a multiplication puzzle.

-   Jan Schormann wrote `solitaire.el`, an implementation of the Solitaire game.

-   Alex Schroeder wrote `ansi-color.el`, a package for translating ANSI color escape sequences to Emacs faces; `sql.el`, a package for interactively running an SQL interpreter in an Emacs buffer; `cus-theme.el`, an interface for custom themes; `master.el`, a package for making a buffer ‘`master`’ over another; and `spam-stat.el`, for statistical detection of junk email. He also wrote parts of the IRC client ERC (q.v.).

-   Randal Schwartz wrote `pp.el`, a pretty-printer for lisp objects.

-   Manuel Serrano wrote the Flyspell package, which does spell checking as you type.

-   Hovav Shacham wrote `windmove.el`, a set of commands for selecting windows based on their geometrical position on the frame.

-   Stanislav Shalunov wrote `uce.el`, for responding to unsolicited commercial email.

-   Richard Sharman wrote `hilit-chg.el`, which uses colors to show recent editing changes.

-   Olin Shivers wrote `comint.el`, a library for modes running interactive command-line-oriented subprocesses, and `shell.el`, for running inferior shells (both since extended by Simon Marshall); `cmuscheme.el`, for running inferior Scheme processes; `inf-lisp.el`, for running inferior Lisp process.

-   Espen Skoglund wrote `pascal.el`, a mode for editing Pascal code.

-   Rick Sladkey wrote `backquote.el`, a lisp macro for creating mostly-constant data.

-   Lynn Slater wrote `help-macro.el`, a macro for writing interactive help for key bindings.

-   Chris Smith wrote `icon.el`, a mode for editing Icon code.

-   David Smith wrote `ielm.el`, a mode for interacting with the Emacs Lisp interpreter as a subprocess.

-   Paul D. Smith wrote `snmp-mode.el`.

-   William Sommerfeld wrote `scribe.el`, a mode for editing Scribe files, and `server.el`, a package allowing programs to send files to an extant Emacs job to be edited.

-   Andre Spiegel made many contributions to the Emacs Version Control package, and in particular made it support multiple back ends.

-   Michael Staats wrote `pc-select.el`, which rebinds keys for selecting regions to follow many other systems.

-   Richard Stallman invented Emacs. He is the original author of GNU Emacs, and has been Emacs maintainer over several non-contiguous periods. In addition to much of the core Emacs code, he has written `easymenu.el`, a facility for defining Emacs menus; `image-mode.el`, support for visiting image files; `menu-bar.el`, the Emacs menu bar support code; `paren.el`, a package to make matching parentheses stand out in color; and also co-authored portions of CC mode.

-   Sam Steingold wrote `midnight.el`, a package for running a command every midnight.

-   Ake Stenhoff and Lars Lindberg wrote `imenu.el`, a framework for browsing indices made from buffer contents.

-   Peter Stephenson wrote `vcursor.el`, which implements a virtual cursor that you can move with the keyboard and use for copying text.

-   Ken Stevens wrote `ispell.el`, a spell-checker interface.

-   Kim F. Storm made many improvements to the Emacs display engine, process support, and networking support. He also wrote `bindat.el`, a package for encoding and decoding binary data; CUA mode, which allows Emacs to emulate the standard CUA key bindings; `ido.el`, a package for selecting buffers and files quickly; `keypad.el` for simplified keypad bindings; and `kmacro.el`, the keyboard macro facility.

-   Martin Stjernholm co-authored CC Mode, a major editing mode for C, C`++`, Objective-C, Java, Pike, CORBA IDL, and AWK code.

-   Steve Strassmann did not write `spook.el`, and even if he did, he really didn’t mean for you to use it in an anarchistic way.

-   Olaf Sylvester wrote `bs.el`, a package for manipulating Emacs buffers.

-   Tibor Šimko and Milan Zamazal wrote `slovak.el`, support for editing text in Slovak language.

-   Luc Teirlinck wrote `help-at-pt.el`, providing local help through the keyboard.

-   Jean-Philippe Theberge wrote `thumbs.el`, a package for viewing image files as thumbnails.

-   Spencer Thomas wrote the original `dabbrev.el`, providing a command which completes the partial word before point, based on other nearby words for which it is a prefix. He also wrote the original dumping support.

-   Toru Tomabechi contributed to Tibetan support.

-   Markus Triska wrote `linum.el`, a minor mode that displays line numbers in the left margin.

-   Tom Tromey and Chris Lindblad wrote `tcl.el`, a mode for editing Tcl/Tk source files and running a Tcl interpreter as an Emacs subprocess. Tom Tromey also wrote `bug-reference.el`, providing clickable links to bug reports; and the first version of the Emacs package system.

-   Eli Tziperman wrote `rmail-spam-filter.el`, a spam filter for RMAIL.

-   Daiki Ueno wrote `starttls.el`, support for Transport Layer Security protocol; `sasl-cram.el` and `sasl-digest.el` (with Kenichi Okada), and `sasl.el`, support for Simple Authentication and Security Layer (SASL); `plstore.el` for secure storage of property lists; and the EasyPG (and its predecessor PGG) package, for GnuPG and PGP support.

-   Masanobu Umeda wrote GNUS, a feature-rich reader for Usenet news that was the ancestor of the current Gnus package. He also wrote `rmailsort.el`, a package for sorting messages in RMAIL folders; `metamail.el`, an interface to the Metamail program; `gnus-kill.el`, the Kill File mode for Gnus; `gnus-mh.el`, an mh-e interface for Gnus; `gnus-msg.el`, a mail and post interface for Gnus; and `timezone.el`, providing functions for dealing with time zones.

-   Neil W. Van Dyke wrote `webjump.el`, a Web hotlist package.

-   Didier Verna wrote `rect.el`, a package of functions for operations on rectangle regions of text. He also contributed to Gnus (q.v.).

-   Joakim Verona implemented ImageMagick support.

-   Ulrik Vieth implemented `meta-mode.el`, for editing MetaFont code.

-   Geoffrey Voelker wrote the Windows NT support. He also wrote `dos-w32.el`, functions shared by the MS-DOS and MS-Windows ports of Emacs, and `w32-fns.el`, MS-Windows specific support functions.

-   Johan Vromans wrote `forms.el` and its associated files, a mode for filling in forms. He also wrote `iso-acc.el`, a minor mode providing electric accent keys.

-   Colin Walters wrote Ibuffer, an enhanced buffer menu.

-   Barry Warsaw wrote `cc-mode.el`, a mode for editing C, C`++`, and Java code, based on earlier work by Dave Detlefs, Stewart Clamen, and Richard Stallman; `elp.el`, a profiler for Emacs Lisp programs; `man.el`, a mode for reading Unix manual pages; `regi.el`, providing an AWK-like functionality for use in lisp programs; `reporter.el`, providing customizable bug reporting for lisp packages; and `supercite.el`, a minor mode for quoting sections of mail messages and news articles.

-   Christoph Wedler wrote `antlr-mode.el`, a major mode for ANTLR grammar files.

-   Morten Welinder helped port Emacs to MS-DOS, and introduced face support into the MS-DOS port of Emacs. He also wrote `desktop.el`, facilities for saving some of Emacs’s state between sessions; `timer.el`, the Emacs facility to run commands at a given time or frequency, or when Emacs is idle, and its C-level support code; `pc-win.el`, the MS-DOS “window-system” support; `internal.el`, an “internal terminal” emulator for the MS-DOS port of Emacs; `arc-mode.el`, the mode for editing compressed archives; `s-region.el`, commands for setting the region using the shift key and motion commands; and `dos-fns.el`, functions for use under MS-DOS.

-   Joe Wells wrote the original version of `apropos.el` (q.v.); `resume.el`, support for processing command-line arguments after resuming a suspended Emacs job; and `mail-extr.el`, a package for extracting names and addresses from mail headers, with contributions from Jamie Zawinski.

-   Rodney Whitby and Reto Zimmermann wrote `vhdl-mode.el`, a major mode for editing VHDL source code.

-   John Wiegley was the Emacs maintainer from Emacs 25 onwards. He wrote `align.el`, a set of commands for aligning text according to regular-expression based rules; `isearchb.el` for fast buffer switching; `timeclock.el`, a package for keeping track of time spent on projects; the Bahá’í calendar support; `pcomplete.el`, a programmable completion facility; `remember.el`, a mode for jotting down things to remember; `eudcb-mab.el`, an address book backend for the Emacs Unified Directory Client; and `eshell`, a command shell implemented entirely in Emacs Lisp. He also contributed to Org mode (q.v.).

-   Mike Williams wrote `thingatpt.el`, a library of functions for finding the “thing” (word, line, s-expression) at point.

-   Roland Winkler wrote `proced.el`, a system process editor.

-   Bill Wohler wrote MH-E, the Emacs interface to the MH mail system; making use of earlier work by James R. Larus. Satyaki Das, Peter S. Galbraith, Stephen Gildea, and Jeffrey C. Honig also wrote various MH-E components.

-   Dale R. Worley wrote `emerge.el`, a package for interactively merging two versions of a file.

-   Francis J. Wright wrote `woman.el`, a package for browsing manual pages without the `man` command.

-   Masatake Yamato wrote `ld-script.el`, an editing mode for GNU linker scripts, and contributed subword handling and style guessing in CC mode.

-   Jonathan Yavner wrote `testcover.el`, a package for keeping track of the testing status of Emacs Lisp code; `unsafep.el` to determine if a Lisp form is safe; and the SES spreadsheet package.

-   Ryan Yeske wrote `rcirc.el` a simple Internet Relay Chat client.

-   Ilya Zakharevich and Bob Olson wrote `cperl-mode.el`, a major mode for editing Perl code. Ilya Zakharevich also wrote `tmm.el`, a mode for accessing the Emacs menu bar on a text-mode terminal.

-   Milan Zamazal wrote `czech.el`, support for editing Czech text; `glasses.el`, a package for easier reading of source code that uses illegible identifier names; and `tildify.el`, commands for adding hard spaces to text, TEX, and SGML/HTML files.

-   Victor Zandy wrote `zone.el`, a package for people who like to zone out in front of Emacs.

-   Eli Zaretskii made many standard Emacs features work on MS-DOS and Microsoft Windows. He also wrote `tty-colors.el`, which implements transparent mapping of X colors to tty colors; and `rxvt.el`. He implemented support for bidirectional text, menus on text-mode terminals, and built-in display of line numbers.

-   Jamie Zawinski wrote much of the support for faces and X selections. With Hallvard Furuseth, he wrote the optimizing byte compiler used from Emacs 19 onwards. He also wrote `mailabbrev.el`, a package that provides automatic expansion of mail aliases, and `tar-mode.el`, which provides simple viewing and editing commands for tar files.

-   Andrew Zhilin created the Emacs 22 icons.

-   Shenghuo Zhu wrote `binhex.el`, a package for reading and writing binhex files; `mm-partial.el`, message/partial support for MIME messages; `rfc1843.el`, an HZ decoding package; `uudecode.el`, an Emacs Lisp decoder for uuencoded data; and `webmail.el`, an interface to Web mail. He also wrote several other Gnus components.

-   Ian T. Zimmerman wrote `gametree.el`.

-   Reto Zimmermann wrote `vera-mode.el`.

-   Neal Ziring and Felix S. T. Wu wrote `vi.el`, an emulation of the VI text editor.

-   Ted Zlatanov (as well as his contributions to the Gnus newsreader) wrote an interface to the GnuTLS library, for secure network connections; and a futures facility for the URL library.

-   Detlev Zundel wrote `re-builder.el`, a package for building regexps with visual feedback.

Key (Character) Index
=====================

Command-Line Options Index
==========================

Command and Function Index
==========================

Variable Index
==============

Concept Index
=============

[1] このマニュアル自身はGNU Free Documentation Licenseにより保護されています。このライセンスの精神はGeneral Public Licenseと同様ですが、よりドキュメントに適したものです。[GNU Free Documentation License](#GNU-Free-Documentation-License)を参照してください。

[2] “point”という用語は、文字‘`.`’に由来します。この文字は、現在ポイントと呼んでいる値を参照するためのTECO(オリジナルのEmacsを記述していた言語)のコマンドです。

[3] 歴史的な理由により、AltのことをMetaという名前で参照します。

[4] `site-start.el`の中で`inhibit-startup-screen`をセットしても機能しません。なぜならスタートアップ画面は`site-start.el`が読み込まれる前にセットアップされるからです。`site-start.el`についての情報は、[Init File](#Init-File)を参照してください。

[5] ASCIIには、文字`C-SPC`はありません。テキスト端末で`C-SPC`をタイプすると、通常は文字`C-@`が与えられます。このキーも`set-mark-command`にバインドされているので、もし異なる挙動を示すテキスト端末の場合は、`C-SPC`のかわりに`C-@`を使うことを考えるのがよいかもしれません。

[6] `C-/`以外に、`undo`コマンドは`C-x
u`にもバインドされています。なぜならこれは初心者が記憶するのが簡単だからです。‘`u`’は“undo”に由来しています。このコマンドは`C-_`にもバインドされています。なぜならいくつかのテキスト端末では、`C-/`とタイプすることにより、`C-_`が入力されるからです。

[7] システムがシンボリックリンクをサポートしていなければ、通常のファイルが使われます。

[8] これはMIMEの‘`text/*`’の本体、および他のネットワーク転送のコンテキストでも指定されています。これはEmacsが直接サポートしないSGMLリファレンス構文のrecord-start/record-endとは異なります。

[9] EmacsをXで実行している場合、以下のようにして新しくインストールしたフォントの場所を、X serverに指示する必要があるでしょう:

    xset fp+ /usr/local/share/emacs/fonts
    xset fp rehash

[10] より具体的には、そのモードは`prog-mode`から”派生”したモードです(section “Derived Modes” in The Emacs Lisp Reference Manualを参照)。

[11] curved single quote文字、U+2018 LEFT SINGLE QUOTATION MARKとU+2018 RIGHT SINGLE QUOTATION MARKです。curved double quote文字はU+201C LEFT DOUBLE QUOTATION MARKとU+201D RIGHT DOUBLE QUOTATION MARKです。これらの文字を表示できないテキスト端末では、Infoリーダーはそれらをtypewriter ASCII quote文字として表示するかもしれません。

[12] これはLATEX由来の‘`slides`’ドキュメントクラスにより置き換えられました。

[13] 単語“sexp”はLispで式を参照するのに使用されます。

[14] 正規表現と構文テーブル。

[15] tagは、識別子リファレンスの同義語です。`etags`パッケージにもとづいたコマンドおよび機能では、伝統的に“tag”という用語をこの意味に使用します。以下のサブセクションでは、この伝統にしたがいます。

[16] The US National Security Agency.

[17] この機能は、Emacsが`libxml2`サポートつきでビルドされているか、Lynxブラウザーがインストールされている必要があります。

[18] PostScriptファイルにたいしてはGhostScriptが絶対条件です。DVIファイルにたいしては`dvipdf`または`dvipdfm`が必要です。OpenDocumentおよびMicrosoft Officeドキュメントにたいしては`unoconv`ツールが必要です。

[19] そのドキュメントに必要な外部ツールが利用可能でなければならず、Emacsがグラフィカルなフレームで実行されていて、PNGイメージをサポートしなければなりません。これらの条件が満たされなければ、Emacsは他のメジャーモードにフォールバックします。

[20] シェルプロセスをサスペンドするべきではありません。これはシェルのサブジョブのサスペンドとはまったく違います。サブジョブのサスペンドは通常行なわれますが、サブジョブを継続するためにはシェルを使用しなければなりません。このコマンドはそれを行ないません。

[21] 別の環境変数を使うプログラムもいくつかあります。たとえば、TEXが‘`emacsclient`’を使うようにするには、環境変数TEXEDITを‘`emacsclient
+%d %s`’にセットします。

[22] MS-DOSでは、DOSファイルシステムの制限により、このファイルの名前は`_dir-locals.el`になります。ファイルシステムによりファイル名が8+3に制限されている場合、OSによりファイル名が`_dir-loc.el`に切り詰められるでしょう。

[23] このオプションはMS-Windowsでは効果がありません。

[24] これ以降、“コロンで区切られたディレクトリーのリスト”という場合は、UnixおよびGNU/Linuxシステムの場合を指します。MS-DOSおよびMS-Windowsでは、DOS/Windowsファイル名にはドライブ文字の後のコロンが含まれるので、かわりにセミコロンでディレクトリーが区切られます。

[25] 古いバージョンのEmacsは、アプリケーションデータディレクトリーをチェックしません。

[26] これには既知の例外が１つあります。ワークステーションをロックする`Windows-L`の組み合せは、システムのより低レベルで処理されます。この理由により、`w32-register-hot-key`はこのキー組み合せをオーバーライドできません。これは常にコンピューターをロックします。

[27] `printer-name`の値は、スラッシュとバックスラッシュの両方でセットできますが、‘`net
use`’コマンドはUNC共有名がWindowsスタイルのバックスラッシュでタイプされるのを要求することに注意してください。

[28] 通常1つの特定のコードページがディスプレーメモリーに組み込まれていて、`CONFIG.SYS`のようなシステム設定ファイルを変更して再起動することにより他のコードページをインストールできます。再起動なしでコードページを変更できるサードパーティーのソフトウェアーもありますが、ここでは普通のMS-DOSシステムが振る舞う方法を説明します。

[29] ISO 8859にたいすEmacsの標準コーディングシステムは、この目的に完全に沿っているとは言えません。なぜならDOSコードページは通常、標準ISO文字コードにマッチしないからです。たとえば文字‘`ç`’(cedillaつきの‘`c`’)は標準Latin-1文字セットのコード231ですが、それに対応するDOSコードページ850はこのグリフにコード135を使用します。

[30] The wording here was careless. The intention was that nobody would have to pay for *permission* to use the GNU system. But the words don’t make this clear, and people often interpret them as saying that copies of GNU should always be distributed at little or no charge. That was never the intent; later on, the manifesto mentions the possibility of companies providing the service of distribution for a profit. Subsequently I have learned to distinguish carefully between “free” in the sense of freedom and “free” in the sense of price. Free software is software that users have the freedom to distribute and change. Some users may obtain copies at no charge, while others pay to obtain copies—and if the funds help support improving the software, so much the better. The important thing is that everyone who has a copy has the freedom to cooperate with others in using it.

[31] This is another place I failed to distinguish carefully between the two different meanings of “free.” The statement as it stands is not false—you can get copies of GNU software at no charge, from your friends or over the net. But it does suggest the wrong idea.

[32] Several such companies now exist.

[33] The Free Software Foundation raises most of its funds from a distribution service, although it is a charity rather than a company. If *no one* chooses to obtain copies by ordering from the FSF, it will be unable to do its work. But this does not mean that proprietary restrictions are justified to force every user to pay. If a small fraction of all the users order copies from the FSF, that is sufficient to keep the FSF afloat. So we ask users to choose to support us in this way. Have you done your part?

[34] A group of computer companies recently pooled funds to support maintenance of the GNU C Compiler.

[35] In the 80s I had not yet realized how confusing it was to speak of “the issue” of “intellectual property.” That term is obviously biased; more subtle is the fact that it lumps together various disparate laws which raise very different issues. Nowadays I urge people to reject the term “intellectual property” entirely, lest it lead others to suppose that those laws form one coherent issue. The way to be clear is to discuss patents, copyrights, and trademarks separately. See <https://www.gnu.org/philosophy/not-ipr.xhtml> for more explanation of how this term spreads confusion and bias.

[36] Subsequently we have discovered the need to distinguish between “free software” and “freeware”. The term “freeware” means software you are free to redistribute, but usually you are not free to study and change the source code, so most of it is not free software. See <https://www.gnu.org/philosophy/words-to-avoid.html> for more explanation.
